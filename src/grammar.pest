//
// Lavendeux Parser Grammar Definition
// Copyright Richard Carson, 2023
//

SCRIPT = {
    LINE* ~ EOI
}

LINE = {
    WHITESPACE* ~ STATEMENT ~ "@" ~ identifier ~ (EOL | &EOI)
    | WHITESPACE* ~ STATEMENT ~ (EOL | &EOI)
    | WHITESPACE* ~ (EOL | INLINE_COMMENT)
}

STATEMENT = _{
    FUNCTION_ASSIGNMENT_STATEMENT
    | TOPLEVEL_EXPRESSION
}

//
// Tokenizer configuration
//

INLINE_COMMENT = @{"//" ~ (!EOL ~ ANY)* ~ (&EOL | &EOI)}
BLOCK_COMMENT = @{"/*" ~ (!"*/" ~ ANY)* ~ "*/"}
COMMENT = _{INLINE_COMMENT | BLOCK_COMMENT}

WHITESPACE = _{" " | "\t" | "\\" ~ EOL | COMMENT}
EOL = _{NEWLINE | ";"}

// 
// Assignment expressions
// 

FUNCTION_EQUAL_OPERATOR = {"="}
FUNCTION_BODY = _{
    "{" ~ LINE+ ~ "}"
    | TOPLEVEL_EXPRESSION
}
FUNCTION_ASSIGNMENT_STATEMENT = {
    identifier ~ "(" ~ ")" ~ FUNCTION_EQUAL_OPERATOR ~ FUNCTION_BODY |
    identifier ~ "(" ~ identifier ~ ("," ~ identifier)* ~ ")" ~ FUNCTION_EQUAL_OPERATOR ~ FUNCTION_BODY
}

//
// Top of expression tree
//

BLOCK = {
    "{" ~ LINE+ ~ TOPLEVEL_EXPRESSION? ~ "}"
    | "{" ~ TOPLEVEL_EXPRESSION ~ "}"
    | TOPLEVEL_EXPRESSION
}

TOPLEVEL_EXPRESSION = _{ 
    SKIP_KEYWORD | BREAK_KEYWORD
    | IF_EXPRESSION
    | SWITCH_EXPRESSION
    | FOR_LOOP_EXPRESSION
    | VARIABLE_ASSIGNMENT_EXPRESSION
    | OPERATIVE_ASSIGNMENT_EXPRESSION
    | DESTRUCTURING_ASSIGNMENT_EXPRESSION
    | INDEX_ASSIGNMENT_EXPRESSION
    | TERNARY_EXPRESSION
}

// 
// Assignment expressions
//

VARIABLE_ASSIGNMENT_EXPRESSION = {identifier ~ "=" ~ TOPLEVEL_EXPRESSION}

OPERATIVE_ASSIGNMENT_OPERATOR = {"+=" | "-=" | "*=" | "/=" | "%=" | "&=" | "|=" | "^=" | "<<=" | ">>=" | "**=" | "&&=" | "||="}
OPERATIVE_ASSIGNMENT_EXPRESSION = {
    identifier ~ OPERATIVE_ASSIGNMENT_OPERATOR ~ TOPLEVEL_EXPRESSION
}

DESTRUCTURING_ASSIGNMENT_EXPRESSION = {
    "(" ~ identifier ~ ("," ~ identifier)* ~ ")" ~ "=" ~ TOPLEVEL_EXPRESSION
}

INDEX_ASSIGNMENT_EXPRESSION = {
    identifier ~ ("[" ~ TOPLEVEL_EXPRESSION ~ "]")+ ~ "=" ~ TOPLEVEL_EXPRESSION
}

// 
// Flow Control expressions
//

IF_EXPRESSION = {
    ("if" ~ TOPLEVEL_EXPRESSION ~ EOL? ~ "then" ~ EOL? ~ BLOCK ~ EOL? ~ "else")+ ~ BLOCK
}

FOR_LOOP_EXPRESSION = {
    "for" ~ (identifier ~ "in")? ~ TOPLEVEL_EXPRESSION ~ "do" ~ BLOCK
}

SWITCH_CASE_EXPRESSION = _{
    ATOMIC_VALUE ~ "=>" ~ BLOCK
}
SWITCH_EXPRESSION = {
    "match" ~ TERNARY_EXPRESSION ~ "{" ~ EOL* ~ (SWITCH_CASE_EXPRESSION ~ "," ~ EOL*)+ ~ (SWITCH_CASE_EXPRESSION ~ EOL*)? ~ "}"
    | "match" ~ TERNARY_EXPRESSION ~ "{" ~ EOL* ~ (SWITCH_CASE_EXPRESSION ~ EOL*) ~ "}"
}

TERNARY_EXPRESSION = {
    BOOLEAN_OR_EXPRESSION ~ ("?" ~ BOOLEAN_OR_EXPRESSION ~ ":" ~ BOOLEAN_OR_EXPRESSION)*
}

//
// Boolean infix expressions
//

BOOLEAN_OR_OPERATOR = {"||"}
BOOLEAN_OR_EXPRESSION = {
    BOOLEAN_AND_EXPRESSION ~ (BOOLEAN_OR_OPERATOR ~ BOOLEAN_AND_EXPRESSION)*
}

BOOLEAN_AND_OPERATOR = {"&&"}
BOOLEAN_AND_EXPRESSION = {
    BOOLEAN_CMP_EXPRESSION ~ (BOOLEAN_AND_OPERATOR ~ BOOLEAN_CMP_EXPRESSION)*
}

BOOLEAN_CMP_OPERATOR = {"<=" | ">=" | "==" | "!=" | "<" | ">"}
BOOLEAN_CMP_EXPRESSION = {
    BITWISE_OR_EXPRESSION ~ (BOOLEAN_CMP_OPERATOR ~ BITWISE_OR_EXPRESSION)*
}

//
// Bitwise infix expressions
//

BITWISE_OR_OPERATOR = {"|" | "^"}
BITWISE_OR_EXPRESSION = {
    BITWISE_XOR_EXPRESSION ~ (BITWISE_OR_OPERATOR ~ BITWISE_XOR_EXPRESSION)*
}

BITWISE_XOR_OPERATOR = {"^"}
BITWISE_XOR_EXPRESSION = {
    BITWISE_AND_EXPRESSION ~ (BITWISE_XOR_OPERATOR ~ BITWISE_AND_EXPRESSION)*
}

BITWISE_AND_OPERATOR = {"&"}
BITWISE_AND_EXPRESSION = {
    BITWISE_SHIFT_EXPRESSION ~ (BITWISE_AND_OPERATOR ~ BITWISE_SHIFT_EXPRESSION)*
}

BITWISE_SHIFT_OPERATOR = {"<<" | ">>"}
BITWISE_SHIFT_EXPRESSION = {
    ARITHMETIC_AS_EXPRESSION ~ (BITWISE_SHIFT_OPERATOR ~ ARITHMETIC_AS_EXPRESSION)*
}

//
// Arithmetic infix expressions
//

ARITHMETIC_AS_OPERATOR = {"+" | "-"}
ARITHMETIC_AS_EXPRESSION = {
    ARITHMETIC_MD_EXPRESSION ~ (ARITHMETIC_AS_OPERATOR ~ ARITHMETIC_MD_EXPRESSION)*
}

ARITHMETIC_MD_OPERATOR = {"*" | "/" | "%"}
ARITHMETIC_MD_EXPRESSION = {
    ARITHMETIC_EXPONENTIATION_EXPRESSION ~ (ARITHMETIC_MD_OPERATOR ~ ARITHMETIC_EXPONENTIATION_EXPRESSION)*
}

ARITHMETIC_EXPONENTIATION_OPERATOR = {"**"}
ARITHMETIC_EXPONENTIATION_EXPRESSION = {
    MATCHING_EXPRESSION ~ (ARITHMETIC_EXPONENTIATION_OPERATOR ~ MATCHING_EXPRESSION)*
}

//
// Ranges and casting
//

MATCHING_OPERATOR = {"contains" | "matches" | "is" | "startswith" | "endswith" | "starts_with" | "ends_with"}
MATCHING_EXPRESSION = {
    CASTING_EXPRESSION ~ (MATCHING_OPERATOR ~ CASTING_EXPRESSION?)?
}

TARGET_TYPE = @{identifier}
CASTING_EXPRESSION = {
    RANGE_EXPRESSION ~ ("as" ~ TARGET_TYPE)?
}

RANGE_OPERATOR = {".."}
RANGE_EXPRESSION = {
    RANGE_OPERATOR ~ DELETE_EXPRESSION
    | RANGE_OPERATOR
    | DELETE_EXPRESSION ~ (RANGE_OPERATOR ~ DELETE_EXPRESSION)?
    | DELETE_EXPRESSION ~ RANGE_OPERATOR
}

DELETE_KEYWORD = {"delete" | "del" | "unset"}
DELETE_EXPRESSION = {
    DELETE_KEYWORD ~ identifier ~ ("[" ~ RETURN_EXPRESSION ~ "]")*
    | RETURN_EXPRESSION
}

SKIP_KEYWORD = {"skip" | "continue"}
BREAK_KEYWORD = {"break"}

RETURN_KEYWORD = {"return"}
RETURN_EXPRESSION = {
    RETURN_KEYWORD ~ BOOLEAN_NOT_EXPRESSION
    | BOOLEAN_NOT_EXPRESSION
}

//
// Prefix unary expressions
//

BOOLEAN_NOT_OPERATOR = {"!"}
BOOLEAN_NOT_EXPRESSION = {
    BOOLEAN_NOT_OPERATOR* ~ BITWISE_NOT_EXPRESSION
}

BITWISE_NOT_OPERATOR = {"~"}
BITWISE_NOT_EXPRESSION = {
    BITWISE_NOT_OPERATOR* ~ ARITHMETIC_NEG_EXPRESSION
}

ARITHMETIC_NEG_OPERATOR = {"-"}
ARITHMETIC_NEG_EXPRESSION = {
    ARITHMETIC_NEG_OPERATOR* ~ INDEXING_EXPRESSION
}

//
// Postfix indexing expression - for arrays and objects
//

INDEXING_EXPRESSION = {
    POSTFIX_FUNCTION_CALL_EXPRESSION ~ ("[" ~ TOPLEVEL_EXPRESSION ~ "]")*
}

//
// Function call stuff
//

POSTFIX_FUNCTION_CALL_EXPRESSION = {
    FUNCTION_CALL_EXPRESSION ~ ("." ~ identifier ~ "(" ~ (FUNCTION_CALL_EXPRESSION ~ ("," ~ FUNCTION_CALL_EXPRESSION)*)? ~ ")")?
}

FUNCTION_START_MARKER = {"("}
FUNCTION_CALL_EXPRESSION = {
    identifier ~ FUNCTION_START_MARKER ~ ")"
    | identifier ~ FUNCTION_START_MARKER ~ TOPLEVEL_EXPRESSION ~ ("," ~ TOPLEVEL_EXPRESSION)* ~ ")"
    | TERM
}

//
// Value Literals
// And value-literal adjascent gubbins
// 

TERM = _{
    "(" ~ TOPLEVEL_EXPRESSION ~ ")"
    | ATOMIC_VALUE
}

ATOMIC_VALUE = _{
    | currency_literal | fixed_literal
    | sci_literal | float_literal
    | sized_literal
    | bool_literal | string_literal | regex_literal
    | array_literal | object_literal
    | const_literal
    | identifier
    | errors
}

array_literal = {
    "[" ~ TOPLEVEL_EXPRESSION ~ ("," ~ TOPLEVEL_EXPRESSION)* ~ "]"
    | "[" ~ "]"
}

object_literal_pair = _{TOPLEVEL_EXPRESSION ~ ":" ~ TOPLEVEL_EXPRESSION}
object_literal = {
    "{" ~ object_literal_pair ~ ("," ~ object_literal_pair)* ~ "}"
    | "{" ~ "}"
}

fixed_literal = @{
    ('0'..'9')+ ~ ("." ~ ('0'..'9')+)? ~ ("D" | "d" | "F" | "f")
}

// Fixed-point currency values
// Symbols from [polyvalue::CurrencyInner]
currency_symbol = @{
    "$" | "¢" | "£" | "¤" | "¥" | "֏" | "؋" | "߾" | "߿" | "৲" | "৳" | "৻" | "૱" | "௹" | "฿" | "៛" | "₠" | "₡" |
    "₢" | "₣" | "₤" | "₥" | "₦" | "₧" | "₨" | "₩" | "₪" | "₫" | "€" | "₭" | "₮" | "₯" | "₰" | "₱" | "₲" | "₳" |
    "₴" | "₵" | "₶" | "₷" | "₸" | "₹" | "₺" | "₻" | "₼" | "₽" | "₾" | "₿" | "꠸" | "﷼" | "﹩" | "＄" | "￠" |
    "￡" | "￥" | "￦"
}
currency_suffix = @{
    "USD" | "US$" | "CAD" | "C$" | "AUD" | "A$" | "NZD" | "NZ$" | "HKD" | "HK$" | "SGD" | "S$" | "EUR" |
    "JPY" | "CNY" | "CN¥" | "GBP" | "NOK" | "kr" | "SEK" | "kr" | "DKK" | "kr" | "CHF" | "Fr." | "ISK" |
    "kr" | "CZK" | "Kč" | "HUF" | "Ft" | "PLN" | "zł" | "HRK" | "kn" | "RUB" | "TRY" | "BRL" | "R$" | "INR" |
    "IDR" | "Rp" | "ILS" | "ZAR" | "SAR" | "AED" | "KRW" | "VND" | "PHP" | "MXN" | "THB" | "MYR" | "RM" |
    "TWD" | "NT$" | "NGN" | "CLP" | "CL$" | "ARS" | "AR$" | "COP" | "CO$" | "PEN" | "S/." | "DOP" | "RD$"
}
currency_literal = {
    ((float_literal | dec_literal) ~ currency_symbol) 
    | (currency_symbol ~ (float_literal | dec_literal))
    | ((float_literal | dec_literal) ~ currency_suffix)
}

// Floating-point literals
sci_literal = @{(float_literal | dec_literal) ~ ^"e" ~ ("+"|"-")? ~ ('0'..'9')+}
float_literal = @{dec_literal? ~ "." ~ ('0'..'9')+}

const_literal = @{"pi" | "e" | "tau"}

// Integer literals
int_sep = _{('0'..'9'){1,3} ~ ("_" ~ ('0'..'9'){3})+}
dec_literal = @{int_sep | ('0'..'9')+}
hex_literal = @{(^"0x") ~ ('a'..'f' | 'A'..'F' | '0'..'9')+}
bin_literal = @{(^"0b") ~ ('0'..'1')+}
oct_literal = @{(^"0o" | "0") ~ ('0'..'7')+}    
int_literal = @{hex_literal | bin_literal | oct_literal | dec_literal}

sized_literal_suffix = {"u8" | "u16" | "u32" | "u64" | "i8" | "i16" | "i32" | "i64"}
sized_literal = @{int_literal ~ sized_literal_suffix?}

// Other literals
bool_literal = @{^"true" | ^"false"}
string_literal = @{("\"" ~ ("\\"~ANY | (!"\"" ~ ANY))* ~ "\"") | ("\'" ~ ("\\"~ANY | (!"\'" ~ ANY))* ~ "\'")}

regex_literal = @{
    "/" ~ (!"/" ~ ANY | "\\/")* ~ "/" ~ ("i" | "g" | "m" | "s" | "u" | "y")*
}

reserved_words = {
    "pi" | "e" | "tau" | "true" | "false" |
    "match" | "if" | "then" | "else" | "for" | "do" | "in" | "as"
    | RETURN_KEYWORD | SKIP_KEYWORD | BREAK_KEYWORD
    | DELETE_KEYWORD
    | MATCHING_OPERATOR
}
identifier = @{reserved_words? ~ ('a'..'z' | 'A'..'Z' | "_") ~ ('a'..'z' | 'A'..'Z' | '0'..'9' | "_")*}

//
// Error Definitions
//

errors = _{
    ERROR_UNTERMINATED_LITERAL | ERROR_UNTERMINATED_LINEBREAK | ERROR_UNTERMINATED_COMMENT
    | ERROR_UNEXPECTED_DECORATOR | ERROR_UNTERMINATED_RETURN
}

ERROR_UNTERMINATED_LITERAL = @{("\"" ~ ("\\"~ANY | (!"\"" ~ ANY))*) | ("\'" ~ ("\\"~ANY | (!"\'" ~ ANY))*)}
ERROR_UNTERMINATED_LINEBREAK = @{"\\" ~ EOI}
ERROR_UNTERMINATED_COMMENT = @{"/*" ~ ANY*}

ERROR_UNEXPECTED_DECORATOR = @{"@" ~ identifier ~ WHITESPACE* ~ (!WHITESPACE ~ !EOL ~ ANY)+ | SOI ~ "@" ~ ANY*}
ERROR_UNTERMINATED_RETURN = @{"return" ~ (ANY)*}
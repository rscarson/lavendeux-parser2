<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>html, body {
  margin: 0;
  padding: 0;
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: #ddd;
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: #ccf;
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: #fcc;
}
.files-list__file_medium {
  background: #ffc;
}
.files-list__file_high {
  background: #cfc;
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: sticky;
  top: 0;
  background: white;
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: #338;
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
  counter-reset: line;
  display: flex;
  flex-direction: column;
}

.code-line::before {
    content: counter(line);
    margin-right: 10px;
}
.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
  counter-increment: line;
}
.code-line_covered {
  background: #cfc;
}
.code-line_uncovered {
  background: #fcc;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","benches","benchmark_macro.rs"],"content":"#[allow(unused_macros)]\r\nmacro_rules! generate_benches {\r\n    ($input_file:literal) =\u003e {\r\n        use lavendeux_parser::pest::NodeExt;\r\n        const INPUT: \u0026'static str = include_str!($input_file);\r\n\r\n        fn raw_pest_pass() -\u003e pest::iterators::Pairs\u003c'static, lavendeux_parser::Rule\u003e {\r\n            \u003clavendeux_parser::pest::LavendeuxParser as pest::Parser\u003clavendeux_parser::Rule\u003e\u003e::parse(\r\n                lavendeux_parser::Rule::SCRIPT,\r\n                INPUT,\r\n            )\r\n            .unwrap()\r\n        }\r\n\r\n        fn pest_pass() -\u003e pest::iterators::Pair\u003c'static, lavendeux_parser::Rule\u003e {\r\n            lavendeux_parser::pest::LavendeuxParser::parse2(INPUT, lavendeux_parser::Rule::SCRIPT)\r\n                .unwrap()\r\n        }\r\n\r\n        fn compiler_pass(\r\n            parser: \u0026mut lavendeux_parser::Lavendeux,\r\n            pairs: pest::iterators::Pair\u003c'static, lavendeux_parser::Rule\u003e,\r\n        ) -\u003e lavendeux_parser::pest::Node\u003c'static\u003e {\r\n            lavendeux_parser::pest::LavendeuxParser::compile_ast(pairs, parser.state_mut()).unwrap()\r\n        }\r\n\r\n        fn evaluate_pass(\r\n            parser: \u0026mut lavendeux_parser::Lavendeux,\r\n            ast: lavendeux_parser::pest::Node\u003c'static\u003e,\r\n        ) -\u003e lavendeux_parser::polyvalue::Value {\r\n            ast.evaluate(parser.state_mut()).unwrap()\r\n        }\r\n\r\n        fn criterion_benchmark(c: \u0026mut Criterion) {\r\n            c.bench_function(\"Pass 1: PEST (raw)\", |b| b.iter(|| raw_pest_pass()));\r\n\r\n            let mut parser = lavendeux_parser::Lavendeux::new(Default::default());\r\n            c.bench_function(\"Pass 1: PEST (wrapper)\", |b| b.iter(|| pest_pass()));\r\n\r\n            let root_pair = pest_pass();\r\n            c.bench_function(\"Pass 2: Compiler\", |b| {\r\n                b.iter(|| compiler_pass(black_box(\u0026mut parser), black_box(root_pair.clone())))\r\n            });\r\n\r\n            let ast = compiler_pass(\u0026mut parser, root_pair);\r\n            c.bench_function(\"Pass 3: Executor\", |b| {\r\n                b.iter(|| evaluate_pass(black_box(\u0026mut parser), black_box(ast.clone())))\r\n            });\r\n        }\r\n    };\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","benches","load_data.rs"],"content":"use criterion::{black_box, criterion_group, criterion_main, Criterion};\r\n\r\n#[macro_use]\r\nmod benchmark_macro;\r\n\r\ngenerate_benches!(\"../example_scripts/zarban_storydata.lav\");\r\n\r\ncriterion_group!(benches, criterion_benchmark);\r\ncriterion_main!(benches);\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","benches","load_script.rs"],"content":"use criterion::{black_box, criterion_group, criterion_main, Criterion};\r\n\r\n#[macro_use]\r\nmod benchmark_macro;\r\n\r\ngenerate_benches!(\"../example_scripts/zarbans_grotto.lav\");\r\n\r\ncriterion_group!(benches, criterion_benchmark);\r\ncriterion_main!(benches);\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","examples","interactive_console.rs"],"content":"use lavendeux_parser::{Lavendeux, ParserOptions};\r\nuse std::collections::VecDeque;\r\nuse std::env;\r\nuse std::io::{stdin, stdout, Write};\r\nuse std::time::Duration;\r\n\r\n/// Get the next command from the user\r\nfn next_command() -\u003e String {\r\n    let mut input = String::new();\r\n    print!(\"\u003e \");\r\n    let _ = stdout().flush();\r\n\r\n    loop {\r\n        stdin()\r\n            .read_line(\u0026mut input)\r\n            .expect(\"error: unable to read user input\");\r\n        if !input.trim().ends_with('\\\\') || input.trim().ends_with(\"\\\\\\\\\") {\r\n            break;\r\n        }\r\n    }\r\n\r\n    return input.trim().to_string();\r\n}\r\n\r\nfn main() {\r\n    let mut lavendeux = Lavendeux::new(ParserOptions {\r\n        timeout: Duration::from_secs(30),\r\n        pest_call_limit: 25000000,\r\n        ..Default::default()\r\n    });\r\n\r\n    // Load example scripts\r\n    //    lavendeux\r\n    //       .parse(\"include('example_scripts/zarbans_grotto.lav')\")\r\n    //       .expect(\"Could not load example scripts\");\r\n\r\n    // Preload command stack from arguments\r\n    let mut stack: VecDeque\u003cString\u003e = env::args().skip(1).collect();\r\n    if stack.is_empty() {\r\n        println!(\"Ready! Type expressions below!\");\r\n    } else {\r\n        stack.push_back(\"exit\".to_string());\r\n    }\r\n\r\n    loop {\r\n        // Make sure we have a command ready\r\n        if stack.is_empty() {\r\n            stack.push_back(next_command());\r\n        }\r\n        let cmd = stack.pop_front().unwrap();\r\n\r\n        if cmd.is_empty() {\r\n            continue;\r\n        } else if [\"exit\", \"quit\"].contains(\u0026cmd.as_str()) {\r\n            break;\r\n        } else {\r\n            // Process the commands\r\n            let t = std::time::Instant::now();\r\n            match lavendeux.parse(\u0026cmd) {\r\n                Ok(values) =\u003e {\r\n                    println!(\"Parsed in {}ms\", t.elapsed().as_millis());\r\n                    for value in values {\r\n                        println!(\"{}\", value);\r\n                    }\r\n                }\r\n                Err(e) =\u003e println!(\"Error:\\n{}\", e),\r\n            }\r\n        }\r\n    }\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","fuzz","fuzz_targets","parse.rs"],"content":"#![no_main]\n\nextern crate libfuzzer_sys;\n\nextern crate lavendeux_parser;\nuse lavendeux_parser::{Error, Lavendeux};\n\nuse libfuzzer_sys::fuzz_target;\n\nfuzz_target!(|data: \u0026[u8]| {\n    if let Ok(s) = std::str::from_utf8(data) {\n        let mut parser = Lavendeux::new(Default::default());\n        if let Err(e) = parser.parse(s) {\n            if let Error::Internal(msg) = e {\n                panic!(\"Internal error: {}\", msg);\n            }\n        }\n    }\n});\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","fuzz","target","x86_64-unknown-linux-gnu","release","build","num-bigint-1257680023a30f1c","out","radix_bases.rs"],"content":"#[deny(overflowing_literals)]\npub(crate) static BASES_16: [(u16, usize); 257] = [\n    (0, 0), // 0\n    (0, 0), // 1\n    (0, 0), // 2\n    (59049, 10), // 3\n    (0, 0), // 4\n    (15625, 6), // 5\n    (46656, 6), // 6\n    (16807, 5), // 7\n    (0, 0), // 8\n    (59049, 5), // 9\n    (10000, 4), // 10\n    (14641, 4), // 11\n    (20736, 4), // 12\n    (28561, 4), // 13\n    (38416, 4), // 14\n    (50625, 4), // 15\n    (0, 0), // 16\n    (4913, 3), // 17\n    (5832, 3), // 18\n    (6859, 3), // 19\n    (8000, 3), // 20\n    (9261, 3), // 21\n    (10648, 3), // 22\n    (12167, 3), // 23\n    (13824, 3), // 24\n    (15625, 3), // 25\n    (17576, 3), // 26\n    (19683, 3), // 27\n    (21952, 3), // 28\n    (24389, 3), // 29\n    (27000, 3), // 30\n    (29791, 3), // 31\n    (0, 0), // 32\n    (35937, 3), // 33\n    (39304, 3), // 34\n    (42875, 3), // 35\n    (46656, 3), // 36\n    (50653, 3), // 37\n    (54872, 3), // 38\n    (59319, 3), // 39\n    (64000, 3), // 40\n    (1681, 2), // 41\n    (1764, 2), // 42\n    (1849, 2), // 43\n    (1936, 2), // 44\n    (2025, 2), // 45\n    (2116, 2), // 46\n    (2209, 2), // 47\n    (2304, 2), // 48\n    (2401, 2), // 49\n    (2500, 2), // 50\n    (2601, 2), // 51\n    (2704, 2), // 52\n    (2809, 2), // 53\n    (2916, 2), // 54\n    (3025, 2), // 55\n    (3136, 2), // 56\n    (3249, 2), // 57\n    (3364, 2), // 58\n    (3481, 2), // 59\n    (3600, 2), // 60\n    (3721, 2), // 61\n    (3844, 2), // 62\n    (3969, 2), // 63\n    (0, 0), // 64\n    (4225, 2), // 65\n    (4356, 2), // 66\n    (4489, 2), // 67\n    (4624, 2), // 68\n    (4761, 2), // 69\n    (4900, 2), // 70\n    (5041, 2), // 71\n    (5184, 2), // 72\n    (5329, 2), // 73\n    (5476, 2), // 74\n    (5625, 2), // 75\n    (5776, 2), // 76\n    (5929, 2), // 77\n    (6084, 2), // 78\n    (6241, 2), // 79\n    (6400, 2), // 80\n    (6561, 2), // 81\n    (6724, 2), // 82\n    (6889, 2), // 83\n    (7056, 2), // 84\n    (7225, 2), // 85\n    (7396, 2), // 86\n    (7569, 2), // 87\n    (7744, 2), // 88\n    (7921, 2), // 89\n    (8100, 2), // 90\n    (8281, 2), // 91\n    (8464, 2), // 92\n    (8649, 2), // 93\n    (8836, 2), // 94\n    (9025, 2), // 95\n    (9216, 2), // 96\n    (9409, 2), // 97\n    (9604, 2), // 98\n    (9801, 2), // 99\n    (10000, 2), // 100\n    (10201, 2), // 101\n    (10404, 2), // 102\n    (10609, 2), // 103\n    (10816, 2), // 104\n    (11025, 2), // 105\n    (11236, 2), // 106\n    (11449, 2), // 107\n    (11664, 2), // 108\n    (11881, 2), // 109\n    (12100, 2), // 110\n    (12321, 2), // 111\n    (12544, 2), // 112\n    (12769, 2), // 113\n    (12996, 2), // 114\n    (13225, 2), // 115\n    (13456, 2), // 116\n    (13689, 2), // 117\n    (13924, 2), // 118\n    (14161, 2), // 119\n    (14400, 2), // 120\n    (14641, 2), // 121\n    (14884, 2), // 122\n    (15129, 2), // 123\n    (15376, 2), // 124\n    (15625, 2), // 125\n    (15876, 2), // 126\n    (16129, 2), // 127\n    (0, 0), // 128\n    (16641, 2), // 129\n    (16900, 2), // 130\n    (17161, 2), // 131\n    (17424, 2), // 132\n    (17689, 2), // 133\n    (17956, 2), // 134\n    (18225, 2), // 135\n    (18496, 2), // 136\n    (18769, 2), // 137\n    (19044, 2), // 138\n    (19321, 2), // 139\n    (19600, 2), // 140\n    (19881, 2), // 141\n    (20164, 2), // 142\n    (20449, 2), // 143\n    (20736, 2), // 144\n    (21025, 2), // 145\n    (21316, 2), // 146\n    (21609, 2), // 147\n    (21904, 2), // 148\n    (22201, 2), // 149\n    (22500, 2), // 150\n    (22801, 2), // 151\n    (23104, 2), // 152\n    (23409, 2), // 153\n    (23716, 2), // 154\n    (24025, 2), // 155\n    (24336, 2), // 156\n    (24649, 2), // 157\n    (24964, 2), // 158\n    (25281, 2), // 159\n    (25600, 2), // 160\n    (25921, 2), // 161\n    (26244, 2), // 162\n    (26569, 2), // 163\n    (26896, 2), // 164\n    (27225, 2), // 165\n    (27556, 2), // 166\n    (27889, 2), // 167\n    (28224, 2), // 168\n    (28561, 2), // 169\n    (28900, 2), // 170\n    (29241, 2), // 171\n    (29584, 2), // 172\n    (29929, 2), // 173\n    (30276, 2), // 174\n    (30625, 2), // 175\n    (30976, 2), // 176\n    (31329, 2), // 177\n    (31684, 2), // 178\n    (32041, 2), // 179\n    (32400, 2), // 180\n    (32761, 2), // 181\n    (33124, 2), // 182\n    (33489, 2), // 183\n    (33856, 2), // 184\n    (34225, 2), // 185\n    (34596, 2), // 186\n    (34969, 2), // 187\n    (35344, 2), // 188\n    (35721, 2), // 189\n    (36100, 2), // 190\n    (36481, 2), // 191\n    (36864, 2), // 192\n    (37249, 2), // 193\n    (37636, 2), // 194\n    (38025, 2), // 195\n    (38416, 2), // 196\n    (38809, 2), // 197\n    (39204, 2), // 198\n    (39601, 2), // 199\n    (40000, 2), // 200\n    (40401, 2), // 201\n    (40804, 2), // 202\n    (41209, 2), // 203\n    (41616, 2), // 204\n    (42025, 2), // 205\n    (42436, 2), // 206\n    (42849, 2), // 207\n    (43264, 2), // 208\n    (43681, 2), // 209\n    (44100, 2), // 210\n    (44521, 2), // 211\n    (44944, 2), // 212\n    (45369, 2), // 213\n    (45796, 2), // 214\n    (46225, 2), // 215\n    (46656, 2), // 216\n    (47089, 2), // 217\n    (47524, 2), // 218\n    (47961, 2), // 219\n    (48400, 2), // 220\n    (48841, 2), // 221\n    (49284, 2), // 222\n    (49729, 2), // 223\n    (50176, 2), // 224\n    (50625, 2), // 225\n    (51076, 2), // 226\n    (51529, 2), // 227\n    (51984, 2), // 228\n    (52441, 2), // 229\n    (52900, 2), // 230\n    (53361, 2), // 231\n    (53824, 2), // 232\n    (54289, 2), // 233\n    (54756, 2), // 234\n    (55225, 2), // 235\n    (55696, 2), // 236\n    (56169, 2), // 237\n    (56644, 2), // 238\n    (57121, 2), // 239\n    (57600, 2), // 240\n    (58081, 2), // 241\n    (58564, 2), // 242\n    (59049, 2), // 243\n    (59536, 2), // 244\n    (60025, 2), // 245\n    (60516, 2), // 246\n    (61009, 2), // 247\n    (61504, 2), // 248\n    (62001, 2), // 249\n    (62500, 2), // 250\n    (63001, 2), // 251\n    (63504, 2), // 252\n    (64009, 2), // 253\n    (64516, 2), // 254\n    (65025, 2), // 255\n    (0, 0), // 256\n];\n#[deny(overflowing_literals)]\npub(crate) static BASES_32: [(u32, usize); 257] = [\n    (0, 0), // 0\n    (0, 0), // 1\n    (0, 0), // 2\n    (3486784401, 20), // 3\n    (0, 0), // 4\n    (1220703125, 13), // 5\n    (2176782336, 12), // 6\n    (1977326743, 11), // 7\n    (0, 0), // 8\n    (3486784401, 10), // 9\n    (1000000000, 9), // 10\n    (2357947691, 9), // 11\n    (429981696, 8), // 12\n    (815730721, 8), // 13\n    (1475789056, 8), // 14\n    (2562890625, 8), // 15\n    (0, 0), // 16\n    (410338673, 7), // 17\n    (612220032, 7), // 18\n    (893871739, 7), // 19\n    (1280000000, 7), // 20\n    (1801088541, 7), // 21\n    (2494357888, 7), // 22\n    (3404825447, 7), // 23\n    (191102976, 6), // 24\n    (244140625, 6), // 25\n    (308915776, 6), // 26\n    (387420489, 6), // 27\n    (481890304, 6), // 28\n    (594823321, 6), // 29\n    (729000000, 6), // 30\n    (887503681, 6), // 31\n    (0, 0), // 32\n    (1291467969, 6), // 33\n    (1544804416, 6), // 34\n    (1838265625, 6), // 35\n    (2176782336, 6), // 36\n    (2565726409, 6), // 37\n    (3010936384, 6), // 38\n    (3518743761, 6), // 39\n    (4096000000, 6), // 40\n    (115856201, 5), // 41\n    (130691232, 5), // 42\n    (147008443, 5), // 43\n    (164916224, 5), // 44\n    (184528125, 5), // 45\n    (205962976, 5), // 46\n    (229345007, 5), // 47\n    (254803968, 5), // 48\n    (282475249, 5), // 49\n    (312500000, 5), // 50\n    (345025251, 5), // 51\n    (380204032, 5), // 52\n    (418195493, 5), // 53\n    (459165024, 5), // 54\n    (503284375, 5), // 55\n    (550731776, 5), // 56\n    (601692057, 5), // 57\n    (656356768, 5), // 58\n    (714924299, 5), // 59\n    (777600000, 5), // 60\n    (844596301, 5), // 61\n    (916132832, 5), // 62\n    (992436543, 5), // 63\n    (0, 0), // 64\n    (1160290625, 5), // 65\n    (1252332576, 5), // 66\n    (1350125107, 5), // 67\n    (1453933568, 5), // 68\n    (1564031349, 5), // 69\n    (1680700000, 5), // 70\n    (1804229351, 5), // 71\n    (1934917632, 5), // 72\n    (2073071593, 5), // 73\n    (2219006624, 5), // 74\n    (2373046875, 5), // 75\n    (2535525376, 5), // 76\n    (2706784157, 5), // 77\n    (2887174368, 5), // 78\n    (3077056399, 5), // 79\n    (3276800000, 5), // 80\n    (3486784401, 5), // 81\n    (3707398432, 5), // 82\n    (3939040643, 5), // 83\n    (4182119424, 5), // 84\n    (52200625, 4), // 85\n    (54700816, 4), // 86\n    (57289761, 4), // 87\n    (59969536, 4), // 88\n    (62742241, 4), // 89\n    (65610000, 4), // 90\n    (68574961, 4), // 91\n    (71639296, 4), // 92\n    (74805201, 4), // 93\n    (78074896, 4), // 94\n    (81450625, 4), // 95\n    (84934656, 4), // 96\n    (88529281, 4), // 97\n    (92236816, 4), // 98\n    (96059601, 4), // 99\n    (100000000, 4), // 100\n    (104060401, 4), // 101\n    (108243216, 4), // 102\n    (112550881, 4), // 103\n    (116985856, 4), // 104\n    (121550625, 4), // 105\n    (126247696, 4), // 106\n    (131079601, 4), // 107\n    (136048896, 4), // 108\n    (141158161, 4), // 109\n    (146410000, 4), // 110\n    (151807041, 4), // 111\n    (157351936, 4), // 112\n    (163047361, 4), // 113\n    (168896016, 4), // 114\n    (174900625, 4), // 115\n    (181063936, 4), // 116\n    (187388721, 4), // 117\n    (193877776, 4), // 118\n    (200533921, 4), // 119\n    (207360000, 4), // 120\n    (214358881, 4), // 121\n    (221533456, 4), // 122\n    (228886641, 4), // 123\n    (236421376, 4), // 124\n    (244140625, 4), // 125\n    (252047376, 4), // 126\n    (260144641, 4), // 127\n    (0, 0), // 128\n    (276922881, 4), // 129\n    (285610000, 4), // 130\n    (294499921, 4), // 131\n    (303595776, 4), // 132\n    (312900721, 4), // 133\n    (322417936, 4), // 134\n    (332150625, 4), // 135\n    (342102016, 4), // 136\n    (352275361, 4), // 137\n    (362673936, 4), // 138\n    (373301041, 4), // 139\n    (384160000, 4), // 140\n    (395254161, 4), // 141\n    (406586896, 4), // 142\n    (418161601, 4), // 143\n    (429981696, 4), // 144\n    (442050625, 4), // 145\n    (454371856, 4), // 146\n    (466948881, 4), // 147\n    (479785216, 4), // 148\n    (492884401, 4), // 149\n    (506250000, 4), // 150\n    (519885601, 4), // 151\n    (533794816, 4), // 152\n    (547981281, 4), // 153\n    (562448656, 4), // 154\n    (577200625, 4), // 155\n    (592240896, 4), // 156\n    (607573201, 4), // 157\n    (623201296, 4), // 158\n    (639128961, 4), // 159\n    (655360000, 4), // 160\n    (671898241, 4), // 161\n    (688747536, 4), // 162\n    (705911761, 4), // 163\n    (723394816, 4), // 164\n    (741200625, 4), // 165\n    (759333136, 4), // 166\n    (777796321, 4), // 167\n    (796594176, 4), // 168\n    (815730721, 4), // 169\n    (835210000, 4), // 170\n    (855036081, 4), // 171\n    (875213056, 4), // 172\n    (895745041, 4), // 173\n    (916636176, 4), // 174\n    (937890625, 4), // 175\n    (959512576, 4), // 176\n    (981506241, 4), // 177\n    (1003875856, 4), // 178\n    (1026625681, 4), // 179\n    (1049760000, 4), // 180\n    (1073283121, 4), // 181\n    (1097199376, 4), // 182\n    (1121513121, 4), // 183\n    (1146228736, 4), // 184\n    (1171350625, 4), // 185\n    (1196883216, 4), // 186\n    (1222830961, 4), // 187\n    (1249198336, 4), // 188\n    (1275989841, 4), // 189\n    (1303210000, 4), // 190\n    (1330863361, 4), // 191\n    (1358954496, 4), // 192\n    (1387488001, 4), // 193\n    (1416468496, 4), // 194\n    (1445900625, 4), // 195\n    (1475789056, 4), // 196\n    (1506138481, 4), // 197\n    (1536953616, 4), // 198\n    (1568239201, 4), // 199\n    (1600000000, 4), // 200\n    (1632240801, 4), // 201\n    (1664966416, 4), // 202\n    (1698181681, 4), // 203\n    (1731891456, 4), // 204\n    (1766100625, 4), // 205\n    (1800814096, 4), // 206\n    (1836036801, 4), // 207\n    (1871773696, 4), // 208\n    (1908029761, 4), // 209\n    (1944810000, 4), // 210\n    (1982119441, 4), // 211\n    (2019963136, 4), // 212\n    (2058346161, 4), // 213\n    (2097273616, 4), // 214\n    (2136750625, 4), // 215\n    (2176782336, 4), // 216\n    (2217373921, 4), // 217\n    (2258530576, 4), // 218\n    (2300257521, 4), // 219\n    (2342560000, 4), // 220\n    (2385443281, 4), // 221\n    (2428912656, 4), // 222\n    (2472973441, 4), // 223\n    (2517630976, 4), // 224\n    (2562890625, 4), // 225\n    (2608757776, 4), // 226\n    (2655237841, 4), // 227\n    (2702336256, 4), // 228\n    (2750058481, 4), // 229\n    (2798410000, 4), // 230\n    (2847396321, 4), // 231\n    (2897022976, 4), // 232\n    (2947295521, 4), // 233\n    (2998219536, 4), // 234\n    (3049800625, 4), // 235\n    (3102044416, 4), // 236\n    (3154956561, 4), // 237\n    (3208542736, 4), // 238\n    (3262808641, 4), // 239\n    (3317760000, 4), // 240\n    (3373402561, 4), // 241\n    (3429742096, 4), // 242\n    (3486784401, 4), // 243\n    (3544535296, 4), // 244\n    (3603000625, 4), // 245\n    (3662186256, 4), // 246\n    (3722098081, 4), // 247\n    (3782742016, 4), // 248\n    (3844124001, 4), // 249\n    (3906250000, 4), // 250\n    (3969126001, 4), // 251\n    (4032758016, 4), // 252\n    (4097152081, 4), // 253\n    (4162314256, 4), // 254\n    (4228250625, 4), // 255\n    (0, 0), // 256\n];\n#[deny(overflowing_literals)]\npub(crate) static BASES_64: [(u64, usize); 257] = [\n    (0, 0), // 0\n    (0, 0), // 1\n    (0, 0), // 2\n    (12157665459056928801, 40), // 3\n    (0, 0), // 4\n    (7450580596923828125, 27), // 5\n    (4738381338321616896, 24), // 6\n    (3909821048582988049, 22), // 7\n    (0, 0), // 8\n    (12157665459056928801, 20), // 9\n    (10000000000000000000, 19), // 10\n    (5559917313492231481, 18), // 11\n    (2218611106740436992, 17), // 12\n    (8650415919381337933, 17), // 13\n    (2177953337809371136, 16), // 14\n    (6568408355712890625, 16), // 15\n    (0, 0), // 16\n    (2862423051509815793, 15), // 17\n    (6746640616477458432, 15), // 18\n    (15181127029874798299, 15), // 19\n    (1638400000000000000, 14), // 20\n    (3243919932521508681, 14), // 21\n    (6221821273427820544, 14), // 22\n    (11592836324538749809, 14), // 23\n    (876488338465357824, 13), // 24\n    (1490116119384765625, 13), // 25\n    (2481152873203736576, 13), // 26\n    (4052555153018976267, 13), // 27\n    (6502111422497947648, 13), // 28\n    (10260628712958602189, 13), // 29\n    (15943230000000000000, 13), // 30\n    (787662783788549761, 12), // 31\n    (0, 0), // 32\n    (1667889514952984961, 12), // 33\n    (2386420683693101056, 12), // 34\n    (3379220508056640625, 12), // 35\n    (4738381338321616896, 12), // 36\n    (6582952005840035281, 12), // 37\n    (9065737908494995456, 12), // 38\n    (12381557655576425121, 12), // 39\n    (16777216000000000000, 12), // 40\n    (550329031716248441, 11), // 41\n    (717368321110468608, 11), // 42\n    (929293739471222707, 11), // 43\n    (1196683881290399744, 11), // 44\n    (1532278301220703125, 11), // 45\n    (1951354384207722496, 11), // 46\n    (2472159215084012303, 11), // 47\n    (3116402981210161152, 11), // 48\n    (3909821048582988049, 11), // 49\n    (4882812500000000000, 11), // 50\n    (6071163615208263051, 11), // 51\n    (7516865509350965248, 11), // 52\n    (9269035929372191597, 11), // 53\n    (11384956040305711104, 11), // 54\n    (13931233916552734375, 11), // 55\n    (16985107389382393856, 11), // 56\n    (362033331456891249, 10), // 57\n    (430804206899405824, 10), // 58\n    (511116753300641401, 10), // 59\n    (604661760000000000, 10), // 60\n    (713342911662882601, 10), // 61\n    (839299365868340224, 10), // 62\n    (984930291881790849, 10), // 63\n    (0, 0), // 64\n    (1346274334462890625, 10), // 65\n    (1568336880910795776, 10), // 66\n    (1822837804551761449, 10), // 67\n    (2113922820157210624, 10), // 68\n    (2446194060654759801, 10), // 69\n    (2824752490000000000, 10), // 70\n    (3255243551009881201, 10), // 71\n    (3743906242624487424, 10), // 72\n    (4297625829703557649, 10), // 73\n    (4923990397355877376, 10), // 74\n    (5631351470947265625, 10), // 75\n    (6428888932339941376, 10), // 76\n    (7326680472586200649, 10), // 77\n    (8335775831236199424, 10), // 78\n    (9468276082626847201, 10), // 79\n    (10737418240000000000, 10), // 80\n    (12157665459056928801, 10), // 81\n    (13744803133596058624, 10), // 82\n    (15516041187205853449, 10), // 83\n    (17490122876598091776, 10), // 84\n    (231616946283203125, 9), // 85\n    (257327417311663616, 9), // 86\n    (285544154243029527, 9), // 87\n    (316478381828866048, 9), // 88\n    (350356403707485209, 9), // 89\n    (387420489000000000, 9), // 90\n    (427929800129788411, 9), // 91\n    (472161363286556672, 9), // 92\n    (520411082988487293, 9), // 93\n    (572994802228616704, 9), // 94\n    (630249409724609375, 9), // 95\n    (692533995824480256, 9), // 96\n    (760231058654565217, 9), // 97\n    (833747762130149888, 9), // 98\n    (913517247483640899, 9), // 99\n    (1000000000000000000, 9), // 100\n    (1093685272684360901, 9), // 101\n    (1195092568622310912, 9), // 102\n    (1304773183829244583, 9), // 103\n    (1423311812421484544, 9), // 104\n    (1551328215978515625, 9), // 105\n    (1689478959002692096, 9), // 106\n    (1838459212420154507, 9), // 107\n    (1999004627104432128, 9), // 108\n    (2171893279442309389, 9), // 109\n    (2357947691000000000, 9), // 110\n    (2558036924386500591, 9), // 111\n    (2773078757450186752, 9), // 112\n    (3004041937984268273, 9), // 113\n    (3251948521156637184, 9), // 114\n    (3517876291919921875, 9), // 115\n    (3802961274698203136, 9), // 116\n    (4108400332687853397, 9), // 117\n    (4435453859151328768, 9), // 118\n    (4785448563124474679, 9), // 119\n    (5159780352000000000, 9), // 120\n    (5559917313492231481, 9), // 121\n    (5987402799531080192, 9), // 122\n    (6443858614676334363, 9), // 123\n    (6930988311686938624, 9), // 124\n    (7450580596923828125, 9), // 125\n    (8004512848309157376, 9), // 126\n    (8594754748609397887, 9), // 127\n    (0, 0), // 128\n    (9892530380752880769, 9), // 129\n    (10604499373000000000, 9), // 130\n    (11361656654439817571, 9), // 131\n    (12166492167065567232, 9), // 132\n    (13021612539908538853, 9), // 133\n    (13929745610903012864, 9), // 134\n    (14893745087865234375, 9), // 135\n    (15916595351771938816, 9), // 136\n    (17001416405572203977, 9), // 137\n    (18151468971815029248, 9), // 138\n    (139353667211683681, 8), // 139\n    (147578905600000000, 8), // 140\n    (156225851787813921, 8), // 141\n    (165312903998914816, 8), // 142\n    (174859124550883201, 8), // 143\n    (184884258895036416, 8), // 144\n    (195408755062890625, 8), // 145\n    (206453783524884736, 8), // 146\n    (218041257467152161, 8), // 147\n    (230193853492166656, 8), // 148\n    (242935032749128801, 8), // 149\n    (256289062500000000, 8), // 150\n    (270281038127131201, 8), // 151\n    (284936905588473856, 8), // 152\n    (300283484326400961, 8), // 153\n    (316348490636206336, 8), // 154\n    (333160561500390625, 8), // 155\n    (350749278894882816, 8), // 156\n    (369145194573386401, 8), // 157\n    (388379855336079616, 8), // 158\n    (408485828788939521, 8), // 159\n    (429496729600000000, 8), // 160\n    (451447246258894081, 8), // 161\n    (474373168346071296, 8), // 162\n    (498311414318121121, 8), // 163\n    (523300059815673856, 8), // 164\n    (549378366500390625, 8), // 165\n    (576586811427594496, 8), // 166\n    (604967116961135041, 8), // 167\n    (634562281237118976, 8), // 168\n    (665416609183179841, 8), // 169\n    (697575744100000000, 8), // 170\n    (731086699811838561, 8), // 171\n    (765997893392859136, 8), // 172\n    (802359178476091681, 8), // 173\n    (840221879151902976, 8), // 174\n    (879638824462890625, 8), // 175\n    (920664383502155776, 8), // 176\n    (963354501121950081, 8), // 177\n    (1007766734259732736, 8), // 178\n    (1053960288888713761, 8), // 179\n    (1101996057600000000, 8), // 180\n    (1151936657823500641, 8), // 181\n    (1203846470694789376, 8), // 182\n    (1257791680575160641, 8), // 183\n    (1313840315232157696, 8), // 184\n    (1372062286687890625, 8), // 185\n    (1432529432742502656, 8), // 186\n    (1495315559180183521, 8), // 187\n    (1560496482665168896, 8), // 188\n    (1628150074335205281, 8), // 189\n    (1698356304100000000, 8), // 190\n    (1771197285652216321, 8), // 191\n    (1846757322198614016, 8), // 192\n    (1925122952918976001, 8), // 193\n    (2006383000160502016, 8), // 194\n    (2090628617375390625, 8), // 195\n    (2177953337809371136, 8), // 196\n    (2268453123948987361, 8), // 197\n    (2362226417735475456, 8), // 198\n    (2459374191553118401, 8), // 199\n    (2560000000000000000, 8), // 200\n    (2664210032449121601, 8), // 201\n    (2772113166407885056, 8), // 202\n    (2883821021683985761, 8), // 203\n    (2999448015365799936, 8), // 204\n    (3119111417625390625, 8), // 205\n    (3242931408352297216, 8), // 206\n    (3371031134626313601, 8), // 207\n    (3503536769037500416, 8), // 208\n    (3640577568861717121, 8), // 209\n    (3782285936100000000, 8), // 210\n    (3928797478390152481, 8), // 211\n    (4080251070798954496, 8), // 212\n    (4236788918503437921, 8), // 213\n    (4398556620369715456, 8), // 214\n    (4565703233437890625, 8), // 215\n    (4738381338321616896, 8), // 216\n    (4916747105530914241, 8), // 217\n    (5100960362726891776, 8), // 218\n    (5291184662917065441, 8), // 219\n    (5487587353600000000, 8), // 220\n    (5690339646868044961, 8), // 221\n    (5899616690476974336, 8), // 222\n    (6115597639891380481, 8), // 223\n    (6338465731314712576, 8), // 224\n    (6568408355712890625, 8), // 225\n    (6805617133840466176, 8), // 226\n    (7050287992278341281, 8), // 227\n    (7302621240492097536, 8), // 228\n    (7562821648920027361, 8), // 229\n    (7831098528100000000, 8), // 230\n    (8107665808844335041, 8), // 231\n    (8392742123471896576, 8), // 232\n    (8686550888106661441, 8), // 233\n    (8989320386052055296, 8), // 234\n    (9301283852250390625, 8), // 235\n    (9622679558836781056, 8), // 236\n    (9953750901796946721, 8), // 237\n    (10294746488738365696, 8), // 238\n    (10645920227784266881, 8), // 239\n    (11007531417600000000, 8), // 240\n    (11379844838561358721, 8), // 241\n    (11763130845074473216, 8), // 242\n    (12157665459056928801, 8), // 243\n    (12563730464589807616, 8), // 244\n    (12981613503750390625, 8), // 245\n    (13411608173635297536, 8), // 246\n    (13854014124583882561, 8), // 247\n    (14309137159611744256, 8), // 248\n    (14777289335064248001, 8), // 249\n    (15258789062500000000, 8), // 250\n    (15753961211814252001, 8), // 251\n    (16263137215612256256, 8), // 252\n    (16786655174842630561, 8), // 253\n    (17324859965700833536, 8), // 254\n    (17878103347812890625, 8), // 255\n    (0, 0), // 256\n];\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","fuzz","target","x86_64-unknown-linux-gnu","release","build","typenum-85e81dd0a8c9dcba","out","consts.rs"],"content":"\n/**\nType aliases for many constants.\n\nThis file is generated by typenum's build script.\n\nFor unsigned integers, the format is `U` followed by the number. We define aliases for\n\n- Numbers 0 through 1024\n- Powers of 2 below `u64::MAX`\n- Powers of 10 below `u64::MAX`\n\nThese alias definitions look like this:\n\n```rust\nuse typenum::{B0, B1, UInt, UTerm};\n\n# #[allow(dead_code)]\ntype U6 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e;\n```\n\nFor positive signed integers, the format is `P` followed by the number and for negative\nsigned integers it is `N` followed by the number. For the signed integer zero, we use\n`Z0`. We define aliases for\n\n- Numbers -1024 through 1024\n- Powers of 2 between `i64::MIN` and `i64::MAX`\n- Powers of 10 between `i64::MIN` and `i64::MAX`\n\nThese alias definitions look like this:\n\n```rust\nuse typenum::{B0, B1, UInt, UTerm, PInt, NInt};\n\n# #[allow(dead_code)]\ntype P6 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n# #[allow(dead_code)]\ntype N6 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n```\n\n# Example\n```rust\n# #[allow(unused_imports)]\nuse typenum::{U0, U1, U2, U3, U4, U5, U6};\n# #[allow(unused_imports)]\nuse typenum::{N3, N2, N1, Z0, P1, P2, P3};\n# #[allow(unused_imports)]\nuse typenum::{U774, N17, N10000, P1024, P4096};\n```\n\nWe also define the aliases `False` and `True` for `B0` and `B1`, respectively.\n*/\n#[allow(missing_docs)]\npub mod consts {\n    use crate::uint::{UInt, UTerm};\n    use crate::int::{PInt, NInt};\n\n    pub use crate::bit::{B0, B1};\n    pub use crate::int::Z0;\n\n    pub type True = B1;\n    pub type False = B0;\n    pub type U0 = UTerm;\n    pub type U1 = UInt\u003cUTerm, B1\u003e;\n    pub type P1 = PInt\u003cU1\u003e; pub type N1 = NInt\u003cU1\u003e;\n    pub type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    pub type P2 = PInt\u003cU2\u003e; pub type N2 = NInt\u003cU2\u003e;\n    pub type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    pub type P3 = PInt\u003cU3\u003e; pub type N3 = NInt\u003cU3\u003e;\n    pub type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    pub type P4 = PInt\u003cU4\u003e; pub type N4 = NInt\u003cU4\u003e;\n    pub type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    pub type P5 = PInt\u003cU5\u003e; pub type N5 = NInt\u003cU5\u003e;\n    pub type U6 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e;\n    pub type P6 = PInt\u003cU6\u003e; pub type N6 = NInt\u003cU6\u003e;\n    pub type U7 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e;\n    pub type P7 = PInt\u003cU7\u003e; pub type N7 = NInt\u003cU7\u003e;\n    pub type U8 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P8 = PInt\u003cU8\u003e; pub type N8 = NInt\u003cU8\u003e;\n    pub type U9 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P9 = PInt\u003cU9\u003e; pub type N9 = NInt\u003cU9\u003e;\n    pub type U10 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P10 = PInt\u003cU10\u003e; pub type N10 = NInt\u003cU10\u003e;\n    pub type U11 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P11 = PInt\u003cU11\u003e; pub type N11 = NInt\u003cU11\u003e;\n    pub type U12 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P12 = PInt\u003cU12\u003e; pub type N12 = NInt\u003cU12\u003e;\n    pub type U13 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P13 = PInt\u003cU13\u003e; pub type N13 = NInt\u003cU13\u003e;\n    pub type U14 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P14 = PInt\u003cU14\u003e; pub type N14 = NInt\u003cU14\u003e;\n    pub type U15 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P15 = PInt\u003cU15\u003e; pub type N15 = NInt\u003cU15\u003e;\n    pub type U16 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P16 = PInt\u003cU16\u003e; pub type N16 = NInt\u003cU16\u003e;\n    pub type U17 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P17 = PInt\u003cU17\u003e; pub type N17 = NInt\u003cU17\u003e;\n    pub type U18 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P18 = PInt\u003cU18\u003e; pub type N18 = NInt\u003cU18\u003e;\n    pub type U19 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P19 = PInt\u003cU19\u003e; pub type N19 = NInt\u003cU19\u003e;\n    pub type U20 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P20 = PInt\u003cU20\u003e; pub type N20 = NInt\u003cU20\u003e;\n    pub type U21 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P21 = PInt\u003cU21\u003e; pub type N21 = NInt\u003cU21\u003e;\n    pub type U22 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P22 = PInt\u003cU22\u003e; pub type N22 = NInt\u003cU22\u003e;\n    pub type U23 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P23 = PInt\u003cU23\u003e; pub type N23 = NInt\u003cU23\u003e;\n    pub type U24 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P24 = PInt\u003cU24\u003e; pub type N24 = NInt\u003cU24\u003e;\n    pub type U25 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P25 = PInt\u003cU25\u003e; pub type N25 = NInt\u003cU25\u003e;\n    pub type U26 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P26 = PInt\u003cU26\u003e; pub type N26 = NInt\u003cU26\u003e;\n    pub type U27 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P27 = PInt\u003cU27\u003e; pub type N27 = NInt\u003cU27\u003e;\n    pub type U28 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P28 = PInt\u003cU28\u003e; pub type N28 = NInt\u003cU28\u003e;\n    pub type U29 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P29 = PInt\u003cU29\u003e; pub type N29 = NInt\u003cU29\u003e;\n    pub type U30 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P30 = PInt\u003cU30\u003e; pub type N30 = NInt\u003cU30\u003e;\n    pub type U31 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P31 = PInt\u003cU31\u003e; pub type N31 = NInt\u003cU31\u003e;\n    pub type U32 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P32 = PInt\u003cU32\u003e; pub type N32 = NInt\u003cU32\u003e;\n    pub type U33 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P33 = PInt\u003cU33\u003e; pub type N33 = NInt\u003cU33\u003e;\n    pub type U34 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P34 = PInt\u003cU34\u003e; pub type N34 = NInt\u003cU34\u003e;\n    pub type U35 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P35 = PInt\u003cU35\u003e; pub type N35 = NInt\u003cU35\u003e;\n    pub type U36 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P36 = PInt\u003cU36\u003e; pub type N36 = NInt\u003cU36\u003e;\n    pub type U37 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P37 = PInt\u003cU37\u003e; pub type N37 = NInt\u003cU37\u003e;\n    pub type U38 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P38 = PInt\u003cU38\u003e; pub type N38 = NInt\u003cU38\u003e;\n    pub type U39 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P39 = PInt\u003cU39\u003e; pub type N39 = NInt\u003cU39\u003e;\n    pub type U40 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P40 = PInt\u003cU40\u003e; pub type N40 = NInt\u003cU40\u003e;\n    pub type U41 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P41 = PInt\u003cU41\u003e; pub type N41 = NInt\u003cU41\u003e;\n    pub type U42 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P42 = PInt\u003cU42\u003e; pub type N42 = NInt\u003cU42\u003e;\n    pub type U43 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P43 = PInt\u003cU43\u003e; pub type N43 = NInt\u003cU43\u003e;\n    pub type U44 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P44 = PInt\u003cU44\u003e; pub type N44 = NInt\u003cU44\u003e;\n    pub type U45 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P45 = PInt\u003cU45\u003e; pub type N45 = NInt\u003cU45\u003e;\n    pub type U46 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P46 = PInt\u003cU46\u003e; pub type N46 = NInt\u003cU46\u003e;\n    pub type U47 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P47 = PInt\u003cU47\u003e; pub type N47 = NInt\u003cU47\u003e;\n    pub type U48 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P48 = PInt\u003cU48\u003e; pub type N48 = NInt\u003cU48\u003e;\n    pub type U49 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P49 = PInt\u003cU49\u003e; pub type N49 = NInt\u003cU49\u003e;\n    pub type U50 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P50 = PInt\u003cU50\u003e; pub type N50 = NInt\u003cU50\u003e;\n    pub type U51 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P51 = PInt\u003cU51\u003e; pub type N51 = NInt\u003cU51\u003e;\n    pub type U52 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P52 = PInt\u003cU52\u003e; pub type N52 = NInt\u003cU52\u003e;\n    pub type U53 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P53 = PInt\u003cU53\u003e; pub type N53 = NInt\u003cU53\u003e;\n    pub type U54 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P54 = PInt\u003cU54\u003e; pub type N54 = NInt\u003cU54\u003e;\n    pub type U55 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P55 = PInt\u003cU55\u003e; pub type N55 = NInt\u003cU55\u003e;\n    pub type U56 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P56 = PInt\u003cU56\u003e; pub type N56 = NInt\u003cU56\u003e;\n    pub type U57 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P57 = PInt\u003cU57\u003e; pub type N57 = NInt\u003cU57\u003e;\n    pub type U58 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P58 = PInt\u003cU58\u003e; pub type N58 = NInt\u003cU58\u003e;\n    pub type U59 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P59 = PInt\u003cU59\u003e; pub type N59 = NInt\u003cU59\u003e;\n    pub type U60 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P60 = PInt\u003cU60\u003e; pub type N60 = NInt\u003cU60\u003e;\n    pub type U61 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P61 = PInt\u003cU61\u003e; pub type N61 = NInt\u003cU61\u003e;\n    pub type U62 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P62 = PInt\u003cU62\u003e; pub type N62 = NInt\u003cU62\u003e;\n    pub type U63 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P63 = PInt\u003cU63\u003e; pub type N63 = NInt\u003cU63\u003e;\n    pub type U64 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P64 = PInt\u003cU64\u003e; pub type N64 = NInt\u003cU64\u003e;\n    pub type U65 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P65 = PInt\u003cU65\u003e; pub type N65 = NInt\u003cU65\u003e;\n    pub type U66 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P66 = PInt\u003cU66\u003e; pub type N66 = NInt\u003cU66\u003e;\n    pub type U67 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P67 = PInt\u003cU67\u003e; pub type N67 = NInt\u003cU67\u003e;\n    pub type U68 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P68 = PInt\u003cU68\u003e; pub type N68 = NInt\u003cU68\u003e;\n    pub type U69 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P69 = PInt\u003cU69\u003e; pub type N69 = NInt\u003cU69\u003e;\n    pub type U70 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P70 = PInt\u003cU70\u003e; pub type N70 = NInt\u003cU70\u003e;\n    pub type U71 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P71 = PInt\u003cU71\u003e; pub type N71 = NInt\u003cU71\u003e;\n    pub type U72 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P72 = PInt\u003cU72\u003e; pub type N72 = NInt\u003cU72\u003e;\n    pub type U73 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P73 = PInt\u003cU73\u003e; pub type N73 = NInt\u003cU73\u003e;\n    pub type U74 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P74 = PInt\u003cU74\u003e; pub type N74 = NInt\u003cU74\u003e;\n    pub type U75 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P75 = PInt\u003cU75\u003e; pub type N75 = NInt\u003cU75\u003e;\n    pub type U76 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P76 = PInt\u003cU76\u003e; pub type N76 = NInt\u003cU76\u003e;\n    pub type U77 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P77 = PInt\u003cU77\u003e; pub type N77 = NInt\u003cU77\u003e;\n    pub type U78 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P78 = PInt\u003cU78\u003e; pub type N78 = NInt\u003cU78\u003e;\n    pub type U79 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P79 = PInt\u003cU79\u003e; pub type N79 = NInt\u003cU79\u003e;\n    pub type U80 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P80 = PInt\u003cU80\u003e; pub type N80 = NInt\u003cU80\u003e;\n    pub type U81 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P81 = PInt\u003cU81\u003e; pub type N81 = NInt\u003cU81\u003e;\n    pub type U82 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P82 = PInt\u003cU82\u003e; pub type N82 = NInt\u003cU82\u003e;\n    pub type U83 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P83 = PInt\u003cU83\u003e; pub type N83 = NInt\u003cU83\u003e;\n    pub type U84 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P84 = PInt\u003cU84\u003e; pub type N84 = NInt\u003cU84\u003e;\n    pub type U85 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P85 = PInt\u003cU85\u003e; pub type N85 = NInt\u003cU85\u003e;\n    pub type U86 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P86 = PInt\u003cU86\u003e; pub type N86 = NInt\u003cU86\u003e;\n    pub type U87 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P87 = PInt\u003cU87\u003e; pub type N87 = NInt\u003cU87\u003e;\n    pub type U88 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P88 = PInt\u003cU88\u003e; pub type N88 = NInt\u003cU88\u003e;\n    pub type U89 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P89 = PInt\u003cU89\u003e; pub type N89 = NInt\u003cU89\u003e;\n    pub type U90 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P90 = PInt\u003cU90\u003e; pub type N90 = NInt\u003cU90\u003e;\n    pub type U91 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P91 = PInt\u003cU91\u003e; pub type N91 = NInt\u003cU91\u003e;\n    pub type U92 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P92 = PInt\u003cU92\u003e; pub type N92 = NInt\u003cU92\u003e;\n    pub type U93 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P93 = PInt\u003cU93\u003e; pub type N93 = NInt\u003cU93\u003e;\n    pub type U94 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P94 = PInt\u003cU94\u003e; pub type N94 = NInt\u003cU94\u003e;\n    pub type U95 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P95 = PInt\u003cU95\u003e; pub type N95 = NInt\u003cU95\u003e;\n    pub type U96 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P96 = PInt\u003cU96\u003e; pub type N96 = NInt\u003cU96\u003e;\n    pub type U97 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P97 = PInt\u003cU97\u003e; pub type N97 = NInt\u003cU97\u003e;\n    pub type U98 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P98 = PInt\u003cU98\u003e; pub type N98 = NInt\u003cU98\u003e;\n    pub type U99 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P99 = PInt\u003cU99\u003e; pub type N99 = NInt\u003cU99\u003e;\n    pub type U100 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P100 = PInt\u003cU100\u003e; pub type N100 = NInt\u003cU100\u003e;\n    pub type U101 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P101 = PInt\u003cU101\u003e; pub type N101 = NInt\u003cU101\u003e;\n    pub type U102 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P102 = PInt\u003cU102\u003e; pub type N102 = NInt\u003cU102\u003e;\n    pub type U103 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P103 = PInt\u003cU103\u003e; pub type N103 = NInt\u003cU103\u003e;\n    pub type U104 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P104 = PInt\u003cU104\u003e; pub type N104 = NInt\u003cU104\u003e;\n    pub type U105 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P105 = PInt\u003cU105\u003e; pub type N105 = NInt\u003cU105\u003e;\n    pub type U106 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P106 = PInt\u003cU106\u003e; pub type N106 = NInt\u003cU106\u003e;\n    pub type U107 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P107 = PInt\u003cU107\u003e; pub type N107 = NInt\u003cU107\u003e;\n    pub type U108 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P108 = PInt\u003cU108\u003e; pub type N108 = NInt\u003cU108\u003e;\n    pub type U109 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P109 = PInt\u003cU109\u003e; pub type N109 = NInt\u003cU109\u003e;\n    pub type U110 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P110 = PInt\u003cU110\u003e; pub type N110 = NInt\u003cU110\u003e;\n    pub type U111 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P111 = PInt\u003cU111\u003e; pub type N111 = NInt\u003cU111\u003e;\n    pub type U112 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P112 = PInt\u003cU112\u003e; pub type N112 = NInt\u003cU112\u003e;\n    pub type U113 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P113 = PInt\u003cU113\u003e; pub type N113 = NInt\u003cU113\u003e;\n    pub type U114 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P114 = PInt\u003cU114\u003e; pub type N114 = NInt\u003cU114\u003e;\n    pub type U115 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P115 = PInt\u003cU115\u003e; pub type N115 = NInt\u003cU115\u003e;\n    pub type U116 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P116 = PInt\u003cU116\u003e; pub type N116 = NInt\u003cU116\u003e;\n    pub type U117 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P117 = PInt\u003cU117\u003e; pub type N117 = NInt\u003cU117\u003e;\n    pub type U118 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P118 = PInt\u003cU118\u003e; pub type N118 = NInt\u003cU118\u003e;\n    pub type U119 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P119 = PInt\u003cU119\u003e; pub type N119 = NInt\u003cU119\u003e;\n    pub type U120 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P120 = PInt\u003cU120\u003e; pub type N120 = NInt\u003cU120\u003e;\n    pub type U121 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P121 = PInt\u003cU121\u003e; pub type N121 = NInt\u003cU121\u003e;\n    pub type U122 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P122 = PInt\u003cU122\u003e; pub type N122 = NInt\u003cU122\u003e;\n    pub type U123 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P123 = PInt\u003cU123\u003e; pub type N123 = NInt\u003cU123\u003e;\n    pub type U124 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P124 = PInt\u003cU124\u003e; pub type N124 = NInt\u003cU124\u003e;\n    pub type U125 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P125 = PInt\u003cU125\u003e; pub type N125 = NInt\u003cU125\u003e;\n    pub type U126 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P126 = PInt\u003cU126\u003e; pub type N126 = NInt\u003cU126\u003e;\n    pub type U127 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P127 = PInt\u003cU127\u003e; pub type N127 = NInt\u003cU127\u003e;\n    pub type U128 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P128 = PInt\u003cU128\u003e; pub type N128 = NInt\u003cU128\u003e;\n    pub type U129 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P129 = PInt\u003cU129\u003e; pub type N129 = NInt\u003cU129\u003e;\n    pub type U130 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P130 = PInt\u003cU130\u003e; pub type N130 = NInt\u003cU130\u003e;\n    pub type U131 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P131 = PInt\u003cU131\u003e; pub type N131 = NInt\u003cU131\u003e;\n    pub type U132 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P132 = PInt\u003cU132\u003e; pub type N132 = NInt\u003cU132\u003e;\n    pub type U133 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P133 = PInt\u003cU133\u003e; pub type N133 = NInt\u003cU133\u003e;\n    pub type U134 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P134 = PInt\u003cU134\u003e; pub type N134 = NInt\u003cU134\u003e;\n    pub type U135 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P135 = PInt\u003cU135\u003e; pub type N135 = NInt\u003cU135\u003e;\n    pub type U136 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P136 = PInt\u003cU136\u003e; pub type N136 = NInt\u003cU136\u003e;\n    pub type U137 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P137 = PInt\u003cU137\u003e; pub type N137 = NInt\u003cU137\u003e;\n    pub type U138 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P138 = PInt\u003cU138\u003e; pub type N138 = NInt\u003cU138\u003e;\n    pub type U139 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P139 = PInt\u003cU139\u003e; pub type N139 = NInt\u003cU139\u003e;\n    pub type U140 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P140 = PInt\u003cU140\u003e; pub type N140 = NInt\u003cU140\u003e;\n    pub type U141 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P141 = PInt\u003cU141\u003e; pub type N141 = NInt\u003cU141\u003e;\n    pub type U142 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P142 = PInt\u003cU142\u003e; pub type N142 = NInt\u003cU142\u003e;\n    pub type U143 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P143 = PInt\u003cU143\u003e; pub type N143 = NInt\u003cU143\u003e;\n    pub type U144 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P144 = PInt\u003cU144\u003e; pub type N144 = NInt\u003cU144\u003e;\n    pub type U145 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P145 = PInt\u003cU145\u003e; pub type N145 = NInt\u003cU145\u003e;\n    pub type U146 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P146 = PInt\u003cU146\u003e; pub type N146 = NInt\u003cU146\u003e;\n    pub type U147 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P147 = PInt\u003cU147\u003e; pub type N147 = NInt\u003cU147\u003e;\n    pub type U148 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P148 = PInt\u003cU148\u003e; pub type N148 = NInt\u003cU148\u003e;\n    pub type U149 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P149 = PInt\u003cU149\u003e; pub type N149 = NInt\u003cU149\u003e;\n    pub type U150 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P150 = PInt\u003cU150\u003e; pub type N150 = NInt\u003cU150\u003e;\n    pub type U151 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P151 = PInt\u003cU151\u003e; pub type N151 = NInt\u003cU151\u003e;\n    pub type U152 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P152 = PInt\u003cU152\u003e; pub type N152 = NInt\u003cU152\u003e;\n    pub type U153 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P153 = PInt\u003cU153\u003e; pub type N153 = NInt\u003cU153\u003e;\n    pub type U154 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P154 = PInt\u003cU154\u003e; pub type N154 = NInt\u003cU154\u003e;\n    pub type U155 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P155 = PInt\u003cU155\u003e; pub type N155 = NInt\u003cU155\u003e;\n    pub type U156 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P156 = PInt\u003cU156\u003e; pub type N156 = NInt\u003cU156\u003e;\n    pub type U157 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P157 = PInt\u003cU157\u003e; pub type N157 = NInt\u003cU157\u003e;\n    pub type U158 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P158 = PInt\u003cU158\u003e; pub type N158 = NInt\u003cU158\u003e;\n    pub type U159 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P159 = PInt\u003cU159\u003e; pub type N159 = NInt\u003cU159\u003e;\n    pub type U160 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P160 = PInt\u003cU160\u003e; pub type N160 = NInt\u003cU160\u003e;\n    pub type U161 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P161 = PInt\u003cU161\u003e; pub type N161 = NInt\u003cU161\u003e;\n    pub type U162 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P162 = PInt\u003cU162\u003e; pub type N162 = NInt\u003cU162\u003e;\n    pub type U163 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P163 = PInt\u003cU163\u003e; pub type N163 = NInt\u003cU163\u003e;\n    pub type U164 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P164 = PInt\u003cU164\u003e; pub type N164 = NInt\u003cU164\u003e;\n    pub type U165 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P165 = PInt\u003cU165\u003e; pub type N165 = NInt\u003cU165\u003e;\n    pub type U166 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P166 = PInt\u003cU166\u003e; pub type N166 = NInt\u003cU166\u003e;\n    pub type U167 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P167 = PInt\u003cU167\u003e; pub type N167 = NInt\u003cU167\u003e;\n    pub type U168 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P168 = PInt\u003cU168\u003e; pub type N168 = NInt\u003cU168\u003e;\n    pub type U169 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P169 = PInt\u003cU169\u003e; pub type N169 = NInt\u003cU169\u003e;\n    pub type U170 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P170 = PInt\u003cU170\u003e; pub type N170 = NInt\u003cU170\u003e;\n    pub type U171 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P171 = PInt\u003cU171\u003e; pub type N171 = NInt\u003cU171\u003e;\n    pub type U172 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P172 = PInt\u003cU172\u003e; pub type N172 = NInt\u003cU172\u003e;\n    pub type U173 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P173 = PInt\u003cU173\u003e; pub type N173 = NInt\u003cU173\u003e;\n    pub type U174 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P174 = PInt\u003cU174\u003e; pub type N174 = NInt\u003cU174\u003e;\n    pub type U175 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P175 = PInt\u003cU175\u003e; pub type N175 = NInt\u003cU175\u003e;\n    pub type U176 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P176 = PInt\u003cU176\u003e; pub type N176 = NInt\u003cU176\u003e;\n    pub type U177 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P177 = PInt\u003cU177\u003e; pub type N177 = NInt\u003cU177\u003e;\n    pub type U178 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P178 = PInt\u003cU178\u003e; pub type N178 = NInt\u003cU178\u003e;\n    pub type U179 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P179 = PInt\u003cU179\u003e; pub type N179 = NInt\u003cU179\u003e;\n    pub type U180 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P180 = PInt\u003cU180\u003e; pub type N180 = NInt\u003cU180\u003e;\n    pub type U181 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P181 = PInt\u003cU181\u003e; pub type N181 = NInt\u003cU181\u003e;\n    pub type U182 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P182 = PInt\u003cU182\u003e; pub type N182 = NInt\u003cU182\u003e;\n    pub type U183 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P183 = PInt\u003cU183\u003e; pub type N183 = NInt\u003cU183\u003e;\n    pub type U184 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P184 = PInt\u003cU184\u003e; pub type N184 = NInt\u003cU184\u003e;\n    pub type U185 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P185 = PInt\u003cU185\u003e; pub type N185 = NInt\u003cU185\u003e;\n    pub type U186 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P186 = PInt\u003cU186\u003e; pub type N186 = NInt\u003cU186\u003e;\n    pub type U187 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P187 = PInt\u003cU187\u003e; pub type N187 = NInt\u003cU187\u003e;\n    pub type U188 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P188 = PInt\u003cU188\u003e; pub type N188 = NInt\u003cU188\u003e;\n    pub type U189 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P189 = PInt\u003cU189\u003e; pub type N189 = NInt\u003cU189\u003e;\n    pub type U190 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P190 = PInt\u003cU190\u003e; pub type N190 = NInt\u003cU190\u003e;\n    pub type U191 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P191 = PInt\u003cU191\u003e; pub type N191 = NInt\u003cU191\u003e;\n    pub type U192 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P192 = PInt\u003cU192\u003e; pub type N192 = NInt\u003cU192\u003e;\n    pub type U193 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P193 = PInt\u003cU193\u003e; pub type N193 = NInt\u003cU193\u003e;\n    pub type U194 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P194 = PInt\u003cU194\u003e; pub type N194 = NInt\u003cU194\u003e;\n    pub type U195 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P195 = PInt\u003cU195\u003e; pub type N195 = NInt\u003cU195\u003e;\n    pub type U196 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P196 = PInt\u003cU196\u003e; pub type N196 = NInt\u003cU196\u003e;\n    pub type U197 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P197 = PInt\u003cU197\u003e; pub type N197 = NInt\u003cU197\u003e;\n    pub type U198 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P198 = PInt\u003cU198\u003e; pub type N198 = NInt\u003cU198\u003e;\n    pub type U199 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P199 = PInt\u003cU199\u003e; pub type N199 = NInt\u003cU199\u003e;\n    pub type U200 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P200 = PInt\u003cU200\u003e; pub type N200 = NInt\u003cU200\u003e;\n    pub type U201 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P201 = PInt\u003cU201\u003e; pub type N201 = NInt\u003cU201\u003e;\n    pub type U202 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P202 = PInt\u003cU202\u003e; pub type N202 = NInt\u003cU202\u003e;\n    pub type U203 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P203 = PInt\u003cU203\u003e; pub type N203 = NInt\u003cU203\u003e;\n    pub type U204 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P204 = PInt\u003cU204\u003e; pub type N204 = NInt\u003cU204\u003e;\n    pub type U205 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P205 = PInt\u003cU205\u003e; pub type N205 = NInt\u003cU205\u003e;\n    pub type U206 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P206 = PInt\u003cU206\u003e; pub type N206 = NInt\u003cU206\u003e;\n    pub type U207 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P207 = PInt\u003cU207\u003e; pub type N207 = NInt\u003cU207\u003e;\n    pub type U208 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P208 = PInt\u003cU208\u003e; pub type N208 = NInt\u003cU208\u003e;\n    pub type U209 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P209 = PInt\u003cU209\u003e; pub type N209 = NInt\u003cU209\u003e;\n    pub type U210 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P210 = PInt\u003cU210\u003e; pub type N210 = NInt\u003cU210\u003e;\n    pub type U211 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P211 = PInt\u003cU211\u003e; pub type N211 = NInt\u003cU211\u003e;\n    pub type U212 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P212 = PInt\u003cU212\u003e; pub type N212 = NInt\u003cU212\u003e;\n    pub type U213 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P213 = PInt\u003cU213\u003e; pub type N213 = NInt\u003cU213\u003e;\n    pub type U214 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P214 = PInt\u003cU214\u003e; pub type N214 = NInt\u003cU214\u003e;\n    pub type U215 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P215 = PInt\u003cU215\u003e; pub type N215 = NInt\u003cU215\u003e;\n    pub type U216 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P216 = PInt\u003cU216\u003e; pub type N216 = NInt\u003cU216\u003e;\n    pub type U217 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P217 = PInt\u003cU217\u003e; pub type N217 = NInt\u003cU217\u003e;\n    pub type U218 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P218 = PInt\u003cU218\u003e; pub type N218 = NInt\u003cU218\u003e;\n    pub type U219 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P219 = PInt\u003cU219\u003e; pub type N219 = NInt\u003cU219\u003e;\n    pub type U220 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P220 = PInt\u003cU220\u003e; pub type N220 = NInt\u003cU220\u003e;\n    pub type U221 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P221 = PInt\u003cU221\u003e; pub type N221 = NInt\u003cU221\u003e;\n    pub type U222 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P222 = PInt\u003cU222\u003e; pub type N222 = NInt\u003cU222\u003e;\n    pub type U223 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P223 = PInt\u003cU223\u003e; pub type N223 = NInt\u003cU223\u003e;\n    pub type U224 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P224 = PInt\u003cU224\u003e; pub type N224 = NInt\u003cU224\u003e;\n    pub type U225 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P225 = PInt\u003cU225\u003e; pub type N225 = NInt\u003cU225\u003e;\n    pub type U226 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P226 = PInt\u003cU226\u003e; pub type N226 = NInt\u003cU226\u003e;\n    pub type U227 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P227 = PInt\u003cU227\u003e; pub type N227 = NInt\u003cU227\u003e;\n    pub type U228 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P228 = PInt\u003cU228\u003e; pub type N228 = NInt\u003cU228\u003e;\n    pub type U229 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P229 = PInt\u003cU229\u003e; pub type N229 = NInt\u003cU229\u003e;\n    pub type U230 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P230 = PInt\u003cU230\u003e; pub type N230 = NInt\u003cU230\u003e;\n    pub type U231 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P231 = PInt\u003cU231\u003e; pub type N231 = NInt\u003cU231\u003e;\n    pub type U232 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P232 = PInt\u003cU232\u003e; pub type N232 = NInt\u003cU232\u003e;\n    pub type U233 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P233 = PInt\u003cU233\u003e; pub type N233 = NInt\u003cU233\u003e;\n    pub type U234 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P234 = PInt\u003cU234\u003e; pub type N234 = NInt\u003cU234\u003e;\n    pub type U235 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P235 = PInt\u003cU235\u003e; pub type N235 = NInt\u003cU235\u003e;\n    pub type U236 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P236 = PInt\u003cU236\u003e; pub type N236 = NInt\u003cU236\u003e;\n    pub type U237 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P237 = PInt\u003cU237\u003e; pub type N237 = NInt\u003cU237\u003e;\n    pub type U238 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P238 = PInt\u003cU238\u003e; pub type N238 = NInt\u003cU238\u003e;\n    pub type U239 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P239 = PInt\u003cU239\u003e; pub type N239 = NInt\u003cU239\u003e;\n    pub type U240 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P240 = PInt\u003cU240\u003e; pub type N240 = NInt\u003cU240\u003e;\n    pub type U241 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P241 = PInt\u003cU241\u003e; pub type N241 = NInt\u003cU241\u003e;\n    pub type U242 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P242 = PInt\u003cU242\u003e; pub type N242 = NInt\u003cU242\u003e;\n    pub type U243 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P243 = PInt\u003cU243\u003e; pub type N243 = NInt\u003cU243\u003e;\n    pub type U244 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P244 = PInt\u003cU244\u003e; pub type N244 = NInt\u003cU244\u003e;\n    pub type U245 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P245 = PInt\u003cU245\u003e; pub type N245 = NInt\u003cU245\u003e;\n    pub type U246 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P246 = PInt\u003cU246\u003e; pub type N246 = NInt\u003cU246\u003e;\n    pub type U247 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P247 = PInt\u003cU247\u003e; pub type N247 = NInt\u003cU247\u003e;\n    pub type U248 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P248 = PInt\u003cU248\u003e; pub type N248 = NInt\u003cU248\u003e;\n    pub type U249 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P249 = PInt\u003cU249\u003e; pub type N249 = NInt\u003cU249\u003e;\n    pub type U250 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P250 = PInt\u003cU250\u003e; pub type N250 = NInt\u003cU250\u003e;\n    pub type U251 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P251 = PInt\u003cU251\u003e; pub type N251 = NInt\u003cU251\u003e;\n    pub type U252 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P252 = PInt\u003cU252\u003e; pub type N252 = NInt\u003cU252\u003e;\n    pub type U253 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P253 = PInt\u003cU253\u003e; pub type N253 = NInt\u003cU253\u003e;\n    pub type U254 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P254 = PInt\u003cU254\u003e; pub type N254 = NInt\u003cU254\u003e;\n    pub type U255 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P255 = PInt\u003cU255\u003e; pub type N255 = NInt\u003cU255\u003e;\n    pub type U256 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P256 = PInt\u003cU256\u003e; pub type N256 = NInt\u003cU256\u003e;\n    pub type U257 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P257 = PInt\u003cU257\u003e; pub type N257 = NInt\u003cU257\u003e;\n    pub type U258 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P258 = PInt\u003cU258\u003e; pub type N258 = NInt\u003cU258\u003e;\n    pub type U259 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P259 = PInt\u003cU259\u003e; pub type N259 = NInt\u003cU259\u003e;\n    pub type U260 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P260 = PInt\u003cU260\u003e; pub type N260 = NInt\u003cU260\u003e;\n    pub type U261 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P261 = PInt\u003cU261\u003e; pub type N261 = NInt\u003cU261\u003e;\n    pub type U262 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P262 = PInt\u003cU262\u003e; pub type N262 = NInt\u003cU262\u003e;\n    pub type U263 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P263 = PInt\u003cU263\u003e; pub type N263 = NInt\u003cU263\u003e;\n    pub type U264 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P264 = PInt\u003cU264\u003e; pub type N264 = NInt\u003cU264\u003e;\n    pub type U265 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P265 = PInt\u003cU265\u003e; pub type N265 = NInt\u003cU265\u003e;\n    pub type U266 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P266 = PInt\u003cU266\u003e; pub type N266 = NInt\u003cU266\u003e;\n    pub type U267 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P267 = PInt\u003cU267\u003e; pub type N267 = NInt\u003cU267\u003e;\n    pub type U268 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P268 = PInt\u003cU268\u003e; pub type N268 = NInt\u003cU268\u003e;\n    pub type U269 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P269 = PInt\u003cU269\u003e; pub type N269 = NInt\u003cU269\u003e;\n    pub type U270 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P270 = PInt\u003cU270\u003e; pub type N270 = NInt\u003cU270\u003e;\n    pub type U271 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P271 = PInt\u003cU271\u003e; pub type N271 = NInt\u003cU271\u003e;\n    pub type U272 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P272 = PInt\u003cU272\u003e; pub type N272 = NInt\u003cU272\u003e;\n    pub type U273 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P273 = PInt\u003cU273\u003e; pub type N273 = NInt\u003cU273\u003e;\n    pub type U274 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P274 = PInt\u003cU274\u003e; pub type N274 = NInt\u003cU274\u003e;\n    pub type U275 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P275 = PInt\u003cU275\u003e; pub type N275 = NInt\u003cU275\u003e;\n    pub type U276 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P276 = PInt\u003cU276\u003e; pub type N276 = NInt\u003cU276\u003e;\n    pub type U277 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P277 = PInt\u003cU277\u003e; pub type N277 = NInt\u003cU277\u003e;\n    pub type U278 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P278 = PInt\u003cU278\u003e; pub type N278 = NInt\u003cU278\u003e;\n    pub type U279 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P279 = PInt\u003cU279\u003e; pub type N279 = NInt\u003cU279\u003e;\n    pub type U280 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P280 = PInt\u003cU280\u003e; pub type N280 = NInt\u003cU280\u003e;\n    pub type U281 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P281 = PInt\u003cU281\u003e; pub type N281 = NInt\u003cU281\u003e;\n    pub type U282 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P282 = PInt\u003cU282\u003e; pub type N282 = NInt\u003cU282\u003e;\n    pub type U283 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P283 = PInt\u003cU283\u003e; pub type N283 = NInt\u003cU283\u003e;\n    pub type U284 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P284 = PInt\u003cU284\u003e; pub type N284 = NInt\u003cU284\u003e;\n    pub type U285 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P285 = PInt\u003cU285\u003e; pub type N285 = NInt\u003cU285\u003e;\n    pub type U286 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P286 = PInt\u003cU286\u003e; pub type N286 = NInt\u003cU286\u003e;\n    pub type U287 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P287 = PInt\u003cU287\u003e; pub type N287 = NInt\u003cU287\u003e;\n    pub type U288 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P288 = PInt\u003cU288\u003e; pub type N288 = NInt\u003cU288\u003e;\n    pub type U289 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P289 = PInt\u003cU289\u003e; pub type N289 = NInt\u003cU289\u003e;\n    pub type U290 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P290 = PInt\u003cU290\u003e; pub type N290 = NInt\u003cU290\u003e;\n    pub type U291 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P291 = PInt\u003cU291\u003e; pub type N291 = NInt\u003cU291\u003e;\n    pub type U292 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P292 = PInt\u003cU292\u003e; pub type N292 = NInt\u003cU292\u003e;\n    pub type U293 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P293 = PInt\u003cU293\u003e; pub type N293 = NInt\u003cU293\u003e;\n    pub type U294 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P294 = PInt\u003cU294\u003e; pub type N294 = NInt\u003cU294\u003e;\n    pub type U295 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P295 = PInt\u003cU295\u003e; pub type N295 = NInt\u003cU295\u003e;\n    pub type U296 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P296 = PInt\u003cU296\u003e; pub type N296 = NInt\u003cU296\u003e;\n    pub type U297 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P297 = PInt\u003cU297\u003e; pub type N297 = NInt\u003cU297\u003e;\n    pub type U298 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P298 = PInt\u003cU298\u003e; pub type N298 = NInt\u003cU298\u003e;\n    pub type U299 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P299 = PInt\u003cU299\u003e; pub type N299 = NInt\u003cU299\u003e;\n    pub type U300 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P300 = PInt\u003cU300\u003e; pub type N300 = NInt\u003cU300\u003e;\n    pub type U301 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P301 = PInt\u003cU301\u003e; pub type N301 = NInt\u003cU301\u003e;\n    pub type U302 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P302 = PInt\u003cU302\u003e; pub type N302 = NInt\u003cU302\u003e;\n    pub type U303 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P303 = PInt\u003cU303\u003e; pub type N303 = NInt\u003cU303\u003e;\n    pub type U304 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P304 = PInt\u003cU304\u003e; pub type N304 = NInt\u003cU304\u003e;\n    pub type U305 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P305 = PInt\u003cU305\u003e; pub type N305 = NInt\u003cU305\u003e;\n    pub type U306 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P306 = PInt\u003cU306\u003e; pub type N306 = NInt\u003cU306\u003e;\n    pub type U307 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P307 = PInt\u003cU307\u003e; pub type N307 = NInt\u003cU307\u003e;\n    pub type U308 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P308 = PInt\u003cU308\u003e; pub type N308 = NInt\u003cU308\u003e;\n    pub type U309 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P309 = PInt\u003cU309\u003e; pub type N309 = NInt\u003cU309\u003e;\n    pub type U310 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P310 = PInt\u003cU310\u003e; pub type N310 = NInt\u003cU310\u003e;\n    pub type U311 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P311 = PInt\u003cU311\u003e; pub type N311 = NInt\u003cU311\u003e;\n    pub type U312 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P312 = PInt\u003cU312\u003e; pub type N312 = NInt\u003cU312\u003e;\n    pub type U313 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P313 = PInt\u003cU313\u003e; pub type N313 = NInt\u003cU313\u003e;\n    pub type U314 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P314 = PInt\u003cU314\u003e; pub type N314 = NInt\u003cU314\u003e;\n    pub type U315 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P315 = PInt\u003cU315\u003e; pub type N315 = NInt\u003cU315\u003e;\n    pub type U316 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P316 = PInt\u003cU316\u003e; pub type N316 = NInt\u003cU316\u003e;\n    pub type U317 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P317 = PInt\u003cU317\u003e; pub type N317 = NInt\u003cU317\u003e;\n    pub type U318 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P318 = PInt\u003cU318\u003e; pub type N318 = NInt\u003cU318\u003e;\n    pub type U319 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P319 = PInt\u003cU319\u003e; pub type N319 = NInt\u003cU319\u003e;\n    pub type U320 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P320 = PInt\u003cU320\u003e; pub type N320 = NInt\u003cU320\u003e;\n    pub type U321 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P321 = PInt\u003cU321\u003e; pub type N321 = NInt\u003cU321\u003e;\n    pub type U322 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P322 = PInt\u003cU322\u003e; pub type N322 = NInt\u003cU322\u003e;\n    pub type U323 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P323 = PInt\u003cU323\u003e; pub type N323 = NInt\u003cU323\u003e;\n    pub type U324 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P324 = PInt\u003cU324\u003e; pub type N324 = NInt\u003cU324\u003e;\n    pub type U325 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P325 = PInt\u003cU325\u003e; pub type N325 = NInt\u003cU325\u003e;\n    pub type U326 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P326 = PInt\u003cU326\u003e; pub type N326 = NInt\u003cU326\u003e;\n    pub type U327 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P327 = PInt\u003cU327\u003e; pub type N327 = NInt\u003cU327\u003e;\n    pub type U328 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P328 = PInt\u003cU328\u003e; pub type N328 = NInt\u003cU328\u003e;\n    pub type U329 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P329 = PInt\u003cU329\u003e; pub type N329 = NInt\u003cU329\u003e;\n    pub type U330 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P330 = PInt\u003cU330\u003e; pub type N330 = NInt\u003cU330\u003e;\n    pub type U331 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P331 = PInt\u003cU331\u003e; pub type N331 = NInt\u003cU331\u003e;\n    pub type U332 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P332 = PInt\u003cU332\u003e; pub type N332 = NInt\u003cU332\u003e;\n    pub type U333 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P333 = PInt\u003cU333\u003e; pub type N333 = NInt\u003cU333\u003e;\n    pub type U334 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P334 = PInt\u003cU334\u003e; pub type N334 = NInt\u003cU334\u003e;\n    pub type U335 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P335 = PInt\u003cU335\u003e; pub type N335 = NInt\u003cU335\u003e;\n    pub type U336 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P336 = PInt\u003cU336\u003e; pub type N336 = NInt\u003cU336\u003e;\n    pub type U337 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P337 = PInt\u003cU337\u003e; pub type N337 = NInt\u003cU337\u003e;\n    pub type U338 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P338 = PInt\u003cU338\u003e; pub type N338 = NInt\u003cU338\u003e;\n    pub type U339 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P339 = PInt\u003cU339\u003e; pub type N339 = NInt\u003cU339\u003e;\n    pub type U340 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P340 = PInt\u003cU340\u003e; pub type N340 = NInt\u003cU340\u003e;\n    pub type U341 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P341 = PInt\u003cU341\u003e; pub type N341 = NInt\u003cU341\u003e;\n    pub type U342 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P342 = PInt\u003cU342\u003e; pub type N342 = NInt\u003cU342\u003e;\n    pub type U343 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P343 = PInt\u003cU343\u003e; pub type N343 = NInt\u003cU343\u003e;\n    pub type U344 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P344 = PInt\u003cU344\u003e; pub type N344 = NInt\u003cU344\u003e;\n    pub type U345 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P345 = PInt\u003cU345\u003e; pub type N345 = NInt\u003cU345\u003e;\n    pub type U346 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P346 = PInt\u003cU346\u003e; pub type N346 = NInt\u003cU346\u003e;\n    pub type U347 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P347 = PInt\u003cU347\u003e; pub type N347 = NInt\u003cU347\u003e;\n    pub type U348 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P348 = PInt\u003cU348\u003e; pub type N348 = NInt\u003cU348\u003e;\n    pub type U349 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P349 = PInt\u003cU349\u003e; pub type N349 = NInt\u003cU349\u003e;\n    pub type U350 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P350 = PInt\u003cU350\u003e; pub type N350 = NInt\u003cU350\u003e;\n    pub type U351 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P351 = PInt\u003cU351\u003e; pub type N351 = NInt\u003cU351\u003e;\n    pub type U352 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P352 = PInt\u003cU352\u003e; pub type N352 = NInt\u003cU352\u003e;\n    pub type U353 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P353 = PInt\u003cU353\u003e; pub type N353 = NInt\u003cU353\u003e;\n    pub type U354 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P354 = PInt\u003cU354\u003e; pub type N354 = NInt\u003cU354\u003e;\n    pub type U355 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P355 = PInt\u003cU355\u003e; pub type N355 = NInt\u003cU355\u003e;\n    pub type U356 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P356 = PInt\u003cU356\u003e; pub type N356 = NInt\u003cU356\u003e;\n    pub type U357 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P357 = PInt\u003cU357\u003e; pub type N357 = NInt\u003cU357\u003e;\n    pub type U358 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P358 = PInt\u003cU358\u003e; pub type N358 = NInt\u003cU358\u003e;\n    pub type U359 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P359 = PInt\u003cU359\u003e; pub type N359 = NInt\u003cU359\u003e;\n    pub type U360 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P360 = PInt\u003cU360\u003e; pub type N360 = NInt\u003cU360\u003e;\n    pub type U361 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P361 = PInt\u003cU361\u003e; pub type N361 = NInt\u003cU361\u003e;\n    pub type U362 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P362 = PInt\u003cU362\u003e; pub type N362 = NInt\u003cU362\u003e;\n    pub type U363 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P363 = PInt\u003cU363\u003e; pub type N363 = NInt\u003cU363\u003e;\n    pub type U364 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P364 = PInt\u003cU364\u003e; pub type N364 = NInt\u003cU364\u003e;\n    pub type U365 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P365 = PInt\u003cU365\u003e; pub type N365 = NInt\u003cU365\u003e;\n    pub type U366 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P366 = PInt\u003cU366\u003e; pub type N366 = NInt\u003cU366\u003e;\n    pub type U367 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P367 = PInt\u003cU367\u003e; pub type N367 = NInt\u003cU367\u003e;\n    pub type U368 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P368 = PInt\u003cU368\u003e; pub type N368 = NInt\u003cU368\u003e;\n    pub type U369 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P369 = PInt\u003cU369\u003e; pub type N369 = NInt\u003cU369\u003e;\n    pub type U370 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P370 = PInt\u003cU370\u003e; pub type N370 = NInt\u003cU370\u003e;\n    pub type U371 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P371 = PInt\u003cU371\u003e; pub type N371 = NInt\u003cU371\u003e;\n    pub type U372 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P372 = PInt\u003cU372\u003e; pub type N372 = NInt\u003cU372\u003e;\n    pub type U373 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P373 = PInt\u003cU373\u003e; pub type N373 = NInt\u003cU373\u003e;\n    pub type U374 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P374 = PInt\u003cU374\u003e; pub type N374 = NInt\u003cU374\u003e;\n    pub type U375 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P375 = PInt\u003cU375\u003e; pub type N375 = NInt\u003cU375\u003e;\n    pub type U376 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P376 = PInt\u003cU376\u003e; pub type N376 = NInt\u003cU376\u003e;\n    pub type U377 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P377 = PInt\u003cU377\u003e; pub type N377 = NInt\u003cU377\u003e;\n    pub type U378 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P378 = PInt\u003cU378\u003e; pub type N378 = NInt\u003cU378\u003e;\n    pub type U379 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P379 = PInt\u003cU379\u003e; pub type N379 = NInt\u003cU379\u003e;\n    pub type U380 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P380 = PInt\u003cU380\u003e; pub type N380 = NInt\u003cU380\u003e;\n    pub type U381 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P381 = PInt\u003cU381\u003e; pub type N381 = NInt\u003cU381\u003e;\n    pub type U382 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P382 = PInt\u003cU382\u003e; pub type N382 = NInt\u003cU382\u003e;\n    pub type U383 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P383 = PInt\u003cU383\u003e; pub type N383 = NInt\u003cU383\u003e;\n    pub type U384 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P384 = PInt\u003cU384\u003e; pub type N384 = NInt\u003cU384\u003e;\n    pub type U385 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P385 = PInt\u003cU385\u003e; pub type N385 = NInt\u003cU385\u003e;\n    pub type U386 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P386 = PInt\u003cU386\u003e; pub type N386 = NInt\u003cU386\u003e;\n    pub type U387 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P387 = PInt\u003cU387\u003e; pub type N387 = NInt\u003cU387\u003e;\n    pub type U388 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P388 = PInt\u003cU388\u003e; pub type N388 = NInt\u003cU388\u003e;\n    pub type U389 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P389 = PInt\u003cU389\u003e; pub type N389 = NInt\u003cU389\u003e;\n    pub type U390 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P390 = PInt\u003cU390\u003e; pub type N390 = NInt\u003cU390\u003e;\n    pub type U391 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P391 = PInt\u003cU391\u003e; pub type N391 = NInt\u003cU391\u003e;\n    pub type U392 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P392 = PInt\u003cU392\u003e; pub type N392 = NInt\u003cU392\u003e;\n    pub type U393 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P393 = PInt\u003cU393\u003e; pub type N393 = NInt\u003cU393\u003e;\n    pub type U394 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P394 = PInt\u003cU394\u003e; pub type N394 = NInt\u003cU394\u003e;\n    pub type U395 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P395 = PInt\u003cU395\u003e; pub type N395 = NInt\u003cU395\u003e;\n    pub type U396 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P396 = PInt\u003cU396\u003e; pub type N396 = NInt\u003cU396\u003e;\n    pub type U397 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P397 = PInt\u003cU397\u003e; pub type N397 = NInt\u003cU397\u003e;\n    pub type U398 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P398 = PInt\u003cU398\u003e; pub type N398 = NInt\u003cU398\u003e;\n    pub type U399 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P399 = PInt\u003cU399\u003e; pub type N399 = NInt\u003cU399\u003e;\n    pub type U400 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P400 = PInt\u003cU400\u003e; pub type N400 = NInt\u003cU400\u003e;\n    pub type U401 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P401 = PInt\u003cU401\u003e; pub type N401 = NInt\u003cU401\u003e;\n    pub type U402 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P402 = PInt\u003cU402\u003e; pub type N402 = NInt\u003cU402\u003e;\n    pub type U403 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P403 = PInt\u003cU403\u003e; pub type N403 = NInt\u003cU403\u003e;\n    pub type U404 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P404 = PInt\u003cU404\u003e; pub type N404 = NInt\u003cU404\u003e;\n    pub type U405 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P405 = PInt\u003cU405\u003e; pub type N405 = NInt\u003cU405\u003e;\n    pub type U406 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P406 = PInt\u003cU406\u003e; pub type N406 = NInt\u003cU406\u003e;\n    pub type U407 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P407 = PInt\u003cU407\u003e; pub type N407 = NInt\u003cU407\u003e;\n    pub type U408 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P408 = PInt\u003cU408\u003e; pub type N408 = NInt\u003cU408\u003e;\n    pub type U409 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P409 = PInt\u003cU409\u003e; pub type N409 = NInt\u003cU409\u003e;\n    pub type U410 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P410 = PInt\u003cU410\u003e; pub type N410 = NInt\u003cU410\u003e;\n    pub type U411 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P411 = PInt\u003cU411\u003e; pub type N411 = NInt\u003cU411\u003e;\n    pub type U412 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P412 = PInt\u003cU412\u003e; pub type N412 = NInt\u003cU412\u003e;\n    pub type U413 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P413 = PInt\u003cU413\u003e; pub type N413 = NInt\u003cU413\u003e;\n    pub type U414 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P414 = PInt\u003cU414\u003e; pub type N414 = NInt\u003cU414\u003e;\n    pub type U415 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P415 = PInt\u003cU415\u003e; pub type N415 = NInt\u003cU415\u003e;\n    pub type U416 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P416 = PInt\u003cU416\u003e; pub type N416 = NInt\u003cU416\u003e;\n    pub type U417 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P417 = PInt\u003cU417\u003e; pub type N417 = NInt\u003cU417\u003e;\n    pub type U418 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P418 = PInt\u003cU418\u003e; pub type N418 = NInt\u003cU418\u003e;\n    pub type U419 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P419 = PInt\u003cU419\u003e; pub type N419 = NInt\u003cU419\u003e;\n    pub type U420 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P420 = PInt\u003cU420\u003e; pub type N420 = NInt\u003cU420\u003e;\n    pub type U421 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P421 = PInt\u003cU421\u003e; pub type N421 = NInt\u003cU421\u003e;\n    pub type U422 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P422 = PInt\u003cU422\u003e; pub type N422 = NInt\u003cU422\u003e;\n    pub type U423 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P423 = PInt\u003cU423\u003e; pub type N423 = NInt\u003cU423\u003e;\n    pub type U424 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P424 = PInt\u003cU424\u003e; pub type N424 = NInt\u003cU424\u003e;\n    pub type U425 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P425 = PInt\u003cU425\u003e; pub type N425 = NInt\u003cU425\u003e;\n    pub type U426 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P426 = PInt\u003cU426\u003e; pub type N426 = NInt\u003cU426\u003e;\n    pub type U427 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P427 = PInt\u003cU427\u003e; pub type N427 = NInt\u003cU427\u003e;\n    pub type U428 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P428 = PInt\u003cU428\u003e; pub type N428 = NInt\u003cU428\u003e;\n    pub type U429 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P429 = PInt\u003cU429\u003e; pub type N429 = NInt\u003cU429\u003e;\n    pub type U430 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P430 = PInt\u003cU430\u003e; pub type N430 = NInt\u003cU430\u003e;\n    pub type U431 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P431 = PInt\u003cU431\u003e; pub type N431 = NInt\u003cU431\u003e;\n    pub type U432 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P432 = PInt\u003cU432\u003e; pub type N432 = NInt\u003cU432\u003e;\n    pub type U433 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P433 = PInt\u003cU433\u003e; pub type N433 = NInt\u003cU433\u003e;\n    pub type U434 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P434 = PInt\u003cU434\u003e; pub type N434 = NInt\u003cU434\u003e;\n    pub type U435 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P435 = PInt\u003cU435\u003e; pub type N435 = NInt\u003cU435\u003e;\n    pub type U436 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P436 = PInt\u003cU436\u003e; pub type N436 = NInt\u003cU436\u003e;\n    pub type U437 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P437 = PInt\u003cU437\u003e; pub type N437 = NInt\u003cU437\u003e;\n    pub type U438 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P438 = PInt\u003cU438\u003e; pub type N438 = NInt\u003cU438\u003e;\n    pub type U439 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P439 = PInt\u003cU439\u003e; pub type N439 = NInt\u003cU439\u003e;\n    pub type U440 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P440 = PInt\u003cU440\u003e; pub type N440 = NInt\u003cU440\u003e;\n    pub type U441 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P441 = PInt\u003cU441\u003e; pub type N441 = NInt\u003cU441\u003e;\n    pub type U442 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P442 = PInt\u003cU442\u003e; pub type N442 = NInt\u003cU442\u003e;\n    pub type U443 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P443 = PInt\u003cU443\u003e; pub type N443 = NInt\u003cU443\u003e;\n    pub type U444 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P444 = PInt\u003cU444\u003e; pub type N444 = NInt\u003cU444\u003e;\n    pub type U445 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P445 = PInt\u003cU445\u003e; pub type N445 = NInt\u003cU445\u003e;\n    pub type U446 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P446 = PInt\u003cU446\u003e; pub type N446 = NInt\u003cU446\u003e;\n    pub type U447 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P447 = PInt\u003cU447\u003e; pub type N447 = NInt\u003cU447\u003e;\n    pub type U448 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P448 = PInt\u003cU448\u003e; pub type N448 = NInt\u003cU448\u003e;\n    pub type U449 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P449 = PInt\u003cU449\u003e; pub type N449 = NInt\u003cU449\u003e;\n    pub type U450 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P450 = PInt\u003cU450\u003e; pub type N450 = NInt\u003cU450\u003e;\n    pub type U451 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P451 = PInt\u003cU451\u003e; pub type N451 = NInt\u003cU451\u003e;\n    pub type U452 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P452 = PInt\u003cU452\u003e; pub type N452 = NInt\u003cU452\u003e;\n    pub type U453 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P453 = PInt\u003cU453\u003e; pub type N453 = NInt\u003cU453\u003e;\n    pub type U454 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P454 = PInt\u003cU454\u003e; pub type N454 = NInt\u003cU454\u003e;\n    pub type U455 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P455 = PInt\u003cU455\u003e; pub type N455 = NInt\u003cU455\u003e;\n    pub type U456 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P456 = PInt\u003cU456\u003e; pub type N456 = NInt\u003cU456\u003e;\n    pub type U457 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P457 = PInt\u003cU457\u003e; pub type N457 = NInt\u003cU457\u003e;\n    pub type U458 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P458 = PInt\u003cU458\u003e; pub type N458 = NInt\u003cU458\u003e;\n    pub type U459 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P459 = PInt\u003cU459\u003e; pub type N459 = NInt\u003cU459\u003e;\n    pub type U460 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P460 = PInt\u003cU460\u003e; pub type N460 = NInt\u003cU460\u003e;\n    pub type U461 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P461 = PInt\u003cU461\u003e; pub type N461 = NInt\u003cU461\u003e;\n    pub type U462 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P462 = PInt\u003cU462\u003e; pub type N462 = NInt\u003cU462\u003e;\n    pub type U463 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P463 = PInt\u003cU463\u003e; pub type N463 = NInt\u003cU463\u003e;\n    pub type U464 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P464 = PInt\u003cU464\u003e; pub type N464 = NInt\u003cU464\u003e;\n    pub type U465 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P465 = PInt\u003cU465\u003e; pub type N465 = NInt\u003cU465\u003e;\n    pub type U466 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P466 = PInt\u003cU466\u003e; pub type N466 = NInt\u003cU466\u003e;\n    pub type U467 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P467 = PInt\u003cU467\u003e; pub type N467 = NInt\u003cU467\u003e;\n    pub type U468 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P468 = PInt\u003cU468\u003e; pub type N468 = NInt\u003cU468\u003e;\n    pub type U469 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P469 = PInt\u003cU469\u003e; pub type N469 = NInt\u003cU469\u003e;\n    pub type U470 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P470 = PInt\u003cU470\u003e; pub type N470 = NInt\u003cU470\u003e;\n    pub type U471 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P471 = PInt\u003cU471\u003e; pub type N471 = NInt\u003cU471\u003e;\n    pub type U472 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P472 = PInt\u003cU472\u003e; pub type N472 = NInt\u003cU472\u003e;\n    pub type U473 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P473 = PInt\u003cU473\u003e; pub type N473 = NInt\u003cU473\u003e;\n    pub type U474 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P474 = PInt\u003cU474\u003e; pub type N474 = NInt\u003cU474\u003e;\n    pub type U475 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P475 = PInt\u003cU475\u003e; pub type N475 = NInt\u003cU475\u003e;\n    pub type U476 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P476 = PInt\u003cU476\u003e; pub type N476 = NInt\u003cU476\u003e;\n    pub type U477 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P477 = PInt\u003cU477\u003e; pub type N477 = NInt\u003cU477\u003e;\n    pub type U478 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P478 = PInt\u003cU478\u003e; pub type N478 = NInt\u003cU478\u003e;\n    pub type U479 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P479 = PInt\u003cU479\u003e; pub type N479 = NInt\u003cU479\u003e;\n    pub type U480 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P480 = PInt\u003cU480\u003e; pub type N480 = NInt\u003cU480\u003e;\n    pub type U481 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P481 = PInt\u003cU481\u003e; pub type N481 = NInt\u003cU481\u003e;\n    pub type U482 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P482 = PInt\u003cU482\u003e; pub type N482 = NInt\u003cU482\u003e;\n    pub type U483 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P483 = PInt\u003cU483\u003e; pub type N483 = NInt\u003cU483\u003e;\n    pub type U484 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P484 = PInt\u003cU484\u003e; pub type N484 = NInt\u003cU484\u003e;\n    pub type U485 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P485 = PInt\u003cU485\u003e; pub type N485 = NInt\u003cU485\u003e;\n    pub type U486 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P486 = PInt\u003cU486\u003e; pub type N486 = NInt\u003cU486\u003e;\n    pub type U487 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P487 = PInt\u003cU487\u003e; pub type N487 = NInt\u003cU487\u003e;\n    pub type U488 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P488 = PInt\u003cU488\u003e; pub type N488 = NInt\u003cU488\u003e;\n    pub type U489 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P489 = PInt\u003cU489\u003e; pub type N489 = NInt\u003cU489\u003e;\n    pub type U490 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P490 = PInt\u003cU490\u003e; pub type N490 = NInt\u003cU490\u003e;\n    pub type U491 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P491 = PInt\u003cU491\u003e; pub type N491 = NInt\u003cU491\u003e;\n    pub type U492 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P492 = PInt\u003cU492\u003e; pub type N492 = NInt\u003cU492\u003e;\n    pub type U493 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P493 = PInt\u003cU493\u003e; pub type N493 = NInt\u003cU493\u003e;\n    pub type U494 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P494 = PInt\u003cU494\u003e; pub type N494 = NInt\u003cU494\u003e;\n    pub type U495 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P495 = PInt\u003cU495\u003e; pub type N495 = NInt\u003cU495\u003e;\n    pub type U496 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P496 = PInt\u003cU496\u003e; pub type N496 = NInt\u003cU496\u003e;\n    pub type U497 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P497 = PInt\u003cU497\u003e; pub type N497 = NInt\u003cU497\u003e;\n    pub type U498 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P498 = PInt\u003cU498\u003e; pub type N498 = NInt\u003cU498\u003e;\n    pub type U499 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P499 = PInt\u003cU499\u003e; pub type N499 = NInt\u003cU499\u003e;\n    pub type U500 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P500 = PInt\u003cU500\u003e; pub type N500 = NInt\u003cU500\u003e;\n    pub type U501 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P501 = PInt\u003cU501\u003e; pub type N501 = NInt\u003cU501\u003e;\n    pub type U502 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P502 = PInt\u003cU502\u003e; pub type N502 = NInt\u003cU502\u003e;\n    pub type U503 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P503 = PInt\u003cU503\u003e; pub type N503 = NInt\u003cU503\u003e;\n    pub type U504 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P504 = PInt\u003cU504\u003e; pub type N504 = NInt\u003cU504\u003e;\n    pub type U505 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P505 = PInt\u003cU505\u003e; pub type N505 = NInt\u003cU505\u003e;\n    pub type U506 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P506 = PInt\u003cU506\u003e; pub type N506 = NInt\u003cU506\u003e;\n    pub type U507 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P507 = PInt\u003cU507\u003e; pub type N507 = NInt\u003cU507\u003e;\n    pub type U508 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P508 = PInt\u003cU508\u003e; pub type N508 = NInt\u003cU508\u003e;\n    pub type U509 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P509 = PInt\u003cU509\u003e; pub type N509 = NInt\u003cU509\u003e;\n    pub type U510 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P510 = PInt\u003cU510\u003e; pub type N510 = NInt\u003cU510\u003e;\n    pub type U511 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P511 = PInt\u003cU511\u003e; pub type N511 = NInt\u003cU511\u003e;\n    pub type U512 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P512 = PInt\u003cU512\u003e; pub type N512 = NInt\u003cU512\u003e;\n    pub type U513 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P513 = PInt\u003cU513\u003e; pub type N513 = NInt\u003cU513\u003e;\n    pub type U514 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P514 = PInt\u003cU514\u003e; pub type N514 = NInt\u003cU514\u003e;\n    pub type U515 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P515 = PInt\u003cU515\u003e; pub type N515 = NInt\u003cU515\u003e;\n    pub type U516 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P516 = PInt\u003cU516\u003e; pub type N516 = NInt\u003cU516\u003e;\n    pub type U517 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P517 = PInt\u003cU517\u003e; pub type N517 = NInt\u003cU517\u003e;\n    pub type U518 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P518 = PInt\u003cU518\u003e; pub type N518 = NInt\u003cU518\u003e;\n    pub type U519 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P519 = PInt\u003cU519\u003e; pub type N519 = NInt\u003cU519\u003e;\n    pub type U520 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P520 = PInt\u003cU520\u003e; pub type N520 = NInt\u003cU520\u003e;\n    pub type U521 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P521 = PInt\u003cU521\u003e; pub type N521 = NInt\u003cU521\u003e;\n    pub type U522 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P522 = PInt\u003cU522\u003e; pub type N522 = NInt\u003cU522\u003e;\n    pub type U523 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P523 = PInt\u003cU523\u003e; pub type N523 = NInt\u003cU523\u003e;\n    pub type U524 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P524 = PInt\u003cU524\u003e; pub type N524 = NInt\u003cU524\u003e;\n    pub type U525 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P525 = PInt\u003cU525\u003e; pub type N525 = NInt\u003cU525\u003e;\n    pub type U526 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P526 = PInt\u003cU526\u003e; pub type N526 = NInt\u003cU526\u003e;\n    pub type U527 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P527 = PInt\u003cU527\u003e; pub type N527 = NInt\u003cU527\u003e;\n    pub type U528 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P528 = PInt\u003cU528\u003e; pub type N528 = NInt\u003cU528\u003e;\n    pub type U529 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P529 = PInt\u003cU529\u003e; pub type N529 = NInt\u003cU529\u003e;\n    pub type U530 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P530 = PInt\u003cU530\u003e; pub type N530 = NInt\u003cU530\u003e;\n    pub type U531 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P531 = PInt\u003cU531\u003e; pub type N531 = NInt\u003cU531\u003e;\n    pub type U532 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P532 = PInt\u003cU532\u003e; pub type N532 = NInt\u003cU532\u003e;\n    pub type U533 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P533 = PInt\u003cU533\u003e; pub type N533 = NInt\u003cU533\u003e;\n    pub type U534 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P534 = PInt\u003cU534\u003e; pub type N534 = NInt\u003cU534\u003e;\n    pub type U535 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P535 = PInt\u003cU535\u003e; pub type N535 = NInt\u003cU535\u003e;\n    pub type U536 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P536 = PInt\u003cU536\u003e; pub type N536 = NInt\u003cU536\u003e;\n    pub type U537 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P537 = PInt\u003cU537\u003e; pub type N537 = NInt\u003cU537\u003e;\n    pub type U538 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P538 = PInt\u003cU538\u003e; pub type N538 = NInt\u003cU538\u003e;\n    pub type U539 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P539 = PInt\u003cU539\u003e; pub type N539 = NInt\u003cU539\u003e;\n    pub type U540 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P540 = PInt\u003cU540\u003e; pub type N540 = NInt\u003cU540\u003e;\n    pub type U541 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P541 = PInt\u003cU541\u003e; pub type N541 = NInt\u003cU541\u003e;\n    pub type U542 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P542 = PInt\u003cU542\u003e; pub type N542 = NInt\u003cU542\u003e;\n    pub type U543 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P543 = PInt\u003cU543\u003e; pub type N543 = NInt\u003cU543\u003e;\n    pub type U544 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P544 = PInt\u003cU544\u003e; pub type N544 = NInt\u003cU544\u003e;\n    pub type U545 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P545 = PInt\u003cU545\u003e; pub type N545 = NInt\u003cU545\u003e;\n    pub type U546 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P546 = PInt\u003cU546\u003e; pub type N546 = NInt\u003cU546\u003e;\n    pub type U547 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P547 = PInt\u003cU547\u003e; pub type N547 = NInt\u003cU547\u003e;\n    pub type U548 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P548 = PInt\u003cU548\u003e; pub type N548 = NInt\u003cU548\u003e;\n    pub type U549 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P549 = PInt\u003cU549\u003e; pub type N549 = NInt\u003cU549\u003e;\n    pub type U550 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P550 = PInt\u003cU550\u003e; pub type N550 = NInt\u003cU550\u003e;\n    pub type U551 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P551 = PInt\u003cU551\u003e; pub type N551 = NInt\u003cU551\u003e;\n    pub type U552 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P552 = PInt\u003cU552\u003e; pub type N552 = NInt\u003cU552\u003e;\n    pub type U553 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P553 = PInt\u003cU553\u003e; pub type N553 = NInt\u003cU553\u003e;\n    pub type U554 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P554 = PInt\u003cU554\u003e; pub type N554 = NInt\u003cU554\u003e;\n    pub type U555 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P555 = PInt\u003cU555\u003e; pub type N555 = NInt\u003cU555\u003e;\n    pub type U556 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P556 = PInt\u003cU556\u003e; pub type N556 = NInt\u003cU556\u003e;\n    pub type U557 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P557 = PInt\u003cU557\u003e; pub type N557 = NInt\u003cU557\u003e;\n    pub type U558 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P558 = PInt\u003cU558\u003e; pub type N558 = NInt\u003cU558\u003e;\n    pub type U559 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P559 = PInt\u003cU559\u003e; pub type N559 = NInt\u003cU559\u003e;\n    pub type U560 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P560 = PInt\u003cU560\u003e; pub type N560 = NInt\u003cU560\u003e;\n    pub type U561 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P561 = PInt\u003cU561\u003e; pub type N561 = NInt\u003cU561\u003e;\n    pub type U562 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P562 = PInt\u003cU562\u003e; pub type N562 = NInt\u003cU562\u003e;\n    pub type U563 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P563 = PInt\u003cU563\u003e; pub type N563 = NInt\u003cU563\u003e;\n    pub type U564 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P564 = PInt\u003cU564\u003e; pub type N564 = NInt\u003cU564\u003e;\n    pub type U565 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P565 = PInt\u003cU565\u003e; pub type N565 = NInt\u003cU565\u003e;\n    pub type U566 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P566 = PInt\u003cU566\u003e; pub type N566 = NInt\u003cU566\u003e;\n    pub type U567 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P567 = PInt\u003cU567\u003e; pub type N567 = NInt\u003cU567\u003e;\n    pub type U568 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P568 = PInt\u003cU568\u003e; pub type N568 = NInt\u003cU568\u003e;\n    pub type U569 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P569 = PInt\u003cU569\u003e; pub type N569 = NInt\u003cU569\u003e;\n    pub type U570 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P570 = PInt\u003cU570\u003e; pub type N570 = NInt\u003cU570\u003e;\n    pub type U571 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P571 = PInt\u003cU571\u003e; pub type N571 = NInt\u003cU571\u003e;\n    pub type U572 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P572 = PInt\u003cU572\u003e; pub type N572 = NInt\u003cU572\u003e;\n    pub type U573 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P573 = PInt\u003cU573\u003e; pub type N573 = NInt\u003cU573\u003e;\n    pub type U574 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P574 = PInt\u003cU574\u003e; pub type N574 = NInt\u003cU574\u003e;\n    pub type U575 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P575 = PInt\u003cU575\u003e; pub type N575 = NInt\u003cU575\u003e;\n    pub type U576 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P576 = PInt\u003cU576\u003e; pub type N576 = NInt\u003cU576\u003e;\n    pub type U577 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P577 = PInt\u003cU577\u003e; pub type N577 = NInt\u003cU577\u003e;\n    pub type U578 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P578 = PInt\u003cU578\u003e; pub type N578 = NInt\u003cU578\u003e;\n    pub type U579 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P579 = PInt\u003cU579\u003e; pub type N579 = NInt\u003cU579\u003e;\n    pub type U580 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P580 = PInt\u003cU580\u003e; pub type N580 = NInt\u003cU580\u003e;\n    pub type U581 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P581 = PInt\u003cU581\u003e; pub type N581 = NInt\u003cU581\u003e;\n    pub type U582 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P582 = PInt\u003cU582\u003e; pub type N582 = NInt\u003cU582\u003e;\n    pub type U583 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P583 = PInt\u003cU583\u003e; pub type N583 = NInt\u003cU583\u003e;\n    pub type U584 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P584 = PInt\u003cU584\u003e; pub type N584 = NInt\u003cU584\u003e;\n    pub type U585 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P585 = PInt\u003cU585\u003e; pub type N585 = NInt\u003cU585\u003e;\n    pub type U586 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P586 = PInt\u003cU586\u003e; pub type N586 = NInt\u003cU586\u003e;\n    pub type U587 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P587 = PInt\u003cU587\u003e; pub type N587 = NInt\u003cU587\u003e;\n    pub type U588 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P588 = PInt\u003cU588\u003e; pub type N588 = NInt\u003cU588\u003e;\n    pub type U589 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P589 = PInt\u003cU589\u003e; pub type N589 = NInt\u003cU589\u003e;\n    pub type U590 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P590 = PInt\u003cU590\u003e; pub type N590 = NInt\u003cU590\u003e;\n    pub type U591 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P591 = PInt\u003cU591\u003e; pub type N591 = NInt\u003cU591\u003e;\n    pub type U592 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P592 = PInt\u003cU592\u003e; pub type N592 = NInt\u003cU592\u003e;\n    pub type U593 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P593 = PInt\u003cU593\u003e; pub type N593 = NInt\u003cU593\u003e;\n    pub type U594 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P594 = PInt\u003cU594\u003e; pub type N594 = NInt\u003cU594\u003e;\n    pub type U595 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P595 = PInt\u003cU595\u003e; pub type N595 = NInt\u003cU595\u003e;\n    pub type U596 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P596 = PInt\u003cU596\u003e; pub type N596 = NInt\u003cU596\u003e;\n    pub type U597 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P597 = PInt\u003cU597\u003e; pub type N597 = NInt\u003cU597\u003e;\n    pub type U598 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P598 = PInt\u003cU598\u003e; pub type N598 = NInt\u003cU598\u003e;\n    pub type U599 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P599 = PInt\u003cU599\u003e; pub type N599 = NInt\u003cU599\u003e;\n    pub type U600 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P600 = PInt\u003cU600\u003e; pub type N600 = NInt\u003cU600\u003e;\n    pub type U601 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P601 = PInt\u003cU601\u003e; pub type N601 = NInt\u003cU601\u003e;\n    pub type U602 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P602 = PInt\u003cU602\u003e; pub type N602 = NInt\u003cU602\u003e;\n    pub type U603 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P603 = PInt\u003cU603\u003e; pub type N603 = NInt\u003cU603\u003e;\n    pub type U604 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P604 = PInt\u003cU604\u003e; pub type N604 = NInt\u003cU604\u003e;\n    pub type U605 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P605 = PInt\u003cU605\u003e; pub type N605 = NInt\u003cU605\u003e;\n    pub type U606 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P606 = PInt\u003cU606\u003e; pub type N606 = NInt\u003cU606\u003e;\n    pub type U607 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P607 = PInt\u003cU607\u003e; pub type N607 = NInt\u003cU607\u003e;\n    pub type U608 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P608 = PInt\u003cU608\u003e; pub type N608 = NInt\u003cU608\u003e;\n    pub type U609 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P609 = PInt\u003cU609\u003e; pub type N609 = NInt\u003cU609\u003e;\n    pub type U610 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P610 = PInt\u003cU610\u003e; pub type N610 = NInt\u003cU610\u003e;\n    pub type U611 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P611 = PInt\u003cU611\u003e; pub type N611 = NInt\u003cU611\u003e;\n    pub type U612 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P612 = PInt\u003cU612\u003e; pub type N612 = NInt\u003cU612\u003e;\n    pub type U613 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P613 = PInt\u003cU613\u003e; pub type N613 = NInt\u003cU613\u003e;\n    pub type U614 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P614 = PInt\u003cU614\u003e; pub type N614 = NInt\u003cU614\u003e;\n    pub type U615 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P615 = PInt\u003cU615\u003e; pub type N615 = NInt\u003cU615\u003e;\n    pub type U616 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P616 = PInt\u003cU616\u003e; pub type N616 = NInt\u003cU616\u003e;\n    pub type U617 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P617 = PInt\u003cU617\u003e; pub type N617 = NInt\u003cU617\u003e;\n    pub type U618 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P618 = PInt\u003cU618\u003e; pub type N618 = NInt\u003cU618\u003e;\n    pub type U619 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P619 = PInt\u003cU619\u003e; pub type N619 = NInt\u003cU619\u003e;\n    pub type U620 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P620 = PInt\u003cU620\u003e; pub type N620 = NInt\u003cU620\u003e;\n    pub type U621 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P621 = PInt\u003cU621\u003e; pub type N621 = NInt\u003cU621\u003e;\n    pub type U622 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P622 = PInt\u003cU622\u003e; pub type N622 = NInt\u003cU622\u003e;\n    pub type U623 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P623 = PInt\u003cU623\u003e; pub type N623 = NInt\u003cU623\u003e;\n    pub type U624 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P624 = PInt\u003cU624\u003e; pub type N624 = NInt\u003cU624\u003e;\n    pub type U625 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P625 = PInt\u003cU625\u003e; pub type N625 = NInt\u003cU625\u003e;\n    pub type U626 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P626 = PInt\u003cU626\u003e; pub type N626 = NInt\u003cU626\u003e;\n    pub type U627 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P627 = PInt\u003cU627\u003e; pub type N627 = NInt\u003cU627\u003e;\n    pub type U628 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P628 = PInt\u003cU628\u003e; pub type N628 = NInt\u003cU628\u003e;\n    pub type U629 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P629 = PInt\u003cU629\u003e; pub type N629 = NInt\u003cU629\u003e;\n    pub type U630 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P630 = PInt\u003cU630\u003e; pub type N630 = NInt\u003cU630\u003e;\n    pub type U631 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P631 = PInt\u003cU631\u003e; pub type N631 = NInt\u003cU631\u003e;\n    pub type U632 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P632 = PInt\u003cU632\u003e; pub type N632 = NInt\u003cU632\u003e;\n    pub type U633 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P633 = PInt\u003cU633\u003e; pub type N633 = NInt\u003cU633\u003e;\n    pub type U634 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P634 = PInt\u003cU634\u003e; pub type N634 = NInt\u003cU634\u003e;\n    pub type U635 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P635 = PInt\u003cU635\u003e; pub type N635 = NInt\u003cU635\u003e;\n    pub type U636 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P636 = PInt\u003cU636\u003e; pub type N636 = NInt\u003cU636\u003e;\n    pub type U637 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P637 = PInt\u003cU637\u003e; pub type N637 = NInt\u003cU637\u003e;\n    pub type U638 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P638 = PInt\u003cU638\u003e; pub type N638 = NInt\u003cU638\u003e;\n    pub type U639 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P639 = PInt\u003cU639\u003e; pub type N639 = NInt\u003cU639\u003e;\n    pub type U640 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P640 = PInt\u003cU640\u003e; pub type N640 = NInt\u003cU640\u003e;\n    pub type U641 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P641 = PInt\u003cU641\u003e; pub type N641 = NInt\u003cU641\u003e;\n    pub type U642 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P642 = PInt\u003cU642\u003e; pub type N642 = NInt\u003cU642\u003e;\n    pub type U643 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P643 = PInt\u003cU643\u003e; pub type N643 = NInt\u003cU643\u003e;\n    pub type U644 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P644 = PInt\u003cU644\u003e; pub type N644 = NInt\u003cU644\u003e;\n    pub type U645 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P645 = PInt\u003cU645\u003e; pub type N645 = NInt\u003cU645\u003e;\n    pub type U646 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P646 = PInt\u003cU646\u003e; pub type N646 = NInt\u003cU646\u003e;\n    pub type U647 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P647 = PInt\u003cU647\u003e; pub type N647 = NInt\u003cU647\u003e;\n    pub type U648 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P648 = PInt\u003cU648\u003e; pub type N648 = NInt\u003cU648\u003e;\n    pub type U649 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P649 = PInt\u003cU649\u003e; pub type N649 = NInt\u003cU649\u003e;\n    pub type U650 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P650 = PInt\u003cU650\u003e; pub type N650 = NInt\u003cU650\u003e;\n    pub type U651 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P651 = PInt\u003cU651\u003e; pub type N651 = NInt\u003cU651\u003e;\n    pub type U652 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P652 = PInt\u003cU652\u003e; pub type N652 = NInt\u003cU652\u003e;\n    pub type U653 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P653 = PInt\u003cU653\u003e; pub type N653 = NInt\u003cU653\u003e;\n    pub type U654 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P654 = PInt\u003cU654\u003e; pub type N654 = NInt\u003cU654\u003e;\n    pub type U655 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P655 = PInt\u003cU655\u003e; pub type N655 = NInt\u003cU655\u003e;\n    pub type U656 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P656 = PInt\u003cU656\u003e; pub type N656 = NInt\u003cU656\u003e;\n    pub type U657 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P657 = PInt\u003cU657\u003e; pub type N657 = NInt\u003cU657\u003e;\n    pub type U658 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P658 = PInt\u003cU658\u003e; pub type N658 = NInt\u003cU658\u003e;\n    pub type U659 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P659 = PInt\u003cU659\u003e; pub type N659 = NInt\u003cU659\u003e;\n    pub type U660 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P660 = PInt\u003cU660\u003e; pub type N660 = NInt\u003cU660\u003e;\n    pub type U661 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P661 = PInt\u003cU661\u003e; pub type N661 = NInt\u003cU661\u003e;\n    pub type U662 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P662 = PInt\u003cU662\u003e; pub type N662 = NInt\u003cU662\u003e;\n    pub type U663 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P663 = PInt\u003cU663\u003e; pub type N663 = NInt\u003cU663\u003e;\n    pub type U664 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P664 = PInt\u003cU664\u003e; pub type N664 = NInt\u003cU664\u003e;\n    pub type U665 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P665 = PInt\u003cU665\u003e; pub type N665 = NInt\u003cU665\u003e;\n    pub type U666 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P666 = PInt\u003cU666\u003e; pub type N666 = NInt\u003cU666\u003e;\n    pub type U667 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P667 = PInt\u003cU667\u003e; pub type N667 = NInt\u003cU667\u003e;\n    pub type U668 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P668 = PInt\u003cU668\u003e; pub type N668 = NInt\u003cU668\u003e;\n    pub type U669 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P669 = PInt\u003cU669\u003e; pub type N669 = NInt\u003cU669\u003e;\n    pub type U670 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P670 = PInt\u003cU670\u003e; pub type N670 = NInt\u003cU670\u003e;\n    pub type U671 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P671 = PInt\u003cU671\u003e; pub type N671 = NInt\u003cU671\u003e;\n    pub type U672 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P672 = PInt\u003cU672\u003e; pub type N672 = NInt\u003cU672\u003e;\n    pub type U673 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P673 = PInt\u003cU673\u003e; pub type N673 = NInt\u003cU673\u003e;\n    pub type U674 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P674 = PInt\u003cU674\u003e; pub type N674 = NInt\u003cU674\u003e;\n    pub type U675 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P675 = PInt\u003cU675\u003e; pub type N675 = NInt\u003cU675\u003e;\n    pub type U676 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P676 = PInt\u003cU676\u003e; pub type N676 = NInt\u003cU676\u003e;\n    pub type U677 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P677 = PInt\u003cU677\u003e; pub type N677 = NInt\u003cU677\u003e;\n    pub type U678 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P678 = PInt\u003cU678\u003e; pub type N678 = NInt\u003cU678\u003e;\n    pub type U679 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P679 = PInt\u003cU679\u003e; pub type N679 = NInt\u003cU679\u003e;\n    pub type U680 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P680 = PInt\u003cU680\u003e; pub type N680 = NInt\u003cU680\u003e;\n    pub type U681 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P681 = PInt\u003cU681\u003e; pub type N681 = NInt\u003cU681\u003e;\n    pub type U682 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P682 = PInt\u003cU682\u003e; pub type N682 = NInt\u003cU682\u003e;\n    pub type U683 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P683 = PInt\u003cU683\u003e; pub type N683 = NInt\u003cU683\u003e;\n    pub type U684 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P684 = PInt\u003cU684\u003e; pub type N684 = NInt\u003cU684\u003e;\n    pub type U685 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P685 = PInt\u003cU685\u003e; pub type N685 = NInt\u003cU685\u003e;\n    pub type U686 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P686 = PInt\u003cU686\u003e; pub type N686 = NInt\u003cU686\u003e;\n    pub type U687 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P687 = PInt\u003cU687\u003e; pub type N687 = NInt\u003cU687\u003e;\n    pub type U688 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P688 = PInt\u003cU688\u003e; pub type N688 = NInt\u003cU688\u003e;\n    pub type U689 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P689 = PInt\u003cU689\u003e; pub type N689 = NInt\u003cU689\u003e;\n    pub type U690 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P690 = PInt\u003cU690\u003e; pub type N690 = NInt\u003cU690\u003e;\n    pub type U691 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P691 = PInt\u003cU691\u003e; pub type N691 = NInt\u003cU691\u003e;\n    pub type U692 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P692 = PInt\u003cU692\u003e; pub type N692 = NInt\u003cU692\u003e;\n    pub type U693 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P693 = PInt\u003cU693\u003e; pub type N693 = NInt\u003cU693\u003e;\n    pub type U694 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P694 = PInt\u003cU694\u003e; pub type N694 = NInt\u003cU694\u003e;\n    pub type U695 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P695 = PInt\u003cU695\u003e; pub type N695 = NInt\u003cU695\u003e;\n    pub type U696 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P696 = PInt\u003cU696\u003e; pub type N696 = NInt\u003cU696\u003e;\n    pub type U697 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P697 = PInt\u003cU697\u003e; pub type N697 = NInt\u003cU697\u003e;\n    pub type U698 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P698 = PInt\u003cU698\u003e; pub type N698 = NInt\u003cU698\u003e;\n    pub type U699 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P699 = PInt\u003cU699\u003e; pub type N699 = NInt\u003cU699\u003e;\n    pub type U700 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P700 = PInt\u003cU700\u003e; pub type N700 = NInt\u003cU700\u003e;\n    pub type U701 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P701 = PInt\u003cU701\u003e; pub type N701 = NInt\u003cU701\u003e;\n    pub type U702 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P702 = PInt\u003cU702\u003e; pub type N702 = NInt\u003cU702\u003e;\n    pub type U703 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P703 = PInt\u003cU703\u003e; pub type N703 = NInt\u003cU703\u003e;\n    pub type U704 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P704 = PInt\u003cU704\u003e; pub type N704 = NInt\u003cU704\u003e;\n    pub type U705 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P705 = PInt\u003cU705\u003e; pub type N705 = NInt\u003cU705\u003e;\n    pub type U706 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P706 = PInt\u003cU706\u003e; pub type N706 = NInt\u003cU706\u003e;\n    pub type U707 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P707 = PInt\u003cU707\u003e; pub type N707 = NInt\u003cU707\u003e;\n    pub type U708 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P708 = PInt\u003cU708\u003e; pub type N708 = NInt\u003cU708\u003e;\n    pub type U709 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P709 = PInt\u003cU709\u003e; pub type N709 = NInt\u003cU709\u003e;\n    pub type U710 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P710 = PInt\u003cU710\u003e; pub type N710 = NInt\u003cU710\u003e;\n    pub type U711 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P711 = PInt\u003cU711\u003e; pub type N711 = NInt\u003cU711\u003e;\n    pub type U712 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P712 = PInt\u003cU712\u003e; pub type N712 = NInt\u003cU712\u003e;\n    pub type U713 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P713 = PInt\u003cU713\u003e; pub type N713 = NInt\u003cU713\u003e;\n    pub type U714 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P714 = PInt\u003cU714\u003e; pub type N714 = NInt\u003cU714\u003e;\n    pub type U715 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P715 = PInt\u003cU715\u003e; pub type N715 = NInt\u003cU715\u003e;\n    pub type U716 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P716 = PInt\u003cU716\u003e; pub type N716 = NInt\u003cU716\u003e;\n    pub type U717 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P717 = PInt\u003cU717\u003e; pub type N717 = NInt\u003cU717\u003e;\n    pub type U718 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P718 = PInt\u003cU718\u003e; pub type N718 = NInt\u003cU718\u003e;\n    pub type U719 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P719 = PInt\u003cU719\u003e; pub type N719 = NInt\u003cU719\u003e;\n    pub type U720 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P720 = PInt\u003cU720\u003e; pub type N720 = NInt\u003cU720\u003e;\n    pub type U721 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P721 = PInt\u003cU721\u003e; pub type N721 = NInt\u003cU721\u003e;\n    pub type U722 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P722 = PInt\u003cU722\u003e; pub type N722 = NInt\u003cU722\u003e;\n    pub type U723 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P723 = PInt\u003cU723\u003e; pub type N723 = NInt\u003cU723\u003e;\n    pub type U724 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P724 = PInt\u003cU724\u003e; pub type N724 = NInt\u003cU724\u003e;\n    pub type U725 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P725 = PInt\u003cU725\u003e; pub type N725 = NInt\u003cU725\u003e;\n    pub type U726 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P726 = PInt\u003cU726\u003e; pub type N726 = NInt\u003cU726\u003e;\n    pub type U727 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P727 = PInt\u003cU727\u003e; pub type N727 = NInt\u003cU727\u003e;\n    pub type U728 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P728 = PInt\u003cU728\u003e; pub type N728 = NInt\u003cU728\u003e;\n    pub type U729 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P729 = PInt\u003cU729\u003e; pub type N729 = NInt\u003cU729\u003e;\n    pub type U730 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P730 = PInt\u003cU730\u003e; pub type N730 = NInt\u003cU730\u003e;\n    pub type U731 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P731 = PInt\u003cU731\u003e; pub type N731 = NInt\u003cU731\u003e;\n    pub type U732 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P732 = PInt\u003cU732\u003e; pub type N732 = NInt\u003cU732\u003e;\n    pub type U733 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P733 = PInt\u003cU733\u003e; pub type N733 = NInt\u003cU733\u003e;\n    pub type U734 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P734 = PInt\u003cU734\u003e; pub type N734 = NInt\u003cU734\u003e;\n    pub type U735 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P735 = PInt\u003cU735\u003e; pub type N735 = NInt\u003cU735\u003e;\n    pub type U736 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P736 = PInt\u003cU736\u003e; pub type N736 = NInt\u003cU736\u003e;\n    pub type U737 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P737 = PInt\u003cU737\u003e; pub type N737 = NInt\u003cU737\u003e;\n    pub type U738 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P738 = PInt\u003cU738\u003e; pub type N738 = NInt\u003cU738\u003e;\n    pub type U739 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P739 = PInt\u003cU739\u003e; pub type N739 = NInt\u003cU739\u003e;\n    pub type U740 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P740 = PInt\u003cU740\u003e; pub type N740 = NInt\u003cU740\u003e;\n    pub type U741 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P741 = PInt\u003cU741\u003e; pub type N741 = NInt\u003cU741\u003e;\n    pub type U742 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P742 = PInt\u003cU742\u003e; pub type N742 = NInt\u003cU742\u003e;\n    pub type U743 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P743 = PInt\u003cU743\u003e; pub type N743 = NInt\u003cU743\u003e;\n    pub type U744 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P744 = PInt\u003cU744\u003e; pub type N744 = NInt\u003cU744\u003e;\n    pub type U745 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P745 = PInt\u003cU745\u003e; pub type N745 = NInt\u003cU745\u003e;\n    pub type U746 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P746 = PInt\u003cU746\u003e; pub type N746 = NInt\u003cU746\u003e;\n    pub type U747 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P747 = PInt\u003cU747\u003e; pub type N747 = NInt\u003cU747\u003e;\n    pub type U748 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P748 = PInt\u003cU748\u003e; pub type N748 = NInt\u003cU748\u003e;\n    pub type U749 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P749 = PInt\u003cU749\u003e; pub type N749 = NInt\u003cU749\u003e;\n    pub type U750 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P750 = PInt\u003cU750\u003e; pub type N750 = NInt\u003cU750\u003e;\n    pub type U751 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P751 = PInt\u003cU751\u003e; pub type N751 = NInt\u003cU751\u003e;\n    pub type U752 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P752 = PInt\u003cU752\u003e; pub type N752 = NInt\u003cU752\u003e;\n    pub type U753 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P753 = PInt\u003cU753\u003e; pub type N753 = NInt\u003cU753\u003e;\n    pub type U754 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P754 = PInt\u003cU754\u003e; pub type N754 = NInt\u003cU754\u003e;\n    pub type U755 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P755 = PInt\u003cU755\u003e; pub type N755 = NInt\u003cU755\u003e;\n    pub type U756 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P756 = PInt\u003cU756\u003e; pub type N756 = NInt\u003cU756\u003e;\n    pub type U757 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P757 = PInt\u003cU757\u003e; pub type N757 = NInt\u003cU757\u003e;\n    pub type U758 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P758 = PInt\u003cU758\u003e; pub type N758 = NInt\u003cU758\u003e;\n    pub type U759 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P759 = PInt\u003cU759\u003e; pub type N759 = NInt\u003cU759\u003e;\n    pub type U760 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P760 = PInt\u003cU760\u003e; pub type N760 = NInt\u003cU760\u003e;\n    pub type U761 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P761 = PInt\u003cU761\u003e; pub type N761 = NInt\u003cU761\u003e;\n    pub type U762 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P762 = PInt\u003cU762\u003e; pub type N762 = NInt\u003cU762\u003e;\n    pub type U763 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P763 = PInt\u003cU763\u003e; pub type N763 = NInt\u003cU763\u003e;\n    pub type U764 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P764 = PInt\u003cU764\u003e; pub type N764 = NInt\u003cU764\u003e;\n    pub type U765 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P765 = PInt\u003cU765\u003e; pub type N765 = NInt\u003cU765\u003e;\n    pub type U766 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P766 = PInt\u003cU766\u003e; pub type N766 = NInt\u003cU766\u003e;\n    pub type U767 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P767 = PInt\u003cU767\u003e; pub type N767 = NInt\u003cU767\u003e;\n    pub type U768 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P768 = PInt\u003cU768\u003e; pub type N768 = NInt\u003cU768\u003e;\n    pub type U769 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P769 = PInt\u003cU769\u003e; pub type N769 = NInt\u003cU769\u003e;\n    pub type U770 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P770 = PInt\u003cU770\u003e; pub type N770 = NInt\u003cU770\u003e;\n    pub type U771 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P771 = PInt\u003cU771\u003e; pub type N771 = NInt\u003cU771\u003e;\n    pub type U772 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P772 = PInt\u003cU772\u003e; pub type N772 = NInt\u003cU772\u003e;\n    pub type U773 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P773 = PInt\u003cU773\u003e; pub type N773 = NInt\u003cU773\u003e;\n    pub type U774 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P774 = PInt\u003cU774\u003e; pub type N774 = NInt\u003cU774\u003e;\n    pub type U775 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P775 = PInt\u003cU775\u003e; pub type N775 = NInt\u003cU775\u003e;\n    pub type U776 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P776 = PInt\u003cU776\u003e; pub type N776 = NInt\u003cU776\u003e;\n    pub type U777 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P777 = PInt\u003cU777\u003e; pub type N777 = NInt\u003cU777\u003e;\n    pub type U778 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P778 = PInt\u003cU778\u003e; pub type N778 = NInt\u003cU778\u003e;\n    pub type U779 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P779 = PInt\u003cU779\u003e; pub type N779 = NInt\u003cU779\u003e;\n    pub type U780 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P780 = PInt\u003cU780\u003e; pub type N780 = NInt\u003cU780\u003e;\n    pub type U781 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P781 = PInt\u003cU781\u003e; pub type N781 = NInt\u003cU781\u003e;\n    pub type U782 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P782 = PInt\u003cU782\u003e; pub type N782 = NInt\u003cU782\u003e;\n    pub type U783 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P783 = PInt\u003cU783\u003e; pub type N783 = NInt\u003cU783\u003e;\n    pub type U784 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P784 = PInt\u003cU784\u003e; pub type N784 = NInt\u003cU784\u003e;\n    pub type U785 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P785 = PInt\u003cU785\u003e; pub type N785 = NInt\u003cU785\u003e;\n    pub type U786 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P786 = PInt\u003cU786\u003e; pub type N786 = NInt\u003cU786\u003e;\n    pub type U787 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P787 = PInt\u003cU787\u003e; pub type N787 = NInt\u003cU787\u003e;\n    pub type U788 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P788 = PInt\u003cU788\u003e; pub type N788 = NInt\u003cU788\u003e;\n    pub type U789 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P789 = PInt\u003cU789\u003e; pub type N789 = NInt\u003cU789\u003e;\n    pub type U790 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P790 = PInt\u003cU790\u003e; pub type N790 = NInt\u003cU790\u003e;\n    pub type U791 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P791 = PInt\u003cU791\u003e; pub type N791 = NInt\u003cU791\u003e;\n    pub type U792 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P792 = PInt\u003cU792\u003e; pub type N792 = NInt\u003cU792\u003e;\n    pub type U793 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P793 = PInt\u003cU793\u003e; pub type N793 = NInt\u003cU793\u003e;\n    pub type U794 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P794 = PInt\u003cU794\u003e; pub type N794 = NInt\u003cU794\u003e;\n    pub type U795 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P795 = PInt\u003cU795\u003e; pub type N795 = NInt\u003cU795\u003e;\n    pub type U796 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P796 = PInt\u003cU796\u003e; pub type N796 = NInt\u003cU796\u003e;\n    pub type U797 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P797 = PInt\u003cU797\u003e; pub type N797 = NInt\u003cU797\u003e;\n    pub type U798 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P798 = PInt\u003cU798\u003e; pub type N798 = NInt\u003cU798\u003e;\n    pub type U799 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P799 = PInt\u003cU799\u003e; pub type N799 = NInt\u003cU799\u003e;\n    pub type U800 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P800 = PInt\u003cU800\u003e; pub type N800 = NInt\u003cU800\u003e;\n    pub type U801 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P801 = PInt\u003cU801\u003e; pub type N801 = NInt\u003cU801\u003e;\n    pub type U802 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P802 = PInt\u003cU802\u003e; pub type N802 = NInt\u003cU802\u003e;\n    pub type U803 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P803 = PInt\u003cU803\u003e; pub type N803 = NInt\u003cU803\u003e;\n    pub type U804 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P804 = PInt\u003cU804\u003e; pub type N804 = NInt\u003cU804\u003e;\n    pub type U805 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P805 = PInt\u003cU805\u003e; pub type N805 = NInt\u003cU805\u003e;\n    pub type U806 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P806 = PInt\u003cU806\u003e; pub type N806 = NInt\u003cU806\u003e;\n    pub type U807 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P807 = PInt\u003cU807\u003e; pub type N807 = NInt\u003cU807\u003e;\n    pub type U808 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P808 = PInt\u003cU808\u003e; pub type N808 = NInt\u003cU808\u003e;\n    pub type U809 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P809 = PInt\u003cU809\u003e; pub type N809 = NInt\u003cU809\u003e;\n    pub type U810 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P810 = PInt\u003cU810\u003e; pub type N810 = NInt\u003cU810\u003e;\n    pub type U811 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P811 = PInt\u003cU811\u003e; pub type N811 = NInt\u003cU811\u003e;\n    pub type U812 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P812 = PInt\u003cU812\u003e; pub type N812 = NInt\u003cU812\u003e;\n    pub type U813 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P813 = PInt\u003cU813\u003e; pub type N813 = NInt\u003cU813\u003e;\n    pub type U814 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P814 = PInt\u003cU814\u003e; pub type N814 = NInt\u003cU814\u003e;\n    pub type U815 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P815 = PInt\u003cU815\u003e; pub type N815 = NInt\u003cU815\u003e;\n    pub type U816 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P816 = PInt\u003cU816\u003e; pub type N816 = NInt\u003cU816\u003e;\n    pub type U817 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P817 = PInt\u003cU817\u003e; pub type N817 = NInt\u003cU817\u003e;\n    pub type U818 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P818 = PInt\u003cU818\u003e; pub type N818 = NInt\u003cU818\u003e;\n    pub type U819 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P819 = PInt\u003cU819\u003e; pub type N819 = NInt\u003cU819\u003e;\n    pub type U820 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P820 = PInt\u003cU820\u003e; pub type N820 = NInt\u003cU820\u003e;\n    pub type U821 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P821 = PInt\u003cU821\u003e; pub type N821 = NInt\u003cU821\u003e;\n    pub type U822 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P822 = PInt\u003cU822\u003e; pub type N822 = NInt\u003cU822\u003e;\n    pub type U823 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P823 = PInt\u003cU823\u003e; pub type N823 = NInt\u003cU823\u003e;\n    pub type U824 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P824 = PInt\u003cU824\u003e; pub type N824 = NInt\u003cU824\u003e;\n    pub type U825 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P825 = PInt\u003cU825\u003e; pub type N825 = NInt\u003cU825\u003e;\n    pub type U826 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P826 = PInt\u003cU826\u003e; pub type N826 = NInt\u003cU826\u003e;\n    pub type U827 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P827 = PInt\u003cU827\u003e; pub type N827 = NInt\u003cU827\u003e;\n    pub type U828 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P828 = PInt\u003cU828\u003e; pub type N828 = NInt\u003cU828\u003e;\n    pub type U829 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P829 = PInt\u003cU829\u003e; pub type N829 = NInt\u003cU829\u003e;\n    pub type U830 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P830 = PInt\u003cU830\u003e; pub type N830 = NInt\u003cU830\u003e;\n    pub type U831 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P831 = PInt\u003cU831\u003e; pub type N831 = NInt\u003cU831\u003e;\n    pub type U832 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P832 = PInt\u003cU832\u003e; pub type N832 = NInt\u003cU832\u003e;\n    pub type U833 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P833 = PInt\u003cU833\u003e; pub type N833 = NInt\u003cU833\u003e;\n    pub type U834 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P834 = PInt\u003cU834\u003e; pub type N834 = NInt\u003cU834\u003e;\n    pub type U835 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P835 = PInt\u003cU835\u003e; pub type N835 = NInt\u003cU835\u003e;\n    pub type U836 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P836 = PInt\u003cU836\u003e; pub type N836 = NInt\u003cU836\u003e;\n    pub type U837 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P837 = PInt\u003cU837\u003e; pub type N837 = NInt\u003cU837\u003e;\n    pub type U838 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P838 = PInt\u003cU838\u003e; pub type N838 = NInt\u003cU838\u003e;\n    pub type U839 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P839 = PInt\u003cU839\u003e; pub type N839 = NInt\u003cU839\u003e;\n    pub type U840 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P840 = PInt\u003cU840\u003e; pub type N840 = NInt\u003cU840\u003e;\n    pub type U841 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P841 = PInt\u003cU841\u003e; pub type N841 = NInt\u003cU841\u003e;\n    pub type U842 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P842 = PInt\u003cU842\u003e; pub type N842 = NInt\u003cU842\u003e;\n    pub type U843 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P843 = PInt\u003cU843\u003e; pub type N843 = NInt\u003cU843\u003e;\n    pub type U844 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P844 = PInt\u003cU844\u003e; pub type N844 = NInt\u003cU844\u003e;\n    pub type U845 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P845 = PInt\u003cU845\u003e; pub type N845 = NInt\u003cU845\u003e;\n    pub type U846 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P846 = PInt\u003cU846\u003e; pub type N846 = NInt\u003cU846\u003e;\n    pub type U847 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P847 = PInt\u003cU847\u003e; pub type N847 = NInt\u003cU847\u003e;\n    pub type U848 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P848 = PInt\u003cU848\u003e; pub type N848 = NInt\u003cU848\u003e;\n    pub type U849 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P849 = PInt\u003cU849\u003e; pub type N849 = NInt\u003cU849\u003e;\n    pub type U850 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P850 = PInt\u003cU850\u003e; pub type N850 = NInt\u003cU850\u003e;\n    pub type U851 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P851 = PInt\u003cU851\u003e; pub type N851 = NInt\u003cU851\u003e;\n    pub type U852 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P852 = PInt\u003cU852\u003e; pub type N852 = NInt\u003cU852\u003e;\n    pub type U853 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P853 = PInt\u003cU853\u003e; pub type N853 = NInt\u003cU853\u003e;\n    pub type U854 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P854 = PInt\u003cU854\u003e; pub type N854 = NInt\u003cU854\u003e;\n    pub type U855 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P855 = PInt\u003cU855\u003e; pub type N855 = NInt\u003cU855\u003e;\n    pub type U856 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P856 = PInt\u003cU856\u003e; pub type N856 = NInt\u003cU856\u003e;\n    pub type U857 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P857 = PInt\u003cU857\u003e; pub type N857 = NInt\u003cU857\u003e;\n    pub type U858 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P858 = PInt\u003cU858\u003e; pub type N858 = NInt\u003cU858\u003e;\n    pub type U859 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P859 = PInt\u003cU859\u003e; pub type N859 = NInt\u003cU859\u003e;\n    pub type U860 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P860 = PInt\u003cU860\u003e; pub type N860 = NInt\u003cU860\u003e;\n    pub type U861 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P861 = PInt\u003cU861\u003e; pub type N861 = NInt\u003cU861\u003e;\n    pub type U862 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P862 = PInt\u003cU862\u003e; pub type N862 = NInt\u003cU862\u003e;\n    pub type U863 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P863 = PInt\u003cU863\u003e; pub type N863 = NInt\u003cU863\u003e;\n    pub type U864 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P864 = PInt\u003cU864\u003e; pub type N864 = NInt\u003cU864\u003e;\n    pub type U865 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P865 = PInt\u003cU865\u003e; pub type N865 = NInt\u003cU865\u003e;\n    pub type U866 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P866 = PInt\u003cU866\u003e; pub type N866 = NInt\u003cU866\u003e;\n    pub type U867 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P867 = PInt\u003cU867\u003e; pub type N867 = NInt\u003cU867\u003e;\n    pub type U868 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P868 = PInt\u003cU868\u003e; pub type N868 = NInt\u003cU868\u003e;\n    pub type U869 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P869 = PInt\u003cU869\u003e; pub type N869 = NInt\u003cU869\u003e;\n    pub type U870 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P870 = PInt\u003cU870\u003e; pub type N870 = NInt\u003cU870\u003e;\n    pub type U871 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P871 = PInt\u003cU871\u003e; pub type N871 = NInt\u003cU871\u003e;\n    pub type U872 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P872 = PInt\u003cU872\u003e; pub type N872 = NInt\u003cU872\u003e;\n    pub type U873 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P873 = PInt\u003cU873\u003e; pub type N873 = NInt\u003cU873\u003e;\n    pub type U874 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P874 = PInt\u003cU874\u003e; pub type N874 = NInt\u003cU874\u003e;\n    pub type U875 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P875 = PInt\u003cU875\u003e; pub type N875 = NInt\u003cU875\u003e;\n    pub type U876 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P876 = PInt\u003cU876\u003e; pub type N876 = NInt\u003cU876\u003e;\n    pub type U877 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P877 = PInt\u003cU877\u003e; pub type N877 = NInt\u003cU877\u003e;\n    pub type U878 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P878 = PInt\u003cU878\u003e; pub type N878 = NInt\u003cU878\u003e;\n    pub type U879 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P879 = PInt\u003cU879\u003e; pub type N879 = NInt\u003cU879\u003e;\n    pub type U880 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P880 = PInt\u003cU880\u003e; pub type N880 = NInt\u003cU880\u003e;\n    pub type U881 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P881 = PInt\u003cU881\u003e; pub type N881 = NInt\u003cU881\u003e;\n    pub type U882 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P882 = PInt\u003cU882\u003e; pub type N882 = NInt\u003cU882\u003e;\n    pub type U883 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P883 = PInt\u003cU883\u003e; pub type N883 = NInt\u003cU883\u003e;\n    pub type U884 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P884 = PInt\u003cU884\u003e; pub type N884 = NInt\u003cU884\u003e;\n    pub type U885 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P885 = PInt\u003cU885\u003e; pub type N885 = NInt\u003cU885\u003e;\n    pub type U886 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P886 = PInt\u003cU886\u003e; pub type N886 = NInt\u003cU886\u003e;\n    pub type U887 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P887 = PInt\u003cU887\u003e; pub type N887 = NInt\u003cU887\u003e;\n    pub type U888 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P888 = PInt\u003cU888\u003e; pub type N888 = NInt\u003cU888\u003e;\n    pub type U889 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P889 = PInt\u003cU889\u003e; pub type N889 = NInt\u003cU889\u003e;\n    pub type U890 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P890 = PInt\u003cU890\u003e; pub type N890 = NInt\u003cU890\u003e;\n    pub type U891 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P891 = PInt\u003cU891\u003e; pub type N891 = NInt\u003cU891\u003e;\n    pub type U892 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P892 = PInt\u003cU892\u003e; pub type N892 = NInt\u003cU892\u003e;\n    pub type U893 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P893 = PInt\u003cU893\u003e; pub type N893 = NInt\u003cU893\u003e;\n    pub type U894 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P894 = PInt\u003cU894\u003e; pub type N894 = NInt\u003cU894\u003e;\n    pub type U895 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P895 = PInt\u003cU895\u003e; pub type N895 = NInt\u003cU895\u003e;\n    pub type U896 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P896 = PInt\u003cU896\u003e; pub type N896 = NInt\u003cU896\u003e;\n    pub type U897 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P897 = PInt\u003cU897\u003e; pub type N897 = NInt\u003cU897\u003e;\n    pub type U898 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P898 = PInt\u003cU898\u003e; pub type N898 = NInt\u003cU898\u003e;\n    pub type U899 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P899 = PInt\u003cU899\u003e; pub type N899 = NInt\u003cU899\u003e;\n    pub type U900 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P900 = PInt\u003cU900\u003e; pub type N900 = NInt\u003cU900\u003e;\n    pub type U901 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P901 = PInt\u003cU901\u003e; pub type N901 = NInt\u003cU901\u003e;\n    pub type U902 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P902 = PInt\u003cU902\u003e; pub type N902 = NInt\u003cU902\u003e;\n    pub type U903 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P903 = PInt\u003cU903\u003e; pub type N903 = NInt\u003cU903\u003e;\n    pub type U904 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P904 = PInt\u003cU904\u003e; pub type N904 = NInt\u003cU904\u003e;\n    pub type U905 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P905 = PInt\u003cU905\u003e; pub type N905 = NInt\u003cU905\u003e;\n    pub type U906 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P906 = PInt\u003cU906\u003e; pub type N906 = NInt\u003cU906\u003e;\n    pub type U907 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P907 = PInt\u003cU907\u003e; pub type N907 = NInt\u003cU907\u003e;\n    pub type U908 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P908 = PInt\u003cU908\u003e; pub type N908 = NInt\u003cU908\u003e;\n    pub type U909 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P909 = PInt\u003cU909\u003e; pub type N909 = NInt\u003cU909\u003e;\n    pub type U910 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P910 = PInt\u003cU910\u003e; pub type N910 = NInt\u003cU910\u003e;\n    pub type U911 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P911 = PInt\u003cU911\u003e; pub type N911 = NInt\u003cU911\u003e;\n    pub type U912 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P912 = PInt\u003cU912\u003e; pub type N912 = NInt\u003cU912\u003e;\n    pub type U913 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P913 = PInt\u003cU913\u003e; pub type N913 = NInt\u003cU913\u003e;\n    pub type U914 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P914 = PInt\u003cU914\u003e; pub type N914 = NInt\u003cU914\u003e;\n    pub type U915 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P915 = PInt\u003cU915\u003e; pub type N915 = NInt\u003cU915\u003e;\n    pub type U916 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P916 = PInt\u003cU916\u003e; pub type N916 = NInt\u003cU916\u003e;\n    pub type U917 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P917 = PInt\u003cU917\u003e; pub type N917 = NInt\u003cU917\u003e;\n    pub type U918 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P918 = PInt\u003cU918\u003e; pub type N918 = NInt\u003cU918\u003e;\n    pub type U919 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P919 = PInt\u003cU919\u003e; pub type N919 = NInt\u003cU919\u003e;\n    pub type U920 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P920 = PInt\u003cU920\u003e; pub type N920 = NInt\u003cU920\u003e;\n    pub type U921 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P921 = PInt\u003cU921\u003e; pub type N921 = NInt\u003cU921\u003e;\n    pub type U922 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P922 = PInt\u003cU922\u003e; pub type N922 = NInt\u003cU922\u003e;\n    pub type U923 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P923 = PInt\u003cU923\u003e; pub type N923 = NInt\u003cU923\u003e;\n    pub type U924 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P924 = PInt\u003cU924\u003e; pub type N924 = NInt\u003cU924\u003e;\n    pub type U925 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P925 = PInt\u003cU925\u003e; pub type N925 = NInt\u003cU925\u003e;\n    pub type U926 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P926 = PInt\u003cU926\u003e; pub type N926 = NInt\u003cU926\u003e;\n    pub type U927 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P927 = PInt\u003cU927\u003e; pub type N927 = NInt\u003cU927\u003e;\n    pub type U928 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P928 = PInt\u003cU928\u003e; pub type N928 = NInt\u003cU928\u003e;\n    pub type U929 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P929 = PInt\u003cU929\u003e; pub type N929 = NInt\u003cU929\u003e;\n    pub type U930 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P930 = PInt\u003cU930\u003e; pub type N930 = NInt\u003cU930\u003e;\n    pub type U931 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P931 = PInt\u003cU931\u003e; pub type N931 = NInt\u003cU931\u003e;\n    pub type U932 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P932 = PInt\u003cU932\u003e; pub type N932 = NInt\u003cU932\u003e;\n    pub type U933 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P933 = PInt\u003cU933\u003e; pub type N933 = NInt\u003cU933\u003e;\n    pub type U934 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P934 = PInt\u003cU934\u003e; pub type N934 = NInt\u003cU934\u003e;\n    pub type U935 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P935 = PInt\u003cU935\u003e; pub type N935 = NInt\u003cU935\u003e;\n    pub type U936 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P936 = PInt\u003cU936\u003e; pub type N936 = NInt\u003cU936\u003e;\n    pub type U937 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P937 = PInt\u003cU937\u003e; pub type N937 = NInt\u003cU937\u003e;\n    pub type U938 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P938 = PInt\u003cU938\u003e; pub type N938 = NInt\u003cU938\u003e;\n    pub type U939 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P939 = PInt\u003cU939\u003e; pub type N939 = NInt\u003cU939\u003e;\n    pub type U940 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P940 = PInt\u003cU940\u003e; pub type N940 = NInt\u003cU940\u003e;\n    pub type U941 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P941 = PInt\u003cU941\u003e; pub type N941 = NInt\u003cU941\u003e;\n    pub type U942 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P942 = PInt\u003cU942\u003e; pub type N942 = NInt\u003cU942\u003e;\n    pub type U943 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P943 = PInt\u003cU943\u003e; pub type N943 = NInt\u003cU943\u003e;\n    pub type U944 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P944 = PInt\u003cU944\u003e; pub type N944 = NInt\u003cU944\u003e;\n    pub type U945 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P945 = PInt\u003cU945\u003e; pub type N945 = NInt\u003cU945\u003e;\n    pub type U946 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P946 = PInt\u003cU946\u003e; pub type N946 = NInt\u003cU946\u003e;\n    pub type U947 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P947 = PInt\u003cU947\u003e; pub type N947 = NInt\u003cU947\u003e;\n    pub type U948 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P948 = PInt\u003cU948\u003e; pub type N948 = NInt\u003cU948\u003e;\n    pub type U949 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P949 = PInt\u003cU949\u003e; pub type N949 = NInt\u003cU949\u003e;\n    pub type U950 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P950 = PInt\u003cU950\u003e; pub type N950 = NInt\u003cU950\u003e;\n    pub type U951 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P951 = PInt\u003cU951\u003e; pub type N951 = NInt\u003cU951\u003e;\n    pub type U952 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P952 = PInt\u003cU952\u003e; pub type N952 = NInt\u003cU952\u003e;\n    pub type U953 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P953 = PInt\u003cU953\u003e; pub type N953 = NInt\u003cU953\u003e;\n    pub type U954 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P954 = PInt\u003cU954\u003e; pub type N954 = NInt\u003cU954\u003e;\n    pub type U955 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P955 = PInt\u003cU955\u003e; pub type N955 = NInt\u003cU955\u003e;\n    pub type U956 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P956 = PInt\u003cU956\u003e; pub type N956 = NInt\u003cU956\u003e;\n    pub type U957 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P957 = PInt\u003cU957\u003e; pub type N957 = NInt\u003cU957\u003e;\n    pub type U958 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P958 = PInt\u003cU958\u003e; pub type N958 = NInt\u003cU958\u003e;\n    pub type U959 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P959 = PInt\u003cU959\u003e; pub type N959 = NInt\u003cU959\u003e;\n    pub type U960 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P960 = PInt\u003cU960\u003e; pub type N960 = NInt\u003cU960\u003e;\n    pub type U961 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P961 = PInt\u003cU961\u003e; pub type N961 = NInt\u003cU961\u003e;\n    pub type U962 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P962 = PInt\u003cU962\u003e; pub type N962 = NInt\u003cU962\u003e;\n    pub type U963 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P963 = PInt\u003cU963\u003e; pub type N963 = NInt\u003cU963\u003e;\n    pub type U964 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P964 = PInt\u003cU964\u003e; pub type N964 = NInt\u003cU964\u003e;\n    pub type U965 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P965 = PInt\u003cU965\u003e; pub type N965 = NInt\u003cU965\u003e;\n    pub type U966 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P966 = PInt\u003cU966\u003e; pub type N966 = NInt\u003cU966\u003e;\n    pub type U967 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P967 = PInt\u003cU967\u003e; pub type N967 = NInt\u003cU967\u003e;\n    pub type U968 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P968 = PInt\u003cU968\u003e; pub type N968 = NInt\u003cU968\u003e;\n    pub type U969 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P969 = PInt\u003cU969\u003e; pub type N969 = NInt\u003cU969\u003e;\n    pub type U970 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P970 = PInt\u003cU970\u003e; pub type N970 = NInt\u003cU970\u003e;\n    pub type U971 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P971 = PInt\u003cU971\u003e; pub type N971 = NInt\u003cU971\u003e;\n    pub type U972 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P972 = PInt\u003cU972\u003e; pub type N972 = NInt\u003cU972\u003e;\n    pub type U973 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P973 = PInt\u003cU973\u003e; pub type N973 = NInt\u003cU973\u003e;\n    pub type U974 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P974 = PInt\u003cU974\u003e; pub type N974 = NInt\u003cU974\u003e;\n    pub type U975 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P975 = PInt\u003cU975\u003e; pub type N975 = NInt\u003cU975\u003e;\n    pub type U976 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P976 = PInt\u003cU976\u003e; pub type N976 = NInt\u003cU976\u003e;\n    pub type U977 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P977 = PInt\u003cU977\u003e; pub type N977 = NInt\u003cU977\u003e;\n    pub type U978 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P978 = PInt\u003cU978\u003e; pub type N978 = NInt\u003cU978\u003e;\n    pub type U979 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P979 = PInt\u003cU979\u003e; pub type N979 = NInt\u003cU979\u003e;\n    pub type U980 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P980 = PInt\u003cU980\u003e; pub type N980 = NInt\u003cU980\u003e;\n    pub type U981 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P981 = PInt\u003cU981\u003e; pub type N981 = NInt\u003cU981\u003e;\n    pub type U982 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P982 = PInt\u003cU982\u003e; pub type N982 = NInt\u003cU982\u003e;\n    pub type U983 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P983 = PInt\u003cU983\u003e; pub type N983 = NInt\u003cU983\u003e;\n    pub type U984 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P984 = PInt\u003cU984\u003e; pub type N984 = NInt\u003cU984\u003e;\n    pub type U985 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P985 = PInt\u003cU985\u003e; pub type N985 = NInt\u003cU985\u003e;\n    pub type U986 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P986 = PInt\u003cU986\u003e; pub type N986 = NInt\u003cU986\u003e;\n    pub type U987 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P987 = PInt\u003cU987\u003e; pub type N987 = NInt\u003cU987\u003e;\n    pub type U988 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P988 = PInt\u003cU988\u003e; pub type N988 = NInt\u003cU988\u003e;\n    pub type U989 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P989 = PInt\u003cU989\u003e; pub type N989 = NInt\u003cU989\u003e;\n    pub type U990 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P990 = PInt\u003cU990\u003e; pub type N990 = NInt\u003cU990\u003e;\n    pub type U991 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P991 = PInt\u003cU991\u003e; pub type N991 = NInt\u003cU991\u003e;\n    pub type U992 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P992 = PInt\u003cU992\u003e; pub type N992 = NInt\u003cU992\u003e;\n    pub type U993 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P993 = PInt\u003cU993\u003e; pub type N993 = NInt\u003cU993\u003e;\n    pub type U994 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P994 = PInt\u003cU994\u003e; pub type N994 = NInt\u003cU994\u003e;\n    pub type U995 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P995 = PInt\u003cU995\u003e; pub type N995 = NInt\u003cU995\u003e;\n    pub type U996 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P996 = PInt\u003cU996\u003e; pub type N996 = NInt\u003cU996\u003e;\n    pub type U997 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P997 = PInt\u003cU997\u003e; pub type N997 = NInt\u003cU997\u003e;\n    pub type U998 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P998 = PInt\u003cU998\u003e; pub type N998 = NInt\u003cU998\u003e;\n    pub type U999 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P999 = PInt\u003cU999\u003e; pub type N999 = NInt\u003cU999\u003e;\n    pub type U1000 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P1000 = PInt\u003cU1000\u003e; pub type N1000 = NInt\u003cU1000\u003e;\n    pub type U1001 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P1001 = PInt\u003cU1001\u003e; pub type N1001 = NInt\u003cU1001\u003e;\n    pub type U1002 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P1002 = PInt\u003cU1002\u003e; pub type N1002 = NInt\u003cU1002\u003e;\n    pub type U1003 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P1003 = PInt\u003cU1003\u003e; pub type N1003 = NInt\u003cU1003\u003e;\n    pub type U1004 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P1004 = PInt\u003cU1004\u003e; pub type N1004 = NInt\u003cU1004\u003e;\n    pub type U1005 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P1005 = PInt\u003cU1005\u003e; pub type N1005 = NInt\u003cU1005\u003e;\n    pub type U1006 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P1006 = PInt\u003cU1006\u003e; pub type N1006 = NInt\u003cU1006\u003e;\n    pub type U1007 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P1007 = PInt\u003cU1007\u003e; pub type N1007 = NInt\u003cU1007\u003e;\n    pub type U1008 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P1008 = PInt\u003cU1008\u003e; pub type N1008 = NInt\u003cU1008\u003e;\n    pub type U1009 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P1009 = PInt\u003cU1009\u003e; pub type N1009 = NInt\u003cU1009\u003e;\n    pub type U1010 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P1010 = PInt\u003cU1010\u003e; pub type N1010 = NInt\u003cU1010\u003e;\n    pub type U1011 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P1011 = PInt\u003cU1011\u003e; pub type N1011 = NInt\u003cU1011\u003e;\n    pub type U1012 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P1012 = PInt\u003cU1012\u003e; pub type N1012 = NInt\u003cU1012\u003e;\n    pub type U1013 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P1013 = PInt\u003cU1013\u003e; pub type N1013 = NInt\u003cU1013\u003e;\n    pub type U1014 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P1014 = PInt\u003cU1014\u003e; pub type N1014 = NInt\u003cU1014\u003e;\n    pub type U1015 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P1015 = PInt\u003cU1015\u003e; pub type N1015 = NInt\u003cU1015\u003e;\n    pub type U1016 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P1016 = PInt\u003cU1016\u003e; pub type N1016 = NInt\u003cU1016\u003e;\n    pub type U1017 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P1017 = PInt\u003cU1017\u003e; pub type N1017 = NInt\u003cU1017\u003e;\n    pub type U1018 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P1018 = PInt\u003cU1018\u003e; pub type N1018 = NInt\u003cU1018\u003e;\n    pub type U1019 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P1019 = PInt\u003cU1019\u003e; pub type N1019 = NInt\u003cU1019\u003e;\n    pub type U1020 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P1020 = PInt\u003cU1020\u003e; pub type N1020 = NInt\u003cU1020\u003e;\n    pub type U1021 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P1021 = PInt\u003cU1021\u003e; pub type N1021 = NInt\u003cU1021\u003e;\n    pub type U1022 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P1022 = PInt\u003cU1022\u003e; pub type N1022 = NInt\u003cU1022\u003e;\n    pub type U1023 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P1023 = PInt\u003cU1023\u003e; pub type N1023 = NInt\u003cU1023\u003e;\n    pub type U1024 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P1024 = PInt\u003cU1024\u003e; pub type N1024 = NInt\u003cU1024\u003e;\n    pub type U2048 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P2048 = PInt\u003cU2048\u003e; pub type N2048 = NInt\u003cU2048\u003e;\n    pub type U4096 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P4096 = PInt\u003cU4096\u003e; pub type N4096 = NInt\u003cU4096\u003e;\n    pub type U8192 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P8192 = PInt\u003cU8192\u003e; pub type N8192 = NInt\u003cU8192\u003e;\n    pub type U16384 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P16384 = PInt\u003cU16384\u003e; pub type N16384 = NInt\u003cU16384\u003e;\n    pub type U32768 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P32768 = PInt\u003cU32768\u003e; pub type N32768 = NInt\u003cU32768\u003e;\n    pub type U65536 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P65536 = PInt\u003cU65536\u003e; pub type N65536 = NInt\u003cU65536\u003e;\n    pub type U131072 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P131072 = PInt\u003cU131072\u003e; pub type N131072 = NInt\u003cU131072\u003e;\n    pub type U262144 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P262144 = PInt\u003cU262144\u003e; pub type N262144 = NInt\u003cU262144\u003e;\n    pub type U524288 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P524288 = PInt\u003cU524288\u003e; pub type N524288 = NInt\u003cU524288\u003e;\n    pub type U1048576 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P1048576 = PInt\u003cU1048576\u003e; pub type N1048576 = NInt\u003cU1048576\u003e;\n    pub type U2097152 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P2097152 = PInt\u003cU2097152\u003e; pub type N2097152 = NInt\u003cU2097152\u003e;\n    pub type U4194304 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P4194304 = PInt\u003cU4194304\u003e; pub type N4194304 = NInt\u003cU4194304\u003e;\n    pub type U8388608 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P8388608 = PInt\u003cU8388608\u003e; pub type N8388608 = NInt\u003cU8388608\u003e;\n    pub type U16777216 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P16777216 = PInt\u003cU16777216\u003e; pub type N16777216 = NInt\u003cU16777216\u003e;\n    pub type U33554432 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P33554432 = PInt\u003cU33554432\u003e; pub type N33554432 = NInt\u003cU33554432\u003e;\n    pub type U67108864 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P67108864 = PInt\u003cU67108864\u003e; pub type N67108864 = NInt\u003cU67108864\u003e;\n    pub type U134217728 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P134217728 = PInt\u003cU134217728\u003e; pub type N134217728 = NInt\u003cU134217728\u003e;\n    pub type U268435456 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P268435456 = PInt\u003cU268435456\u003e; pub type N268435456 = NInt\u003cU268435456\u003e;\n    pub type U536870912 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P536870912 = PInt\u003cU536870912\u003e; pub type N536870912 = NInt\u003cU536870912\u003e;\n    pub type U1073741824 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P1073741824 = PInt\u003cU1073741824\u003e; pub type N1073741824 = NInt\u003cU1073741824\u003e;\n    pub type U2147483648 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P2147483648 = PInt\u003cU2147483648\u003e; pub type N2147483648 = NInt\u003cU2147483648\u003e;\n    pub type U4294967296 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P4294967296 = PInt\u003cU4294967296\u003e; pub type N4294967296 = NInt\u003cU4294967296\u003e;\n    pub type U8589934592 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P8589934592 = PInt\u003cU8589934592\u003e; pub type N8589934592 = NInt\u003cU8589934592\u003e;\n    pub type U17179869184 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P17179869184 = PInt\u003cU17179869184\u003e; pub type N17179869184 = NInt\u003cU17179869184\u003e;\n    pub type U34359738368 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P34359738368 = PInt\u003cU34359738368\u003e; pub type N34359738368 = NInt\u003cU34359738368\u003e;\n    pub type U68719476736 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P68719476736 = PInt\u003cU68719476736\u003e; pub type N68719476736 = NInt\u003cU68719476736\u003e;\n    pub type U137438953472 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P137438953472 = PInt\u003cU137438953472\u003e; pub type N137438953472 = NInt\u003cU137438953472\u003e;\n    pub type U274877906944 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P274877906944 = PInt\u003cU274877906944\u003e; pub type N274877906944 = NInt\u003cU274877906944\u003e;\n    pub type U549755813888 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P549755813888 = PInt\u003cU549755813888\u003e; pub type N549755813888 = NInt\u003cU549755813888\u003e;\n    pub type U1099511627776 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P1099511627776 = PInt\u003cU1099511627776\u003e; pub type N1099511627776 = NInt\u003cU1099511627776\u003e;\n    pub type U2199023255552 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P2199023255552 = PInt\u003cU2199023255552\u003e; pub type N2199023255552 = NInt\u003cU2199023255552\u003e;\n    pub type U4398046511104 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P4398046511104 = PInt\u003cU4398046511104\u003e; pub type N4398046511104 = NInt\u003cU4398046511104\u003e;\n    pub type U8796093022208 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P8796093022208 = PInt\u003cU8796093022208\u003e; pub type N8796093022208 = NInt\u003cU8796093022208\u003e;\n    pub type U17592186044416 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P17592186044416 = PInt\u003cU17592186044416\u003e; pub type N17592186044416 = NInt\u003cU17592186044416\u003e;\n    pub type U35184372088832 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P35184372088832 = PInt\u003cU35184372088832\u003e; pub type N35184372088832 = NInt\u003cU35184372088832\u003e;\n    pub type U70368744177664 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P70368744177664 = PInt\u003cU70368744177664\u003e; pub type N70368744177664 = NInt\u003cU70368744177664\u003e;\n    pub type U140737488355328 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P140737488355328 = PInt\u003cU140737488355328\u003e; pub type N140737488355328 = NInt\u003cU140737488355328\u003e;\n    pub type U281474976710656 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P281474976710656 = PInt\u003cU281474976710656\u003e; pub type N281474976710656 = NInt\u003cU281474976710656\u003e;\n    pub type U562949953421312 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P562949953421312 = PInt\u003cU562949953421312\u003e; pub type N562949953421312 = NInt\u003cU562949953421312\u003e;\n    pub type U1125899906842624 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P1125899906842624 = PInt\u003cU1125899906842624\u003e; pub type N1125899906842624 = NInt\u003cU1125899906842624\u003e;\n    pub type U2251799813685248 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P2251799813685248 = PInt\u003cU2251799813685248\u003e; pub type N2251799813685248 = NInt\u003cU2251799813685248\u003e;\n    pub type U4503599627370496 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P4503599627370496 = PInt\u003cU4503599627370496\u003e; pub type N4503599627370496 = NInt\u003cU4503599627370496\u003e;\n    pub type U9007199254740992 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P9007199254740992 = PInt\u003cU9007199254740992\u003e; pub type N9007199254740992 = NInt\u003cU9007199254740992\u003e;\n    pub type U18014398509481984 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P18014398509481984 = PInt\u003cU18014398509481984\u003e; pub type N18014398509481984 = NInt\u003cU18014398509481984\u003e;\n    pub type U36028797018963968 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P36028797018963968 = PInt\u003cU36028797018963968\u003e; pub type N36028797018963968 = NInt\u003cU36028797018963968\u003e;\n    pub type U72057594037927936 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P72057594037927936 = PInt\u003cU72057594037927936\u003e; pub type N72057594037927936 = NInt\u003cU72057594037927936\u003e;\n    pub type U144115188075855872 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P144115188075855872 = PInt\u003cU144115188075855872\u003e; pub type N144115188075855872 = NInt\u003cU144115188075855872\u003e;\n    pub type U288230376151711744 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P288230376151711744 = PInt\u003cU288230376151711744\u003e; pub type N288230376151711744 = NInt\u003cU288230376151711744\u003e;\n    pub type U576460752303423488 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P576460752303423488 = PInt\u003cU576460752303423488\u003e; pub type N576460752303423488 = NInt\u003cU576460752303423488\u003e;\n    pub type U1152921504606846976 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P1152921504606846976 = PInt\u003cU1152921504606846976\u003e; pub type N1152921504606846976 = NInt\u003cU1152921504606846976\u003e;\n    pub type U2305843009213693952 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P2305843009213693952 = PInt\u003cU2305843009213693952\u003e; pub type N2305843009213693952 = NInt\u003cU2305843009213693952\u003e;\n    pub type U4611686018427387904 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P4611686018427387904 = PInt\u003cU4611686018427387904\u003e; pub type N4611686018427387904 = NInt\u003cU4611686018427387904\u003e;\n    pub type U9223372036854775808 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type U10000 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P10000 = PInt\u003cU10000\u003e; pub type N10000 = NInt\u003cU10000\u003e;\n    pub type U100000 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P100000 = PInt\u003cU100000\u003e; pub type N100000 = NInt\u003cU100000\u003e;\n    pub type U1000000 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P1000000 = PInt\u003cU1000000\u003e; pub type N1000000 = NInt\u003cU1000000\u003e;\n    pub type U10000000 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P10000000 = PInt\u003cU10000000\u003e; pub type N10000000 = NInt\u003cU10000000\u003e;\n    pub type U100000000 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P100000000 = PInt\u003cU100000000\u003e; pub type N100000000 = NInt\u003cU100000000\u003e;\n    pub type U1000000000 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P1000000000 = PInt\u003cU1000000000\u003e; pub type N1000000000 = NInt\u003cU1000000000\u003e;\n    pub type U10000000000 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P10000000000 = PInt\u003cU10000000000\u003e; pub type N10000000000 = NInt\u003cU10000000000\u003e;\n    pub type U100000000000 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P100000000000 = PInt\u003cU100000000000\u003e; pub type N100000000000 = NInt\u003cU100000000000\u003e;\n    pub type U1000000000000 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P1000000000000 = PInt\u003cU1000000000000\u003e; pub type N1000000000000 = NInt\u003cU1000000000000\u003e;\n    pub type U10000000000000 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P10000000000000 = PInt\u003cU10000000000000\u003e; pub type N10000000000000 = NInt\u003cU10000000000000\u003e;\n    pub type U100000000000000 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P100000000000000 = PInt\u003cU100000000000000\u003e; pub type N100000000000000 = NInt\u003cU100000000000000\u003e;\n    pub type U1000000000000000 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P1000000000000000 = PInt\u003cU1000000000000000\u003e; pub type N1000000000000000 = NInt\u003cU1000000000000000\u003e;\n    pub type U10000000000000000 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P10000000000000000 = PInt\u003cU10000000000000000\u003e; pub type N10000000000000000 = NInt\u003cU10000000000000000\u003e;\n    pub type U100000000000000000 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P100000000000000000 = PInt\u003cU100000000000000000\u003e; pub type N100000000000000000 = NInt\u003cU100000000000000000\u003e;\n    pub type U1000000000000000000 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P1000000000000000000 = PInt\u003cU1000000000000000000\u003e; pub type N1000000000000000000 = NInt\u003cU1000000000000000000\u003e;\n    pub type U10000000000000000000 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n}","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","fuzz","target","x86_64-unknown-linux-gnu","release","build","typenum-85e81dd0a8c9dcba","out","op.rs"],"content":"\n/**\nConvenient type operations.\n\nAny types representing values must be able to be expressed as `ident`s. That means they need to be\nin scope.\n\nFor example, `P5` is okay, but `typenum::P5` is not.\n\nYou may combine operators arbitrarily, although doing so excessively may require raising the\nrecursion limit.\n\n# Example\n```rust\n#![recursion_limit=\"128\"]\n#[macro_use] extern crate typenum;\nuse typenum::consts::*;\n\nfn main() {\n    assert_type!(\n        op!(min((P1 - P2) * (N3 + N7), P5 * (P3 + P4)) == P10)\n    );\n}\n```\nOperators are evaluated based on the operator precedence outlined\n[here](https://doc.rust-lang.org/reference.html#operator-precedence).\n\nThe full list of supported operators and functions is as follows:\n\n`*`, `/`, `%`, `+`, `-`, `\u003c\u003c`, `\u003e\u003e`, `\u0026`, `^`, `|`, `==`, `!=`, `\u003c=`, `\u003e=`, `\u003c`, `\u003e`, `cmp`, `sqr`, `sqrt`, `abs`, `cube`, `pow`, `min`, `max`, `log2`, `gcd`\n\nThey all expand to type aliases defined in the `operator_aliases` module. Here is an expanded list,\nincluding examples:\n\n---\nOperator `*`. Expands to `Prod`.\n\n```rust\n# #[macro_use] extern crate typenum;\n# use typenum::*;\n# fn main() {\nassert_type_eq!(op!(P2 * P3), P6);\n# }\n```\n\n---\nOperator `/`. Expands to `Quot`.\n\n```rust\n# #[macro_use] extern crate typenum;\n# use typenum::*;\n# fn main() {\nassert_type_eq!(op!(P6 / P2), P3);\n# }\n```\n\n---\nOperator `%`. Expands to `Mod`.\n\n```rust\n# #[macro_use] extern crate typenum;\n# use typenum::*;\n# fn main() {\nassert_type_eq!(op!(P5 % P3), P2);\n# }\n```\n\n---\nOperator `+`. Expands to `Sum`.\n\n```rust\n# #[macro_use] extern crate typenum;\n# use typenum::*;\n# fn main() {\nassert_type_eq!(op!(P2 + P3), P5);\n# }\n```\n\n---\nOperator `-`. Expands to `Diff`.\n\n```rust\n# #[macro_use] extern crate typenum;\n# use typenum::*;\n# fn main() {\nassert_type_eq!(op!(P2 - P3), N1);\n# }\n```\n\n---\nOperator `\u003c\u003c`. Expands to `Shleft`.\n\n```rust\n# #[macro_use] extern crate typenum;\n# use typenum::*;\n# fn main() {\nassert_type_eq!(op!(U1 \u003c\u003c U5), U32);\n# }\n```\n\n---\nOperator `\u003e\u003e`. Expands to `Shright`.\n\n```rust\n# #[macro_use] extern crate typenum;\n# use typenum::*;\n# fn main() {\nassert_type_eq!(op!(U32 \u003e\u003e U5), U1);\n# }\n```\n\n---\nOperator `\u0026`. Expands to `And`.\n\n```rust\n# #[macro_use] extern crate typenum;\n# use typenum::*;\n# fn main() {\nassert_type_eq!(op!(U5 \u0026 U3), U1);\n# }\n```\n\n---\nOperator `^`. Expands to `Xor`.\n\n```rust\n# #[macro_use] extern crate typenum;\n# use typenum::*;\n# fn main() {\nassert_type_eq!(op!(U5 ^ U3), U6);\n# }\n```\n\n---\nOperator `|`. Expands to `Or`.\n\n```rust\n# #[macro_use] extern crate typenum;\n# use typenum::*;\n# fn main() {\nassert_type_eq!(op!(U5 | U3), U7);\n# }\n```\n\n---\nOperator `==`. Expands to `Eq`.\n\n```rust\n# #[macro_use] extern crate typenum;\n# use typenum::*;\n# fn main() {\nassert_type_eq!(op!(P5 == P3 + P2), True);\n# }\n```\n\n---\nOperator `!=`. Expands to `NotEq`.\n\n```rust\n# #[macro_use] extern crate typenum;\n# use typenum::*;\n# fn main() {\nassert_type_eq!(op!(P5 != P3 + P2), False);\n# }\n```\n\n---\nOperator `\u003c=`. Expands to `LeEq`.\n\n```rust\n# #[macro_use] extern crate typenum;\n# use typenum::*;\n# fn main() {\nassert_type_eq!(op!(P6 \u003c= P3 + P2), False);\n# }\n```\n\n---\nOperator `\u003e=`. Expands to `GrEq`.\n\n```rust\n# #[macro_use] extern crate typenum;\n# use typenum::*;\n# fn main() {\nassert_type_eq!(op!(P6 \u003e= P3 + P2), True);\n# }\n```\n\n---\nOperator `\u003c`. Expands to `Le`.\n\n```rust\n# #[macro_use] extern crate typenum;\n# use typenum::*;\n# fn main() {\nassert_type_eq!(op!(P4 \u003c P3 + P2), True);\n# }\n```\n\n---\nOperator `\u003e`. Expands to `Gr`.\n\n```rust\n# #[macro_use] extern crate typenum;\n# use typenum::*;\n# fn main() {\nassert_type_eq!(op!(P5 \u003c P3 + P2), False);\n# }\n```\n\n---\nOperator `cmp`. Expands to `Compare`.\n\n```rust\n# #[macro_use] extern crate typenum;\n# use typenum::*;\n# fn main() {\nassert_type_eq!(op!(cmp(P2, P3)), Less);\n# }\n```\n\n---\nOperator `sqr`. Expands to `Square`.\n\n```rust\n# #[macro_use] extern crate typenum;\n# use typenum::*;\n# fn main() {\nassert_type_eq!(op!(sqr(P2)), P4);\n# }\n```\n\n---\nOperator `sqrt`. Expands to `Sqrt`.\n\n```rust\n# #[macro_use] extern crate typenum;\n# use typenum::*;\n# fn main() {\nassert_type_eq!(op!(sqrt(U9)), U3);\n# }\n```\n\n---\nOperator `abs`. Expands to `AbsVal`.\n\n```rust\n# #[macro_use] extern crate typenum;\n# use typenum::*;\n# fn main() {\nassert_type_eq!(op!(abs(N2)), P2);\n# }\n```\n\n---\nOperator `cube`. Expands to `Cube`.\n\n```rust\n# #[macro_use] extern crate typenum;\n# use typenum::*;\n# fn main() {\nassert_type_eq!(op!(cube(P2)), P8);\n# }\n```\n\n---\nOperator `pow`. Expands to `Exp`.\n\n```rust\n# #[macro_use] extern crate typenum;\n# use typenum::*;\n# fn main() {\nassert_type_eq!(op!(pow(P2, P3)), P8);\n# }\n```\n\n---\nOperator `min`. Expands to `Minimum`.\n\n```rust\n# #[macro_use] extern crate typenum;\n# use typenum::*;\n# fn main() {\nassert_type_eq!(op!(min(P2, P3)), P2);\n# }\n```\n\n---\nOperator `max`. Expands to `Maximum`.\n\n```rust\n# #[macro_use] extern crate typenum;\n# use typenum::*;\n# fn main() {\nassert_type_eq!(op!(max(P2, P3)), P3);\n# }\n```\n\n---\nOperator `log2`. Expands to `Log2`.\n\n```rust\n# #[macro_use] extern crate typenum;\n# use typenum::*;\n# fn main() {\nassert_type_eq!(op!(log2(U9)), U3);\n# }\n```\n\n---\nOperator `gcd`. Expands to `Gcf`.\n\n```rust\n# #[macro_use] extern crate typenum;\n# use typenum::*;\n# fn main() {\nassert_type_eq!(op!(gcd(U9, U21)), U3);\n# }\n```\n\n*/\n#[macro_export(local_inner_macros)]\nmacro_rules! op {\n    ($($tail:tt)*) =\u003e ( __op_internal__!($($tail)*) );\n}\n\n    #[doc(hidden)]\n    #[macro_export(local_inner_macros)]\n    macro_rules! __op_internal__ {\n\n(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: cmp $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[Compare, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)\n);\n(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: sqr $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[Square, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)\n);\n(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: sqrt $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[Sqrt, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)\n);\n(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: abs $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[AbsVal, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)\n);\n(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: cube $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[Cube, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)\n);\n(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: pow $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[Exp, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)\n);\n(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: min $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[Minimum, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)\n);\n(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: max $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[Maximum, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)\n);\n(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: log2 $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[Log2, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)\n);\n(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: gcd $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[Gcf, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)\n);\n(@stack[LParen, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: , $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[LParen, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)\n);\n(@stack[$stack_top:ident, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: , $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[$stack_top, $($queue,)*] @tail: , $($tail)*)\n);\n(@stack[Prod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: * $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Prod, $($queue,)*] @tail: * $($tail)*)\n);\n(@stack[Quot, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: * $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Quot, $($queue,)*] @tail: * $($tail)*)\n);\n(@stack[Mod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: * $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Mod, $($queue,)*] @tail: * $($tail)*)\n);\n(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: * $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[Prod, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)\n);\n(@stack[Prod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: / $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Prod, $($queue,)*] @tail: / $($tail)*)\n);\n(@stack[Quot, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: / $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Quot, $($queue,)*] @tail: / $($tail)*)\n);\n(@stack[Mod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: / $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Mod, $($queue,)*] @tail: / $($tail)*)\n);\n(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: / $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[Quot, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)\n);\n(@stack[Prod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: % $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Prod, $($queue,)*] @tail: % $($tail)*)\n);\n(@stack[Quot, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: % $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Quot, $($queue,)*] @tail: % $($tail)*)\n);\n(@stack[Mod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: % $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Mod, $($queue,)*] @tail: % $($tail)*)\n);\n(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: % $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[Mod, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)\n);\n(@stack[Prod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: + $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Prod, $($queue,)*] @tail: + $($tail)*)\n);\n(@stack[Quot, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: + $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Quot, $($queue,)*] @tail: + $($tail)*)\n);\n(@stack[Mod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: + $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Mod, $($queue,)*] @tail: + $($tail)*)\n);\n(@stack[Sum, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: + $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Sum, $($queue,)*] @tail: + $($tail)*)\n);\n(@stack[Diff, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: + $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Diff, $($queue,)*] @tail: + $($tail)*)\n);\n(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: + $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[Sum, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)\n);\n(@stack[Prod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: - $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Prod, $($queue,)*] @tail: - $($tail)*)\n);\n(@stack[Quot, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: - $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Quot, $($queue,)*] @tail: - $($tail)*)\n);\n(@stack[Mod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: - $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Mod, $($queue,)*] @tail: - $($tail)*)\n);\n(@stack[Sum, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: - $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Sum, $($queue,)*] @tail: - $($tail)*)\n);\n(@stack[Diff, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: - $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Diff, $($queue,)*] @tail: - $($tail)*)\n);\n(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: - $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[Diff, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)\n);\n(@stack[Prod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c\u003c $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Prod, $($queue,)*] @tail: \u003c\u003c $($tail)*)\n);\n(@stack[Quot, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c\u003c $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Quot, $($queue,)*] @tail: \u003c\u003c $($tail)*)\n);\n(@stack[Mod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c\u003c $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Mod, $($queue,)*] @tail: \u003c\u003c $($tail)*)\n);\n(@stack[Sum, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c\u003c $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Sum, $($queue,)*] @tail: \u003c\u003c $($tail)*)\n);\n(@stack[Diff, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c\u003c $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Diff, $($queue,)*] @tail: \u003c\u003c $($tail)*)\n);\n(@stack[Shleft, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c\u003c $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Shleft, $($queue,)*] @tail: \u003c\u003c $($tail)*)\n);\n(@stack[Shright, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c\u003c $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Shright, $($queue,)*] @tail: \u003c\u003c $($tail)*)\n);\n(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c\u003c $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[Shleft, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)\n);\n(@stack[Prod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e\u003e $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Prod, $($queue,)*] @tail: \u003e\u003e $($tail)*)\n);\n(@stack[Quot, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e\u003e $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Quot, $($queue,)*] @tail: \u003e\u003e $($tail)*)\n);\n(@stack[Mod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e\u003e $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Mod, $($queue,)*] @tail: \u003e\u003e $($tail)*)\n);\n(@stack[Sum, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e\u003e $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Sum, $($queue,)*] @tail: \u003e\u003e $($tail)*)\n);\n(@stack[Diff, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e\u003e $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Diff, $($queue,)*] @tail: \u003e\u003e $($tail)*)\n);\n(@stack[Shleft, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e\u003e $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Shleft, $($queue,)*] @tail: \u003e\u003e $($tail)*)\n);\n(@stack[Shright, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e\u003e $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Shright, $($queue,)*] @tail: \u003e\u003e $($tail)*)\n);\n(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e\u003e $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[Shright, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)\n);\n(@stack[Prod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u0026 $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Prod, $($queue,)*] @tail: \u0026 $($tail)*)\n);\n(@stack[Quot, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u0026 $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Quot, $($queue,)*] @tail: \u0026 $($tail)*)\n);\n(@stack[Mod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u0026 $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Mod, $($queue,)*] @tail: \u0026 $($tail)*)\n);\n(@stack[Sum, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u0026 $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Sum, $($queue,)*] @tail: \u0026 $($tail)*)\n);\n(@stack[Diff, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u0026 $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Diff, $($queue,)*] @tail: \u0026 $($tail)*)\n);\n(@stack[Shleft, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u0026 $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Shleft, $($queue,)*] @tail: \u0026 $($tail)*)\n);\n(@stack[Shright, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u0026 $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Shright, $($queue,)*] @tail: \u0026 $($tail)*)\n);\n(@stack[And, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u0026 $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[And, $($queue,)*] @tail: \u0026 $($tail)*)\n);\n(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u0026 $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[And, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)\n);\n(@stack[Prod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: ^ $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Prod, $($queue,)*] @tail: ^ $($tail)*)\n);\n(@stack[Quot, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: ^ $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Quot, $($queue,)*] @tail: ^ $($tail)*)\n);\n(@stack[Mod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: ^ $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Mod, $($queue,)*] @tail: ^ $($tail)*)\n);\n(@stack[Sum, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: ^ $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Sum, $($queue,)*] @tail: ^ $($tail)*)\n);\n(@stack[Diff, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: ^ $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Diff, $($queue,)*] @tail: ^ $($tail)*)\n);\n(@stack[Shleft, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: ^ $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Shleft, $($queue,)*] @tail: ^ $($tail)*)\n);\n(@stack[Shright, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: ^ $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Shright, $($queue,)*] @tail: ^ $($tail)*)\n);\n(@stack[And, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: ^ $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[And, $($queue,)*] @tail: ^ $($tail)*)\n);\n(@stack[Xor, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: ^ $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Xor, $($queue,)*] @tail: ^ $($tail)*)\n);\n(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: ^ $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[Xor, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)\n);\n(@stack[Prod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: | $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Prod, $($queue,)*] @tail: | $($tail)*)\n);\n(@stack[Quot, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: | $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Quot, $($queue,)*] @tail: | $($tail)*)\n);\n(@stack[Mod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: | $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Mod, $($queue,)*] @tail: | $($tail)*)\n);\n(@stack[Sum, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: | $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Sum, $($queue,)*] @tail: | $($tail)*)\n);\n(@stack[Diff, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: | $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Diff, $($queue,)*] @tail: | $($tail)*)\n);\n(@stack[Shleft, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: | $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Shleft, $($queue,)*] @tail: | $($tail)*)\n);\n(@stack[Shright, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: | $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Shright, $($queue,)*] @tail: | $($tail)*)\n);\n(@stack[And, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: | $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[And, $($queue,)*] @tail: | $($tail)*)\n);\n(@stack[Xor, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: | $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Xor, $($queue,)*] @tail: | $($tail)*)\n);\n(@stack[Or, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: | $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Or, $($queue,)*] @tail: | $($tail)*)\n);\n(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: | $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[Or, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)\n);\n(@stack[Prod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: == $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Prod, $($queue,)*] @tail: == $($tail)*)\n);\n(@stack[Quot, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: == $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Quot, $($queue,)*] @tail: == $($tail)*)\n);\n(@stack[Mod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: == $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Mod, $($queue,)*] @tail: == $($tail)*)\n);\n(@stack[Sum, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: == $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Sum, $($queue,)*] @tail: == $($tail)*)\n);\n(@stack[Diff, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: == $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Diff, $($queue,)*] @tail: == $($tail)*)\n);\n(@stack[Shleft, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: == $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Shleft, $($queue,)*] @tail: == $($tail)*)\n);\n(@stack[Shright, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: == $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Shright, $($queue,)*] @tail: == $($tail)*)\n);\n(@stack[And, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: == $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[And, $($queue,)*] @tail: == $($tail)*)\n);\n(@stack[Xor, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: == $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Xor, $($queue,)*] @tail: == $($tail)*)\n);\n(@stack[Or, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: == $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Or, $($queue,)*] @tail: == $($tail)*)\n);\n(@stack[Eq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: == $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Eq, $($queue,)*] @tail: == $($tail)*)\n);\n(@stack[NotEq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: == $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[NotEq, $($queue,)*] @tail: == $($tail)*)\n);\n(@stack[LeEq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: == $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[LeEq, $($queue,)*] @tail: == $($tail)*)\n);\n(@stack[GrEq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: == $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[GrEq, $($queue,)*] @tail: == $($tail)*)\n);\n(@stack[Le, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: == $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Le, $($queue,)*] @tail: == $($tail)*)\n);\n(@stack[Gr, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: == $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Gr, $($queue,)*] @tail: == $($tail)*)\n);\n(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: == $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[Eq, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)\n);\n(@stack[Prod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: != $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Prod, $($queue,)*] @tail: != $($tail)*)\n);\n(@stack[Quot, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: != $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Quot, $($queue,)*] @tail: != $($tail)*)\n);\n(@stack[Mod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: != $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Mod, $($queue,)*] @tail: != $($tail)*)\n);\n(@stack[Sum, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: != $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Sum, $($queue,)*] @tail: != $($tail)*)\n);\n(@stack[Diff, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: != $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Diff, $($queue,)*] @tail: != $($tail)*)\n);\n(@stack[Shleft, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: != $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Shleft, $($queue,)*] @tail: != $($tail)*)\n);\n(@stack[Shright, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: != $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Shright, $($queue,)*] @tail: != $($tail)*)\n);\n(@stack[And, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: != $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[And, $($queue,)*] @tail: != $($tail)*)\n);\n(@stack[Xor, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: != $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Xor, $($queue,)*] @tail: != $($tail)*)\n);\n(@stack[Or, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: != $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Or, $($queue,)*] @tail: != $($tail)*)\n);\n(@stack[Eq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: != $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Eq, $($queue,)*] @tail: != $($tail)*)\n);\n(@stack[NotEq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: != $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[NotEq, $($queue,)*] @tail: != $($tail)*)\n);\n(@stack[LeEq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: != $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[LeEq, $($queue,)*] @tail: != $($tail)*)\n);\n(@stack[GrEq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: != $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[GrEq, $($queue,)*] @tail: != $($tail)*)\n);\n(@stack[Le, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: != $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Le, $($queue,)*] @tail: != $($tail)*)\n);\n(@stack[Gr, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: != $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Gr, $($queue,)*] @tail: != $($tail)*)\n);\n(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: != $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[NotEq, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)\n);\n(@stack[Prod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Prod, $($queue,)*] @tail: \u003c= $($tail)*)\n);\n(@stack[Quot, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Quot, $($queue,)*] @tail: \u003c= $($tail)*)\n);\n(@stack[Mod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Mod, $($queue,)*] @tail: \u003c= $($tail)*)\n);\n(@stack[Sum, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Sum, $($queue,)*] @tail: \u003c= $($tail)*)\n);\n(@stack[Diff, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Diff, $($queue,)*] @tail: \u003c= $($tail)*)\n);\n(@stack[Shleft, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Shleft, $($queue,)*] @tail: \u003c= $($tail)*)\n);\n(@stack[Shright, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Shright, $($queue,)*] @tail: \u003c= $($tail)*)\n);\n(@stack[And, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[And, $($queue,)*] @tail: \u003c= $($tail)*)\n);\n(@stack[Xor, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Xor, $($queue,)*] @tail: \u003c= $($tail)*)\n);\n(@stack[Or, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Or, $($queue,)*] @tail: \u003c= $($tail)*)\n);\n(@stack[Eq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Eq, $($queue,)*] @tail: \u003c= $($tail)*)\n);\n(@stack[NotEq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[NotEq, $($queue,)*] @tail: \u003c= $($tail)*)\n);\n(@stack[LeEq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[LeEq, $($queue,)*] @tail: \u003c= $($tail)*)\n);\n(@stack[GrEq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[GrEq, $($queue,)*] @tail: \u003c= $($tail)*)\n);\n(@stack[Le, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Le, $($queue,)*] @tail: \u003c= $($tail)*)\n);\n(@stack[Gr, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Gr, $($queue,)*] @tail: \u003c= $($tail)*)\n);\n(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[LeEq, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)\n);\n(@stack[Prod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Prod, $($queue,)*] @tail: \u003e= $($tail)*)\n);\n(@stack[Quot, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Quot, $($queue,)*] @tail: \u003e= $($tail)*)\n);\n(@stack[Mod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Mod, $($queue,)*] @tail: \u003e= $($tail)*)\n);\n(@stack[Sum, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Sum, $($queue,)*] @tail: \u003e= $($tail)*)\n);\n(@stack[Diff, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Diff, $($queue,)*] @tail: \u003e= $($tail)*)\n);\n(@stack[Shleft, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Shleft, $($queue,)*] @tail: \u003e= $($tail)*)\n);\n(@stack[Shright, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Shright, $($queue,)*] @tail: \u003e= $($tail)*)\n);\n(@stack[And, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[And, $($queue,)*] @tail: \u003e= $($tail)*)\n);\n(@stack[Xor, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Xor, $($queue,)*] @tail: \u003e= $($tail)*)\n);\n(@stack[Or, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Or, $($queue,)*] @tail: \u003e= $($tail)*)\n);\n(@stack[Eq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Eq, $($queue,)*] @tail: \u003e= $($tail)*)\n);\n(@stack[NotEq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[NotEq, $($queue,)*] @tail: \u003e= $($tail)*)\n);\n(@stack[LeEq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[LeEq, $($queue,)*] @tail: \u003e= $($tail)*)\n);\n(@stack[GrEq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[GrEq, $($queue,)*] @tail: \u003e= $($tail)*)\n);\n(@stack[Le, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Le, $($queue,)*] @tail: \u003e= $($tail)*)\n);\n(@stack[Gr, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Gr, $($queue,)*] @tail: \u003e= $($tail)*)\n);\n(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[GrEq, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)\n);\n(@stack[Prod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Prod, $($queue,)*] @tail: \u003c $($tail)*)\n);\n(@stack[Quot, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Quot, $($queue,)*] @tail: \u003c $($tail)*)\n);\n(@stack[Mod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Mod, $($queue,)*] @tail: \u003c $($tail)*)\n);\n(@stack[Sum, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Sum, $($queue,)*] @tail: \u003c $($tail)*)\n);\n(@stack[Diff, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Diff, $($queue,)*] @tail: \u003c $($tail)*)\n);\n(@stack[Shleft, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Shleft, $($queue,)*] @tail: \u003c $($tail)*)\n);\n(@stack[Shright, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Shright, $($queue,)*] @tail: \u003c $($tail)*)\n);\n(@stack[And, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[And, $($queue,)*] @tail: \u003c $($tail)*)\n);\n(@stack[Xor, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Xor, $($queue,)*] @tail: \u003c $($tail)*)\n);\n(@stack[Or, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Or, $($queue,)*] @tail: \u003c $($tail)*)\n);\n(@stack[Eq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Eq, $($queue,)*] @tail: \u003c $($tail)*)\n);\n(@stack[NotEq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[NotEq, $($queue,)*] @tail: \u003c $($tail)*)\n);\n(@stack[LeEq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[LeEq, $($queue,)*] @tail: \u003c $($tail)*)\n);\n(@stack[GrEq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[GrEq, $($queue,)*] @tail: \u003c $($tail)*)\n);\n(@stack[Le, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Le, $($queue,)*] @tail: \u003c $($tail)*)\n);\n(@stack[Gr, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Gr, $($queue,)*] @tail: \u003c $($tail)*)\n);\n(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[Le, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)\n);\n(@stack[Prod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Prod, $($queue,)*] @tail: \u003e $($tail)*)\n);\n(@stack[Quot, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Quot, $($queue,)*] @tail: \u003e $($tail)*)\n);\n(@stack[Mod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Mod, $($queue,)*] @tail: \u003e $($tail)*)\n);\n(@stack[Sum, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Sum, $($queue,)*] @tail: \u003e $($tail)*)\n);\n(@stack[Diff, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Diff, $($queue,)*] @tail: \u003e $($tail)*)\n);\n(@stack[Shleft, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Shleft, $($queue,)*] @tail: \u003e $($tail)*)\n);\n(@stack[Shright, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Shright, $($queue,)*] @tail: \u003e $($tail)*)\n);\n(@stack[And, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[And, $($queue,)*] @tail: \u003e $($tail)*)\n);\n(@stack[Xor, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Xor, $($queue,)*] @tail: \u003e $($tail)*)\n);\n(@stack[Or, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Or, $($queue,)*] @tail: \u003e $($tail)*)\n);\n(@stack[Eq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Eq, $($queue,)*] @tail: \u003e $($tail)*)\n);\n(@stack[NotEq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[NotEq, $($queue,)*] @tail: \u003e $($tail)*)\n);\n(@stack[LeEq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[LeEq, $($queue,)*] @tail: \u003e $($tail)*)\n);\n(@stack[GrEq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[GrEq, $($queue,)*] @tail: \u003e $($tail)*)\n);\n(@stack[Le, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Le, $($queue,)*] @tail: \u003e $($tail)*)\n);\n(@stack[Gr, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Gr, $($queue,)*] @tail: \u003e $($tail)*)\n);\n(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[Gr, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)\n);\n(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: ( $($stuff:tt)* ) $($tail:tt)* )\n =\u003e (\n    __op_internal__!(@stack[LParen, $($stack,)*] @queue[$($queue,)*]\n                     @tail: $($stuff)* RParen $($tail)*)\n);\n(@stack[LParen, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: RParen $($tail:tt)*) =\u003e (\n    __op_internal__!(@rp3 @stack[$($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)\n);\n(@stack[$stack_top:ident, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: RParen $($tail:tt)*)\n =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[$stack_top, $($queue,)*] @tail: RParen $($tail)*)\n);\n(@rp3 @stack[Compare, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Compare, $($queue,)*] @tail: $($tail)*)\n);\n(@rp3 @stack[Square, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Square, $($queue,)*] @tail: $($tail)*)\n);\n(@rp3 @stack[Sqrt, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Sqrt, $($queue,)*] @tail: $($tail)*)\n);\n(@rp3 @stack[AbsVal, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[AbsVal, $($queue,)*] @tail: $($tail)*)\n);\n(@rp3 @stack[Cube, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Cube, $($queue,)*] @tail: $($tail)*)\n);\n(@rp3 @stack[Exp, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Exp, $($queue,)*] @tail: $($tail)*)\n);\n(@rp3 @stack[Minimum, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Minimum, $($queue,)*] @tail: $($tail)*)\n);\n(@rp3 @stack[Maximum, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Maximum, $($queue,)*] @tail: $($tail)*)\n);\n(@rp3 @stack[Log2, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Log2, $($queue,)*] @tail: $($tail)*)\n);\n(@rp3 @stack[Gcf, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Gcf, $($queue,)*] @tail: $($tail)*)\n);\n(@rp3 @stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)\n);\n(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: $num:ident $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[$num, $($queue,)*] @tail: $($tail)*)\n);\n(@stack[] @queue[$($queue:ident,)*] @tail: ) =\u003e (\n    __op_internal__!(@reverse[] @input: $($queue,)*)\n);\n(@stack[$stack_top:ident, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail:) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[$stack_top, $($queue,)*] @tail: )\n);\n(@reverse[$($revved:ident,)*] @input: $head:ident, $($tail:ident,)* ) =\u003e (\n    __op_internal__!(@reverse[$head, $($revved,)*] @input: $($tail,)*)\n);\n(@reverse[$($revved:ident,)*] @input: ) =\u003e (\n    __op_internal__!(@eval @stack[] @input[$($revved,)*])\n);\n(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[Prod, $($tail:ident,)*]) =\u003e (\n    __op_internal__!(@eval @stack[$crate::Prod\u003c$b, $a\u003e, $($stack,)*] @input[$($tail,)*])\n);\n(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[Quot, $($tail:ident,)*]) =\u003e (\n    __op_internal__!(@eval @stack[$crate::Quot\u003c$b, $a\u003e, $($stack,)*] @input[$($tail,)*])\n);\n(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[Mod, $($tail:ident,)*]) =\u003e (\n    __op_internal__!(@eval @stack[$crate::Mod\u003c$b, $a\u003e, $($stack,)*] @input[$($tail,)*])\n);\n(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[Sum, $($tail:ident,)*]) =\u003e (\n    __op_internal__!(@eval @stack[$crate::Sum\u003c$b, $a\u003e, $($stack,)*] @input[$($tail,)*])\n);\n(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[Diff, $($tail:ident,)*]) =\u003e (\n    __op_internal__!(@eval @stack[$crate::Diff\u003c$b, $a\u003e, $($stack,)*] @input[$($tail,)*])\n);\n(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[Shleft, $($tail:ident,)*]) =\u003e (\n    __op_internal__!(@eval @stack[$crate::Shleft\u003c$b, $a\u003e, $($stack,)*] @input[$($tail,)*])\n);\n(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[Shright, $($tail:ident,)*]) =\u003e (\n    __op_internal__!(@eval @stack[$crate::Shright\u003c$b, $a\u003e, $($stack,)*] @input[$($tail,)*])\n);\n(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[And, $($tail:ident,)*]) =\u003e (\n    __op_internal__!(@eval @stack[$crate::And\u003c$b, $a\u003e, $($stack,)*] @input[$($tail,)*])\n);\n(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[Xor, $($tail:ident,)*]) =\u003e (\n    __op_internal__!(@eval @stack[$crate::Xor\u003c$b, $a\u003e, $($stack,)*] @input[$($tail,)*])\n);\n(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[Or, $($tail:ident,)*]) =\u003e (\n    __op_internal__!(@eval @stack[$crate::Or\u003c$b, $a\u003e, $($stack,)*] @input[$($tail,)*])\n);\n(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[Eq, $($tail:ident,)*]) =\u003e (\n    __op_internal__!(@eval @stack[$crate::Eq\u003c$b, $a\u003e, $($stack,)*] @input[$($tail,)*])\n);\n(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[NotEq, $($tail:ident,)*]) =\u003e (\n    __op_internal__!(@eval @stack[$crate::NotEq\u003c$b, $a\u003e, $($stack,)*] @input[$($tail,)*])\n);\n(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[LeEq, $($tail:ident,)*]) =\u003e (\n    __op_internal__!(@eval @stack[$crate::LeEq\u003c$b, $a\u003e, $($stack,)*] @input[$($tail,)*])\n);\n(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[GrEq, $($tail:ident,)*]) =\u003e (\n    __op_internal__!(@eval @stack[$crate::GrEq\u003c$b, $a\u003e, $($stack,)*] @input[$($tail,)*])\n);\n(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[Le, $($tail:ident,)*]) =\u003e (\n    __op_internal__!(@eval @stack[$crate::Le\u003c$b, $a\u003e, $($stack,)*] @input[$($tail,)*])\n);\n(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[Gr, $($tail:ident,)*]) =\u003e (\n    __op_internal__!(@eval @stack[$crate::Gr\u003c$b, $a\u003e, $($stack,)*] @input[$($tail,)*])\n);\n(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[Compare, $($tail:ident,)*]) =\u003e (\n    __op_internal__!(@eval @stack[$crate::Compare\u003c$b, $a\u003e, $($stack,)*] @input[$($tail,)*])\n);\n(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[Exp, $($tail:ident,)*]) =\u003e (\n    __op_internal__!(@eval @stack[$crate::Exp\u003c$b, $a\u003e, $($stack,)*] @input[$($tail,)*])\n);\n(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[Minimum, $($tail:ident,)*]) =\u003e (\n    __op_internal__!(@eval @stack[$crate::Minimum\u003c$b, $a\u003e, $($stack,)*] @input[$($tail,)*])\n);\n(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[Maximum, $($tail:ident,)*]) =\u003e (\n    __op_internal__!(@eval @stack[$crate::Maximum\u003c$b, $a\u003e, $($stack,)*] @input[$($tail,)*])\n);\n(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[Gcf, $($tail:ident,)*]) =\u003e (\n    __op_internal__!(@eval @stack[$crate::Gcf\u003c$b, $a\u003e, $($stack,)*] @input[$($tail,)*])\n);\n(@eval @stack[$a:ty, $($stack:ty,)*] @input[Square, $($tail:ident,)*]) =\u003e (\n    __op_internal__!(@eval @stack[$crate::Square\u003c$a\u003e, $($stack,)*] @input[$($tail,)*])\n);\n(@eval @stack[$a:ty, $($stack:ty,)*] @input[Sqrt, $($tail:ident,)*]) =\u003e (\n    __op_internal__!(@eval @stack[$crate::Sqrt\u003c$a\u003e, $($stack,)*] @input[$($tail,)*])\n);\n(@eval @stack[$a:ty, $($stack:ty,)*] @input[AbsVal, $($tail:ident,)*]) =\u003e (\n    __op_internal__!(@eval @stack[$crate::AbsVal\u003c$a\u003e, $($stack,)*] @input[$($tail,)*])\n);\n(@eval @stack[$a:ty, $($stack:ty,)*] @input[Cube, $($tail:ident,)*]) =\u003e (\n    __op_internal__!(@eval @stack[$crate::Cube\u003c$a\u003e, $($stack,)*] @input[$($tail,)*])\n);\n(@eval @stack[$a:ty, $($stack:ty,)*] @input[Log2, $($tail:ident,)*]) =\u003e (\n    __op_internal__!(@eval @stack[$crate::Log2\u003c$a\u003e, $($stack,)*] @input[$($tail,)*])\n);\n(@eval @stack[$($stack:ty,)*] @input[$head:ident, $($tail:ident,)*]) =\u003e (\n    __op_internal__!(@eval @stack[$head, $($stack,)*] @input[$($tail,)*])\n);\n(@eval @stack[$stack:ty,] @input[]) =\u003e (\n    $stack\n);\n($($tail:tt)* ) =\u003e (\n    __op_internal__!(@stack[] @queue[] @tail: $($tail)*)\n);\n}","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","fuzz","target","x86_64-unknown-linux-gnu","release","build","typenum-85e81dd0a8c9dcba","out","tests.rs"],"content":"\nextern crate typenum;\n\nuse std::ops::*;\nuse std::cmp::Ordering;\nuse typenum::*;\n\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitAnd_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0BitAndU0 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitAndU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitOr_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0BitOrU0 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitOrU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitXor_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0BitXorU0 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitXorU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shl_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShlU0 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0ShlU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shr_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShrU0 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0ShrU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Add_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0AddU0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0AddU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Min_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MinU0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MinU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Max_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MaxU0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MaxU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Gcd_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0GcdU0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0GcdU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Sub_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0SubU0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0SubU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Mul_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MulU0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MulU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Pow_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0PowU0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0PowU0 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Cmp_0() {\n    type A = UTerm;\n    type B = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0CmpU0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU0CmpU0 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitAnd_1() {\n    type A = UTerm;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0BitAndU1 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitAndU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitOr_1() {\n    type A = UTerm;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0BitOrU1 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitOrU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitXor_1() {\n    type A = UTerm;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0BitXorU1 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitXorU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shl_1() {\n    type A = UTerm;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShlU1 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0ShlU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shr_1() {\n    type A = UTerm;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShrU1 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0ShrU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Add_1() {\n    type A = UTerm;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0AddU1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0AddU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Min_1() {\n    type A = UTerm;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MinU1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MinU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Max_1() {\n    type A = UTerm;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0MaxU1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MaxU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Gcd_1() {\n    type A = UTerm;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0GcdU1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0GcdU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Mul_1() {\n    type A = UTerm;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MulU1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MulU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Div_1() {\n    type A = UTerm;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0DivU1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0DivU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Rem_1() {\n    type A = UTerm;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0RemU1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0RemU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_PartialDiv_1() {\n    type A = UTerm;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0PartialDivU1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0PartialDivU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Pow_1() {\n    type A = UTerm;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0PowU1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0PowU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Cmp_1() {\n    type A = UTerm;\n    type B = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0CmpU1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU0CmpU1 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitAnd_2() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0BitAndU2 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitAndU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitOr_2() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0BitOrU2 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitOrU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitXor_2() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0BitXorU2 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitXorU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shl_2() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShlU2 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0ShlU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shr_2() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShrU2 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0ShrU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Add_2() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0AddU2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0AddU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Min_2() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MinU2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MinU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Max_2() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0MaxU2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MaxU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Gcd_2() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0GcdU2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0GcdU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Mul_2() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MulU2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MulU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Div_2() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0DivU2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0DivU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Rem_2() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0RemU2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0RemU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_PartialDiv_2() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0PartialDivU2 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0PartialDivU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Pow_2() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0PowU2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0PowU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Cmp_2() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0CmpU2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU0CmpU2 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitAnd_3() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0BitAndU3 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitAndU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitOr_3() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0BitOrU3 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitOrU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitXor_3() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0BitXorU3 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitXorU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shl_3() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShlU3 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0ShlU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shr_3() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShrU3 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0ShrU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Add_3() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0AddU3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0AddU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Min_3() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MinU3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MinU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Max_3() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0MaxU3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MaxU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Gcd_3() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0GcdU3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0GcdU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Mul_3() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MulU3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MulU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Div_3() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0DivU3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0DivU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Rem_3() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0RemU3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0RemU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_PartialDiv_3() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0PartialDivU3 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0PartialDivU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Pow_3() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0PowU3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0PowU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Cmp_3() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0CmpU3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU0CmpU3 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitAnd_4() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0BitAndU4 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitAndU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitOr_4() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0BitOrU4 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitOrU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitXor_4() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0BitXorU4 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitXorU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shl_4() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShlU4 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0ShlU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shr_4() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShrU4 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0ShrU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Add_4() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0AddU4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0AddU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Min_4() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MinU4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MinU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Max_4() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0MaxU4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MaxU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Gcd_4() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0GcdU4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0GcdU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Mul_4() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MulU4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MulU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Div_4() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0DivU4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0DivU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Rem_4() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0RemU4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0RemU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_PartialDiv_4() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0PartialDivU4 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0PartialDivU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Pow_4() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0PowU4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0PowU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Cmp_4() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0CmpU4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU0CmpU4 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitAnd_5() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0BitAndU5 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitAndU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitOr_5() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0BitOrU5 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitOrU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitXor_5() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0BitXorU5 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitXorU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shl_5() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShlU5 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0ShlU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shr_5() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShrU5 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0ShrU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Add_5() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0AddU5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0AddU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Min_5() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MinU5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MinU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Max_5() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0MaxU5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MaxU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Gcd_5() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0GcdU5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0GcdU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Mul_5() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MulU5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MulU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Div_5() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0DivU5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0DivU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Rem_5() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0RemU5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0RemU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_PartialDiv_5() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0PartialDivU5 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0PartialDivU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Pow_5() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0PowU5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0PowU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Cmp_5() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0CmpU5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU0CmpU5 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitAnd_0() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1BitAndU0 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitAndU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitOr_0() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UTerm;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1BitOrU0 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitOrU0 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitXor_0() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UTerm;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1BitXorU0 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitXorU0 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shl_0() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UTerm;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1ShlU0 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1ShlU0 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shr_0() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UTerm;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1ShrU0 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1ShrU0 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Add_0() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UTerm;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1AddU0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1AddU0 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Min_0() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1MinU0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MinU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Max_0() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UTerm;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MaxU0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MaxU0 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Gcd_0() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UTerm;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1GcdU0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1GcdU0 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Sub_0() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UTerm;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1SubU0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1SubU0 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Mul_0() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1MulU0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MulU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Pow_0() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UTerm;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1PowU0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1PowU0 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Cmp_0() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1CmpU0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU1CmpU0 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitAnd_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1BitAndU1 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitAndU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitOr_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1BitOrU1 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitOrU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitXor_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1BitXorU1 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitXorU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shl_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1ShlU1 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1ShlU1 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shr_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1ShrU1 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1ShrU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Add_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1AddU1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1AddU1 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Min_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MinU1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MinU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Max_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MaxU1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MaxU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Gcd_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1GcdU1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1GcdU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Sub_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1SubU1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1SubU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Mul_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MulU1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MulU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Div_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1DivU1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1DivU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Rem_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1RemU1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1RemU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_PartialDiv_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1PartialDivU1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1PartialDivU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Pow_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1PowU1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1PowU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Cmp_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1CmpU1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU1CmpU1 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitAnd_2() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1BitAndU2 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitAndU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitOr_2() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1BitOrU2 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitOrU2 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitXor_2() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1BitXorU2 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitXorU2 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shl_2() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1ShlU2 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1ShlU2 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shr_2() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1ShrU2 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1ShrU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Add_2() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1AddU2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1AddU2 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Min_2() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MinU2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MinU2 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Max_2() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MaxU2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MaxU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Gcd_2() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1GcdU2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1GcdU2 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Mul_2() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MulU2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MulU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Div_2() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1DivU2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1DivU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Rem_2() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1RemU2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1RemU2 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Pow_2() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1PowU2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1PowU2 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Cmp_2() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1CmpU2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU1CmpU2 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitAnd_3() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1BitAndU3 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitAndU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitOr_3() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1BitOrU3 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitOrU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitXor_3() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1BitXorU3 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitXorU3 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shl_3() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U8 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1ShlU3 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU8\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1ShlU3 as Unsigned\u003e::to_u64(), \u003cU8 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shr_3() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1ShrU3 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1ShrU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Add_3() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1AddU3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1AddU3 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Min_3() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MinU3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MinU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Max_3() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MaxU3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MaxU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Gcd_3() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1GcdU3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1GcdU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Mul_3() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MulU3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MulU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Div_3() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1DivU3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1DivU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Rem_3() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1RemU3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1RemU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Pow_3() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1PowU3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1PowU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Cmp_3() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1CmpU3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU1CmpU3 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitAnd_4() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1BitAndU4 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitAndU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitOr_4() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1BitOrU4 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitOrU4 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitXor_4() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1BitXorU4 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitXorU4 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shl_4() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U16 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1ShlU4 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU16\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1ShlU4 as Unsigned\u003e::to_u64(), \u003cU16 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shr_4() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1ShrU4 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1ShrU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Add_4() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1AddU4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1AddU4 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Min_4() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MinU4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MinU4 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Max_4() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MaxU4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MaxU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Gcd_4() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1GcdU4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1GcdU4 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Mul_4() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MulU4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MulU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Div_4() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1DivU4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1DivU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Rem_4() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1RemU4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1RemU4 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Pow_4() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1PowU4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1PowU4 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Cmp_4() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1CmpU4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU1CmpU4 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitAnd_5() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1BitAndU5 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitAndU5 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitOr_5() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1BitOrU5 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitOrU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitXor_5() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1BitXorU5 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitXorU5 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shl_5() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U32 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1ShlU5 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU32\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1ShlU5 as Unsigned\u003e::to_u64(), \u003cU32 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shr_5() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1ShrU5 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1ShrU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Add_5() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U6 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1AddU5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU6\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1AddU5 as Unsigned\u003e::to_u64(), \u003cU6 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Min_5() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MinU5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MinU5 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Max_5() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MaxU5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MaxU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Gcd_5() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1GcdU5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1GcdU5 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Mul_5() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MulU5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MulU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Div_5() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1DivU5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1DivU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Rem_5() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1RemU5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1RemU5 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Pow_5() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1PowU5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1PowU5 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Cmp_5() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1CmpU5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU1CmpU5 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitAnd_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2BitAndU0 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitAndU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitOr_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UTerm;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2BitOrU0 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitOrU0 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitXor_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UTerm;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2BitXorU0 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitXorU0 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shl_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UTerm;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2ShlU0 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2ShlU0 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shr_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UTerm;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2ShrU0 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2ShrU0 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Add_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UTerm;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2AddU0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2AddU0 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Min_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2MinU0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MinU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Max_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UTerm;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MaxU0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MaxU0 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Gcd_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UTerm;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2GcdU0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2GcdU0 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Sub_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UTerm;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2SubU0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2SubU0 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Mul_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2MulU0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MulU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Pow_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UTerm;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2PowU0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2PowU0 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Cmp_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2CmpU0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU2CmpU0 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitAnd_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2BitAndU1 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitAndU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitOr_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2BitOrU1 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitOrU1 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitXor_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2BitXorU1 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitXorU1 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shl_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2ShlU1 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2ShlU1 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shr_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2ShrU1 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2ShrU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Add_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2AddU1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2AddU1 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Min_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MinU1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MinU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Max_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MaxU1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MaxU1 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Gcd_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2GcdU1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2GcdU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Sub_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2SubU1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2SubU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Mul_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MulU1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MulU1 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Div_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2DivU1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2DivU1 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Rem_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2RemU1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2RemU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_PartialDiv_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2PartialDivU1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2PartialDivU1 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Pow_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2PowU1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2PowU1 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Cmp_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2CmpU1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU2CmpU1 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitAnd_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2BitAndU2 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitAndU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitOr_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2BitOrU2 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitOrU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitXor_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2BitXorU2 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitXorU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shl_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U8 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2ShlU2 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU8\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2ShlU2 as Unsigned\u003e::to_u64(), \u003cU8 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shr_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2ShrU2 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2ShrU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Add_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2AddU2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2AddU2 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Min_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MinU2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MinU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Max_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MaxU2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MaxU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Gcd_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2GcdU2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2GcdU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Sub_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2SubU2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2SubU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Mul_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MulU2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MulU2 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Div_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2DivU2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2DivU2 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Rem_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2RemU2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2RemU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_PartialDiv_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2PartialDivU2 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2PartialDivU2 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Pow_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2PowU2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2PowU2 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Cmp_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2CmpU2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU2CmpU2 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitAnd_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2BitAndU3 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitAndU3 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitOr_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2BitOrU3 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitOrU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitXor_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2BitXorU3 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitXorU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shl_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U16 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2ShlU3 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU16\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2ShlU3 as Unsigned\u003e::to_u64(), \u003cU16 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shr_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2ShrU3 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2ShrU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Add_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2AddU3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2AddU3 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Min_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MinU3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MinU3 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Max_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MaxU3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MaxU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Gcd_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2GcdU3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2GcdU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Mul_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U6 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MulU3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU6\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MulU3 as Unsigned\u003e::to_u64(), \u003cU6 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Div_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2DivU3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2DivU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Rem_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2RemU3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2RemU3 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Pow_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U8 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2PowU3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU8\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2PowU3 as Unsigned\u003e::to_u64(), \u003cU8 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Cmp_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2CmpU3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU2CmpU3 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitAnd_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2BitAndU4 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitAndU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitOr_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U6 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2BitOrU4 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU6\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitOrU4 as Unsigned\u003e::to_u64(), \u003cU6 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitXor_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U6 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2BitXorU4 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU6\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitXorU4 as Unsigned\u003e::to_u64(), \u003cU6 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shl_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U32 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2ShlU4 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU32\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2ShlU4 as Unsigned\u003e::to_u64(), \u003cU32 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shr_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2ShrU4 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2ShrU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Add_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U6 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2AddU4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU6\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2AddU4 as Unsigned\u003e::to_u64(), \u003cU6 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Min_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MinU4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MinU4 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Max_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MaxU4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MaxU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Gcd_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2GcdU4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2GcdU4 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Mul_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U8 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MulU4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU8\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MulU4 as Unsigned\u003e::to_u64(), \u003cU8 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Div_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2DivU4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2DivU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Rem_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2RemU4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2RemU4 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Pow_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U16 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2PowU4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU16\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2PowU4 as Unsigned\u003e::to_u64(), \u003cU16 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Cmp_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2CmpU4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU2CmpU4 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitAnd_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2BitAndU5 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitAndU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitOr_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U7 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2BitOrU5 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU7\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitOrU5 as Unsigned\u003e::to_u64(), \u003cU7 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitXor_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U7 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2BitXorU5 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU7\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitXorU5 as Unsigned\u003e::to_u64(), \u003cU7 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shl_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U64 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2ShlU5 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU64\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2ShlU5 as Unsigned\u003e::to_u64(), \u003cU64 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shr_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2ShrU5 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2ShrU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Add_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U7 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2AddU5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU7\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2AddU5 as Unsigned\u003e::to_u64(), \u003cU7 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Min_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MinU5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MinU5 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Max_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MaxU5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MaxU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Gcd_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2GcdU5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2GcdU5 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Mul_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U10 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MulU5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU10\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MulU5 as Unsigned\u003e::to_u64(), \u003cU10 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Div_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2DivU5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2DivU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Rem_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2RemU5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2RemU5 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Pow_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U32 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2PowU5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU32\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2PowU5 as Unsigned\u003e::to_u64(), \u003cU32 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Cmp_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2CmpU5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU2CmpU5 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitAnd_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3BitAndU0 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitAndU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitOr_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UTerm;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3BitOrU0 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitOrU0 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitXor_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UTerm;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3BitXorU0 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitXorU0 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shl_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UTerm;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3ShlU0 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3ShlU0 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shr_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UTerm;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3ShrU0 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3ShrU0 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Add_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UTerm;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3AddU0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3AddU0 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Min_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3MinU0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MinU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Max_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UTerm;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MaxU0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MaxU0 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Gcd_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UTerm;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3GcdU0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3GcdU0 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Sub_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UTerm;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3SubU0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3SubU0 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Mul_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3MulU0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MulU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Pow_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UTerm;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3PowU0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3PowU0 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Cmp_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3CmpU0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU3CmpU0 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitAnd_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3BitAndU1 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitAndU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitOr_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3BitOrU1 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitOrU1 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitXor_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3BitXorU1 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitXorU1 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shl_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U6 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3ShlU1 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU6\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3ShlU1 as Unsigned\u003e::to_u64(), \u003cU6 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shr_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3ShrU1 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3ShrU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Add_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3AddU1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3AddU1 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Min_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MinU1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MinU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Max_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MaxU1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MaxU1 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Gcd_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3GcdU1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3GcdU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Sub_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3SubU1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3SubU1 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Mul_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MulU1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MulU1 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Div_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3DivU1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3DivU1 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Rem_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3RemU1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3RemU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_PartialDiv_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3PartialDivU1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3PartialDivU1 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Pow_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3PowU1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3PowU1 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Cmp_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3CmpU1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU3CmpU1 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitAnd_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3BitAndU2 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitAndU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitOr_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3BitOrU2 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitOrU2 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitXor_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3BitXorU2 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitXorU2 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shl_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U12 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3ShlU2 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU12\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3ShlU2 as Unsigned\u003e::to_u64(), \u003cU12 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shr_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3ShrU2 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3ShrU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Add_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3AddU2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3AddU2 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Min_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MinU2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MinU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Max_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MaxU2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MaxU2 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Gcd_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3GcdU2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3GcdU2 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Sub_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3SubU2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3SubU2 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Mul_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U6 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MulU2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU6\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MulU2 as Unsigned\u003e::to_u64(), \u003cU6 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Div_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3DivU2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3DivU2 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Rem_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3RemU2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3RemU2 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Pow_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U9 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3PowU2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU9\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3PowU2 as Unsigned\u003e::to_u64(), \u003cU9 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Cmp_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3CmpU2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU3CmpU2 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitAnd_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3BitAndU3 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitAndU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitOr_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3BitOrU3 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitOrU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitXor_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3BitXorU3 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitXorU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shl_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U24 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3ShlU3 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU24\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3ShlU3 as Unsigned\u003e::to_u64(), \u003cU24 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shr_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3ShrU3 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3ShrU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Add_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U6 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3AddU3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU6\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3AddU3 as Unsigned\u003e::to_u64(), \u003cU6 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Min_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MinU3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MinU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Max_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MaxU3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MaxU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Gcd_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3GcdU3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3GcdU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Sub_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3SubU3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3SubU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Mul_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U9 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MulU3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU9\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MulU3 as Unsigned\u003e::to_u64(), \u003cU9 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Div_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3DivU3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3DivU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Rem_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3RemU3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3RemU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_PartialDiv_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3PartialDivU3 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3PartialDivU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Pow_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U27 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3PowU3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU27\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3PowU3 as Unsigned\u003e::to_u64(), \u003cU27 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Cmp_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3CmpU3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU3CmpU3 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitAnd_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3BitAndU4 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitAndU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitOr_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U7 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3BitOrU4 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU7\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitOrU4 as Unsigned\u003e::to_u64(), \u003cU7 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitXor_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U7 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3BitXorU4 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU7\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitXorU4 as Unsigned\u003e::to_u64(), \u003cU7 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shl_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U48 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3ShlU4 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU48\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3ShlU4 as Unsigned\u003e::to_u64(), \u003cU48 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shr_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3ShrU4 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3ShrU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Add_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U7 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3AddU4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU7\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3AddU4 as Unsigned\u003e::to_u64(), \u003cU7 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Min_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MinU4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MinU4 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Max_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MaxU4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MaxU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Gcd_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3GcdU4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3GcdU4 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Mul_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U12 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MulU4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU12\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MulU4 as Unsigned\u003e::to_u64(), \u003cU12 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Div_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3DivU4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3DivU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Rem_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3RemU4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3RemU4 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Pow_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U81 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3PowU4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU81\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3PowU4 as Unsigned\u003e::to_u64(), \u003cU81 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Cmp_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3CmpU4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU3CmpU4 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitAnd_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3BitAndU5 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitAndU5 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitOr_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U7 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3BitOrU5 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU7\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitOrU5 as Unsigned\u003e::to_u64(), \u003cU7 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitXor_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U6 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3BitXorU5 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU6\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitXorU5 as Unsigned\u003e::to_u64(), \u003cU6 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shl_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U96 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3ShlU5 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU96\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3ShlU5 as Unsigned\u003e::to_u64(), \u003cU96 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shr_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3ShrU5 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3ShrU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Add_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U8 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3AddU5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU8\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3AddU5 as Unsigned\u003e::to_u64(), \u003cU8 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Min_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MinU5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MinU5 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Max_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MaxU5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MaxU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Gcd_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3GcdU5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3GcdU5 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Mul_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U15 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MulU5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU15\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MulU5 as Unsigned\u003e::to_u64(), \u003cU15 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Div_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3DivU5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3DivU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Rem_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3RemU5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3RemU5 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Pow_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U243 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3PowU5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU243\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3PowU5 as Unsigned\u003e::to_u64(), \u003cU243 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Cmp_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3CmpU5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU3CmpU5 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitAnd_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4BitAndU0 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitAndU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitOr_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UTerm;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4BitOrU0 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitOrU0 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitXor_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UTerm;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4BitXorU0 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitXorU0 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shl_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UTerm;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4ShlU0 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4ShlU0 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shr_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UTerm;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4ShrU0 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4ShrU0 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Add_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UTerm;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4AddU0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4AddU0 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Min_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4MinU0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MinU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Max_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UTerm;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MaxU0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MaxU0 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Gcd_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UTerm;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4GcdU0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4GcdU0 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Sub_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UTerm;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4SubU0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4SubU0 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Mul_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4MulU0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MulU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Pow_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UTerm;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4PowU0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4PowU0 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Cmp_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4CmpU0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU4CmpU0 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitAnd_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4BitAndU1 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitAndU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitOr_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4BitOrU1 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitOrU1 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitXor_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4BitXorU1 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitXorU1 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shl_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U8 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4ShlU1 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU8\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4ShlU1 as Unsigned\u003e::to_u64(), \u003cU8 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shr_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4ShrU1 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4ShrU1 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Add_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4AddU1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4AddU1 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Min_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MinU1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MinU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Max_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MaxU1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MaxU1 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Gcd_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4GcdU1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4GcdU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Sub_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4SubU1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4SubU1 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Mul_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MulU1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MulU1 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Div_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4DivU1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4DivU1 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Rem_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4RemU1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4RemU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_PartialDiv_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4PartialDivU1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4PartialDivU1 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Pow_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4PowU1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4PowU1 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Cmp_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4CmpU1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU4CmpU1 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitAnd_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4BitAndU2 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitAndU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitOr_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U6 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4BitOrU2 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU6\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitOrU2 as Unsigned\u003e::to_u64(), \u003cU6 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitXor_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U6 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4BitXorU2 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU6\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitXorU2 as Unsigned\u003e::to_u64(), \u003cU6 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shl_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U16 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4ShlU2 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU16\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4ShlU2 as Unsigned\u003e::to_u64(), \u003cU16 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shr_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4ShrU2 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4ShrU2 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Add_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U6 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4AddU2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU6\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4AddU2 as Unsigned\u003e::to_u64(), \u003cU6 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Min_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MinU2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MinU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Max_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MaxU2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MaxU2 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Gcd_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4GcdU2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4GcdU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Sub_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4SubU2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4SubU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Mul_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U8 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MulU2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU8\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MulU2 as Unsigned\u003e::to_u64(), \u003cU8 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Div_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4DivU2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4DivU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Rem_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4RemU2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4RemU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_PartialDiv_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4PartialDivU2 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4PartialDivU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Pow_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U16 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4PowU2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU16\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4PowU2 as Unsigned\u003e::to_u64(), \u003cU16 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Cmp_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4CmpU2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU4CmpU2 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitAnd_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4BitAndU3 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitAndU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitOr_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U7 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4BitOrU3 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU7\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitOrU3 as Unsigned\u003e::to_u64(), \u003cU7 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitXor_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U7 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4BitXorU3 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU7\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitXorU3 as Unsigned\u003e::to_u64(), \u003cU7 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shl_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U32 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4ShlU3 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU32\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4ShlU3 as Unsigned\u003e::to_u64(), \u003cU32 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shr_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4ShrU3 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4ShrU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Add_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U7 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4AddU3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU7\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4AddU3 as Unsigned\u003e::to_u64(), \u003cU7 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Min_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MinU3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MinU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Max_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MaxU3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MaxU3 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Gcd_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4GcdU3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4GcdU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Sub_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4SubU3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4SubU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Mul_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U12 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MulU3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU12\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MulU3 as Unsigned\u003e::to_u64(), \u003cU12 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Div_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4DivU3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4DivU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Rem_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4RemU3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4RemU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Pow_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U64 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4PowU3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU64\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4PowU3 as Unsigned\u003e::to_u64(), \u003cU64 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Cmp_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4CmpU3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU4CmpU3 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitAnd_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4BitAndU4 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitAndU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitOr_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4BitOrU4 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitOrU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitXor_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4BitXorU4 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitXorU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shl_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U64 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4ShlU4 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU64\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4ShlU4 as Unsigned\u003e::to_u64(), \u003cU64 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shr_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4ShrU4 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4ShrU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Add_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U8 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4AddU4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU8\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4AddU4 as Unsigned\u003e::to_u64(), \u003cU8 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Min_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MinU4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MinU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Max_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MaxU4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MaxU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Gcd_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4GcdU4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4GcdU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Sub_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4SubU4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4SubU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Mul_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U16 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MulU4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU16\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MulU4 as Unsigned\u003e::to_u64(), \u003cU16 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Div_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4DivU4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4DivU4 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Rem_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4RemU4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4RemU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_PartialDiv_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4PartialDivU4 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4PartialDivU4 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Pow_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U256 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4PowU4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU256\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4PowU4 as Unsigned\u003e::to_u64(), \u003cU256 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Cmp_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4CmpU4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU4CmpU4 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitAnd_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4BitAndU5 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitAndU5 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitOr_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4BitOrU5 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitOrU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitXor_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4BitXorU5 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitXorU5 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shl_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U128 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4ShlU5 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU128\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4ShlU5 as Unsigned\u003e::to_u64(), \u003cU128 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shr_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4ShrU5 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4ShrU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Add_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U9 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4AddU5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU9\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4AddU5 as Unsigned\u003e::to_u64(), \u003cU9 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Min_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MinU5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MinU5 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Max_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MaxU5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MaxU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Gcd_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4GcdU5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4GcdU5 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Mul_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U20 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MulU5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU20\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MulU5 as Unsigned\u003e::to_u64(), \u003cU20 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Div_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4DivU5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4DivU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Rem_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4RemU5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4RemU5 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Pow_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U1024 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4PowU5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU1024\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4PowU5 as Unsigned\u003e::to_u64(), \u003cU1024 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Cmp_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4CmpU5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU4CmpU5 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitAnd_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5BitAndU0 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitAndU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitOr_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UTerm;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5BitOrU0 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitOrU0 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitXor_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UTerm;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5BitXorU0 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitXorU0 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shl_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UTerm;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5ShlU0 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5ShlU0 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shr_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UTerm;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5ShrU0 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5ShrU0 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Add_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UTerm;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5AddU0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5AddU0 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Min_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5MinU0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MinU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Max_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UTerm;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MaxU0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MaxU0 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Gcd_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UTerm;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5GcdU0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5GcdU0 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Sub_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UTerm;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5SubU0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5SubU0 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Mul_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5MulU0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MulU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Pow_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UTerm;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5PowU0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5PowU0 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Cmp_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5CmpU0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU5CmpU0 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitAnd_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5BitAndU1 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitAndU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitOr_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5BitOrU1 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitOrU1 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitXor_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5BitXorU1 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitXorU1 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shl_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U10 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5ShlU1 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU10\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5ShlU1 as Unsigned\u003e::to_u64(), \u003cU10 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shr_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5ShrU1 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5ShrU1 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Add_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U6 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5AddU1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU6\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5AddU1 as Unsigned\u003e::to_u64(), \u003cU6 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Min_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MinU1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MinU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Max_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MaxU1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MaxU1 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Gcd_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5GcdU1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5GcdU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Sub_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5SubU1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5SubU1 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Mul_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MulU1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MulU1 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Div_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5DivU1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5DivU1 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Rem_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5RemU1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5RemU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_PartialDiv_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5PartialDivU1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5PartialDivU1 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Pow_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5PowU1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5PowU1 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Cmp_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5CmpU1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU5CmpU1 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitAnd_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5BitAndU2 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitAndU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitOr_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U7 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5BitOrU2 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU7\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitOrU2 as Unsigned\u003e::to_u64(), \u003cU7 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitXor_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U7 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5BitXorU2 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU7\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitXorU2 as Unsigned\u003e::to_u64(), \u003cU7 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shl_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U20 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5ShlU2 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU20\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5ShlU2 as Unsigned\u003e::to_u64(), \u003cU20 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shr_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5ShrU2 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5ShrU2 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Add_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U7 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5AddU2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU7\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5AddU2 as Unsigned\u003e::to_u64(), \u003cU7 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Min_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MinU2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MinU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Max_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MaxU2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MaxU2 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Gcd_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5GcdU2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5GcdU2 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Sub_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5SubU2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5SubU2 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Mul_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U10 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MulU2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU10\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MulU2 as Unsigned\u003e::to_u64(), \u003cU10 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Div_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5DivU2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5DivU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Rem_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5RemU2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5RemU2 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Pow_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U25 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5PowU2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU25\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5PowU2 as Unsigned\u003e::to_u64(), \u003cU25 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Cmp_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5CmpU2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU5CmpU2 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitAnd_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5BitAndU3 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitAndU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitOr_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U7 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5BitOrU3 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU7\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitOrU3 as Unsigned\u003e::to_u64(), \u003cU7 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitXor_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U6 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5BitXorU3 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU6\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitXorU3 as Unsigned\u003e::to_u64(), \u003cU6 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shl_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U40 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5ShlU3 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU40\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5ShlU3 as Unsigned\u003e::to_u64(), \u003cU40 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shr_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5ShrU3 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5ShrU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Add_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U8 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5AddU3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU8\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5AddU3 as Unsigned\u003e::to_u64(), \u003cU8 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Min_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MinU3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MinU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Max_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MaxU3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MaxU3 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Gcd_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5GcdU3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5GcdU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Sub_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5SubU3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5SubU3 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Mul_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U15 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MulU3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU15\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MulU3 as Unsigned\u003e::to_u64(), \u003cU15 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Div_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5DivU3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5DivU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Rem_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5RemU3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5RemU3 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Pow_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U125 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5PowU3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU125\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5PowU3 as Unsigned\u003e::to_u64(), \u003cU125 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Cmp_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5CmpU3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU5CmpU3 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitAnd_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5BitAndU4 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitAndU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitOr_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5BitOrU4 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitOrU4 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitXor_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5BitXorU4 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitXorU4 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shl_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U80 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5ShlU4 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU80\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5ShlU4 as Unsigned\u003e::to_u64(), \u003cU80 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shr_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5ShrU4 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5ShrU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Add_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U9 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5AddU4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU9\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5AddU4 as Unsigned\u003e::to_u64(), \u003cU9 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Min_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MinU4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MinU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Max_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MaxU4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MaxU4 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Gcd_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5GcdU4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5GcdU4 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Sub_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5SubU4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5SubU4 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Mul_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U20 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MulU4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU20\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MulU4 as Unsigned\u003e::to_u64(), \u003cU20 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Div_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5DivU4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5DivU4 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Rem_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5RemU4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5RemU4 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Pow_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U625 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5PowU4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU625\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5PowU4 as Unsigned\u003e::to_u64(), \u003cU625 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Cmp_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5CmpU4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU5CmpU4 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitAnd_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5BitAndU5 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitAndU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitOr_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5BitOrU5 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitOrU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitXor_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5BitXorU5 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitXorU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shl_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U160 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5ShlU5 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU160\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5ShlU5 as Unsigned\u003e::to_u64(), \u003cU160 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shr_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5ShrU5 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5ShrU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Add_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U10 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5AddU5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU10\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5AddU5 as Unsigned\u003e::to_u64(), \u003cU10 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Min_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MinU5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MinU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Max_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MaxU5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MaxU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Gcd_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5GcdU5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5GcdU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Sub_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5SubU5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5SubU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Mul_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U25 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MulU5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU25\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MulU5 as Unsigned\u003e::to_u64(), \u003cU25 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Div_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5DivU5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5DivU5 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Rem_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5RemU5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5RemU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_PartialDiv_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5PartialDivU5 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5PartialDivU5 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Pow_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U3125 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5PowU5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU3125\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5PowU5 as Unsigned\u003e::to_u64(), \u003cU3125 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Cmp_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5CmpU5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU5CmpU5 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Add_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N10 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5AddN5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN10\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5AddN5 as Integer\u003e::to_i64(), \u003cN10 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Sub_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N5SubN5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5SubN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Mul_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P25 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MulN5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP25\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MulN5 as Integer\u003e::to_i64(), \u003cP25 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Min_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MinN5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MinN5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Max_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MaxN5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MaxN5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Gcd_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5GcdN5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5GcdN5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Div_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5DivN5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5DivN5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Rem_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N5RemN5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5RemN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_PartialDiv_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5PartialDivN5 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5PartialDivN5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Cmp_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5CmpN5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN5CmpN5 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Add_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N9 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5AddN4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN9\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5AddN4 as Integer\u003e::to_i64(), \u003cN9 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Sub_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5SubN4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5SubN4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Mul_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P20 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MulN4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP20\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MulN4 as Integer\u003e::to_i64(), \u003cP20 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Min_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MinN4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MinN4 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Max_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MaxN4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MaxN4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Gcd_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5GcdN4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5GcdN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Div_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5DivN4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5DivN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Rem_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5RemN4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5RemN4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Cmp_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5CmpN4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN5CmpN4 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Add_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N8 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5AddN3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN8\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5AddN3 as Integer\u003e::to_i64(), \u003cN8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Sub_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5SubN3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5SubN3 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Mul_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P15 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MulN3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP15\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MulN3 as Integer\u003e::to_i64(), \u003cP15 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Min_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MinN3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MinN3 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Max_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MaxN3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MaxN3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Gcd_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5GcdN3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5GcdN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Div_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5DivN3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5DivN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Rem_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5RemN3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5RemN3 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Cmp_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5CmpN3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN5CmpN3 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Add_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N7 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5AddN2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN7\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5AddN2 as Integer\u003e::to_i64(), \u003cN7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Sub_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5SubN2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5SubN2 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Mul_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P10 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MulN2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP10\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MulN2 as Integer\u003e::to_i64(), \u003cP10 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Min_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MinN2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MinN2 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Max_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MaxN2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MaxN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Gcd_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5GcdN2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5GcdN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Div_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5DivN2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5DivN2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Rem_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5RemN2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5RemN2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Cmp_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5CmpN2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN5CmpN2 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Add_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N6 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5AddN1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN6\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5AddN1 as Integer\u003e::to_i64(), \u003cN6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Sub_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5SubN1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5SubN1 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Mul_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MulN1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MulN1 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Min_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MinN1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MinN1 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Max_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MaxN1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MaxN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Gcd_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5GcdN1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5GcdN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Div_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5DivN1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5DivN1 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Rem_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N5RemN1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5RemN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_PartialDiv_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5PartialDivN1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5PartialDivN1 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Cmp_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5CmpN1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN5CmpN1 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Add__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5Add_0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5Add_0 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Sub__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5Sub_0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5Sub_0 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Mul__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N5Mul_0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5Mul_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Min__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5Min_0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5Min_0 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Max__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N5Max_0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5Max_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Gcd__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5Gcd_0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5Gcd_0 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Pow__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5Pow_0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5Pow_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Cmp__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N5Cmp_0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN5Cmp_0 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Add_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5AddP1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5AddP1 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Sub_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N6 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5SubP1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN6\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5SubP1 as Integer\u003e::to_i64(), \u003cN6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Mul_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MulP1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MulP1 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Min_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MinP1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MinP1 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Max_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MaxP1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MaxP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Gcd_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5GcdP1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5GcdP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Div_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5DivP1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5DivP1 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Rem_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N5RemP1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5RemP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_PartialDiv_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5PartialDivP1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5PartialDivP1 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Pow_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5PowP1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5PowP1 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Cmp_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5CmpP1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN5CmpP1 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Add_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5AddP2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5AddP2 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Sub_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N7 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5SubP2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN7\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5SubP2 as Integer\u003e::to_i64(), \u003cN7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Mul_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N10 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MulP2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN10\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MulP2 as Integer\u003e::to_i64(), \u003cN10 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Min_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MinP2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MinP2 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Max_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MaxP2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MaxP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Gcd_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5GcdP2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5GcdP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Div_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5DivP2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5DivP2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Rem_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5RemP2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5RemP2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Pow_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P25 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5PowP2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP25\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5PowP2 as Integer\u003e::to_i64(), \u003cP25 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Cmp_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5CmpP2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN5CmpP2 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Add_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5AddP3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5AddP3 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Sub_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N8 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5SubP3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN8\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5SubP3 as Integer\u003e::to_i64(), \u003cN8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Mul_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N15 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MulP3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN15\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MulP3 as Integer\u003e::to_i64(), \u003cN15 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Min_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MinP3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MinP3 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Max_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MaxP3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MaxP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Gcd_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5GcdP3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5GcdP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Div_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5DivP3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5DivP3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Rem_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5RemP3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5RemP3 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Pow_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N125 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5PowP3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN125\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5PowP3 as Integer\u003e::to_i64(), \u003cN125 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Cmp_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5CmpP3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN5CmpP3 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Add_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5AddP4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5AddP4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Sub_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N9 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5SubP4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN9\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5SubP4 as Integer\u003e::to_i64(), \u003cN9 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Mul_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N20 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MulP4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN20\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MulP4 as Integer\u003e::to_i64(), \u003cN20 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Min_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MinP4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MinP4 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Max_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MaxP4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MaxP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Gcd_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5GcdP4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5GcdP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Div_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5DivP4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5DivP4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Rem_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5RemP4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5RemP4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Pow_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P625 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5PowP4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP625\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5PowP4 as Integer\u003e::to_i64(), \u003cP625 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Cmp_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5CmpP4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN5CmpP4 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Add_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N5AddP5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5AddP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Sub_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N10 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5SubP5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN10\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5SubP5 as Integer\u003e::to_i64(), \u003cN10 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Mul_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N25 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MulP5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN25\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MulP5 as Integer\u003e::to_i64(), \u003cN25 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Min_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MinP5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MinP5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Max_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MaxP5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MaxP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Gcd_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5GcdP5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5GcdP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Div_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5DivP5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5DivP5 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Rem_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N5RemP5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5RemP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_PartialDiv_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5PartialDivP5 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5PartialDivP5 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Pow_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N3125 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5PowP5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN3125\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5PowP5 as Integer\u003e::to_i64(), \u003cN3125 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Cmp_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5CmpP5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN5CmpP5 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Add_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N9 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4AddN5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN9\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4AddN5 as Integer\u003e::to_i64(), \u003cN9 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Sub_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4SubN5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4SubN5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Mul_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P20 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MulN5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP20\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MulN5 as Integer\u003e::to_i64(), \u003cP20 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Min_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MinN5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MinN5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Max_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MaxN5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MaxN5 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Gcd_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4GcdN5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4GcdN5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Div_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4DivN5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4DivN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Rem_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4RemN5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4RemN5 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Cmp_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4CmpN5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN4CmpN5 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Add_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N8 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4AddN4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN8\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4AddN4 as Integer\u003e::to_i64(), \u003cN8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Sub_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4SubN4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4SubN4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Mul_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P16 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MulN4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP16\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MulN4 as Integer\u003e::to_i64(), \u003cP16 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Min_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MinN4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MinN4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Max_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MaxN4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MaxN4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Gcd_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4GcdN4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4GcdN4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Div_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4DivN4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4DivN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Rem_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4RemN4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4RemN4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_PartialDiv_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4PartialDivN4 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4PartialDivN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Cmp_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4CmpN4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN4CmpN4 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Add_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N7 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4AddN3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN7\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4AddN3 as Integer\u003e::to_i64(), \u003cN7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Sub_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4SubN3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4SubN3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Mul_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P12 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MulN3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP12\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MulN3 as Integer\u003e::to_i64(), \u003cP12 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Min_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MinN3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MinN3 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Max_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MaxN3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MaxN3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Gcd_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4GcdN3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4GcdN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Div_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4DivN3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4DivN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Rem_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4RemN3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4RemN3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Cmp_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4CmpN3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN4CmpN3 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Add_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N6 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4AddN2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN6\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4AddN2 as Integer\u003e::to_i64(), \u003cN6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Sub_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4SubN2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4SubN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Mul_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P8 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MulN2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP8\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MulN2 as Integer\u003e::to_i64(), \u003cP8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Min_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MinN2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MinN2 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Max_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MaxN2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MaxN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Gcd_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4GcdN2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4GcdN2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Div_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4DivN2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4DivN2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Rem_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4RemN2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4RemN2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_PartialDiv_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4PartialDivN2 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4PartialDivN2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Cmp_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4CmpN2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN4CmpN2 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Add_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4AddN1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4AddN1 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Sub_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4SubN1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4SubN1 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Mul_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MulN1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MulN1 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Min_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MinN1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MinN1 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Max_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MaxN1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MaxN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Gcd_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4GcdN1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4GcdN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Div_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4DivN1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4DivN1 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Rem_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4RemN1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4RemN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_PartialDiv_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4PartialDivN1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4PartialDivN1 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Cmp_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4CmpN1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN4CmpN1 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Add__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4Add_0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4Add_0 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Sub__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4Sub_0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4Sub_0 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Mul__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4Mul_0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4Mul_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Min__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4Min_0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4Min_0 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Max__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4Max_0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4Max_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Gcd__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4Gcd_0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4Gcd_0 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Pow__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4Pow_0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4Pow_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Cmp__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4Cmp_0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN4Cmp_0 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Add_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4AddP1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4AddP1 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Sub_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4SubP1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4SubP1 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Mul_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MulP1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MulP1 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Min_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MinP1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MinP1 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Max_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MaxP1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MaxP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Gcd_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4GcdP1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4GcdP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Div_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4DivP1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4DivP1 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Rem_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4RemP1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4RemP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_PartialDiv_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4PartialDivP1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4PartialDivP1 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Pow_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4PowP1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4PowP1 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Cmp_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4CmpP1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN4CmpP1 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Add_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4AddP2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4AddP2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Sub_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N6 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4SubP2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN6\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4SubP2 as Integer\u003e::to_i64(), \u003cN6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Mul_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N8 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MulP2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN8\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MulP2 as Integer\u003e::to_i64(), \u003cN8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Min_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MinP2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MinP2 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Max_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MaxP2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MaxP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Gcd_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4GcdP2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4GcdP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Div_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4DivP2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4DivP2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Rem_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4RemP2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4RemP2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_PartialDiv_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4PartialDivP2 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4PartialDivP2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Pow_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P16 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4PowP2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP16\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4PowP2 as Integer\u003e::to_i64(), \u003cP16 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Cmp_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4CmpP2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN4CmpP2 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Add_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4AddP3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4AddP3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Sub_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N7 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4SubP3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN7\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4SubP3 as Integer\u003e::to_i64(), \u003cN7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Mul_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N12 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MulP3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN12\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MulP3 as Integer\u003e::to_i64(), \u003cN12 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Min_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MinP3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MinP3 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Max_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MaxP3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MaxP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Gcd_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4GcdP3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4GcdP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Div_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4DivP3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4DivP3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Rem_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4RemP3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4RemP3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Pow_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N64 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4PowP3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN64\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4PowP3 as Integer\u003e::to_i64(), \u003cN64 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Cmp_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4CmpP3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN4CmpP3 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Add_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4AddP4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4AddP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Sub_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N8 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4SubP4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN8\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4SubP4 as Integer\u003e::to_i64(), \u003cN8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Mul_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N16 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MulP4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN16\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MulP4 as Integer\u003e::to_i64(), \u003cN16 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Min_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MinP4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MinP4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Max_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MaxP4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MaxP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Gcd_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4GcdP4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4GcdP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Div_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4DivP4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4DivP4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Rem_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4RemP4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4RemP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_PartialDiv_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4PartialDivP4 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4PartialDivP4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Pow_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P256 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4PowP4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP256\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4PowP4 as Integer\u003e::to_i64(), \u003cP256 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Cmp_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4CmpP4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN4CmpP4 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Add_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4AddP5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4AddP5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Sub_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N9 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4SubP5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN9\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4SubP5 as Integer\u003e::to_i64(), \u003cN9 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Mul_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N20 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MulP5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN20\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MulP5 as Integer\u003e::to_i64(), \u003cN20 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Min_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MinP5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MinP5 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Max_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MaxP5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MaxP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Gcd_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4GcdP5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4GcdP5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Div_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4DivP5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4DivP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Rem_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4RemP5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4RemP5 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Pow_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N1024 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4PowP5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN1024\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4PowP5 as Integer\u003e::to_i64(), \u003cN1024 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Cmp_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4CmpP5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN4CmpP5 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Add_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N8 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3AddN5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN8\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3AddN5 as Integer\u003e::to_i64(), \u003cN8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Sub_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3SubN5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3SubN5 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Mul_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P15 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MulN5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP15\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MulN5 as Integer\u003e::to_i64(), \u003cP15 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Min_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MinN5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MinN5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Max_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MaxN5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MaxN5 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Gcd_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3GcdN5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3GcdN5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Div_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3DivN5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3DivN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Rem_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3RemN5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3RemN5 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Cmp_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3CmpN5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN3CmpN5 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Add_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N7 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3AddN4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN7\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3AddN4 as Integer\u003e::to_i64(), \u003cN7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Sub_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3SubN4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3SubN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Mul_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P12 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MulN4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP12\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MulN4 as Integer\u003e::to_i64(), \u003cP12 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Min_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MinN4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MinN4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Max_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MaxN4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MaxN4 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Gcd_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3GcdN4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3GcdN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Div_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3DivN4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3DivN4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Rem_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3RemN4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3RemN4 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Cmp_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3CmpN4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN3CmpN4 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Add_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N6 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3AddN3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN6\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3AddN3 as Integer\u003e::to_i64(), \u003cN6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Sub_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3SubN3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3SubN3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Mul_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P9 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MulN3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP9\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MulN3 as Integer\u003e::to_i64(), \u003cP9 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Min_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MinN3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MinN3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Max_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MaxN3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MaxN3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Gcd_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3GcdN3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3GcdN3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Div_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3DivN3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3DivN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Rem_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3RemN3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3RemN3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_PartialDiv_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3PartialDivN3 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3PartialDivN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Cmp_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3CmpN3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN3CmpN3 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Add_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3AddN2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3AddN2 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Sub_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3SubN2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3SubN2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Mul_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P6 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MulN2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP6\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MulN2 as Integer\u003e::to_i64(), \u003cP6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Min_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MinN2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MinN2 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Max_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MaxN2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MaxN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Gcd_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3GcdN2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3GcdN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Div_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3DivN2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3DivN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Rem_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3RemN2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3RemN2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Cmp_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3CmpN2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN3CmpN2 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Add_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3AddN1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3AddN1 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Sub_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3SubN1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3SubN1 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Mul_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MulN1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MulN1 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Min_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MinN1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MinN1 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Max_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MaxN1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MaxN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Gcd_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3GcdN1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3GcdN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Div_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3DivN1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3DivN1 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Rem_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3RemN1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3RemN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_PartialDiv_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3PartialDivN1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3PartialDivN1 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Cmp_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3CmpN1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN3CmpN1 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Add__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3Add_0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3Add_0 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Sub__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3Sub_0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3Sub_0 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Mul__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3Mul_0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3Mul_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Min__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3Min_0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3Min_0 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Max__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3Max_0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3Max_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Gcd__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3Gcd_0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3Gcd_0 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Pow__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3Pow_0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3Pow_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Cmp__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3Cmp_0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN3Cmp_0 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Add_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3AddP1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3AddP1 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Sub_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3SubP1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3SubP1 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Mul_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MulP1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MulP1 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Min_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MinP1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MinP1 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Max_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MaxP1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MaxP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Gcd_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3GcdP1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3GcdP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Div_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3DivP1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3DivP1 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Rem_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3RemP1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3RemP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_PartialDiv_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3PartialDivP1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3PartialDivP1 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Pow_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3PowP1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3PowP1 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Cmp_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3CmpP1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN3CmpP1 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Add_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3AddP2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3AddP2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Sub_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3SubP2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3SubP2 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Mul_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N6 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MulP2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN6\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MulP2 as Integer\u003e::to_i64(), \u003cN6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Min_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MinP2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MinP2 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Max_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MaxP2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MaxP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Gcd_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3GcdP2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3GcdP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Div_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3DivP2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3DivP2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Rem_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3RemP2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3RemP2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Pow_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P9 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3PowP2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP9\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3PowP2 as Integer\u003e::to_i64(), \u003cP9 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Cmp_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3CmpP2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN3CmpP2 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Add_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3AddP3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3AddP3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Sub_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N6 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3SubP3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN6\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3SubP3 as Integer\u003e::to_i64(), \u003cN6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Mul_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N9 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MulP3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN9\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MulP3 as Integer\u003e::to_i64(), \u003cN9 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Min_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MinP3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MinP3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Max_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MaxP3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MaxP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Gcd_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3GcdP3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3GcdP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Div_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3DivP3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3DivP3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Rem_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3RemP3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3RemP3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_PartialDiv_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3PartialDivP3 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3PartialDivP3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Pow_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N27 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3PowP3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN27\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3PowP3 as Integer\u003e::to_i64(), \u003cN27 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Cmp_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3CmpP3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN3CmpP3 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Add_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3AddP4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3AddP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Sub_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N7 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3SubP4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN7\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3SubP4 as Integer\u003e::to_i64(), \u003cN7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Mul_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N12 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MulP4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN12\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MulP4 as Integer\u003e::to_i64(), \u003cN12 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Min_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MinP4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MinP4 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Max_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MaxP4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MaxP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Gcd_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3GcdP4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3GcdP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Div_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3DivP4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3DivP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Rem_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3RemP4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3RemP4 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Pow_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P81 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3PowP4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP81\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3PowP4 as Integer\u003e::to_i64(), \u003cP81 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Cmp_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3CmpP4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN3CmpP4 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Add_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3AddP5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3AddP5 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Sub_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N8 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3SubP5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN8\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3SubP5 as Integer\u003e::to_i64(), \u003cN8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Mul_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N15 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MulP5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN15\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MulP5 as Integer\u003e::to_i64(), \u003cN15 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Min_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MinP5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MinP5 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Max_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MaxP5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MaxP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Gcd_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3GcdP5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3GcdP5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Div_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3DivP5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3DivP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Rem_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3RemP5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3RemP5 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Pow_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N243 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3PowP5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN243\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3PowP5 as Integer\u003e::to_i64(), \u003cN243 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Cmp_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3CmpP5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN3CmpP5 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Add_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N7 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2AddN5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN7\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2AddN5 as Integer\u003e::to_i64(), \u003cN7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Sub_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2SubN5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2SubN5 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Mul_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P10 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MulN5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP10\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MulN5 as Integer\u003e::to_i64(), \u003cP10 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Min_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MinN5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MinN5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Max_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MaxN5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MaxN5 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Gcd_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2GcdN5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2GcdN5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Div_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2DivN5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2DivN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Rem_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2RemN5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2RemN5 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Cmp_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2CmpN5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN2CmpN5 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Add_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N6 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2AddN4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN6\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2AddN4 as Integer\u003e::to_i64(), \u003cN6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Sub_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2SubN4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2SubN4 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Mul_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P8 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MulN4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP8\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MulN4 as Integer\u003e::to_i64(), \u003cP8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Min_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MinN4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MinN4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Max_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MaxN4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MaxN4 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Gcd_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2GcdN4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2GcdN4 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Div_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2DivN4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2DivN4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Rem_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2RemN4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2RemN4 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Cmp_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2CmpN4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN2CmpN4 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Add_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2AddN3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2AddN3 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Sub_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2SubN3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2SubN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Mul_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P6 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MulN3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP6\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MulN3 as Integer\u003e::to_i64(), \u003cP6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Min_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MinN3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MinN3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Max_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MaxN3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MaxN3 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Gcd_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2GcdN3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2GcdN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Div_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2DivN3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2DivN3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Rem_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2RemN3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2RemN3 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Cmp_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2CmpN3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN2CmpN3 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Add_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2AddN2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2AddN2 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Sub_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2SubN2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2SubN2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Mul_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MulN2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MulN2 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Min_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MinN2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MinN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Max_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MaxN2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MaxN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Gcd_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2GcdN2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2GcdN2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Div_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2DivN2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2DivN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Rem_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2RemN2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2RemN2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_PartialDiv_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2PartialDivN2 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2PartialDivN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Cmp_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2CmpN2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN2CmpN2 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Add_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2AddN1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2AddN1 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Sub_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2SubN1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2SubN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Mul_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MulN1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MulN1 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Min_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MinN1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MinN1 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Max_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MaxN1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MaxN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Gcd_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2GcdN1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2GcdN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Div_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2DivN1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2DivN1 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Rem_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2RemN1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2RemN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_PartialDiv_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2PartialDivN1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2PartialDivN1 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Cmp_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2CmpN1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN2CmpN1 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Add__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2Add_0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2Add_0 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Sub__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2Sub_0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2Sub_0 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Mul__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2Mul_0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2Mul_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Min__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2Min_0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2Min_0 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Max__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2Max_0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2Max_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Gcd__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2Gcd_0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2Gcd_0 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Pow__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2Pow_0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2Pow_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Cmp__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2Cmp_0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN2Cmp_0 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Add_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2AddP1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2AddP1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Sub_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2SubP1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2SubP1 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Mul_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MulP1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MulP1 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Min_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MinP1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MinP1 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Max_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MaxP1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MaxP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Gcd_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2GcdP1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2GcdP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Div_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2DivP1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2DivP1 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Rem_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2RemP1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2RemP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_PartialDiv_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2PartialDivP1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2PartialDivP1 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Pow_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2PowP1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2PowP1 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Cmp_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2CmpP1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN2CmpP1 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Add_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2AddP2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2AddP2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Sub_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2SubP2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2SubP2 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Mul_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MulP2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MulP2 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Min_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MinP2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MinP2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Max_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MaxP2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MaxP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Gcd_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2GcdP2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2GcdP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Div_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2DivP2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2DivP2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Rem_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2RemP2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2RemP2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_PartialDiv_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2PartialDivP2 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2PartialDivP2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Pow_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2PowP2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2PowP2 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Cmp_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2CmpP2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN2CmpP2 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Add_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2AddP3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2AddP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Sub_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2SubP3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2SubP3 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Mul_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N6 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MulP3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN6\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MulP3 as Integer\u003e::to_i64(), \u003cN6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Min_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MinP3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MinP3 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Max_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MaxP3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MaxP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Gcd_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2GcdP3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2GcdP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Div_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2DivP3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2DivP3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Rem_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2RemP3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2RemP3 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Pow_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N8 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2PowP3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN8\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2PowP3 as Integer\u003e::to_i64(), \u003cN8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Cmp_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2CmpP3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN2CmpP3 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Add_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2AddP4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2AddP4 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Sub_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N6 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2SubP4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN6\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2SubP4 as Integer\u003e::to_i64(), \u003cN6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Mul_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N8 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MulP4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN8\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MulP4 as Integer\u003e::to_i64(), \u003cN8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Min_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MinP4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MinP4 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Max_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MaxP4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MaxP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Gcd_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2GcdP4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2GcdP4 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Div_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2DivP4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2DivP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Rem_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2RemP4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2RemP4 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Pow_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P16 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2PowP4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP16\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2PowP4 as Integer\u003e::to_i64(), \u003cP16 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Cmp_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2CmpP4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN2CmpP4 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Add_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2AddP5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2AddP5 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Sub_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N7 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2SubP5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN7\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2SubP5 as Integer\u003e::to_i64(), \u003cN7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Mul_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N10 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MulP5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN10\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MulP5 as Integer\u003e::to_i64(), \u003cN10 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Min_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MinP5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MinP5 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Max_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MaxP5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MaxP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Gcd_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2GcdP5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2GcdP5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Div_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2DivP5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2DivP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Rem_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2RemP5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2RemP5 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Pow_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N32 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2PowP5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN32\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2PowP5 as Integer\u003e::to_i64(), \u003cN32 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Cmp_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2CmpP5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN2CmpP5 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Add_N5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N6 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1AddN5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN6\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1AddN5 as Integer\u003e::to_i64(), \u003cN6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Sub_N5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1SubN5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1SubN5 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Mul_N5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MulN5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MulN5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Min_N5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MinN5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MinN5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Max_N5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MaxN5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MaxN5 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Gcd_N5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1GcdN5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1GcdN5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Div_N5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1DivN5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1DivN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Rem_N5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1RemN5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1RemN5 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Pow_N5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1PowN5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1PowN5 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Cmp_N5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1CmpN5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN1CmpN5 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Add_N4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1AddN4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1AddN4 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Sub_N4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1SubN4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1SubN4 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Mul_N4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MulN4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MulN4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Min_N4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MinN4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MinN4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Max_N4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MaxN4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MaxN4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Gcd_N4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1GcdN4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1GcdN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Div_N4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1DivN4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1DivN4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Rem_N4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1RemN4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1RemN4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Pow_N4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1PowN4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1PowN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Cmp_N4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1CmpN4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN1CmpN4 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Add_N3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1AddN3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1AddN3 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Sub_N3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1SubN3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1SubN3 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Mul_N3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MulN3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MulN3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Min_N3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MinN3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MinN3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Max_N3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MaxN3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MaxN3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Gcd_N3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1GcdN3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1GcdN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Div_N3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1DivN3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1DivN3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Rem_N3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1RemN3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1RemN3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Pow_N3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1PowN3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1PowN3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Cmp_N3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1CmpN3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN1CmpN3 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Add_N2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1AddN2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1AddN2 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Sub_N2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1SubN2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1SubN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Mul_N2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MulN2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MulN2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Min_N2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MinN2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MinN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Max_N2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MaxN2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MaxN2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Gcd_N2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1GcdN2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1GcdN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Div_N2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1DivN2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1DivN2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Rem_N2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1RemN2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1RemN2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Pow_N2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1PowN2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1PowN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Cmp_N2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1CmpN2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN1CmpN2 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Add_N1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1AddN1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1AddN1 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Sub_N1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1SubN1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1SubN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Mul_N1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MulN1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MulN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Min_N1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MinN1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MinN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Max_N1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MaxN1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MaxN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Gcd_N1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1GcdN1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1GcdN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Div_N1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1DivN1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1DivN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Rem_N1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1RemN1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1RemN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_PartialDiv_N1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1PartialDivN1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1PartialDivN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Pow_N1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1PowN1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1PowN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Cmp_N1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1CmpN1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN1CmpN1 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Add__0() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1Add_0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1Add_0 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Sub__0() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1Sub_0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1Sub_0 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Mul__0() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1Mul_0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1Mul_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Min__0() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1Min_0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1Min_0 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Max__0() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1Max_0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1Max_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Gcd__0() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1Gcd_0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1Gcd_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Pow__0() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1Pow_0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1Pow_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Cmp__0() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1Cmp_0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN1Cmp_0 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Add_P1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1AddP1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1AddP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Sub_P1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1SubP1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1SubP1 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Mul_P1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MulP1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MulP1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Min_P1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MinP1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MinP1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Max_P1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MaxP1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MaxP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Gcd_P1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1GcdP1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1GcdP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Div_P1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1DivP1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1DivP1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Rem_P1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1RemP1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1RemP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_PartialDiv_P1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1PartialDivP1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1PartialDivP1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Pow_P1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1PowP1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1PowP1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Cmp_P1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1CmpP1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN1CmpP1 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Add_P2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1AddP2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1AddP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Sub_P2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1SubP2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1SubP2 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Mul_P2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MulP2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MulP2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Min_P2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MinP2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MinP2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Max_P2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MaxP2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MaxP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Gcd_P2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1GcdP2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1GcdP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Div_P2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1DivP2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1DivP2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Rem_P2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1RemP2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1RemP2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Pow_P2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1PowP2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1PowP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Cmp_P2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1CmpP2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN1CmpP2 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Add_P3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1AddP3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1AddP3 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Sub_P3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1SubP3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1SubP3 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Mul_P3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MulP3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MulP3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Min_P3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MinP3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MinP3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Max_P3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MaxP3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MaxP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Gcd_P3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1GcdP3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1GcdP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Div_P3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1DivP3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1DivP3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Rem_P3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1RemP3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1RemP3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Pow_P3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1PowP3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1PowP3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Cmp_P3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1CmpP3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN1CmpP3 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Add_P4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1AddP4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1AddP4 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Sub_P4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1SubP4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1SubP4 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Mul_P4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MulP4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MulP4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Min_P4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MinP4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MinP4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Max_P4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MaxP4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MaxP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Gcd_P4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1GcdP4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1GcdP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Div_P4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1DivP4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1DivP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Rem_P4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1RemP4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1RemP4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Pow_P4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1PowP4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1PowP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Cmp_P4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1CmpP4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN1CmpP4 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Add_P5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1AddP5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1AddP5 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Sub_P5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N6 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1SubP5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN6\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1SubP5 as Integer\u003e::to_i64(), \u003cN6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Mul_P5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MulP5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MulP5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Min_P5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MinP5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MinP5 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Max_P5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MaxP5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MaxP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Gcd_P5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1GcdP5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1GcdP5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Div_P5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1DivP5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1DivP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Rem_P5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1RemP5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1RemP5 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Pow_P5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1PowP5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1PowP5 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Cmp_P5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1CmpP5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN1CmpP5 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Add_N5() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0AddN5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0AddN5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Sub_N5() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0SubN5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0SubN5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Mul_N5() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MulN5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MulN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Min_N5() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0MinN5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MinN5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Max_N5() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MaxN5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MaxN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Gcd_N5() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0GcdN5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0GcdN5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Div_N5() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0DivN5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0DivN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Rem_N5() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0RemN5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0RemN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_PartialDiv_N5() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PartialDivN5 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0PartialDivN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Cmp_N5() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0CmpN5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003c_0CmpN5 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Add_N4() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0AddN4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0AddN4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Sub_N4() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0SubN4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0SubN4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Mul_N4() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MulN4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MulN4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Min_N4() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0MinN4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MinN4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Max_N4() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MaxN4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MaxN4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Gcd_N4() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0GcdN4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0GcdN4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Div_N4() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0DivN4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0DivN4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Rem_N4() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0RemN4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0RemN4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_PartialDiv_N4() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PartialDivN4 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0PartialDivN4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Cmp_N4() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0CmpN4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003c_0CmpN4 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Add_N3() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0AddN3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0AddN3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Sub_N3() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0SubN3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0SubN3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Mul_N3() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MulN3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MulN3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Min_N3() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0MinN3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MinN3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Max_N3() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MaxN3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MaxN3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Gcd_N3() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0GcdN3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0GcdN3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Div_N3() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0DivN3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0DivN3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Rem_N3() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0RemN3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0RemN3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_PartialDiv_N3() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PartialDivN3 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0PartialDivN3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Cmp_N3() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0CmpN3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003c_0CmpN3 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Add_N2() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0AddN2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0AddN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Sub_N2() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0SubN2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0SubN2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Mul_N2() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MulN2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MulN2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Min_N2() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0MinN2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MinN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Max_N2() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MaxN2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MaxN2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Gcd_N2() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0GcdN2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0GcdN2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Div_N2() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0DivN2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0DivN2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Rem_N2() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0RemN2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0RemN2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_PartialDiv_N2() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PartialDivN2 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0PartialDivN2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Cmp_N2() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0CmpN2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003c_0CmpN2 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Add_N1() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0AddN1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0AddN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Sub_N1() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0SubN1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0SubN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Mul_N1() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MulN1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MulN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Min_N1() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0MinN1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MinN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Max_N1() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MaxN1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MaxN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Gcd_N1() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0GcdN1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0GcdN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Div_N1() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0DivN1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0DivN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Rem_N1() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0RemN1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0RemN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_PartialDiv_N1() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PartialDivN1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0PartialDivN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Cmp_N1() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0CmpN1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003c_0CmpN1 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Add__0() {\n    type A = Z0;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0Add_0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0Add_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Sub__0() {\n    type A = Z0;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0Sub_0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0Sub_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Mul__0() {\n    type A = Z0;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0Mul_0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0Mul_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Min__0() {\n    type A = Z0;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0Min_0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0Min_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Max__0() {\n    type A = Z0;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0Max_0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0Max_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Gcd__0() {\n    type A = Z0;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0Gcd_0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0Gcd_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Pow__0() {\n    type A = Z0;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0Pow_0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0Pow_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Cmp__0() {\n    type A = Z0;\n    type B = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0Cmp_0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003c_0Cmp_0 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Add_P1() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0AddP1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0AddP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Sub_P1() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0SubP1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0SubP1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Mul_P1() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MulP1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MulP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Min_P1() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MinP1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MinP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Max_P1() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0MaxP1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MaxP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Gcd_P1() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0GcdP1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0GcdP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Div_P1() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0DivP1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0DivP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Rem_P1() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0RemP1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0RemP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_PartialDiv_P1() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PartialDivP1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0PartialDivP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Pow_P1() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PowP1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0PowP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Cmp_P1() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0CmpP1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003c_0CmpP1 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Add_P2() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0AddP2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0AddP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Sub_P2() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0SubP2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0SubP2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Mul_P2() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MulP2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MulP2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Min_P2() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MinP2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MinP2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Max_P2() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0MaxP2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MaxP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Gcd_P2() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0GcdP2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0GcdP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Div_P2() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0DivP2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0DivP2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Rem_P2() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0RemP2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0RemP2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_PartialDiv_P2() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PartialDivP2 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0PartialDivP2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Pow_P2() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PowP2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0PowP2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Cmp_P2() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0CmpP2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003c_0CmpP2 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Add_P3() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0AddP3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0AddP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Sub_P3() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0SubP3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0SubP3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Mul_P3() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MulP3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MulP3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Min_P3() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MinP3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MinP3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Max_P3() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0MaxP3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MaxP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Gcd_P3() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0GcdP3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0GcdP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Div_P3() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0DivP3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0DivP3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Rem_P3() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0RemP3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0RemP3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_PartialDiv_P3() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PartialDivP3 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0PartialDivP3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Pow_P3() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PowP3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0PowP3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Cmp_P3() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0CmpP3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003c_0CmpP3 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Add_P4() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0AddP4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0AddP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Sub_P4() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0SubP4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0SubP4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Mul_P4() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MulP4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MulP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Min_P4() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MinP4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MinP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Max_P4() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0MaxP4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MaxP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Gcd_P4() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0GcdP4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0GcdP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Div_P4() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0DivP4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0DivP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Rem_P4() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0RemP4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0RemP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_PartialDiv_P4() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PartialDivP4 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0PartialDivP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Pow_P4() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PowP4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0PowP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Cmp_P4() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0CmpP4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003c_0CmpP4 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Add_P5() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0AddP5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0AddP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Sub_P5() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0SubP5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0SubP5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Mul_P5() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MulP5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MulP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Min_P5() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MinP5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MinP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Max_P5() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0MaxP5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MaxP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Gcd_P5() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0GcdP5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0GcdP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Div_P5() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0DivP5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0DivP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Rem_P5() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0RemP5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0RemP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_PartialDiv_P5() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PartialDivP5 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0PartialDivP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Pow_P5() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PowP5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0PowP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Cmp_P5() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0CmpP5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003c_0CmpP5 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Add_N5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1AddN5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1AddN5 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Sub_N5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P6 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1SubN5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP6\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1SubN5 as Integer\u003e::to_i64(), \u003cP6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Mul_N5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MulN5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MulN5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Min_N5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MinN5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MinN5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Max_N5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MaxN5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MaxN5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Gcd_N5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1GcdN5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1GcdN5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Div_N5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1DivN5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1DivN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Rem_N5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1RemN5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1RemN5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Pow_N5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1PowN5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1PowN5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Cmp_N5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1CmpN5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP1CmpN5 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Add_N4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1AddN4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1AddN4 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Sub_N4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1SubN4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1SubN4 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Mul_N4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MulN4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MulN4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Min_N4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MinN4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MinN4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Max_N4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MaxN4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MaxN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Gcd_N4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1GcdN4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1GcdN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Div_N4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1DivN4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1DivN4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Rem_N4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1RemN4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1RemN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Pow_N4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1PowN4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1PowN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Cmp_N4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1CmpN4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP1CmpN4 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Add_N3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1AddN3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1AddN3 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Sub_N3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1SubN3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1SubN3 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Mul_N3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MulN3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MulN3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Min_N3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MinN3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MinN3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Max_N3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MaxN3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MaxN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Gcd_N3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1GcdN3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1GcdN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Div_N3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1DivN3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1DivN3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Rem_N3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1RemN3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1RemN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Pow_N3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1PowN3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1PowN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Cmp_N3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1CmpN3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP1CmpN3 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Add_N2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1AddN2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1AddN2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Sub_N2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1SubN2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1SubN2 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Mul_N2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MulN2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MulN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Min_N2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MinN2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MinN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Max_N2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MaxN2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MaxN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Gcd_N2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1GcdN2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1GcdN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Div_N2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1DivN2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1DivN2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Rem_N2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1RemN2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1RemN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Pow_N2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1PowN2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1PowN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Cmp_N2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1CmpN2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP1CmpN2 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Add_N1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1AddN1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1AddN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Sub_N1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1SubN1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1SubN1 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Mul_N1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MulN1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MulN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Min_N1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MinN1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MinN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Max_N1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MaxN1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MaxN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Gcd_N1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1GcdN1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1GcdN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Div_N1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1DivN1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1DivN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Rem_N1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1RemN1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1RemN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_PartialDiv_N1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1PartialDivN1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1PartialDivN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Pow_N1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1PowN1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1PowN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Cmp_N1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1CmpN1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP1CmpN1 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Add__0() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1Add_0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1Add_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Sub__0() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1Sub_0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1Sub_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Mul__0() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1Mul_0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1Mul_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Min__0() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1Min_0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1Min_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Max__0() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1Max_0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1Max_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Gcd__0() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1Gcd_0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1Gcd_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Pow__0() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1Pow_0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1Pow_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Cmp__0() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1Cmp_0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP1Cmp_0 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Add_P1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1AddP1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1AddP1 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Sub_P1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1SubP1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1SubP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Mul_P1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MulP1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MulP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Min_P1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MinP1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MinP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Max_P1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MaxP1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MaxP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Gcd_P1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1GcdP1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1GcdP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Div_P1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1DivP1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1DivP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Rem_P1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1RemP1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1RemP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_PartialDiv_P1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1PartialDivP1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1PartialDivP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Pow_P1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1PowP1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1PowP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Cmp_P1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1CmpP1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP1CmpP1 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Add_P2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1AddP2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1AddP2 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Sub_P2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1SubP2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1SubP2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Mul_P2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MulP2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MulP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Min_P2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MinP2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MinP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Max_P2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MaxP2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MaxP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Gcd_P2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1GcdP2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1GcdP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Div_P2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1DivP2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1DivP2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Rem_P2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1RemP2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1RemP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Pow_P2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1PowP2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1PowP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Cmp_P2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1CmpP2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP1CmpP2 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Add_P3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1AddP3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1AddP3 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Sub_P3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1SubP3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1SubP3 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Mul_P3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MulP3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MulP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Min_P3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MinP3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MinP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Max_P3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MaxP3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MaxP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Gcd_P3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1GcdP3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1GcdP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Div_P3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1DivP3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1DivP3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Rem_P3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1RemP3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1RemP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Pow_P3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1PowP3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1PowP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Cmp_P3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1CmpP3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP1CmpP3 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Add_P4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1AddP4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1AddP4 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Sub_P4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1SubP4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1SubP4 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Mul_P4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MulP4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MulP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Min_P4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MinP4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MinP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Max_P4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MaxP4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MaxP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Gcd_P4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1GcdP4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1GcdP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Div_P4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1DivP4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1DivP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Rem_P4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1RemP4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1RemP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Pow_P4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1PowP4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1PowP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Cmp_P4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1CmpP4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP1CmpP4 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Add_P5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P6 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1AddP5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP6\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1AddP5 as Integer\u003e::to_i64(), \u003cP6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Sub_P5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1SubP5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1SubP5 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Mul_P5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MulP5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MulP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Min_P5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MinP5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MinP5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Max_P5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MaxP5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MaxP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Gcd_P5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1GcdP5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1GcdP5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Div_P5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1DivP5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1DivP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Rem_P5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1RemP5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1RemP5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Pow_P5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1PowP5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1PowP5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Cmp_P5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1CmpP5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP1CmpP5 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Add_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2AddN5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2AddN5 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Sub_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P7 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2SubN5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP7\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2SubN5 as Integer\u003e::to_i64(), \u003cP7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Mul_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N10 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MulN5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN10\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MulN5 as Integer\u003e::to_i64(), \u003cN10 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Min_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MinN5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MinN5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Max_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MaxN5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MaxN5 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Gcd_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2GcdN5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2GcdN5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Div_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2DivN5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2DivN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Rem_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2RemN5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2RemN5 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Cmp_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2CmpN5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP2CmpN5 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Add_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2AddN4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2AddN4 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Sub_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P6 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2SubN4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP6\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2SubN4 as Integer\u003e::to_i64(), \u003cP6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Mul_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N8 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MulN4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN8\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MulN4 as Integer\u003e::to_i64(), \u003cN8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Min_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MinN4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MinN4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Max_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MaxN4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MaxN4 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Gcd_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2GcdN4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2GcdN4 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Div_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2DivN4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2DivN4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Rem_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2RemN4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2RemN4 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Cmp_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2CmpN4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP2CmpN4 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Add_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2AddN3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2AddN3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Sub_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2SubN3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2SubN3 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Mul_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N6 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MulN3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN6\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MulN3 as Integer\u003e::to_i64(), \u003cN6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Min_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MinN3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MinN3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Max_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MaxN3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MaxN3 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Gcd_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2GcdN3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2GcdN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Div_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2DivN3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2DivN3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Rem_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2RemN3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2RemN3 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Cmp_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2CmpN3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP2CmpN3 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Add_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2AddN2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2AddN2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Sub_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2SubN2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2SubN2 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Mul_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MulN2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MulN2 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Min_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MinN2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MinN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Max_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MaxN2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MaxN2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Gcd_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2GcdN2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2GcdN2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Div_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2DivN2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2DivN2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Rem_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2RemN2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2RemN2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_PartialDiv_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2PartialDivN2 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2PartialDivN2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Cmp_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2CmpN2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP2CmpN2 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Add_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2AddN1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2AddN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Sub_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2SubN1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2SubN1 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Mul_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MulN1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MulN1 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Min_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MinN1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MinN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Max_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MaxN1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MaxN1 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Gcd_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2GcdN1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2GcdN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Div_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2DivN1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2DivN1 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Rem_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2RemN1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2RemN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_PartialDiv_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2PartialDivN1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2PartialDivN1 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Cmp_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2CmpN1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP2CmpN1 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Add__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2Add_0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2Add_0 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Sub__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2Sub_0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2Sub_0 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Mul__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2Mul_0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2Mul_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Min__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2Min_0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2Min_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Max__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2Max_0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2Max_0 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Gcd__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2Gcd_0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2Gcd_0 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Pow__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2Pow_0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2Pow_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Cmp__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2Cmp_0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP2Cmp_0 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Add_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2AddP1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2AddP1 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Sub_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2SubP1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2SubP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Mul_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MulP1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MulP1 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Min_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MinP1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MinP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Max_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MaxP1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MaxP1 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Gcd_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2GcdP1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2GcdP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Div_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2DivP1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2DivP1 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Rem_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2RemP1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2RemP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_PartialDiv_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2PartialDivP1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2PartialDivP1 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Pow_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2PowP1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2PowP1 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Cmp_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2CmpP1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP2CmpP1 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Add_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2AddP2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2AddP2 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Sub_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2SubP2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2SubP2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Mul_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MulP2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MulP2 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Min_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MinP2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MinP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Max_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MaxP2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MaxP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Gcd_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2GcdP2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2GcdP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Div_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2DivP2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2DivP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Rem_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2RemP2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2RemP2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_PartialDiv_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2PartialDivP2 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2PartialDivP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Pow_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2PowP2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2PowP2 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Cmp_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2CmpP2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP2CmpP2 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Add_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2AddP3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2AddP3 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Sub_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2SubP3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2SubP3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Mul_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P6 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MulP3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP6\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MulP3 as Integer\u003e::to_i64(), \u003cP6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Min_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MinP3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MinP3 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Max_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MaxP3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MaxP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Gcd_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2GcdP3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2GcdP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Div_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2DivP3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2DivP3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Rem_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2RemP3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2RemP3 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Pow_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P8 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2PowP3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP8\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2PowP3 as Integer\u003e::to_i64(), \u003cP8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Cmp_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2CmpP3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP2CmpP3 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Add_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P6 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2AddP4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP6\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2AddP4 as Integer\u003e::to_i64(), \u003cP6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Sub_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2SubP4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2SubP4 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Mul_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P8 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MulP4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP8\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MulP4 as Integer\u003e::to_i64(), \u003cP8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Min_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MinP4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MinP4 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Max_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MaxP4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MaxP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Gcd_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2GcdP4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2GcdP4 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Div_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2DivP4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2DivP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Rem_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2RemP4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2RemP4 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Pow_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P16 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2PowP4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP16\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2PowP4 as Integer\u003e::to_i64(), \u003cP16 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Cmp_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2CmpP4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP2CmpP4 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Add_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P7 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2AddP5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP7\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2AddP5 as Integer\u003e::to_i64(), \u003cP7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Sub_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2SubP5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2SubP5 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Mul_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P10 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MulP5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP10\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MulP5 as Integer\u003e::to_i64(), \u003cP10 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Min_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MinP5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MinP5 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Max_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MaxP5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MaxP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Gcd_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2GcdP5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2GcdP5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Div_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2DivP5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2DivP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Rem_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2RemP5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2RemP5 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Pow_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P32 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2PowP5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP32\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2PowP5 as Integer\u003e::to_i64(), \u003cP32 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Cmp_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2CmpP5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP2CmpP5 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Add_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3AddN5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3AddN5 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Sub_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P8 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3SubN5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP8\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3SubN5 as Integer\u003e::to_i64(), \u003cP8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Mul_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N15 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MulN5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN15\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MulN5 as Integer\u003e::to_i64(), \u003cN15 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Min_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MinN5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MinN5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Max_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MaxN5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MaxN5 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Gcd_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3GcdN5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3GcdN5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Div_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3DivN5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3DivN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Rem_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3RemN5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3RemN5 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Cmp_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3CmpN5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP3CmpN5 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Add_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3AddN4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3AddN4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Sub_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P7 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3SubN4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP7\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3SubN4 as Integer\u003e::to_i64(), \u003cP7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Mul_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N12 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MulN4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN12\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MulN4 as Integer\u003e::to_i64(), \u003cN12 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Min_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MinN4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MinN4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Max_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MaxN4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MaxN4 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Gcd_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3GcdN4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3GcdN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Div_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3DivN4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3DivN4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Rem_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3RemN4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3RemN4 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Cmp_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3CmpN4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP3CmpN4 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Add_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3AddN3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3AddN3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Sub_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P6 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3SubN3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP6\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3SubN3 as Integer\u003e::to_i64(), \u003cP6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Mul_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N9 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MulN3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN9\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MulN3 as Integer\u003e::to_i64(), \u003cN9 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Min_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MinN3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MinN3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Max_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MaxN3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MaxN3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Gcd_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3GcdN3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3GcdN3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Div_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3DivN3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3DivN3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Rem_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3RemN3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3RemN3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_PartialDiv_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3PartialDivN3 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3PartialDivN3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Cmp_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3CmpN3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP3CmpN3 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Add_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3AddN2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3AddN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Sub_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3SubN2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3SubN2 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Mul_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N6 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MulN2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN6\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MulN2 as Integer\u003e::to_i64(), \u003cN6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Min_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MinN2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MinN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Max_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MaxN2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MaxN2 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Gcd_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3GcdN2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3GcdN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Div_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3DivN2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3DivN2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Rem_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3RemN2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3RemN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Cmp_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3CmpN2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP3CmpN2 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Add_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3AddN1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3AddN1 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Sub_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3SubN1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3SubN1 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Mul_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MulN1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MulN1 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Min_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MinN1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MinN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Max_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MaxN1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MaxN1 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Gcd_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3GcdN1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3GcdN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Div_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3DivN1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3DivN1 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Rem_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3RemN1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3RemN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_PartialDiv_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3PartialDivN1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3PartialDivN1 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Cmp_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3CmpN1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP3CmpN1 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Add__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3Add_0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3Add_0 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Sub__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3Sub_0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3Sub_0 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Mul__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3Mul_0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3Mul_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Min__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3Min_0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3Min_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Max__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3Max_0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3Max_0 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Gcd__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3Gcd_0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3Gcd_0 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Pow__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3Pow_0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3Pow_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Cmp__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3Cmp_0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP3Cmp_0 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Add_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3AddP1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3AddP1 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Sub_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3SubP1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3SubP1 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Mul_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MulP1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MulP1 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Min_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MinP1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MinP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Max_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MaxP1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MaxP1 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Gcd_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3GcdP1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3GcdP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Div_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3DivP1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3DivP1 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Rem_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3RemP1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3RemP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_PartialDiv_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3PartialDivP1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3PartialDivP1 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Pow_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3PowP1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3PowP1 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Cmp_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3CmpP1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP3CmpP1 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Add_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3AddP2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3AddP2 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Sub_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3SubP2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3SubP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Mul_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P6 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MulP2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP6\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MulP2 as Integer\u003e::to_i64(), \u003cP6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Min_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MinP2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MinP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Max_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MaxP2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MaxP2 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Gcd_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3GcdP2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3GcdP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Div_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3DivP2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3DivP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Rem_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3RemP2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3RemP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Pow_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P9 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3PowP2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP9\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3PowP2 as Integer\u003e::to_i64(), \u003cP9 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Cmp_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3CmpP2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP3CmpP2 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Add_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P6 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3AddP3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP6\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3AddP3 as Integer\u003e::to_i64(), \u003cP6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Sub_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3SubP3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3SubP3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Mul_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P9 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MulP3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP9\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MulP3 as Integer\u003e::to_i64(), \u003cP9 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Min_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MinP3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MinP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Max_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MaxP3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MaxP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Gcd_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3GcdP3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3GcdP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Div_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3DivP3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3DivP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Rem_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3RemP3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3RemP3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_PartialDiv_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3PartialDivP3 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3PartialDivP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Pow_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P27 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3PowP3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP27\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3PowP3 as Integer\u003e::to_i64(), \u003cP27 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Cmp_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3CmpP3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP3CmpP3 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Add_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P7 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3AddP4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP7\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3AddP4 as Integer\u003e::to_i64(), \u003cP7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Sub_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3SubP4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3SubP4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Mul_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P12 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MulP4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP12\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MulP4 as Integer\u003e::to_i64(), \u003cP12 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Min_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MinP4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MinP4 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Max_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MaxP4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MaxP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Gcd_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3GcdP4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3GcdP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Div_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3DivP4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3DivP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Rem_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3RemP4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3RemP4 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Pow_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P81 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3PowP4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP81\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3PowP4 as Integer\u003e::to_i64(), \u003cP81 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Cmp_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3CmpP4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP3CmpP4 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Add_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P8 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3AddP5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP8\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3AddP5 as Integer\u003e::to_i64(), \u003cP8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Sub_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3SubP5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3SubP5 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Mul_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P15 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MulP5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP15\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MulP5 as Integer\u003e::to_i64(), \u003cP15 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Min_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MinP5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MinP5 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Max_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MaxP5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MaxP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Gcd_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3GcdP5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3GcdP5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Div_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3DivP5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3DivP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Rem_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3RemP5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3RemP5 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Pow_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P243 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3PowP5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP243\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3PowP5 as Integer\u003e::to_i64(), \u003cP243 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Cmp_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3CmpP5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP3CmpP5 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Add_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4AddN5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4AddN5 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Sub_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P9 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4SubN5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP9\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4SubN5 as Integer\u003e::to_i64(), \u003cP9 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Mul_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N20 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MulN5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN20\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MulN5 as Integer\u003e::to_i64(), \u003cN20 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Min_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MinN5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MinN5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Max_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MaxN5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MaxN5 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Gcd_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4GcdN5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4GcdN5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Div_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4DivN5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4DivN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Rem_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4RemN5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4RemN5 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Cmp_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4CmpN5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP4CmpN5 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Add_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4AddN4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4AddN4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Sub_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P8 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4SubN4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP8\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4SubN4 as Integer\u003e::to_i64(), \u003cP8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Mul_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N16 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MulN4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN16\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MulN4 as Integer\u003e::to_i64(), \u003cN16 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Min_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MinN4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MinN4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Max_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MaxN4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MaxN4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Gcd_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4GcdN4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4GcdN4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Div_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4DivN4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4DivN4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Rem_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4RemN4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4RemN4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_PartialDiv_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4PartialDivN4 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4PartialDivN4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Cmp_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4CmpN4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP4CmpN4 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Add_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4AddN3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4AddN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Sub_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P7 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4SubN3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP7\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4SubN3 as Integer\u003e::to_i64(), \u003cP7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Mul_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N12 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MulN3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN12\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MulN3 as Integer\u003e::to_i64(), \u003cN12 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Min_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MinN3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MinN3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Max_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MaxN3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MaxN3 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Gcd_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4GcdN3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4GcdN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Div_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4DivN3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4DivN3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Rem_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4RemN3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4RemN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Cmp_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4CmpN3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP4CmpN3 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Add_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4AddN2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4AddN2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Sub_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P6 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4SubN2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP6\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4SubN2 as Integer\u003e::to_i64(), \u003cP6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Mul_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N8 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MulN2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN8\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MulN2 as Integer\u003e::to_i64(), \u003cN8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Min_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MinN2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MinN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Max_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MaxN2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MaxN2 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Gcd_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4GcdN2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4GcdN2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Div_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4DivN2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4DivN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Rem_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4RemN2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4RemN2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_PartialDiv_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4PartialDivN2 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4PartialDivN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Cmp_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4CmpN2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP4CmpN2 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Add_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4AddN1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4AddN1 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Sub_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4SubN1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4SubN1 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Mul_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MulN1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MulN1 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Min_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MinN1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MinN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Max_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MaxN1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MaxN1 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Gcd_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4GcdN1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4GcdN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Div_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4DivN1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4DivN1 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Rem_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4RemN1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4RemN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_PartialDiv_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4PartialDivN1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4PartialDivN1 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Cmp_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4CmpN1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP4CmpN1 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Add__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4Add_0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4Add_0 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Sub__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4Sub_0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4Sub_0 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Mul__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4Mul_0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4Mul_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Min__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4Min_0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4Min_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Max__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4Max_0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4Max_0 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Gcd__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4Gcd_0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4Gcd_0 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Pow__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4Pow_0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4Pow_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Cmp__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4Cmp_0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP4Cmp_0 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Add_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4AddP1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4AddP1 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Sub_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4SubP1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4SubP1 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Mul_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MulP1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MulP1 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Min_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MinP1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MinP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Max_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MaxP1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MaxP1 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Gcd_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4GcdP1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4GcdP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Div_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4DivP1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4DivP1 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Rem_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4RemP1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4RemP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_PartialDiv_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4PartialDivP1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4PartialDivP1 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Pow_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4PowP1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4PowP1 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Cmp_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4CmpP1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP4CmpP1 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Add_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P6 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4AddP2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP6\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4AddP2 as Integer\u003e::to_i64(), \u003cP6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Sub_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4SubP2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4SubP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Mul_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P8 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MulP2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP8\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MulP2 as Integer\u003e::to_i64(), \u003cP8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Min_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MinP2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MinP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Max_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MaxP2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MaxP2 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Gcd_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4GcdP2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4GcdP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Div_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4DivP2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4DivP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Rem_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4RemP2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4RemP2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_PartialDiv_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4PartialDivP2 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4PartialDivP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Pow_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P16 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4PowP2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP16\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4PowP2 as Integer\u003e::to_i64(), \u003cP16 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Cmp_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4CmpP2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP4CmpP2 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Add_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P7 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4AddP3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP7\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4AddP3 as Integer\u003e::to_i64(), \u003cP7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Sub_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4SubP3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4SubP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Mul_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P12 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MulP3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP12\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MulP3 as Integer\u003e::to_i64(), \u003cP12 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Min_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MinP3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MinP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Max_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MaxP3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MaxP3 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Gcd_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4GcdP3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4GcdP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Div_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4DivP3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4DivP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Rem_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4RemP3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4RemP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Pow_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P64 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4PowP3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP64\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4PowP3 as Integer\u003e::to_i64(), \u003cP64 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Cmp_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4CmpP3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP4CmpP3 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Add_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P8 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4AddP4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP8\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4AddP4 as Integer\u003e::to_i64(), \u003cP8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Sub_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4SubP4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4SubP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Mul_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P16 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MulP4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP16\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MulP4 as Integer\u003e::to_i64(), \u003cP16 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Min_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MinP4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MinP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Max_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MaxP4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MaxP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Gcd_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4GcdP4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4GcdP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Div_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4DivP4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4DivP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Rem_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4RemP4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4RemP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_PartialDiv_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4PartialDivP4 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4PartialDivP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Pow_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P256 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4PowP4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP256\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4PowP4 as Integer\u003e::to_i64(), \u003cP256 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Cmp_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4CmpP4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP4CmpP4 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Add_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P9 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4AddP5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP9\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4AddP5 as Integer\u003e::to_i64(), \u003cP9 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Sub_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4SubP5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4SubP5 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Mul_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P20 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MulP5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP20\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MulP5 as Integer\u003e::to_i64(), \u003cP20 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Min_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MinP5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MinP5 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Max_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MaxP5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MaxP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Gcd_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4GcdP5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4GcdP5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Div_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4DivP5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4DivP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Rem_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4RemP5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4RemP5 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Pow_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1024 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4PowP5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1024\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4PowP5 as Integer\u003e::to_i64(), \u003cP1024 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Cmp_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4CmpP5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP4CmpP5 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Add_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P5AddN5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5AddN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Sub_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P10 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5SubN5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP10\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5SubN5 as Integer\u003e::to_i64(), \u003cP10 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Mul_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N25 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MulN5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN25\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MulN5 as Integer\u003e::to_i64(), \u003cN25 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Min_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MinN5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MinN5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Max_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MaxN5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MaxN5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Gcd_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5GcdN5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5GcdN5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Div_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5DivN5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5DivN5 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Rem_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P5RemN5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5RemN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_PartialDiv_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5PartialDivN5 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5PartialDivN5 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Cmp_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5CmpN5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP5CmpN5 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Add_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5AddN4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5AddN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Sub_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P9 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5SubN4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP9\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5SubN4 as Integer\u003e::to_i64(), \u003cP9 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Mul_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N20 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MulN4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN20\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MulN4 as Integer\u003e::to_i64(), \u003cN20 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Min_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MinN4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MinN4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Max_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MaxN4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MaxN4 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Gcd_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5GcdN4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5GcdN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Div_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5DivN4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5DivN4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Rem_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5RemN4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5RemN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Cmp_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5CmpN4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP5CmpN4 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Add_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5AddN3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5AddN3 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Sub_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P8 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5SubN3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP8\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5SubN3 as Integer\u003e::to_i64(), \u003cP8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Mul_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N15 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MulN3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN15\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MulN3 as Integer\u003e::to_i64(), \u003cN15 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Min_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MinN3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MinN3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Max_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MaxN3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MaxN3 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Gcd_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5GcdN3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5GcdN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Div_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5DivN3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5DivN3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Rem_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5RemN3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5RemN3 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Cmp_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5CmpN3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP5CmpN3 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Add_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5AddN2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5AddN2 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Sub_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P7 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5SubN2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP7\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5SubN2 as Integer\u003e::to_i64(), \u003cP7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Mul_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N10 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MulN2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN10\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MulN2 as Integer\u003e::to_i64(), \u003cN10 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Min_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MinN2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MinN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Max_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MaxN2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MaxN2 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Gcd_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5GcdN2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5GcdN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Div_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5DivN2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5DivN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Rem_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5RemN2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5RemN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Cmp_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5CmpN2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP5CmpN2 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Add_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5AddN1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5AddN1 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Sub_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P6 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5SubN1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP6\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5SubN1 as Integer\u003e::to_i64(), \u003cP6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Mul_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MulN1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MulN1 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Min_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MinN1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MinN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Max_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MaxN1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MaxN1 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Gcd_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5GcdN1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5GcdN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Div_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5DivN1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5DivN1 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Rem_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P5RemN1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5RemN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_PartialDiv_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5PartialDivN1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5PartialDivN1 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Cmp_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5CmpN1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP5CmpN1 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Add__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5Add_0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5Add_0 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Sub__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5Sub_0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5Sub_0 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Mul__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P5Mul_0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5Mul_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Min__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P5Min_0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5Min_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Max__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5Max_0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5Max_0 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Gcd__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5Gcd_0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5Gcd_0 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Pow__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5Pow_0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5Pow_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Cmp__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P5Cmp_0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP5Cmp_0 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Add_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P6 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5AddP1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP6\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5AddP1 as Integer\u003e::to_i64(), \u003cP6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Sub_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5SubP1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5SubP1 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Mul_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MulP1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MulP1 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Min_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MinP1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MinP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Max_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MaxP1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MaxP1 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Gcd_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5GcdP1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5GcdP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Div_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5DivP1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5DivP1 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Rem_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P5RemP1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5RemP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_PartialDiv_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5PartialDivP1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5PartialDivP1 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Pow_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5PowP1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5PowP1 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Cmp_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5CmpP1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP5CmpP1 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Add_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P7 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5AddP2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP7\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5AddP2 as Integer\u003e::to_i64(), \u003cP7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Sub_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5SubP2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5SubP2 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Mul_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P10 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MulP2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP10\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MulP2 as Integer\u003e::to_i64(), \u003cP10 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Min_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MinP2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MinP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Max_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MaxP2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MaxP2 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Gcd_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5GcdP2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5GcdP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Div_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5DivP2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5DivP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Rem_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5RemP2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5RemP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Pow_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P25 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5PowP2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP25\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5PowP2 as Integer\u003e::to_i64(), \u003cP25 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Cmp_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5CmpP2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP5CmpP2 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Add_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P8 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5AddP3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP8\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5AddP3 as Integer\u003e::to_i64(), \u003cP8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Sub_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5SubP3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5SubP3 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Mul_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P15 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MulP3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP15\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MulP3 as Integer\u003e::to_i64(), \u003cP15 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Min_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MinP3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MinP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Max_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MaxP3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MaxP3 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Gcd_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5GcdP3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5GcdP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Div_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5DivP3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5DivP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Rem_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5RemP3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5RemP3 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Pow_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P125 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5PowP3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP125\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5PowP3 as Integer\u003e::to_i64(), \u003cP125 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Cmp_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5CmpP3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP5CmpP3 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Add_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P9 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5AddP4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP9\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5AddP4 as Integer\u003e::to_i64(), \u003cP9 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Sub_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5SubP4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5SubP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Mul_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P20 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MulP4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP20\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MulP4 as Integer\u003e::to_i64(), \u003cP20 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Min_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MinP4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MinP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Max_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MaxP4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MaxP4 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Gcd_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5GcdP4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5GcdP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Div_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5DivP4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5DivP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Rem_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5RemP4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5RemP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Pow_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P625 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5PowP4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP625\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5PowP4 as Integer\u003e::to_i64(), \u003cP625 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Cmp_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5CmpP4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP5CmpP4 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Add_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P10 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5AddP5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP10\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5AddP5 as Integer\u003e::to_i64(), \u003cP10 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Sub_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P5SubP5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5SubP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Mul_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P25 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MulP5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP25\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MulP5 as Integer\u003e::to_i64(), \u003cP25 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Min_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MinP5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MinP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Max_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MaxP5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MaxP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Gcd_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5GcdP5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5GcdP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Div_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5DivP5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5DivP5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Rem_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P5RemP5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5RemP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_PartialDiv_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5PartialDivP5 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5PartialDivP5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Pow_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P3125 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5PowP5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP3125\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5PowP5 as Integer\u003e::to_i64(), \u003cP3125 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Cmp_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5CmpP5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP5CmpP5 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Neg() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type NegN5 = \u003c\u003cA as Neg\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n    assert_eq!(\u003cNegN5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Abs() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type AbsN5 = \u003c\u003cA as Abs\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n    assert_eq!(\u003cAbsN5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Neg() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type NegN4 = \u003c\u003cA as Neg\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n    assert_eq!(\u003cNegN4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Abs() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type AbsN4 = \u003c\u003cA as Abs\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n    assert_eq!(\u003cAbsN4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Neg() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type NegN3 = \u003c\u003cA as Neg\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n    assert_eq!(\u003cNegN3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Abs() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type AbsN3 = \u003c\u003cA as Abs\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n    assert_eq!(\u003cAbsN3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Neg() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type NegN2 = \u003c\u003cA as Neg\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n    assert_eq!(\u003cNegN2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Abs() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type AbsN2 = \u003c\u003cA as Abs\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n    assert_eq!(\u003cAbsN2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Neg() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type NegN1 = \u003c\u003cA as Neg\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n    assert_eq!(\u003cNegN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Abs() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type AbsN1 = \u003c\u003cA as Abs\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n    assert_eq!(\u003cAbsN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Neg() {\n    type A = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type Neg_0 = \u003c\u003cA as Neg\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n    assert_eq!(\u003cNeg_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Abs() {\n    type A = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type Abs_0 = \u003c\u003cA as Abs\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n    assert_eq!(\u003cAbs_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Neg() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type NegP1 = \u003c\u003cA as Neg\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n    assert_eq!(\u003cNegP1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Abs() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type AbsP1 = \u003c\u003cA as Abs\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n    assert_eq!(\u003cAbsP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Neg() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type NegP2 = \u003c\u003cA as Neg\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n    assert_eq!(\u003cNegP2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Abs() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type AbsP2 = \u003c\u003cA as Abs\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n    assert_eq!(\u003cAbsP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Neg() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type NegP3 = \u003c\u003cA as Neg\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n    assert_eq!(\u003cNegP3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Abs() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type AbsP3 = \u003c\u003cA as Abs\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n    assert_eq!(\u003cAbsP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Neg() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type NegP4 = \u003c\u003cA as Neg\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n    assert_eq!(\u003cNegP4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Abs() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type AbsP4 = \u003c\u003cA as Abs\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n    assert_eq!(\u003cAbsP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Neg() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type NegP5 = \u003c\u003cA as Neg\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n    assert_eq!(\u003cNegP5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Abs() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type AbsP5 = \u003c\u003cA as Abs\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n    assert_eq!(\u003cAbsP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","bin","coverage_report.rs"],"content":"//! This script runs `cargo tarpaulin` and opens the generated HTML report in the default browser.\r\n//! Used to regenerate the code-coverage report\r\n\r\nuse std::process::Command;\r\n\r\nfn run_command(cmd: \u0026str) {\r\n    let mut parts = cmd.split_whitespace().collect::\u003cVec\u003c_\u003e\u003e();\r\n    let cmd = parts.remove(0);\r\n\r\n    let mut child = Command::new(cmd)\r\n        .args(\u0026parts)\r\n        .spawn()\r\n        .expect(\"Failed to start command\");\r\n    let ecode = child.wait().expect(\"Failed to wait on command\");\r\n    assert!(ecode.success());\r\n}\r\n\r\nfn main() {\r\n    // run `cargo tarpaulin -ohtml`\r\n    // open `tarpaulin-report.html` in your browser\r\n    run_command(\"cargo tarpaulin -ohtml\");\r\n    run_command(\"open tarpaulin-report.html\");\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","bin","generate_docs","main.rs"],"content":"//! This is a simple binary that generates the documentation for the Lavendeux parser.\r\n//! Regenerates the contents of `documentation.md`, and `documentation.html`\r\nuse lavendeux_parser::Lavendeux;\r\nuse std::process::Command;\r\n\r\nfn run_command(cmd: \u0026str) {\r\n    let mut parts = cmd.split_whitespace().collect::\u003cVec\u003c_\u003e\u003e();\r\n    let cmd = parts.remove(0);\r\n\r\n    let mut child = Command::new(cmd)\r\n        .args(\u0026parts)\r\n        .spawn()\r\n        .expect(\"Failed to start command\");\r\n    let ecode = child.wait().expect(\"Failed to wait on command\");\r\n    assert!(ecode.success());\r\n}\r\n\r\nfn main() {\r\n    let parser = Lavendeux::new(Default::default());\r\n    let docs = parser.generate_documentation();\r\n    std::fs::write(\"documentation.md\", docs).expect(\"Failed to write documentation.md\");\r\n    run_command(\"rustdoc documentation.md --o ./ --html-before-content=src/bin/generate_docs/documentation_template.html\")\r\n}\r\n","traces":[{"line":6,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":7,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":8,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":10,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":11,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":12},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","documentation","markdown.rs"],"content":"use super::{operator_documentation, DocumentationFormatter, FunctionsByCategory};\r\n\r\n#[allow(dead_code)]\r\nenum MarkdownSnippet {\r\n    H1(String),\r\n    H2(String),\r\n    H3(String),\r\n    H4(String),\r\n\r\n    CodeBlock(String),\r\n    CodeInline(String),\r\n\r\n    Text(String),\r\n}\r\nimpl std::fmt::Display for MarkdownSnippet {\r\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\r\n        match self {\r\n            MarkdownSnippet::H1(s) =\u003e write!(f, \"# {}\", s.trim()),\r\n            MarkdownSnippet::H2(s) =\u003e write!(f, \"## {}\", s.trim()),\r\n            MarkdownSnippet::H3(s) =\u003e write!(f, \"### {}\", s.trim()),\r\n            MarkdownSnippet::H4(s) =\u003e write!(f, \"#### {}\", s.trim()),\r\n            MarkdownSnippet::CodeBlock(s) =\u003e write!(f, \"```lavendeux\\n{}\\n```\", s.trim()),\r\n            MarkdownSnippet::CodeInline(s) =\u003e write!(f, \"`{}`\", s.trim()),\r\n            MarkdownSnippet::Text(s) =\u003e write!(f, \"{}\", s),\r\n        }?;\r\n        writeln!(f)\r\n    }\r\n}\r\n\r\npub struct MarkdownFormatter;\r\nimpl DocumentationFormatter for MarkdownFormatter {\r\n    //\r\n    // Functions\r\n    //\r\n\r\n    fn format_function(\u0026self, state: \u0026crate::State, name: \u0026str) -\u003e Option\u003cString\u003e {\r\n        let function = state.get_function(name)?;\r\n        let mut pieces = Vec::new();\r\n\r\n        pieces.push(MarkdownSnippet::H3(function.name().to_string()));\r\n        pieces.push(MarkdownSnippet::CodeBlock(function.signature().to_string()));\r\n\r\n        if let Some(desc) = function.documentation().description() {\r\n            pieces.push(MarkdownSnippet::Text(desc.to_string()));\r\n        }\r\n        if let Some(ext_desc) = function.documentation().ext_description() {\r\n            for line in ext_desc.split('\\n') {\r\n                pieces.push(MarkdownSnippet::Text(line.to_string() + \"  \"));\r\n            }\r\n        }\r\n        if let Some(examples) = function.documentation().examples() {\r\n            let examples = examples.trim_start_matches(\"#skip\").trim();\r\n            if !examples.is_empty() {\r\n                pieces.push(MarkdownSnippet::Text(\"**Examples:**  \".to_string()));\r\n                pieces.push(MarkdownSnippet::CodeBlock(examples.to_string()));\r\n            }\r\n        }\r\n\r\n        Some(\r\n            pieces\r\n                .iter()\r\n                .map(|p| p.to_string())\r\n                .collect::\u003cVec\u003c_\u003e\u003e()\r\n                .join(\"\"),\r\n        )\r\n    }\r\n\r\n    fn format_function_category(\u0026self, state: \u0026crate::State, category: \u0026str) -\u003e Option\u003cString\u003e {\r\n        let functions = state.functions_by_category();\r\n        let key = functions\r\n            .keys()\r\n            .find(|k| k.to_lowercase() == category.to_lowercase())?;\r\n        let functions = functions.get(key)?;\r\n\r\n        let mut output = Vec::new();\r\n\r\n        for f in functions {\r\n            output.push(self.format_function(state, f.name())?);\r\n        }\r\n\r\n        Some(output.join(\"\\n------------\\n\"))\r\n    }\r\n\r\n    fn format_function_list(\u0026self, state: \u0026crate::State) -\u003e String {\r\n        let categories = state.functions_by_category();\r\n        let mut output = vec![];\r\n\r\n        let mut sorted_categories: Vec\u003c_\u003e = categories.keys().collect();\r\n        sorted_categories.sort();\r\n\r\n        for category in sorted_categories {\r\n            output.push(MarkdownSnippet::H2(category.to_string() + \" Functions\"));\r\n            output.push(MarkdownSnippet::Text(\r\n                self.format_function_category(state, category)\r\n                    .unwrap_or_default(),\r\n            ));\r\n        }\r\n\r\n        output\r\n            .iter()\r\n            .map(|p| p.to_string())\r\n            .collect::\u003cVec\u003c_\u003e\u003e()\r\n            .join(\"\")\r\n    }\r\n\r\n    //\r\n    // Section Loaders\r\n    //\r\n\r\n    fn format_operators(\u0026self) -\u003e String {\r\n        let mut output = vec![];\r\n        let mut operators = operator_documentation::all();\r\n        operators.sort_by(|a, b| a.name.cmp(b.name));\r\n\r\n        for operator in operators {\r\n            output.push(MarkdownSnippet::H2(operator.name.to_string()));\r\n\r\n            let symbols = operator.symbols.join(\", \");\r\n            output.push(MarkdownSnippet::Text(format!(\"`[{}]`  \", symbols)));\r\n\r\n            output.push(MarkdownSnippet::Text(operator.description.to_string()));\r\n\r\n            output.push(MarkdownSnippet::Text(\"**Examples:**  \".to_string()));\r\n            output.push(MarkdownSnippet::CodeBlock(operator.examples.to_string()));\r\n        }\r\n\r\n        output\r\n            .iter()\r\n            .map(|p| p.to_string())\r\n            .collect::\u003cVec\u003c_\u003e\u003e()\r\n            .join(\"\")\r\n    }\r\n\r\n    fn format_title(\u0026self, title: \u0026str) -\u003e String {\r\n        MarkdownSnippet::H1(title.to_string()).to_string()\r\n    }\r\n\r\n    fn format_subtitle(\u0026self, title: \u0026str) -\u003e String {\r\n        MarkdownSnippet::H2(title.to_string()).to_string()\r\n    }\r\n\r\n    fn format_subsubtitle(\u0026self, title: \u0026str) -\u003e String {\r\n        MarkdownSnippet::H3(title.to_string()).to_string()\r\n    }\r\n\r\n    fn format_text(\u0026self, text: \u0026str) -\u003e String {\r\n        MarkdownSnippet::Text(text.to_string()).to_string()\r\n    }\r\n}\r\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":1324},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":1324},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":129},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":287},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":863},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":1324},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":129},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":258},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":129},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":258},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":562},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":281},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":258},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":129},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":129},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":129},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":129},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":129},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":1055},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":98},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":270},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":37},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":88},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":146},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":225},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":225},"fn_name":null}],"covered":57,"coverable":64},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","documentation","mod.rs"],"content":"use crate::{functions::ParserFunction, State};\r\nuse std::collections::HashMap;\r\n\r\nmod plain;\r\npub use plain::PlaintextFormatter;\r\n\r\nmod markdown;\r\npub use markdown::MarkdownFormatter;\r\n\r\n#[macro_use]\r\nmod operator_documentation;\r\npub use operator_documentation::OperatorDocumentation;\r\n\r\nmod static_docs;\r\npub use static_docs::DocumentationTemplate;\r\n\r\npub trait FunctionsByCategory {\r\n    fn functions_by_category(\u0026self) -\u003e HashMap\u003cString, Vec\u003c\u0026dyn ParserFunction\u003e\u003e;\r\n}\r\n\r\nimpl FunctionsByCategory for State {\r\n    fn functions_by_category(\u0026self) -\u003e HashMap\u003cString, Vec\u003c\u0026dyn ParserFunction\u003e\u003e {\r\n        let mut categories: HashMap\u003cString, Vec\u003c\u0026dyn ParserFunction\u003e\u003e = HashMap::new();\r\n        for (_, function) in self.all_functions().iter() {\r\n            if function.name().starts_with(\"__\") {\r\n                // Skip hidden functions\r\n                continue;\r\n            }\r\n\r\n            if !categories.contains_key(function.documentation().category()) {\r\n                categories.insert(function.documentation().category().to_string(), Vec::new());\r\n            }\r\n            categories\r\n                .get_mut(function.documentation().category())\r\n                .unwrap()\r\n                .push(function.as_ref());\r\n        }\r\n\r\n        for (_, functions) in categories.iter_mut() {\r\n            functions.sort_by(|f1, f2| f1.name().cmp(f2.name()));\r\n        }\r\n        categories\r\n    }\r\n}\r\n\r\npub trait DocumentationFormatter {\r\n    /// A single function including extended descriptions and examples\r\n    fn format_function(\u0026self, state: \u0026State, name: \u0026str) -\u003e Option\u003cString\u003e;\r\n\r\n    /// A more focussed list of functions including extended descriptions\r\n    fn format_function_category(\u0026self, state: \u0026State, category: \u0026str) -\u003e Option\u003cString\u003e;\r\n\r\n    /// A general list of function signatures and short descriptions\r\n    fn format_function_list(\u0026self, state: \u0026State) -\u003e String;\r\n\r\n    //\r\n    // Section Documentation\r\n    //\r\n\r\n    fn format_operators(\u0026self) -\u003e String;\r\n\r\n    fn format_functions(\u0026self, state: \u0026State, search: Option\u003c\u0026str\u003e) -\u003e String {\r\n        if let Some(search) = search {\r\n            if let Some(s) = self.format_function(state, search) {\r\n                s\r\n            } else if let Some(s) = self.format_function_category(state, search) {\r\n                s\r\n            } else {\r\n                format!(\"No function or category found for '{}'\", search)\r\n            }\r\n        } else {\r\n            self.format_function_list(state)\r\n        }\r\n    }\r\n\r\n    //\r\n    // Global\r\n    //\r\n\r\n    fn format_title(\u0026self, title: \u0026str) -\u003e String;\r\n    fn format_subtitle(\u0026self, title: \u0026str) -\u003e String;\r\n    fn format_subsubtitle(\u0026self, title: \u0026str) -\u003e String;\r\n    fn format_text(\u0026self, text: \u0026str) -\u003e String;\r\n}\r\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":1834},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":1820},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":1974},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":168},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":1806},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":1806},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":1806},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":350},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":7005},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":20,"coverable":21},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","documentation","operator_documentation.rs"],"content":"use crate::pest::Rule;\r\npub struct OperatorDocumentation {\r\n    pub rules: \u0026'static [Rule],\r\n    pub name: \u0026'static str,\r\n    pub symbols: \u0026'static [\u0026'static str],\r\n\r\n    pub description: \u0026'static str,\r\n    pub examples: \u0026'static str,\r\n}\r\n\r\ninventory::collect!(OperatorDocumentation);\r\npub fn all() -\u003e Vec\u003c\u0026'static OperatorDocumentation\u003e {\r\n    let mut all: Vec\u003c_\u003e = inventory::iter::\u003cOperatorDocumentation\u003e\r\n        .into_iter()\r\n        .collect();\r\n    all.sort_by(|a, b| a.name.cmp(b.name));\r\n    all\r\n}\r\n\r\n/// Generates a documentation entry for an operator\r\nmacro_rules! document_operator {\r\n    (\r\n        name = $name:literal,\r\n        rules = [$($rule:ident),*],\r\n        symbols = [$($symbol:literal),*],\r\n        description = $description:literal,\r\n        examples = $examples:literal$(,)?\r\n    ) =\u003e {\r\n        inventory::submit! {\r\n            crate::documentation::OperatorDocumentation {\r\n                name: $name,\r\n                rules: \u0026[$(Rule::$rule),*],\r\n                symbols: \u0026[$($symbol),*],\r\n                description: indoc::indoc! { $description },\r\n                examples: indoc::indoc! { $examples }\r\n            }\r\n        }\r\n    };\r\n}\r\n\r\n#[cfg(test)]\r\nmod test {\r\n    use crate::{error::ErrorDetails, Error};\r\n\r\n    use super::*;\r\n\r\n    #[test]\r\n    fn test_all_rules_documented() {\r\n        let docs = all();\r\n        let mut errors = vec![];\r\n\r\n        for operator in docs {\r\n            let result = crate::Lavendeux::new(Default::default()).parse(operator.examples);\r\n            if let Err(e) = result {\r\n                errors.push(Error {\r\n                    details: ErrorDetails::Custom {\r\n                        msg: format!(\"{} Example Error\", operator.name),\r\n                    },\r\n                    source: Some(Box::new(e)),\r\n                    context: None,\r\n                });\r\n            }\r\n        }\r\n        for error in \u0026errors {\r\n            eprintln!(\"{}\\n\", error);\r\n        }\r\n\r\n        assert!(\r\n            errors.is_empty(),\r\n            \"{} errors found in operator documentation\",\r\n            errors.len()\r\n        );\r\n    }\r\n}\r\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":250},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":2},"fn_name":null}],"covered":4,"coverable":4},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","documentation","plain.rs"],"content":"use super::{DocumentationFormatter, FunctionsByCategory};\r\nuse crate::State;\r\n\r\npub struct PlaintextFormatter;\r\nimpl PlaintextFormatter {\r\n    fn draw_cool_box(title: \u0026str, lines: \u0026Vec\u003cString\u003e) -\u003e String {\r\n        let mut max_length = 0;\r\n        for line in lines.iter() {\r\n            if line.len() \u003e max_length {\r\n                max_length = line.len();\r\n            }\r\n        }\r\n        if title.len() \u003e max_length {\r\n            max_length = title.len();\r\n        }\r\n\r\n        // pad to max_length+1\r\n        let title = format!(\"{: \u003cwidth$}\", title, width = max_length + 1);\r\n\r\n        let mut output = format!(\"{}\\n\", \"\".repeat(max_length + 2));\r\n        output += \u0026format!(\" {}\\n\", title);\r\n        output += \u0026format!(\"{}\\n\", \"\".repeat(max_length + 2));\r\n        for line in lines {\r\n            output += \u0026format!(\" {: \u003cwidth$}\\n\", line, width = max_length + 1);\r\n        }\r\n        output += \u0026format!(\"{}\\n\", \"\".repeat(max_length + 2));\r\n\r\n        output\r\n    }\r\n}\r\nimpl DocumentationFormatter for PlaintextFormatter {\r\n    //\r\n    // Functions\r\n    //\r\n\r\n    fn format_function(\u0026self, state: \u0026State, name: \u0026str) -\u003e Option\u003cString\u003e {\r\n        let function = state.get_function(name)?;\r\n        let mut lines = Vec::new();\r\n        if let Some(desc) = function.documentation().description() {\r\n            lines.push(desc.to_string());\r\n        }\r\n        if let Some(ext_desc) = function.documentation().ext_description() {\r\n            for line in ext_desc.split('\\n') {\r\n                lines.push(line.to_string());\r\n            }\r\n        }\r\n        if let Some(examples) = function.documentation().examples() {\r\n            let examples = examples.trim_start_matches(\"#skip\").trim();\r\n            if !examples.is_empty() {\r\n                lines.push(\"Examples:\".to_string());\r\n                for line in examples.split('\\n') {\r\n                    lines.push(format!(\"  {}\", line));\r\n                }\r\n            }\r\n        }\r\n\r\n        Some(Self::draw_cool_box(\u0026function.signature(), \u0026lines))\r\n    }\r\n\r\n    fn format_function_category(\u0026self, state: \u0026State, category: \u0026str) -\u003e Option\u003cString\u003e {\r\n        let functions = state.functions_by_category();\r\n        let key = functions\r\n            .keys()\r\n            .find(|k| k.to_lowercase() == category.to_lowercase())?;\r\n        let functions = functions.get(key)?;\r\n\r\n        let mut output = Vec::new();\r\n\r\n        for f in functions {\r\n            let mut lines = Vec::new();\r\n            if let Some(desc) = f.documentation().description() {\r\n                lines.push(desc.to_string());\r\n            }\r\n            if let Some(ext_desc) = f.documentation().ext_description() {\r\n                for line in ext_desc.split('\\n') {\r\n                    lines.push(line.to_string());\r\n                }\r\n            }\r\n\r\n            if lines.is_empty() {\r\n                output.push(f.signature());\r\n            } else {\r\n                output.push(Self::draw_cool_box(\u0026f.signature(), \u0026lines));\r\n            }\r\n        }\r\n\r\n        Some(output.join(\"\\n\"))\r\n    }\r\n\r\n    fn format_function_list(\u0026self, state: \u0026State) -\u003e String {\r\n        let categories = state.functions_by_category();\r\n        let mut output = Vec::new();\r\n\r\n        let mut sorted_categories: Vec\u003c_\u003e = categories.keys().collect();\r\n        sorted_categories.sort();\r\n\r\n        for category in sorted_categories {\r\n            let functions = categories.get(category).unwrap();\r\n            let lines = functions\r\n                .iter()\r\n                .map(|f| match f.documentation().description() {\r\n                    Some(desc) =\u003e format!(\"{} : {}\", f.signature(), desc),\r\n                    None =\u003e f.signature(),\r\n                })\r\n                .collect();\r\n            output.push(Self::draw_cool_box(category, \u0026lines));\r\n        }\r\n\r\n        output.join(\"\\n\")\r\n    }\r\n\r\n    //\r\n    // Section Loaders\r\n    //\r\n\r\n    fn format_operators(\u0026self) -\u003e String {\r\n        todo!()\r\n    }\r\n\r\n    fn format_title(\u0026self, title: \u0026str) -\u003e String {\r\n        format!(\"{}\\n{}\", title, \"=\".repeat(title.len()))\r\n    }\r\n\r\n    fn format_subtitle(\u0026self, title: \u0026str) -\u003e String {\r\n        format!(\"{}\\n{}\", title, \"-\".repeat(title.len()))\r\n    }\r\n\r\n    fn format_subsubtitle(\u0026self, title: \u0026str) -\u003e String {\r\n        format!(\"{}\\n\\n\", title)\r\n    }\r\n\r\n    fn format_text(\u0026self, text: \u0026str) -\u003e String {\r\n        text.to_string()\r\n    }\r\n}\r\n","traces":[{"line":6,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":7,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":8,"address":[],"length":0,"stats":{"Line":141},"fn_name":null},{"line":9,"address":[],"length":0,"stats":{"Line":166},"fn_name":null},{"line":10,"address":[],"length":0,"stats":{"Line":50},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":373},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":116},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":47},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":46},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":156},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":38,"coverable":62},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","documentation","static_docs.rs"],"content":"use lazy_static::lazy_static;\r\nuse serde_json::{json, Value};\r\n\r\nuse super::DocumentationFormatter;\r\n\r\npub struct DocumentationTemplate(Box\u003cdyn DocumentationFormatter\u003e);\r\nimpl DocumentationTemplate {\r\n    const FUNCTION_TITLE: \u0026'static str = \"Functions\";\r\n    const OPERATOR_TITLE: \u0026'static str = \"Operators and Syntax\";\r\n\r\n    pub fn new(formatter: impl DocumentationFormatter + 'static) -\u003e Self {\r\n        Self(Box::new(formatter))\r\n    }\r\n\r\n    pub fn render_functions(\u0026self, state: \u0026crate::State, search: Option\u003c\u0026str\u003e) -\u003e String {\r\n        self.0.format_functions(state, search)\r\n    }\r\n\r\n    pub fn render_operators(\u0026self) -\u003e String {\r\n        self.0.format_operators()\r\n    }\r\n\r\n    pub fn render_values(\u0026self) -\u003e String {\r\n        let mut output = String::new();\r\n\r\n        let sections = VALUE_SECTION_DATA[\"contents\"].as_array().unwrap().iter();\r\n        for section in sections {\r\n            output += \u0026self.0.format_title(section[\"section\"].as_str().unwrap());\r\n            output += \u0026section[\"text\"]\r\n                .as_str()\r\n                .unwrap()\r\n                .split('\\n')\r\n                .map(|s| self.0.format_text(s.trim()))\r\n                .collect::\u003cString\u003e();\r\n        }\r\n\r\n        output\r\n    }\r\n\r\n    pub fn render(\u0026self, state: \u0026crate::State) -\u003e String {\r\n        let mut output = String::new();\r\n        output += \u0026self.render_values();\r\n        output += \"\\n\\n------------\\n\\n\";\r\n\r\n        output += \u0026self.0.format_title(Self::OPERATOR_TITLE);\r\n        output += \u0026self.render_operators();\r\n        output += \"\\n\\n------------\\n\\n\";\r\n\r\n        output += \u0026self.0.format_title(Self::FUNCTION_TITLE);\r\n        output += \u0026self.render_functions(state, None);\r\n\r\n        output\r\n    }\r\n}\r\n\r\nlazy_static! {\r\n    pub static ref VALUE_SECTION_DATA: Value = json!({\r\n        \"contents\": [\r\n            {\r\n                \"section\": \"Lavendeux Documentation\",\r\n                \"text\": \"\r\n                    Lavendish a language designed to manipulate values with concise, single-line expressions.\r\n                    It was created for use in Lavendeux (\u003chttps://rscarson.github.io/lavendeux/\u003e).\r\n\r\n                    Inputs are a series of expressions separated by a newline, or a `;`.\r\n                    Expressions can optionally end with an @decorator to format the output as a string\r\n\r\n                    Key features:\r\n                    - Functions ([reference](\u003c#function-assignment\u003e))\r\n                    - @Decorators ([reference](\u003c#decorator\u003e))\r\n                    - Seamless type conversion ([reference](\u003c#the-type-system\u003e))\r\n                \"\r\n            },\r\n\r\n            {\r\n                \"section\": \"The Type System\",\r\n                \"text\": \"\r\n                    All expressions in Lavendeux must return a value of a specific type.\r\n                    These types can be broadly categorized as `numeric`, `collection`, or `string`.\r\n\r\n                    The type of a given expression is calculated on a hierarchy, based on the 'specificity' of the types involved.\r\n                    The hierarchy is as follows (from lowest to highest priority):  \r\n                    - Bool\r\n                    - Int (in order, `u8, i8, u16, i16, u32, i32, u64, i64`)\r\n                    - Float\r\n                    - Fixed, then Currency\r\n                    - String\r\n                    - Array, then Object\r\n\r\n                    Note that range is not included, since it can only be compared to itself, or to arrays.\r\n\r\n                    So for example, if you add an int to a float, the result will be a float.\r\n                    Some types can also be grouped together, like `int` (see aboove), or `numeric` (which includes all numeric types), \r\n                    and `collection` (which includes range, string, array and object). 'any' is the implicit type that includes everything.\r\n\r\n                    The names of the types, for the most part, are self-explanatory, but here's a quick rundown:\r\n                    `bool` - A single-bit truth value\r\n                    `int` - A signed or unsigned integer of various sizes (`u8` to `i64`)\r\n                    `float` - A 64bit floating-point number\r\n                    `fixed` - A fixed-point decimal value\r\n                    `currency` - A fixed-point decimal value with a currency symbol and set precision\r\n                    `array` - An ordered collection of values, indexed by integers\r\n                    `object` - An unordered collection of key-value pairs\r\n                    `range` - An inclusive range of integers\r\n                    `string` - A sequence of characters\r\n                    `numeric` - The implicit type that includes all numeric types, and `bool`\r\n                    `collection` - The implicit type that includes all collection types\r\n                    `any` - The implicit type that includes everything\r\n\r\n                    --------\r\n\r\n                    ## bool\r\n                    The `bool` type is a single-bit truth value, and can be either `true` or `false`.\r\n                    In arithmetic operations, `true` is equivalent to `1`, and `false` is equivalent to `0`; operations are performed as if on a wrapping 1-bit integer.\r\n                    \r\n                    **Casting:**  \r\n                    It can be cast from any type; and truth is determined by equivalence to 0, or by emptiness, depending on the type.\r\n\r\n                    **Formatting:**  \r\n                    When cast to a string, it will be formatted as `true` or `false`.\r\n\r\n                    **Examples:**\r\n                    ```lavendeux\r\n                    1 as bool; // true\r\n                    [] as bool; // false\r\n                    ```\r\n\r\n                    ## int\r\n                    Covering the types from `u8` to `i64`, `int` is a signed or unsigned integer of various sizes.\r\n                    Integers can be written in decimal, binary, octal, or hexadecimal, with an optional suffix to specify the type.\r\n                    If no suffix is provided, the type defaults to i64.\r\n\r\n                    **Casting:**\r\n                    It can be cast from and to any type, and from any numeric type.\r\n\r\n                    **Formatting:**  \r\n                    When cast to a string, it will be formatted as a decimal number. For other formatting options, see [decorators](\u003c#decorators-functions\u003e).\r\n\r\n                    **Examples:**\r\n                    ```lavendeux\r\n                    0xFFu8; // 255\r\n                    0o77i16; // 63\r\n                    077; // 63\r\n                    0b1010_1010_1010_1010i32; // 43690\r\n                    38_000; // 38,000\r\n                    ```\r\n\r\n                    ## float\r\n                    A 64bit floating-point number, `float` can be written in decimal, or in scientific notation.\r\n\r\n                    **Casting:**\r\n                    It can be cast from and to any type, and from any numeric type.\r\n\r\n                    **Formatting:**  \r\n                    When cast to a string, it will be formatted as a decimal number. For other formatting options, see [decorators](\u003c#decorators-functions\u003e).\r\n\r\n                    **Examples:**\r\n                    ```lavendeux\r\n                    1.0; // 1.0\r\n                    .2; // 0.2\r\n                    3e+7; // 30,000,000\r\n                    ```\r\n\r\n                    ## fixed\r\n                    A fixed-point decimal value. Fixed literals are suffixed with `D`.\r\n\r\n                    Note that fixed-point exponentiation is not supported, and will result in an implicit cast to float.\r\n\r\n                    **Casting:**\r\n                    It can be cast from and to any type, and from any numeric type.\r\n\r\n                    **Formatting:**  \r\n                    When cast to a string, it will appear similar to int or float, depending on the decimal precision of the value.\r\n\r\n                    **Examples:**\r\n                    ```lavendeux\r\n                    1.22D; // 1.22\r\n                    4D; // 4\r\n                    ```\r\n\r\n                    ## currency\r\n                    A fixed-point decimal value with a currency symbol and set precision. Arithmetic operations will maintain the currency symbol only if both operands share the same one, and will use the larger precision.\r\n\r\n                    **Casting:**\r\n                    It can be cast from and to any type, and from any numeric type.\r\n\r\n                    **Formatting:**  \r\n                    When cast to a string, it will appear similar to fixed, but with the currency symbol.\r\n\r\n                    **Examples:**\r\n                    ```lavendeux\r\n                    $1.00 + 1; // $1.00\r\n                    $2.00 + 1.000; // 3.000\r\n                    3; // 3\r\n                    ```\r\n\r\n                    **Supported currency symbols:**\r\n\r\n                    ```text\r\n                    $ |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |\r\n                     |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |\r\n                     |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |\r\n                     |  | \r\n                    ```\r\n\r\n                    ## array\r\n                    An ordered collection of values, indexed by integers. Values can be a mix of types.\r\n\r\n                    **Casting:**\r\n                    It can be cast from any type; and will result in a single-value array - `A as array` is equivalent to `[A]`.\r\n                    When cast to any non-collection type, it will extract the single value, if the array has a length of 1 - `['a'] as int` would result in `a`.\r\n                    Casting a larger array to a non-collection type will result in an error.\r\n                    Casting array to object will result in an object with integer keys, and the values of the array.\r\n                    Casting range to array will result in an array of the range values (very large ranges may result in an error).\r\n\r\n                    **Formatting:**  \r\n                    When cast to a string, it will be formatted as a comma-separated list of values, enclosed in square brackets.\r\n\r\n                    **Examples:**\r\n                    ```lavendeux\r\n                    [1, 2, 3]; // [1, 2, 3]\r\n                    [1] as int; // 1\r\n                    [1, 2, 3] as object; // {0: 1, 1: 2, 2: 3}\r\n                    1..3 as array; // [1, 2, 3]\r\n                    ```\r\n\r\n                    ## object\r\n                    An unordered collection of key-value pairs, where keys are any non-collection type and values can be a mix of types.\r\n                    Unlike boolean comparison operators (see \u003c#boolean\u003e), key comparison is type-sensitive - `{1: 2} == {'1': 2}` would be false.\r\n\r\n                    **Casting:**\r\n                    It can be cast from any type; and will result in a single-value object - `A as object` is equivalent to `{0: A}`.\r\n                    This is the same as casting to array, then to object.\r\n                    When cast to any non-collection type, it will extract the single value, if the object has a length of 1 - `{0: 'a'} as int` would result in `a`.\r\n                    Casting a larger object to a non-collection type will result in an error.\r\n                    Casting object to array will result in an array of the object values.\r\n\r\n                    **Formatting:**  \r\n                    When cast to a string, it will be formatted as a comma-separated list of key-value pairs, enclosed in curly brackets.\r\n\r\n                    **Examples:**\r\n                    ```lavendeux\r\n                    {1: 2}; // {1: 2}\r\n                    {1: 2} as array; // [2]\r\n                    {1: 2} as int; // 2\r\n                    {1: 2} as string; // \\\"{1: 2}\\\"\r\n                    ```\r\n\r\n                    ## range\r\n                    An inclusive range of integers, with a start and end value. Start and end can be single characters, or any numeric type.\r\n                    \r\n                    **Casting:**\r\n                    Ranges cannot be cast from any type, and can only be cast to an array.\r\n\r\n                    **Formatting:**  \r\n                    When cast to a string, it will be formatted in the form `start..end`.\r\n\r\n                    **Examples:**\r\n                    ```lavendeux\r\n                    1..3 as array; // [1, 2, 3]\r\n                    'a'..'c' as array // ['a', 'b', 'c']\r\n                    ```\r\n\r\n                    ## string\r\n                    Any value can be cast to a string, to get a string representation of that value. It is encoding as a UTF-8 string.\r\n                    It is enclosed in single or double quotes, and supports the following supported escape sequences:\r\n                    - `\\\\\\'` Single-quote\r\n                    - `\\\\\\\"` Double-quote\r\n                    - `\\\\n` Newline\r\n                    - `\\\\r` Carriage-return\r\n                    - `\\\\t` Tab\r\n                    - `\\\\\\\\` Literal backslash\r\n\r\n                    **Casting:**\r\n                    It can be cast from any type, and cast to array or object.\r\n                    Casting to array will result in a character array, and casting to object will in a single-value object with the key `0i64`\r\n\r\n                    **Formatting:**  \r\n                    When cast to a string, it will be formatted as a string literal, without enclosing quotes.\r\n                    Inside a, array or object, it will be formatted as a string literal, with enclosing quotes.\r\n\r\n                    **Examples:**\r\n                    ```lavendeux\r\n                    \\\"test \\\\\\\"\\\"\r\n                    1 as string // \\\"1\\\"\r\n                    [1] as string // \\\"[1]\\\"\r\n                    {0: 1} as string // \\\"{0: 1}\\\"\r\n                    ```\r\n                \"\r\n            },\r\n        ]\r\n    });\r\n}\r\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":229},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":28,"coverable":28},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","error","error_details.rs"],"content":"use polyvalue::{Value, ValueType};\r\nuse thiserror::Error;\r\n\r\nuse super::SyntaxErrorCause;\r\n\r\nconst BUG_REPORT_URL : \u0026str = \"https://github.com/rscarson/lavendeux-parser/issues/new?assignees=\u0026labels=\u0026template=bug_report.md\u0026title=\";\r\n\r\n/// Inner error type for Lavendeux\r\n/// Gives more detailed information about the error\r\n/// And gets wrapped in the main Error type, along with metadata\r\n#[derive(Error, Debug)]\r\n#[rustfmt::skip]\r\npub enum ErrorDetails {\r\n    //\r\n    // Core\r\n    //\r\n\r\n    /// An error caused by a problem with the parser itself\r\n    #[error(\r\n        \"Internal parser issue: {msg}\\nPlease report this problem at {}\",\r\n        BUG_REPORT_URL\r\n    )]\r\n    Internal {\r\n        /// Message describing the error\r\n        msg: String,\r\n    },\r\n\r\n    /// An error caused by leaving a block empty\r\n    #[error(\"Block cannot be empty\")]\r\n    EmptyBlock,\r\n\r\n    /// An error caused by a problem with the syntax of the script\r\n    #[error(\"Syntax error; {cause}\")]\r\n    Syntax {\r\n        /// Cause of the syntax error\r\n        cause: SyntaxErrorCause\r\n    },\r\n\r\n    /// Error causing the parser thread to panic\r\n    #[error(\"Fatal error: {msg}\")]\r\n    Fatal {\r\n        /// Message describing the error\r\n        msg: String\r\n    },\r\n\r\n    /// A timeout error caused by a script taking too long to execute\r\n    #[error(\"Script execution timed out\")]\r\n    Timeout,\r\n\r\n    /// An error caused by a custom error message\r\n    #[error(\"{msg}\")]\r\n    Custom {\r\n        /// Message describing the error\r\n        msg: String,\r\n    },\r\n\r\n    /// An error used to return a value from a function early\r\n    #[error(\"Returned from the root scope\")]\r\n    Return {\r\n        /// Value being returned\r\n        value: Value,\r\n    },\r\n\r\n    /// An error used to skip a value from a loop\r\n    #[error(\"Skipped from outside a loop\")]\r\n    Skip,\r\n\r\n    /// An error used to skip a value from a loop\r\n    #[error(\"Break called from outside a loop\")]\r\n    Break,\r\n\r\n    ///////////////////////////////////////////////////////////////////////////\r\n    // Syntax Errors\r\n    // Deals with issues during Pest tree parsing\r\n    ///////////////////////////////////////////////////////////////////////////\r\n\r\n    /// An error caused by attempting to modify a read-only stdlib function\r\n    #[error(\"Could not alter system function {name}\")]\r\n    ReadOnlyFunction {\r\n        /// Name of the function being referred to\r\n        name: String,\r\n    },\r\n\r\n    /// An error caused by a problem with the syntax of the script\r\n    #[error(\"If statements are required return a value - use 'else' to select a default value\")]\r\n    NoElseBlock,\r\n    \r\n    /// An error caused by a problem with the syntax of the script\r\n    #[error(\"Did not specify a value for return\")]\r\n    UnterminatedReturn,\r\n\r\n    /// An error caused by using a decorator in the wrong place\r\n    #[error(\"@decorators must be at the end of a statement\")]\r\n    UnexpectedDecorator,\r\n\r\n    /// An error caused by using a postfix operator without an operand\r\n    #[error(\"Unterminated block comment: Expected '*/'\")]\r\n    UnterminatedComment,\r\n\r\n    /// An error caused by a missing bracket\r\n    #[error(\"Unclosed bracket: Expected ']'\")]\r\n    UnterminatedArray,\r\n\r\n    /// An error caused by a missing brace\r\n    #[error(\"Unclosed brace: Expected '}}'\")]\r\n    UnterminatedObject,\r\n\r\n    /// An error caused by a missing brace\r\n    #[error(\"Unclosed parentheses: Expected '('\")]\r\n    UnterminatedParen,\r\n\r\n    /// An error caused by ending a script on a backslash\r\n    #[error(\"Missing linebreak after '\\\\'\")]\r\n    UnterminatedLinebreak,\r\n\r\n    /// An error caused by a missing quote\r\n    #[error(\"Expected ' or \\\"\")]\r\n    UnterminatedLiteral,\r\n\r\n    /// Cause by a missing default case in a switch statement\r\n    #[error(\"Match expression is not exhaustive. Add a default case '_' to match all values\")]\r\n    NonExhaustiveSwitch,\r\n\r\n    /// Caused by a default case eclipsing other cases in a switch statement\r\n    #[error(\"All cases after the default case '_' are unreachable\")]\r\n    UnreachableSwitchCase,\r\n\r\n    /// Caused by a type mismatch in a switch statement\r\n    #[error(\"{case} is not valid for this switch statement. Expected a {expected_type}\")]\r\n    SwitchCaseTypeMismatch {\r\n        /// Case that caused the issue\r\n        case: Value,\r\n\r\n        /// Type that was expected\r\n        expected_type: ValueType,\r\n    },\r\n\r\n    ///////////////////////////////////////////////////////////////////////////\r\n    // Value Errors\r\n    // Mostly deals with variables, and value objects\r\n    ///////////////////////////////////////////////////////////////////////////\r\n    \r\n    /// Caused by assignments to constants\r\n    #[error(\"Cannot assign to a constant value\")]\r\n    ConstantValue,\r\n\r\n    /// An error caused by a mismatch in types for a range\r\n    #[error(\"Invalid combination of types for range. Use a pair of either integers, or characters\")]\r\n    RangeTypeMismatch,\r\n\r\n    /// An error caused by invalid range values\r\n    #[error(\"{start}..{end} is not a valid range: use integers or single-byte strings\")]\r\n    InvalidRange {\r\n        /// Start value\r\n        start: String,\r\n\r\n        /// End value\r\n        end: String,\r\n    },\r\n\r\n    /// An error caused by invalid range values\r\n    #[error(\"{start}..{end} is not a valid range: start \u003e end\")]\r\n    RangeStartGT {\r\n        /// Start value\r\n        start: String,\r\n\r\n        /// End value\r\n        end: String,\r\n    },\r\n\r\n    /// An error caused by a value being out of range\r\n    #[error(\"Arithmetic overflow\")]\r\n    Overflow,\r\n\r\n    /// Caused by a mismatch in the number of values in a destructuring assignment\r\n    #[error(\"Expected {expected_length} values, found {actual_length}\")]\r\n    DestructuringAssignment {\r\n        /// Number of values expected\r\n        expected_length: usize,\r\n\r\n        /// Number of values found\r\n        actual_length: usize,\r\n    },\r\n\r\n    /// An error caused by a value not being able to be parsed\r\n    #[error(\"Input could not be parsed as {expected_format}\")]\r\n    ValueFormat {\r\n        /// Format that was expected\r\n        expected_format: String,\r\n    },\r\n\r\n    /// An error caused by a value being out of range\r\n    #[error(\"{input} was out of range\")]\r\n    Range {\r\n        /// Input that was out of range\r\n        input: String,\r\n    },\r\n\r\n    /// An error caused by a missing variable\r\n    #[error(\"Undefined variable {name}. You can assign a value with {name} = ...\")]\r\n    VariableName {\r\n        /// Name of the variable being referred to\r\n        name: String,\r\n    },\r\n\r\n    /// An error caused by an attempt to access an element of an empty array\r\n    #[error(\"Array empty\")]\r\n    ArrayEmpty,\r\n\r\n    ///////////////////////////////////////////////////////////////////////////\r\n    // Function Errors\r\n    // Deals with issues during builtin, user, or extension function calls\r\n    ///////////////////////////////////////////////////////////////////////////\r\n\r\n    /// An error caused by a decorator specifying the wrong number of arguments\r\n    #[error(\"Decorator @{name} must accept a single argument\")]\r\n    DecoratorSignatureArgs {\r\n        /// Name of the decorator being referred to\r\n        name: String,\r\n    },\r\n\r\n    /// An error caused by a decorator specifying a return type\r\n    #[error(\"@{name} does not need to specify a return type; decorators always return a string\")]\r\n    DecoratorSignatureReturn {\r\n        /// Name of the decorator being referred to\r\n        name: String,\r\n    },\r\n\r\n    /// An error caused by a function call\r\n    #[error(\"Error in `{name}()`\")]\r\n    FunctionCall {\r\n        /// Name of the source function\r\n        name: String\r\n    },\r\n\r\n    /// An error caused by a function calling itself too many times\r\n    #[error(\"Recursive function went too deep\")]\r\n    StackOverflow,\r\n    \r\n    /// An error caused by calling a function with the wrong type of argument\r\n    #[error(\"Expected {expected_type} value for argument {arg} of `{signature}`\")]\r\n    FunctionArgumentType {\r\n        /// Argument number causing the issue (1-based)\r\n        arg: usize,\r\n\r\n        /// Type that was requested\r\n        expected_type: ValueType,\r\n        \r\n        /// Signature of the function called\r\n        signature: String,\r\n\r\n    },\r\n\r\n    /// An error caused by calling a function that does not exist\r\n    #[error(\"Undefined function {name}. You can define a function with {name}(a, b, c) = ...\")]\r\n    FunctionName {\r\n        /// Name of the function being referred to\r\n        name: String,\r\n    },\r\n\r\n    /// An error caused by calling a function using the wrong number of arguments\r\n    #[error(\r\n        \"Expected {} arguments for `{signature}`\",\r\n        if min == max {format!(\"{}\", min)} else {format!(\"{}-{}\", min, max)}\r\n    )]\r\n    FunctionArguments {\r\n        /// Smallest number of arguments accepted by the function\r\n        min: usize,\r\n        \r\n        /// Largest number of arguments accepted by the function\r\n        max: usize, \r\n        \r\n        \r\n        /// Signature of the function called\r\n        signature: String,\r\n        \r\n    },\r\n\r\n    /// An error caused by calling a decorator that does not exist\r\n    #[error(\"No decorator named {name}\")]\r\n    DecoratorName {\r\n        /// Name of the decorator being referred to\r\n        name: String,\r\n    },\r\n    \r\n    /// An error caused by attempting to use an API without registering it\r\n    #[error(\"API {name} was not found. Add it with api_register(\\\"{name}\\\", base_url, [optional api key])\")]\r\n    UnknownApi {\r\n        /// Name of the API being referred to\r\n        name: String,\r\n    },\r\n\r\n    //\r\n    // 3rd Party\r\n    //\r\n    \r\n    /// Error dealing with polyvalue issues\r\n    #[error(\"{0}\")]\r\n    Value(#[from] polyvalue::Error),\r\n\r\n    /// Error dealing with filesystem issues\r\n    #[error(\"{0}\")]\r\n    Io(#[from] std::io::Error),\r\n\r\n    /// Error dealing with network issues from the reqwest crate\r\n    #[error(\"{0}\")]\r\n    Network(#[from] reqwest::Error),\r\n\r\n    /// Error dealing with int parsing issues\r\n    #[error(\"{0}\")]\r\n    ParseIntError(#[from] std::num::ParseIntError),\r\n\r\n    /// Error dealing with utf8 issues\r\n    #[error(\"{0}\")]\r\n    FromUtf8Error(#[from] std::string::FromUtf8Error),\r\n\r\n    /// Error dealing with json issues\r\n    #[error(\"{0}\")]\r\n    SerdeJsonError(#[from] serde_json::Error),\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","error","macros.rs"],"content":"/// Matches an error to the type of ErrorDetails it contains\r\n/// # Arguments\r\n/// * `err` - The error to match\r\n/// * `pat` - The pattern to match against\r\n///\r\n/// # Example\r\n/// ```rust\r\n/// # use lavendeux_parser::error::Error;\r\n/// # use lavendeux_parser::error::ErrorDetails;\r\n/// # use lavendeux_parser::error_matches;\r\n///\r\n/// let err = Error {\r\n///     details: ErrorDetails::ArrayEmpty,\r\n///     context: None,\r\n///     source: None,\r\n/// };\r\n/// assert!(error_matches!(err, ArrayEmpty));\r\n/// ```\r\n#[macro_export]\r\nmacro_rules! error_matches {\r\n    ($err:expr, $pat:ident) =\u003e {\r\n        matches!(($err).details, $crate::error::ErrorDetails::$pat { .. })\r\n    };\r\n}\r\n\r\n/// Returns an Err(Error), optionally with a context and/or source\r\n/// Example:\r\n/// ```rust\r\n/// # use lavendeux_parser::error::Error;\r\n/// # use lavendeux_parser::oops;\r\n/// # use lavendeux_parser::Token;\r\n/// # fn example() -\u003e Result\u003c(), Error\u003e {\r\n/// # let token = Token::dummy();\r\n/// # let parent_error = Error::from(lavendeux_parser::error::ErrorDetails::ArrayEmpty);\r\n/// return oops!(FunctionName { name: \"foo\".to_string() }, token);\r\n/// return oops!(FunctionName { name: \"foo\".to_string() }, token = token, src = parent_error);\r\n/// # Ok(())\r\n/// # }\r\n/// ```\r\n#[macro_export]\r\nmacro_rules! oops {\r\n    ($variant:ident $({ $($n:ident$(:$v:expr)?),+ })?, token = $context:expr, src = $src:expr) =\u003e {\r\n        Err($crate::error::Error {\r\n            details: $crate::error::ErrorDetails::$variant $({ $($n $(: $v)?),+ })?,\r\n            context: Some($context.into_owned()),\r\n            source: Some(Box::new($src)),\r\n        })\r\n    };\r\n    ($variant:ident $({ $($n:ident$(:$v:expr)?),+ })?, $context:expr) =\u003e {\r\n        Err($crate::error::Error {\r\n            details: $crate::error::ErrorDetails::$variant $({ $($n $(: $v)?),+ })?,\r\n            context: Some($context.into_owned()),\r\n            source: None,\r\n        })\r\n    };\r\n    ($variant:ident $({ $($n:ident$(:$v:expr)?),+ })?, src = $src:expr) =\u003e {\r\n        Err($crate::error::Error {\r\n            details: $crate::error::ErrorDetails::$variant $({ $($n $(: $v)?),+ })?,\r\n            context: None,\r\n            source: Some(Box::new($src)),\r\n        })\r\n    };\r\n    ($variant:ident $({ $($n:ident$(:$v:expr)?),+ })?) =\u003e {\r\n        Err($crate::error::Error {\r\n            details: $crate::error::ErrorDetails::$variant $({ $($n $(: $v)?),+ })?,\r\n            context: None,\r\n            source: None,\r\n        })\r\n    };\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","error","mod.rs"],"content":"//! Error handling module.\r\n//! Defines the Error/ErrorDetails types, and associated traits and macros.\r\nuse crate::Token;\r\n\r\n#[macro_use]\r\nmod macros;\r\n\r\nmod error_details;\r\npub use error_details::ErrorDetails;\r\n\r\nmod traits;\r\npub use traits::*;\r\n\r\n/// Error type for the Lavendeux parser\r\n/// Can have optional context [Token], and parent error\r\n#[derive(Debug)]\r\npub struct Error {\r\n    /// details: The specific error that occurred - see [ErrorDetails]\r\n    pub details: ErrorDetails,\r\n\r\n    /// context: The [Token] that caused the error, or was being parsed when the error occurred\r\n    pub context: Option\u003cToken\u003c'static\u003e\u003e,\r\n\r\n    /// source: A parent error, if one exists - errors during a function call, for example\r\n    pub source: Option\u003cBox\u003cError\u003e\u003e,\r\n}\r\n\r\nimpl\u003c'i\u003e Error {\r\n    /// Add context to this error, in the form a [Token]\r\n    pub fn with_context(self, context: Token\u003c'i\u003e) -\u003e Self {\r\n        Error {\r\n            context: Some(context.into_owned()),\r\n            ..self\r\n        }\r\n    }\r\n\r\n    /// Link the parent error to this error\r\n    pub fn with_source(self, source: Error) -\u003e Self {\r\n        Error {\r\n            source: Some(Box::new(source)),\r\n            ..self\r\n        }\r\n    }\r\n\r\n    /// Remove context from this error\r\n    pub fn without_context(self) -\u003e Self {\r\n        Error {\r\n            context: None,\r\n            ..self\r\n        }\r\n    }\r\n\r\n    /// Offset the line-numbers in this and all parent errors\r\n    /// Useful for when a script is included in another script\r\n    /// Or for function calls\r\n    pub fn offset_linecount(mut self, offset: usize) -\u003e Self {\r\n        let mut new_context = self.context.clone();\r\n        if let Some(context) = \u0026mut new_context {\r\n            context.line += offset;\r\n        }\r\n\r\n        let mut new_source = std::mem::take(\u0026mut self.source);\r\n        if let Some(source) = new_source {\r\n            new_source = Some(Box::new(source.offset_linecount(offset)));\r\n        }\r\n\r\n        Error {\r\n            context: new_context,\r\n            source: new_source,\r\n            ..self\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003cT\u003e From\u003cT\u003e for Error\r\nwhere\r\n    T: std::convert::Into\u003cErrorDetails\u003e,\r\n{\r\n    fn from(details: T) -\u003e Self {\r\n        Error {\r\n            details: details.into(),\r\n            context: None,\r\n            source: None,\r\n        }\r\n    }\r\n}\r\n\r\nimpl std::error::Error for Error {}\r\nimpl std::fmt::Display for Error {\r\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter) -\u003e std::fmt::Result {\r\n        let token_part = if let Some(context) = \u0026self.context {\r\n            format!(\"{context}\\n= \")\r\n        } else {\r\n            \"\".to_string()\r\n        };\r\n\r\n        let source_part = if let Some(source) = \u0026self.source {\r\n            format!(\"\\n{}\", source)\r\n        } else {\r\n            \"\".to_string()\r\n        };\r\n\r\n        write!(f, \"{}{}{}\", token_part, self.details, source_part)\r\n    }\r\n}\r\n","traces":[{"line":30,"address":[],"length":0,"stats":{"Line":754},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":754},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":17,"coverable":19},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","error","traits.rs"],"content":"use std::{borrow::Cow, collections::HashSet};\r\n\r\nuse pest::error::ErrorVariant;\r\n\r\nuse crate::{error::ErrorDetails, pest::Rule, Error, Token};\r\n\r\n/// Describe the cause of a syntax error.\r\n#[derive(Debug, Clone, PartialEq, Eq, Hash)]\r\npub struct SyntaxErrorCause {\r\n    /// Tokens that could have followed the input\r\n    pub expected: Vec\u003cRuleCategory\u003e,\r\n\r\n    /// Tokens that were found instead\r\n    pub unexpected: Vec\u003cRuleCategory\u003e,\r\n}\r\nimpl std::fmt::Display for SyntaxErrorCause {\r\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\r\n        if !self.unexpected.is_empty() {\r\n            // Unexpected token\r\n            write!(f, \"Unexpected {}\", RuleCategory::fmt(\u0026self.unexpected))\r\n        } else if self.expected.len() == 1 {\r\n            // Expected a single token\r\n            write!(f, \"Expected {}\", self.expected[0])\r\n        } else if !self.expected.is_empty() {\r\n            // Expected multiple tokens\r\n            write!(f, \"Expected one of: {}\", RuleCategory::fmt(\u0026self.expected))\r\n        } else {\r\n            // No tokens expected\r\n            write!(f, \"Unexpected token\")\r\n        }\r\n    }\r\n}\r\n\r\n/// Wraps a syntax error into an Error.\r\npub trait WrapSyntaxError\u003cT, R\u003e {\r\n    /// Turns a pest error into an Error.\r\n    fn wrap_syntax_error(self, input: \u0026str) -\u003e Result\u003cT, Error\u003e;\r\n}\r\nimpl\u003cT\u003e WrapSyntaxError\u003cT, Rule\u003e for Result\u003cT, pest::error::Error\u003cRule\u003e\u003e {\r\n    fn wrap_syntax_error(self, input: \u0026str) -\u003e Result\u003cT, Error\u003e {\r\n        match self {\r\n            Ok(v) =\u003e Ok(v),\r\n            Err(e) =\u003e {\r\n                let span = match e.location {\r\n                    pest::error::InputLocation::Pos(pos) =\u003e pos..(input.len()),\r\n                    pest::error::InputLocation::Span(span) =\u003e span.0..span.1,\r\n                };\r\n                let span = \u0026input[span];\r\n\r\n                let line = match e.line_col {\r\n                    pest::error::LineColLocation::Pos((line, _)) =\u003e line,\r\n                    pest::error::LineColLocation::Span((line, _), _) =\u003e line,\r\n                };\r\n\r\n                let token = crate::Token {\r\n                    line,\r\n                    rule: crate::Rule::SCRIPT,\r\n                    input: Cow::Borrowed(span.split('\\n').next().unwrap_or_default()),\r\n                }\r\n                .into_owned();\r\n\r\n                match e.variant {\r\n                    ErrorVariant::ParsingError {\r\n                        positives,\r\n                        negatives,\r\n                    } =\u003e {\r\n                        let cause = SyntaxErrorCause {\r\n                            expected: RuleCategory::collect(\u0026positives),\r\n                            unexpected: RuleCategory::collect(\u0026negatives),\r\n                        };\r\n                        oops!(Syntax { cause }, token)\r\n                    }\r\n\r\n                    ErrorVariant::CustomError { message } if message.contains(\"call limit\") =\u003e {\r\n                        oops!(StackOverflow, token)\r\n                    }\r\n\r\n                    _ =\u003e oops!(\r\n                        Syntax {\r\n                            cause: SyntaxErrorCause {\r\n                                expected: vec![],\r\n                                unexpected: vec![]\r\n                            }\r\n                        },\r\n                        token\r\n                    ),\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/// Wrap a 3rd party error into an Error.\r\npub trait WrapExternalError\u003c'i, T\u003e {\r\n    /// Adds a context [Token]\r\n    fn with_context(self, context: \u0026Token\u003c'i\u003e) -\u003e Result\u003cT, Error\u003e;\r\n\r\n    /// Adds a source [Error]\r\n    fn with_source(self, source: Error) -\u003e Result\u003cT, Error\u003e;\r\n\r\n    /// Wraps the error without context or a source\r\n    fn without_context(self) -\u003e Result\u003cT, Error\u003e;\r\n}\r\n\r\nimpl\u003c'i, T, E\u003e WrapExternalError\u003c'i, T\u003e for Result\u003cT, E\u003e\r\nwhere\r\n    E: Into\u003cError\u003e,\r\n{\r\n    fn with_context(self, context: \u0026Token\u003c'i\u003e) -\u003e Result\u003cT, Error\u003e {\r\n        match self {\r\n            Ok(v) =\u003e Ok(v),\r\n            Err(e) =\u003e Err(e.into().with_context(context.clone())),\r\n        }\r\n    }\r\n\r\n    fn with_source(self, source: Error) -\u003e Result\u003cT, Error\u003e {\r\n        match self {\r\n            Ok(v) =\u003e Ok(v),\r\n            Err(e) =\u003e Err(e.into().with_source(source)),\r\n        }\r\n    }\r\n\r\n    fn without_context(self) -\u003e Result\u003cT, Error\u003e {\r\n        match self {\r\n            Ok(v) =\u003e Ok(v),\r\n            Err(e) =\u003e Err(e.into().without_context()),\r\n        }\r\n    }\r\n}\r\n\r\n/// Wrap an `Option\u003cT\u003e` into a `Result\u003cT, Error\u003e`\r\npub trait WrapOption\u003c'i, T\u003e {\r\n    /// Turns an `Option\u003cT\u003e` into a `Result\u003cT, Error\u003e`\r\n    fn or_error(self, error: ErrorDetails) -\u003e Result\u003cT, Error\u003e;\r\n}\r\nimpl\u003c'i, T\u003e WrapOption\u003c'i, T\u003e for Option\u003cT\u003e {\r\n    fn or_error(self, error: ErrorDetails) -\u003e Result\u003cT, Error\u003e {\r\n        match self {\r\n            Some(v) =\u003e Ok(v),\r\n            None =\u003e Err(Error {\r\n                details: error,\r\n                context: None,\r\n                source: None,\r\n            }),\r\n        }\r\n    }\r\n}\r\n\r\n/// Describes the category of a rule.\r\n/// Used for error messages.\r\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\r\n#[allow(missing_docs)]\r\npub enum RuleCategory {\r\n    Block,\r\n    FunctionAssignment,\r\n    Expression,\r\n    Literal,\r\n    Identifier,\r\n    Operator,\r\n    Array,\r\n    Object,\r\n    Symbol(\u0026'static str),\r\n\r\n    IntSizeSuffix,\r\n    CurrencySymbol,\r\n\r\n    Hidden,\r\n}\r\n\r\nimpl RuleCategory {\r\n    /// Collects all rule categories from a list of rules.\r\n    pub fn collect(rules: \u0026[Rule]) -\u003e Vec\u003cSelf\u003e {\r\n        let set = rules\r\n            .iter()\r\n            .map(|r| RuleCategory::from(*r))\r\n            .filter(|e| e != \u0026RuleCategory::Hidden)\r\n            .collect::\u003cHashSet\u003c_\u003e\u003e();\r\n        set.into_iter().collect()\r\n    }\r\n\r\n    /// Formats a set of rule categories into a string.\r\n    pub fn fmt(cats: \u0026[Self]) -\u003e String {\r\n        let mut cats = cats.iter().map(|c| c.to_string()).collect::\u003cVec\u003c_\u003e\u003e();\r\n        cats.sort();\r\n        cats.join(\", \")\r\n    }\r\n}\r\n\r\nimpl std::fmt::Display for RuleCategory {\r\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\r\n        match self {\r\n            Self::Block =\u003e write!(f, \"block\"),\r\n            Self::FunctionAssignment =\u003e write!(f, \"function assignment\"),\r\n            Self::Expression =\u003e write!(f, \"expression\"),\r\n            Self::Literal =\u003e write!(f, \"value\"),\r\n            Self::Identifier =\u003e write!(f, \"identifier\"),\r\n            Self::Operator =\u003e write!(f, \"operator\"),\r\n            Self::Array =\u003e write!(f, \"array\"),\r\n            Self::Object =\u003e write!(f, \"object\"),\r\n            Self::Symbol(s) =\u003e write!(f, \"`{}`\", s),\r\n\r\n            Self::IntSizeSuffix =\u003e write!(f, \"integer suffix\"),\r\n            Self::CurrencySymbol =\u003e write!(f, \"currency symbol\"),\r\n\r\n            Self::Hidden =\u003e write!(f, \"\"),\r\n        }\r\n    }\r\n}\r\n\r\nimpl From\u003cRule\u003e for RuleCategory {\r\n    fn from(rule: Rule) -\u003e Self {\r\n        match rule {\r\n            Rule::BLOCK =\u003e Self::Block,\r\n\r\n            Rule::FUNCTION_ASSIGNMENT_STATEMENT =\u003e Self::FunctionAssignment,\r\n\r\n            Rule::SKIP_KEYWORD\r\n            | Rule::BREAK_KEYWORD\r\n            | Rule::RETURN_EXPRESSION\r\n            | Rule::SWITCH_EXPRESSION\r\n            | Rule::FOR_LOOP_EXPRESSION\r\n            | Rule::IF_EXPRESSION\r\n            | Rule::EXPR =\u003e Self::Expression,\r\n\r\n            Rule::symbol_questionmark =\u003e Self::Symbol(\"?\"),\r\n            Rule::symbol_colon =\u003e Self::Symbol(\":\"),\r\n            Rule::symbol_comma =\u003e Self::Symbol(\",\"),\r\n\r\n            Rule::symbol_opencurly =\u003e Self::Symbol(\"{\"),\r\n            Rule::symbol_closecurly =\u003e Self::Symbol(\"}\"),\r\n            Rule::array_symbol_opensquare =\u003e Self::Symbol(\"[\"),\r\n            Rule::symbol_opensquare =\u003e Self::Symbol(\"[\"),\r\n            Rule::symbol_closesquare =\u003e Self::Symbol(\"]\"),\r\n            Rule::symbol_arrow =\u003e Self::Symbol(\"=\u003e\"),\r\n            Rule::symbol_at =\u003e Self::Symbol(\"@\"),\r\n            Rule::symbol_eq =\u003e Self::Symbol(\"=\"),\r\n            Rule::EOL =\u003e Self::Symbol(\"EOL\"),\r\n\r\n            Rule::POSTFIX_EMPTYINDEX\r\n            | Rule::del_keyword\r\n            | Rule::POSTFIX_DECORATE\r\n            | Rule::POSTFIX_INDEX\r\n            | Rule::POSTFIX_CALL\r\n            | Rule::PREFIX_DEL\r\n            | Rule::PREFIX_BOOL_NOT\r\n            | Rule::PREFIX_BIT_NOT\r\n            | Rule::PREFIX_NEG\r\n            | Rule::PREFIX_INC\r\n            | Rule::PREFIX_DEC\r\n            | Rule::POSTFIX_INC\r\n            | Rule::POSTFIX_DEC\r\n            | Rule::OP_ASSIGN_ADD\r\n            | Rule::OP_ASSIGN_SUB\r\n            | Rule::OP_ASSIGN_POW\r\n            | Rule::OP_ASSIGN_MUL\r\n            | Rule::OP_ASSIGN_DIV\r\n            | Rule::OP_ASSIGN_MOD\r\n            | Rule::OP_BASSIGN_AND\r\n            | Rule::OP_BASSIGN_OR\r\n            | Rule::OP_ASSIGN_OR\r\n            | Rule::OP_ASSIGN_AND\r\n            | Rule::OP_ASSIGN_XOR\r\n            | Rule::OP_ASSIGN_SL\r\n            | Rule::OP_ASSIGN_SR\r\n            | Rule::OP_ASSIGN\r\n            | Rule::OP_BOOL_OR\r\n            | Rule::OP_BOOL_AND\r\n            | Rule::OP_BOOL_EQ\r\n            | Rule::OP_BOOL_NE\r\n            | Rule::OP_BOOL_LE\r\n            | Rule::OP_BOOL_GE\r\n            | Rule::OP_BOOL_LT\r\n            | Rule::OP_BOOL_GT\r\n            | Rule::OP_BIT_OR\r\n            | Rule::OP_BIT_XOR\r\n            | Rule::OP_BIT_AND\r\n            | Rule::OP_BIT_SL\r\n            | Rule::OP_BIT_SR\r\n            | Rule::OP_ADD\r\n            | Rule::OP_SUB\r\n            | Rule::OP_MUL\r\n            | Rule::OP_DIV\r\n            | Rule::OP_MOD\r\n            | Rule::OP_POW\r\n            | Rule::match_infix_op\r\n            | Rule::OP_MATCH_CONTAINS\r\n            | Rule::OP_MATCH_MATCHES\r\n            | Rule::OP_MATCH_IS\r\n            | Rule::OP_MATCH_STARTSWITH\r\n            | Rule::OP_MATCH_ENDSWITH\r\n            | Rule::OP_RANGE\r\n            | Rule::OP_CAST\r\n            | Rule::OP_TERNARY\r\n            | Rule::bool_infix_op\r\n            | Rule::bitwise_infix_op\r\n            | Rule::arithmetic_infix_op\r\n            | Rule::assignment_infix_op\r\n            | Rule::prefix_op\r\n            | Rule::prefix_arith\r\n            | Rule::postfix_arith\r\n            | Rule::KEYWORD_EXPRESSION\r\n            | Rule::postfix_operation\r\n            | Rule::postfixcall_args\r\n            | Rule::POSTFIX_NORMALMODE\r\n            | Rule::POSTFIX_OBJECTMODE\r\n            | Rule::infix_op =\u003e Self::Operator,\r\n\r\n            Rule::ARRAY_TERM =\u003e Self::Array,\r\n            Rule::OBJECT_TERM =\u003e Self::Object,\r\n\r\n            Rule::TERM\r\n            | Rule::ATOMIC_VALUE\r\n            | Rule::dec_literal\r\n            | Rule::hex_literal\r\n            | Rule::bin_literal\r\n            | Rule::oct_literal\r\n            | Rule::fixed_literal\r\n            | Rule::currency_literal\r\n            | Rule::sci_literal\r\n            | Rule::float_literal\r\n            | Rule::const_literal\r\n            | Rule::int_literal\r\n            | Rule::bool_literal\r\n            | Rule::string_literal\r\n            | Rule::regex_literal =\u003e Self::Literal,\r\n\r\n            Rule::identifier =\u003e Self::Identifier,\r\n\r\n            Rule::int_sep\r\n            | Rule::sized_literal_suffix\r\n            | Rule::intsize_u8\r\n            | Rule::intsize_i8\r\n            | Rule::intsize_u16\r\n            | Rule::intsize_i16\r\n            | Rule::intsize_u32\r\n            | Rule::intsize_i32\r\n            | Rule::intsize_u64\r\n            | Rule::intsize_i64 =\u003e Self::IntSizeSuffix,\r\n\r\n            Rule::currency_suffix | Rule::currency_symbol =\u003e Self::CurrencySymbol,\r\n\r\n            Rule::object_keyvalue_pair\r\n            | Rule::block_line\r\n            | Rule::for_conditional\r\n            | Rule::switch_case\r\n            | Rule::if_block\r\n            | Rule::function_typespec\r\n            | Rule::function_argument\r\n            | Rule::function_name\r\n            | Rule::SCRIPT\r\n            | Rule::reserved_words\r\n            | Rule::ERROR\r\n            | Rule::UNTERMINATED_BLOCK_COMMENT\r\n            | Rule::UNTERMINATED_STRING_LITERAL\r\n            | Rule::UNCLOSED_BRACKET\r\n            | Rule::UNCLOSED_BRACE\r\n            | Rule::UNCLOSED_PAREN\r\n            | Rule::MISSING_LINEBREAK\r\n            | Rule::EOI\r\n            | Rule::LINE\r\n            | Rule::INLINE_COMMENT\r\n            | Rule::BLOCK_COMMENT\r\n            | Rule::COMMENT\r\n            | Rule::WHITESPACE\r\n            | Rule::STATEMENT =\u003e Self::Hidden,\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":523},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":523},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":514},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":18840},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":18840},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":18086},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":754},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":1933},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":1933},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":1921},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":478},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":478},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":442},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":442},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":306,"address":[],"length":0,"stats":{"Line":372},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":338,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":340,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":365,"address":[],"length":0,"stats":{"Line":16},"fn_name":null}],"covered":50,"coverable":103},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","functions","compiler_cache.rs"],"content":"use crate::{pest, Error, Node};\r\nuse once_cell::sync::OnceCell;\r\nuse std::cell::RefCell;\r\nuse std::collections::hash_map::Entry;\r\nuse std::collections::HashMap;\r\nuse std::rc::Rc;\r\n\r\n// A cache of pre-compiled user function bodies\r\nthread_local! {\r\n    static USER_FUNCTION_CACHE: OnceCell\u003cRefCell\u003cHashMap\u003cString, Rc\u003cNode\u003e\u003e\u003e\u003e = OnceCell::new();\r\n}\r\n\r\npub fn cached_fn_compile(src: \u0026'i str, line_offset: usize) -\u003e Result\u003cRc\u003cNode\u003c'i\u003e\u003e, Error\u003e {\r\n    USER_FUNCTION_CACHE.with(|once_lock| {\r\n        let rt_mut = once_lock.get_or_init(|| RefCell::new(HashMap::new()));\r\n        let mut cache = rt_mut.borrow_mut();\r\n\r\n        match cache.entry(src.to_string()) {\r\n            Entry::Occupied(o) =\u003e Ok(o.get().clone()),\r\n            Entry::Vacant(v) =\u003e {\r\n                let mut node = pest::parse_input(src, pest::Rule::EXPR)?;\r\n                node.token_offsetline(line_offset);\r\n                Ok(v.insert(Rc::new(node)).clone())\r\n            }\r\n        }\r\n    })\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","functions","documentation.rs"],"content":"/// Documentation for a function\r\npub trait FunctionDocumentation: core::fmt::Debug {\r\n    /// Clone the documentation\r\n    fn clone_self(\u0026self) -\u003e Box\u003cdyn FunctionDocumentation\u003e;\r\n\r\n    /// The category of the function\r\n    fn category(\u0026self) -\u003e \u0026str;\r\n\r\n    /// Set the category of the function\r\n    fn set_category(\u0026mut self, category: \u0026str);\r\n\r\n    /// The description of the function\r\n    fn description(\u0026self) -\u003e Option\u003c\u0026str\u003e;\r\n\r\n    /// Set the description of the function\r\n    fn set_description(\u0026mut self, description: Option\u003c\u0026str\u003e);\r\n\r\n    /// The extended description of the function\r\n    fn ext_description(\u0026self) -\u003e Option\u003c\u0026str\u003e;\r\n\r\n    /// Set the extended description of the function\r\n    fn set_ext_description(\u0026mut self, ext_description: Option\u003c\u0026str\u003e);\r\n\r\n    /// The examples of the function\r\n    fn examples(\u0026self) -\u003e Option\u003c\u0026str\u003e;\r\n\r\n    /// Set the examples of the function\r\n    fn set_examples(\u0026mut self, examples: Option\u003c\u0026str\u003e);\r\n}\r\n\r\n/// Documentation for a function\r\n#[derive(Debug, Clone, Copy)]\r\npub struct StaticFunctionDocumentation {\r\n    /// The category of the function\r\n    pub category: \u0026'static str,\r\n\r\n    /// The description of the function\r\n    pub description: Option\u003c\u0026'static str\u003e,\r\n\r\n    /// The extended description of the function\r\n    pub ext_description: Option\u003c\u0026'static str\u003e,\r\n\r\n    /// The examples for the function\r\n    pub examples: Option\u003c\u0026'static str\u003e,\r\n}\r\nimpl FunctionDocumentation for StaticFunctionDocumentation {\r\n    fn clone_self(\u0026self) -\u003e Box\u003cdyn FunctionDocumentation\u003e {\r\n        Box::new(*self)\r\n    }\r\n\r\n    fn category(\u0026self) -\u003e \u0026str {\r\n        self.category\r\n    }\r\n    fn description(\u0026self) -\u003e Option\u003c\u0026str\u003e {\r\n        self.description\r\n    }\r\n    fn ext_description(\u0026self) -\u003e Option\u003c\u0026str\u003e {\r\n        self.ext_description\r\n    }\r\n    fn examples(\u0026self) -\u003e Option\u003c\u0026str\u003e {\r\n        self.examples\r\n    }\r\n\r\n    fn set_category(\u0026mut self, _: \u0026str) {}\r\n    fn set_description(\u0026mut self, _: Option\u003c\u0026str\u003e) {}\r\n    fn set_ext_description(\u0026mut self, _: Option\u003c\u0026str\u003e) {}\r\n    fn set_examples(\u0026mut self, _: Option\u003c\u0026str\u003e) {}\r\n}\r\n\r\n/// Documentation for a function\r\n#[derive(Debug, Clone)]\r\npub struct UserFunctionDocumentation {\r\n    /// The category of the function\r\n    pub category: String,\r\n\r\n    /// The description of the function\r\n    pub description: Option\u003cString\u003e,\r\n\r\n    /// The extended description of the function\r\n    pub ext_description: Option\u003cString\u003e,\r\n\r\n    /// The examples for the function\r\n    pub examples: Option\u003cString\u003e,\r\n}\r\nimpl FunctionDocumentation for UserFunctionDocumentation {\r\n    fn clone_self(\u0026self) -\u003e Box\u003cdyn FunctionDocumentation\u003e {\r\n        Box::new(self.clone())\r\n    }\r\n\r\n    fn category(\u0026self) -\u003e \u0026str {\r\n        \u0026self.category\r\n    }\r\n    fn set_category(\u0026mut self, category: \u0026str) {\r\n        self.category = category.to_string();\r\n    }\r\n\r\n    fn description(\u0026self) -\u003e Option\u003c\u0026str\u003e {\r\n        self.description.as_deref()\r\n    }\r\n    fn set_description(\u0026mut self, description: Option\u003c\u0026str\u003e) {\r\n        self.description = description.map(|s| s.to_string());\r\n    }\r\n\r\n    fn ext_description(\u0026self) -\u003e Option\u003c\u0026str\u003e {\r\n        self.ext_description.as_deref()\r\n    }\r\n    fn set_ext_description(\u0026mut self, ext_description: Option\u003c\u0026str\u003e) {\r\n        self.ext_description = ext_description.map(|s| s.to_string());\r\n    }\r\n\r\n    fn examples(\u0026self) -\u003e Option\u003c\u0026str\u003e {\r\n        self.examples.as_deref()\r\n    }\r\n    fn set_examples(\u0026mut self, examples: Option\u003c\u0026str\u003e) {\r\n        self.examples = examples.map(|s| s.to_string());\r\n    }\r\n}\r\n","traces":[{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":3780},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":3780},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":153},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":153},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":153},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":153},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":260},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":260},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":3},"fn_name":null}],"covered":22,"coverable":32},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","functions","macros.rs"],"content":"/// This macro defines a standard function and registers it with the standard library of functions.\r\n/// The standard function is a function that takes multiple arguments and returns a value.\r\n///\r\n/// # Usage\r\n/// ```rust\r\n/// use lavendeux_parser::{define_stdfunction, required_arg};\r\n/// define_stdfunction!(\r\n///     add { a: Standard::Numeric, b: Standard::Numeric },\r\n///     returns = Numeric,\r\n///     docs = {\r\n///         category: \"Math\",\r\n///         description: \"Addition\",\r\n///         ext_description: \"Adds two numbers together.\",\r\n///         examples: \"\r\n///             assert_eq(\r\n///                 add(2, 3),\r\n///                 5\r\n///             )\r\n///         \"\r\n///     },\r\n///     handler = (state, reference) {\r\n///         let a = required_arg!(state::a).as_a::\u003ci64\u003e()?;\r\n///         let b = required_arg!(state::b).as_a::\u003ci64\u003e()?;\r\n///         Ok((a + b).into())\r\n///     }\r\n/// );\r\n/// ```\r\n///\r\n/// # Arguments\r\n/// - `$name:ident`: The name of the function.\r\n/// - `$aname:ident : $meta:ident::$atype:ident`: The arguments of the function, where `$aname` is the argument name, `$meta` is how to process the argument (Standard, Optional or Plural), and `$atype` is the argument value type (See [polyvalue::ValueType]).\r\n/// - `returns = $return:ident`: The return value type of the function. See [polyvalue::ValueType].\r\n/// - `docs = { ... }`: The documentation for the function, including the category name, description, extended description, and examples.\r\n/// - `handler = $handler:expr`: The handler function that implements the logic of the function.\r\n#[macro_export]\r\nmacro_rules! define_stdfunction {\r\n    (\r\n        $name:ident { $($aname:ident : $meta:ident::$atype:ident),* },\r\n        returns = $return:ident,\r\n        docs = {\r\n            category: $category:literal,\r\n            description: $description:expr,\r\n            ext_description: $ext_description:literal,\r\n            examples: $examples:literal$(,)?\r\n        },\r\n        handler = ($hndstate:ident, $hndref:ident) $handler:block$(,)?\r\n    ) =\u003e {\r\n        paste::paste! {\r\n            #[allow(non_camel_case_types)]\r\n            #[derive(Debug, Copy, Clone)]\r\n            pub struct [\u003c_stdlibfn_$name\u003e];\r\n            impl [\u003c_stdlibfn_$name\u003e] {\r\n                const NAME: \u0026'static str = stringify!($name);\r\n\r\n                const DOCS: $crate::functions::StaticFunctionDocumentation = $crate::functions::StaticFunctionDocumentation {\r\n                    category: $category,\r\n                    description: Some($description),\r\n                    ext_description: Some(indoc::indoc! { $ext_description }),\r\n                    examples: Some(indoc::indoc! { $examples })\r\n                };\r\n                const ARGUMENTS: \u0026'static [(\u0026'static str, $crate::functions::FunctionArgument)] = \u0026[$(\r\n                    (stringify!($aname), $crate::functions::FunctionArgument {\r\n                        expected_type: $crate::polyvalue::ValueType::$atype,\r\n                        meta: $crate::functions::FunctionArgumentType::$meta\r\n                    })\r\n                ),*];\r\n\r\n                pub fn new() -\u003e Self {\r\n                    Self\r\n                }\r\n            }\r\n\r\n            impl $crate::functions::ParserFunction for [\u003c_stdlibfn_$name\u003e] {\r\n                fn name(\u0026self) -\u003e \u0026str {\r\n                    Self::NAME\r\n                }\r\n\r\n                fn is_readonly(\u0026self) -\u003e bool {\r\n                    true\r\n                }\r\n\r\n                fn documentation(\u0026self) -\u003e \u0026dyn $crate::functions::FunctionDocumentation {\r\n                    \u0026Self::DOCS\r\n                }\r\n\r\n                fn documentation_mut(\u0026mut self) -\u003e \u0026mut dyn $crate::functions::FunctionDocumentation {\r\n                    unimplemented!()\r\n                }\r\n\r\n                fn return_type(\u0026self) -\u003e $crate::polyvalue::ValueType {\r\n                    $crate::polyvalue::ValueType::$return\r\n                }\r\n\r\n                fn expected_arguments(\u0026self) -\u003e Vec\u003c(std::borrow::Cow\u003c'static, str\u003e, $crate::functions::FunctionArgument)\u003e {\r\n                    Self::ARGUMENTS\r\n                        .iter()\r\n                        .copied()\r\n                        .map(|(name, arg)| (std::borrow::Cow::Borrowed(name), arg))\r\n                        .collect()\r\n                }\r\n\r\n                fn clone_self(\u0026self) -\u003e Box\u003cdyn $crate::functions::ParserFunction\u003e {\r\n                    Box::new(Self::new())\r\n                }\r\n\r\n                fn call(\u0026self, $hndstate: \u0026mut $crate::State, $hndref: Option\u003c\u0026$crate::AssignmentTarget\u003e) -\u003e Result\u003c$crate::polyvalue::Value, $crate::Error\u003e $handler\r\n            }\r\n\r\n            inventory::submit! {\r\n                \u0026[\u003c_stdlibfn_$name\u003e] as \u0026'static dyn $crate::functions::ParserFunction\r\n            }\r\n        }\r\n    };\r\n}\r\n\r\n/// Defines a decorator function and registers it with the standard library of functions.\r\n/// The decorator function is a function that takes a single argument and returns a string.\r\n///\r\n/// # Usage\r\n/// ```rust\r\n/// use lavendeux_parser::{define_stddecorator};\r\n/// define_stddecorator!(\r\n///     upper { input: String },\r\n///     docs = {\r\n///         description: \"Uppercase\",\r\n///         ext_description: \"Converts the input string to uppercase.\",\r\n///         examples: \"\r\n///             assert_eq(\r\n///                 'hello' @upper,\r\n///                 'HELLO'\r\n///             )\r\n///         \"\r\n///     },\r\n///     handler = (input) {\r\n///         Ok(input.as_a::\u003cString\u003e()?.to_uppercase())\r\n///     }\r\n/// );\r\n/// ```\r\n///\r\n/// # Arguments\r\n/// - `$name:ident`: The name of the function.\r\n/// - `$aname:ident : $atype:ident`: The argument of the function, where `$aname` is the argument name and `$atype` is the argument value type (See [polyvalue::ValueType]).\r\n/// - `docs = { ... }`: The documentation for the function, including the category name, description, extended description, and examples.\r\n/// - `handler = $handler:expr`: The handler function that implements the logic of the function.\r\n#[macro_export]\r\nmacro_rules! define_stddecorator {\r\n    (\r\n        $name:ident { $aname:ident : $atype:ident },\r\n        docs = {\r\n            description: $description:expr,\r\n            ext_description: $ext_description:literal,\r\n            examples: $examples:literal$(,)?\r\n        },\r\n        handler = ($hndval:ident) $handler:block$(,)?\r\n    ) =\u003e {\r\n        paste::paste! {\r\n            #[allow(non_camel_case_types)]\r\n            #[derive(Debug, Copy, Clone)]\r\n            pub struct [\u003c_stdlibfn_dec_$name\u003e];\r\n            impl [\u003c_stdlibfn_dec_$name\u003e] {\r\n                const NAME: \u0026'static str = concat!(\"@\", stringify!($name));\r\n\r\n                const DOCS: $crate::functions::StaticFunctionDocumentation = $crate::functions::StaticFunctionDocumentation {\r\n                    category: \"Decorators\",\r\n                    description: Some($description),\r\n                    ext_description: Some(indoc::indoc! { $ext_description }),\r\n                    examples: Some(indoc::indoc! { $examples })\r\n                };\r\n                const ARGUMENTS: \u0026'static [(\u0026'static str, $crate::functions::FunctionArgument)] = \u0026[\r\n                    (stringify!($aname), $crate::functions::FunctionArgument {\r\n                        expected_type: $crate::polyvalue::ValueType::$atype,\r\n                        meta: $crate::functions::FunctionArgumentType::Standard\r\n                    })\r\n                ];\r\n\r\n                pub fn new() -\u003e Self {\r\n                    Self\r\n                }\r\n            }\r\n\r\n            impl $crate::functions::ParserFunction for [\u003c_stdlibfn_dec_$name\u003e] {\r\n                fn name(\u0026self) -\u003e \u0026str {\r\n                    Self::NAME\r\n                }\r\n\r\n                fn is_readonly(\u0026self) -\u003e bool {\r\n                    true\r\n                }\r\n\r\n                fn documentation(\u0026self) -\u003e \u0026 dyn $crate::functions::FunctionDocumentation {\r\n                    \u0026Self::DOCS\r\n                }\r\n\r\n                fn documentation_mut(\u0026mut self) -\u003e \u0026mut dyn $crate::functions::FunctionDocumentation {\r\n                    unimplemented!()\r\n                }\r\n\r\n                fn return_type(\u0026self) -\u003e $crate::polyvalue::ValueType {\r\n                    $crate::polyvalue::ValueType::String\r\n                }\r\n\r\n                fn expected_arguments(\u0026self) -\u003e Vec\u003c(std::borrow::Cow\u003c'static, str\u003e, $crate::functions::FunctionArgument)\u003e {\r\n                    Self::ARGUMENTS\r\n                        .iter()\r\n                        .copied()\r\n                        .map(|(name, arg)| (std::borrow::Cow::Borrowed(name), arg))\r\n                        .collect()\r\n                }\r\n\r\n                fn clone_self(\u0026self) -\u003e Box\u003cdyn $crate::functions::ParserFunction\u003e {\r\n                    Box::new(Self::new())\r\n                }\r\n\r\n                fn call(\u0026self, state: \u0026mut $crate::State, _: Option\u003c\u0026$crate::AssignmentTarget\u003e) -\u003e Result\u003c$crate::polyvalue::Value, $crate::Error\u003e {\r\n                    let $hndval = $crate::required_arg!(state::$aname);\r\n                    let value: Result\u003cString, $crate::Error\u003e = $handler;\r\n                    Ok(value?.into())\r\n                }\r\n            }\r\n\r\n            inventory::submit! {\r\n                \u0026[\u003c_stdlibfn_dec_$name\u003e] as \u0026'static dyn $crate::functions::ParserFunction\r\n            }\r\n        }\r\n    };\r\n}\r\n\r\n/// Extracts a required argument from the state and returns it. If the argument is not found, it returns an error.\r\n/// Use it like `required_arg!(state::name)`.\r\n#[macro_export]\r\nmacro_rules! required_arg {\r\n    ($state:ident :: $name:ident) =\u003e {\r\n        match $state.get_variable(stringify!($name)).cloned() {\r\n            Some(v) =\u003e v,\r\n            None =\u003e {\r\n                return $crate::oops!(Internal {\r\n                    msg: format!(\"Missing required argument: {}\", stringify!($name))\r\n                })\r\n            }\r\n        }\r\n    };\r\n}\r\n\r\n/// Extracts an optional argument from the state and returns it. If the argument is not found, it returns `None`.\r\n/// Use it like `optional_arg!(state::name)`.\r\n#[macro_export]\r\nmacro_rules! optional_arg {\r\n    ($state:ident :: $name:ident) =\u003e {\r\n        $state.get_variable(stringify!($name)).cloned()\r\n    };\r\n}\r\n","traces":[{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":32602},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":32602},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":45037},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":45037},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":3692},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":3692},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":835},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":835},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":1537},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":1537},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":1537},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":1537},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":3074},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":1537},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":32602},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":32602},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":5824},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":5824},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":8958},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":8958},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":654},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":654},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":44},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":44},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":68},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":68},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":68},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":68},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":136},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":68},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":5824},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":5824},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":48},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":48},"fn_name":null}],"covered":36,"coverable":46},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","functions","mod.rs"],"content":"mod std_function;\r\nmod user_function;\r\n\r\n#[macro_use]\r\nmod macros;\r\n\r\nmod documentation;\r\npub use documentation::*;\r\n\r\npub use std_function::{FunctionArgument, FunctionArgumentType, ParserFunction};\r\npub use user_function::UserDefinedFunction;\r\n\r\n/// The standard library of functions\r\n/// Loaded by the state by default\r\npub mod stdlib;\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","functions","std_function.rs"],"content":"use std::borrow::Cow;\r\n\r\nuse crate::{syntax_tree::AssignmentTarget, Error, State};\r\nuse polyvalue::{Value, ValueType};\r\n\r\nuse super::FunctionDocumentation;\r\n\r\n/// A function argument type\r\n#[derive(Debug, Copy, Clone)]\r\npub enum FunctionArgumentType {\r\n    /// Normal argument\r\n    Standard,\r\n    /// 0-or-more of\r\n    Plural,\r\n    /// 0-or-1 of\r\n    Optional,\r\n}\r\n\r\n/// A function argument\r\n#[derive(Debug, Copy, Clone)]\r\npub struct FunctionArgument {\r\n    /// Type condition to enforce\r\n    pub expected_type: ValueType,\r\n\r\n    /// How to parse the argument\r\n    pub meta: FunctionArgumentType,\r\n}\r\n\r\nimpl FunctionArgument {\r\n    /// Returns true if the argument can be skipped on type errors or missing values\r\n    pub fn is_optional(\u0026self) -\u003e bool {\r\n        !matches!(self.meta, FunctionArgumentType::Standard)\r\n    }\r\n\r\n    /// Returns true if the argument should consume 0 or more args until a non-matching type is found\r\n    pub fn is_plural(\u0026self) -\u003e bool {\r\n        matches!(self.meta, FunctionArgumentType::Plural)\r\n    }\r\n}\r\n\r\npub trait ManageArguments {\r\n    fn arg_count_span(\u0026self) -\u003e (usize, usize);\r\n    fn map_arguments(\r\n        \u0026self,\r\n        values: \u0026[Value],\r\n        state: \u0026mut State,\r\n        function_signature: String,\r\n    ) -\u003e Result\u003c(), Error\u003e;\r\n}\r\nimpl ManageArguments for Vec\u003c(Cow\u003c'_, str\u003e, FunctionArgument)\u003e {\r\n    fn arg_count_span(\u0026self) -\u003e (usize, usize) {\r\n        let (mut min, mut max) = (0, 0);\r\n        for (_, arg) in self.iter() {\r\n            if !arg.is_optional() {\r\n                min += 1;\r\n            }\r\n            max += 1;\r\n        }\r\n        (min, max)\r\n    }\r\n\r\n    fn map_arguments(\r\n        \u0026self,\r\n        values: \u0026[Value],\r\n        state: \u0026mut State,\r\n        function_signature: String,\r\n    ) -\u003e Result\u003c(), Error\u003e {\r\n        let mut values = values.iter().peekable();\r\n\r\n        for (i, (name, arg)) in self.iter().enumerate() {\r\n            let next = values.next();\r\n            if next.is_none() \u0026\u0026 !arg.is_optional() {\r\n                let span = self.arg_count_span();\r\n                return oops!(FunctionArguments {\r\n                    min: span.0,\r\n                    max: span.1,\r\n                    signature: function_signature\r\n                });\r\n            } else if next.is_none() {\r\n                continue;\r\n            }\r\n\r\n            let next = next.unwrap().clone().as_type(arg.expected_type);\r\n            if next.is_err() {\r\n                if arg.is_optional() {\r\n                    continue;\r\n                } else {\r\n                    return oops!(FunctionArgumentType {\r\n                        arg: i + 1,\r\n                        expected_type: arg.expected_type,\r\n                        signature: function_signature\r\n                    });\r\n                }\r\n            }\r\n            let next = next.unwrap();\r\n\r\n            if arg.is_plural() {\r\n                let mut matches = Vec::new();\r\n                matches.push(next);\r\n                while let Some(next) = values.peek() {\r\n                    if next.is_a(arg.expected_type) {\r\n                        matches.push(values.next().unwrap().clone());\r\n                    } else {\r\n                        break;\r\n                    }\r\n                }\r\n                state.set_variable(name, Value::array(matches));\r\n            } else {\r\n                state.set_variable(name, next);\r\n            }\r\n        }\r\n\r\n        if values.next().is_some() {\r\n            let span = self.arg_count_span();\r\n            return oops!(FunctionArguments {\r\n                min: span.0,\r\n                max: span.1,\r\n                signature: function_signature\r\n            });\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n}\r\n\r\n/// Object trait used for parser functions\r\npub trait ParserFunction\r\nwhere\r\n    Self: Send + Sync + std::fmt::Debug,\r\n{\r\n    /// Name of the function\r\n    fn name(\u0026self) -\u003e \u0026str;\r\n\r\n    /// Return type of the function\r\n    fn return_type(\u0026self) -\u003e ValueType;\r\n\r\n    /// Expected arguments for the function\r\n    fn expected_arguments(\u0026self) -\u003e Vec\u003c(Cow\u003c'static, str\u003e, FunctionArgument)\u003e;\r\n\r\n    /// Clones the function\r\n    fn clone_self(\u0026self) -\u003e Box\u003cdyn ParserFunction\u003e;\r\n\r\n    /// Identifies system functions that should not be overridden by user functions\r\n    fn is_readonly(\u0026self) -\u003e bool {\r\n        false\r\n    }\r\n\r\n    /// Documentation for the function\r\n    fn documentation(\u0026self) -\u003e \u0026dyn FunctionDocumentation;\r\n\r\n    /// Mutable version of documentation\r\n    fn documentation_mut(\u0026mut self) -\u003e \u0026mut dyn FunctionDocumentation;\r\n\r\n    /// Call the function's handler - use exec instead to map arguments first\r\n    fn call(\u0026self, state: \u0026mut State, reference: Option\u003c\u0026AssignmentTarget\u003e)\r\n        -\u003e Result\u003cValue, Error\u003e;\r\n\r\n    /// Loads the arguments into the state\r\n    fn load_arguments(\u0026self, values: \u0026[Value], state: \u0026mut State) -\u003e Result\u003c(), Error\u003e {\r\n        match self\r\n            .expected_arguments()\r\n            .map_arguments(values, state, self.signature())\r\n        {\r\n            Ok(_) =\u003e Ok(()),\r\n            Err(e) =\u003e {\r\n                state.scope_out();\r\n                Err(e)\r\n            }\r\n        }\r\n    }\r\n\r\n    /// Returns the function signature\r\n    fn signature(\u0026self) -\u003e String {\r\n        format!(\r\n            \"{}({}) -\u003e {}\",\r\n            self.name(),\r\n            self.expected_arguments()\r\n                .iter()\r\n                .map(|(name, arg)| {\r\n                    let type_name = if arg.expected_type == ValueType::Any {\r\n                        \"\".to_string()\r\n                    } else {\r\n                        format!(\":{}\", arg.expected_type)\r\n                    };\r\n                    (if arg.is_optional() {\r\n                        format!(\"[{}{}]\", name, type_name)\r\n                    } else {\r\n                        format!(\"{}{}\", name, type_name)\r\n                    } + if arg.is_plural() { \", ...\" } else { \"\" })\r\n                })\r\n                .collect::\u003cVec\u003cString\u003e\u003e()\r\n                .join(\", \"),\r\n            self.return_type(),\r\n        )\r\n    }\r\n\r\n    /// Executes the function with the given values\r\n    /// Values are checked mapped into the state into a new scope\r\n    /// arg1_references is used to add a pass-by-reference flag to the first argument\r\n    fn exec(\r\n        \u0026self,\r\n        values: \u0026[Value],\r\n        state: \u0026mut State,\r\n        reference: Option\u003c\u0026AssignmentTarget\u003e,\r\n    ) -\u003e Result\u003cValue, Error\u003e {\r\n        state.scope_into()?;\r\n        state.lock_scope();\r\n        self.load_arguments(values, state)?;\r\n\r\n        let result = self.call(state, reference);\r\n        state.scope_out();\r\n\r\n        result\r\n    }\r\n}\r\n","traces":[{"line":31,"address":[],"length":0,"stats":{"Line":1629},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":1656},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":2983},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":5966},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":882},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":882},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":2248},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":1366},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":1371},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":1366},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":1361},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":1361},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":1360},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":1360},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":1360},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":882},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":882},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":882},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":882},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":882},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":882},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":882},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":1115},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":1115},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":1115},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":1115},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":1115},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":2738},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":3246},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":1118},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":505},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":1602},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":3246},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":1115},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":1115},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":1115},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":882},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":882},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":882},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":882},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":882},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":882},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":882},"fn_name":null}],"covered":49,"coverable":81},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","functions","stdlib","bitwise.rs"],"content":"use crate::define_stdfunction;\r\nuse polyvalue::{\r\n    operations::{BitwiseOperation, BitwiseOperationExt},\r\n    types::I64,\r\n    InnerValue,\r\n};\r\n\r\nmacro_rules! define_standard_bitwise_fn {\r\n    ($operation:ident, $examples:literal, $bitwise_op:ident) =\u003e {\r\n        define_stdfunction!(\r\n            $operation {\r\n                left: Standard::Int,\r\n                right: Standard::Int\r\n            },\r\n            returns = Int,\r\n            docs = {\r\n                category: \"Bitwise\",\r\n                description: concat!(\"Performs a bitwise \", stringify!($operation), \" operation on two integers\"),\r\n                ext_description: \"\r\n                    Floats and Fixed-point numbers will be truncated to integers before the operation is performed.\r\n                \",\r\n                examples: $examples,\r\n            },\r\n            handler = (state, _reference) {\r\n                let left = required_arg!(state::left);\r\n                let right = required_arg!(state::right);\r\n                Ok(left.bitwise_op(right, BitwiseOperation::$bitwise_op)?)\r\n            },\r\n        );\r\n    };\r\n}\r\n\r\ndefine_standard_bitwise_fn!(xor, \"assert_eq(0b1010, xor(0b1100, 0b0110))\", Xor);\r\ndefine_standard_bitwise_fn!(and, \"assert_eq(0b0100, and(0b1100, 0b0110))\", And);\r\ndefine_standard_bitwise_fn!(or, \"assert_eq(0b1110, or(0b1100, 0b0110))\", Or);\r\n\r\ndefine_stdfunction!(\r\n    not {\r\n        value: Standard::Int\r\n    },\r\n    returns = Int,\r\n    docs = {\r\n        category: \"Bitwise\",\r\n        description: \"Performs a bitwise NOT operation on an integer\",\r\n        ext_description: \"\r\n            Floats and Fixed-point numbers will be truncated to integers before the operation is performed.\r\n        \",\r\n        examples: \"\r\n            assert_eq(0b1111_1111u8, not(0b0000_0000u8))\r\n        \",\r\n    },\r\n    handler = (state, _reference) {\r\n        let value = required_arg!(state::value);\r\n        Ok(value.bitwise_not()?)\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    llshift {\r\n        value: Standard::Int,\r\n        shift: Standard::Int\r\n    },\r\n    returns = Int,\r\n    docs = {\r\n        category: \"Bitwise\",\r\n        description: \"Performs a logical bitwise left shift operation on an integer\",\r\n        ext_description: \"\r\n            Floats and Fixed-point numbers will be truncated to integers before the operation is performed.\r\n            Will always ignore the sign bit.\r\n        \",\r\n        examples: \"\r\n            assert_eq(\r\n                0b1000_0010i8,\r\n                llshift(0b0100_0001i8, 1)\r\n            )\r\n        \",\r\n    },\r\n    handler = (state, _reference) {\r\n        let value = required_arg!(state::value);\r\n        let shift = required_arg!(state::shift).as_a::\u003ci32\u003e()?;\r\n\r\n        Ok(match value.inner() {\r\n            InnerValue::U8(v) =\u003e v.logical_lshift(shift)?.into(),\r\n            InnerValue::U16(v) =\u003e v.logical_lshift(shift)?.into(),\r\n            InnerValue::U32(v) =\u003e v.logical_lshift(shift)?.into(),\r\n            InnerValue::U64(v) =\u003e v.logical_lshift(shift)?.into(),\r\n            InnerValue::I8(v) =\u003e v.logical_lshift(shift)?.into(),\r\n            InnerValue::I16(v) =\u003e v.logical_lshift(shift)?.into(),\r\n            InnerValue::I32(v) =\u003e v.logical_lshift(shift)?.into(),\r\n            _ =\u003e {\r\n                let v = value.as_a::\u003cI64\u003e()?;\r\n                v.logical_lshift(shift)?.into()\r\n            }\r\n        })\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    lrshift {\r\n        value: Standard::Int,\r\n        shift: Standard::Int\r\n    },\r\n    returns = Int,\r\n    docs = {\r\n        category: \"Bitwise\",\r\n        description: \"Performs a logical bitwise right shift operation on an integer\",\r\n        ext_description: \"\r\n            Floats and Fixed-point numbers will be truncated to integers before the operation is performed.\r\n            Will always ignore the sign bit.\r\n        \",\r\n        examples: \"\r\n            assert_eq(\r\n                0b0100_0000i8,\r\n                lrshift(0b1000_0001i8, 1)\r\n            )\r\n        \",\r\n    },\r\n    handler = (state, _reference) {\r\n        let value = required_arg!(state::value);\r\n        let shift = required_arg!(state::shift).as_a::\u003ci32\u003e()?;\r\n\r\n        Ok(match value.inner() {\r\n            InnerValue::U8(v) =\u003e v.logical_rshift(shift)?.into(),\r\n            InnerValue::U16(v) =\u003e v.logical_rshift(shift)?.into(),\r\n            InnerValue::U32(v) =\u003e v.logical_rshift(shift)?.into(),\r\n            InnerValue::U64(v) =\u003e v.logical_rshift(shift)?.into(),\r\n            InnerValue::I8(v) =\u003e v.logical_rshift(shift)?.into(),\r\n            InnerValue::I16(v) =\u003e v.logical_rshift(shift)?.into(),\r\n            InnerValue::I32(v) =\u003e v.logical_rshift(shift)?.into(),\r\n            _ =\u003e {\r\n                let v = value.as_a::\u003cI64\u003e()?;\r\n                v.logical_rshift(shift)?.into()\r\n            }\r\n        })\r\n    },\r\n);\r\n","traces":[{"line":24,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":6},"fn_name":null}],"covered":85,"coverable":85},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","functions","stdlib","collections.rs"],"content":"use crate::{\r\n    define_stdfunction,\r\n    error::{ErrorDetails, WrapExternalError},\r\n};\r\nuse polyvalue::{\r\n    operations::{IndexingMutationExt, IndexingOperationExt},\r\n    types::{Array, Object},\r\n    Value, ValueType,\r\n};\r\n\r\n/**********************************************\r\n *\r\n * Array Metadata Functions\r\n *\r\n *********************************************/\r\n\r\ndefine_stdfunction!(\r\n    len { input: Standard::Any },\r\n    returns = Int,\r\n    docs = {\r\n        category: \"Collections\",\r\n        description: \"Returns the length of the given array or object\",\r\n        ext_description: \"\r\n            For arrays and objects, this function returns the number of elements in the array or object.\r\n            For strings, it returns the number of characters.\r\n            For all other types it will return 1\r\n        \",\r\n        examples: \"\r\n            assert_eq(len('test'),       4);\r\n            assert_eq(len([1, 2, 3]),    3);\r\n            assert_eq(len({'a': 1, 'b': 2}), 2);\r\n            assert_eq(len(38),           1);\r\n        \",\r\n    },\r\n    handler = (state, _reference) {\r\n        let input = required_arg!(state::input);\r\n        Ok(Value::i64(input.len() as i64))\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    is_empty { input: Standard::Any },\r\n    returns = Bool,\r\n    docs = {\r\n    category: \"Collections\",\r\n    description: \"Returns true if the given array or object is empty\",\r\n    ext_description: \"\r\n        For arrays and objects, this function returns true if the array or object has no elements.\r\n        For strings, it returns true if the string is empty.\r\n        For all other types it will return false\r\n    \",\r\n    examples: \"\r\n        assert_eq(is_empty([]),     true);\r\n        assert_eq(is_empty({}),     true);\r\n        assert_eq(is_empty('test'), false);\r\n        assert_eq(is_empty(38),     false);\r\n        \",\r\n    },\r\n    handler = (state, _reference) {\r\n        let input = required_arg!(state::input);\r\n        Ok(Value::bool(input.len() == 0))\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    first { input: Standard::Array },\r\n    returns = Any,\r\n    docs = {\r\n        category: \"Collections\",\r\n        description: \"Returns the first element of the given array\",\r\n        ext_description: \"\r\n            Coerces its argument to an array and returns the first element.\r\n            If the resulting array is empty, an error is returned.\r\n        \",\r\n        examples: \"\r\n            assert_eq(first([1, 2, 3]), 1);\r\n            assert_eq(first(3),         3); // equivalent to first([3])\r\n            \r\n            would_err('first([])'); // Array is empty, so an error is returned\r\n        \",\r\n    },\r\n    handler = (state, _reference) {\r\n        let input = required_arg!(state::input).as_a::\u003cArray\u003e()?;\r\n        input.first().cloned().ok_or(ErrorDetails::ArrayEmpty).without_context()\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    last { input: Standard::Array },\r\n    returns = Any,\r\n    docs = {\r\n        category: \"Collections\",\r\n        description: \"Returns the last element of the given array\",\r\n        ext_description: \"\r\n            Coerces its argument to an array and returns the last element.\r\n            If the resulting array is empty, an error is returned.\r\n        \",\r\n        examples: \"\r\n            assert_eq(last([1, 2, 3]), 3);\r\n            assert_eq(last(3),         3); // equivalent to last([3])\r\n\r\n            would_err('last([])'); // Array is empty, so an error is returned\r\n        \",\r\n    },\r\n    handler = (state, _reference) {\r\n        let input = required_arg!(state::input).as_a::\u003cArray\u003e()?;\r\n        input.last().cloned().ok_or(ErrorDetails::ArrayEmpty).without_context()\r\n    },\r\n);\r\n\r\n/**********************************************\r\n *\r\n * Array Manipulation Functions\r\n *\r\n *********************************************/\r\n\r\ndefine_stdfunction!(\r\n    pop { input: Standard::Array },\r\n    returns = Any,\r\n    docs = {\r\n        category: \"Collections\",\r\n        description: \"Removes and returns the last element of the given array\",\r\n        ext_description: \"\r\n            Removes the last element from the given array and returns it.\r\n            If the array is empty, an error is returned.\r\n            If the input is a reference to an array in a variable, the variable is updated.\r\n        \",\r\n        examples: \"\r\n            assert_eq(pop([1, 2, 3]), 3);\r\n            would_err('pop([]') // Array is empty, so an error is returned\r\n            \r\n            a = [1];\r\n            assert_eq(pop(a), 1);\r\n            assert_eq(a, []);\r\n        \",\r\n    },\r\n    handler = (state, reference) {\r\n        let input = required_arg!(state::input);\r\n        let input_type = input.own_type();\r\n        let mut input = input.as_a::\u003cArray\u003e()?.clone();\r\n        let value = input.pop().ok_or(ErrorDetails::ArrayEmpty).without_context()?;\r\n\r\n        // Update the array if it references a variable containing an array\r\n        if let Some(reference) = reference {\r\n            if input_type == ValueType::Array {\r\n                reference.update_value_in_parent(state, input.clone().into())?;\r\n            }\r\n        };\r\n\r\n        Ok(value)\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    push { input: Standard::Collection, value: Standard::Any },\r\n    returns = Array,\r\n    docs = {\r\n        category: \"Collections\",\r\n        description: \"Appends the given value to the end of the given collection, and returns the result\",\r\n        ext_description: \"\r\n            Appends the given value to the end of the given collection.\r\n            If the input is a reference to a collection in a variable, the variable is updated.\r\n        \",\r\n        examples: \"\r\n        assert_eq(push([1, 2], 3), [1, 2, 3]);\r\n        assert_eq(push([], 3), [3]);\r\n        \r\n        a = [1];\r\n        assert_eq(push(a, 2), [1, 2]);\r\n        assert_eq(a, [1, 2]);\r\n    \",\r\n    },\r\n    handler = (state, reference) {\r\n        let input = required_arg!(state::input);\r\n        let input_type = input.own_type();\r\n        let value = required_arg!(state::value);\r\n\r\n        match input_type {\r\n            ValueType::Array =\u003e {\r\n                let mut input = input.as_a::\u003cArray\u003e()?;\r\n                input.push(value.clone());\r\n\r\n                // Update the array if it references a variable containing an array\r\n                if let Some(reference) = reference {\r\n                    if let Some(target) = reference.get_target_mut_in_parent(state)? {\r\n                        *target = input.clone().into();\r\n                    }\r\n                };\r\n\r\n                Ok(input.into())\r\n            }\r\n\r\n            ValueType::String =\u003e {\r\n                let mut input = input.as_a::\u003cString\u003e()?;\r\n                input.push_str(\u0026value.to_string());\r\n\r\n                // Update the array if it references a variable containing an array\r\n                if let Some(reference) = reference {\r\n                    reference.update_value_in_parent(state, input.clone().into())?;\r\n                };\r\n\r\n                Ok(input.into())\r\n            }\r\n\r\n            _ =\u003e oops!(Custom {\r\n                msg: format!(\"cannot push to `{input_type}`\")\r\n            })\r\n        }\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    enqueue { input: Standard::Array, value: Standard::Any },\r\n    returns = Array,\r\n    docs = {\r\n        category: \"Collections\",\r\n        description: \"Appends the given value to the start of the given array, and returns the result\",\r\n        ext_description: \"\r\n            Appends the given value to the start of the given array.\r\n            If the input is a reference to an array in a variable, the variable is updated.\r\n            This function is less performant than `push` for large arrays, as it requires shifting all elements by one position.\r\n        \",\r\n        examples: \"\r\n            assert_eq(enqueue([1, 2], 3), [3, 1, 2])\r\n            assert_eq(enqueue([], 3), [3])\r\n            \r\n            a = [1]\r\n            assert_eq(enqueue(a, 2), [2, 1])\r\n            assert_eq(a, [2, 1])\r\n        \",\r\n    },\r\n    handler = (state, reference) {\r\n        let input = required_arg!(state::input);\r\n        let input_type = input.own_type();\r\n        let mut input = input.as_a::\u003cArray\u003e()?.clone();\r\n        let value = required_arg!(state::value).clone();\r\n\r\n        input.insert(0, value);\r\n\r\n        // Update the array if it references a variable containing an array\r\n        if let Some(reference) = reference {\r\n            if input_type == ValueType::Array {\r\n                reference.update_value_in_parent(state, input.clone().into())?;\r\n            }\r\n        };\r\n\r\n        Ok(input.into())\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    dequeue { input: Standard::Array },\r\n    returns = Array,\r\n    docs = {\r\n        category: \"Collections\",\r\n        description: \"Removes and returns the first element of the given array\",\r\n        ext_description: \"\r\n            Removes the first element from the given array and returns it.\r\n            If the array is empty, an error is returned.\r\n            If the input is a reference to an array in a variable, the variable is updated.\r\n            This function is less performant than `pop` for large arrays, as it requires shifting all elements by one position.\r\n        \",\r\n        examples: \"\r\n            assert_eq(dequeue([1, 2, 3]), 1);\r\n            would_err('dequeue([]') // Array is empty, so an error is returned\r\n            \r\n            a = [1, 2];\r\n            assert_eq(dequeue(a), 1);\r\n            assert_eq(a, [2]);\r\n        \",\r\n    },\r\n    handler = (state, reference) {\r\n        let input = required_arg!(state::input);\r\n        let input_type = input.own_type();\r\n        let mut input = input.as_a::\u003cArray\u003e()?.clone();\r\n        let value = input.remove(0).ok_or(ErrorDetails::ArrayEmpty).without_context()?;\r\n\r\n        // Update the array if it references a variable containing an array\r\n        if let Some(reference) = reference {\r\n            if input_type == ValueType::Array {\r\n                reference.update_value_in_parent(state, input.clone().into())?;\r\n            }\r\n        };\r\n\r\n        Ok(value)\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    insert {\r\n        input: Standard::Array,\r\n        index: Standard::Int,\r\n        value: Standard::Any\r\n    },\r\n    returns = Array,\r\n    docs = {\r\n        category: \"Collections\",\r\n        description: \"Inserts the given value at the given index in the given array, and returns the result\",\r\n        ext_description: \"\r\n            Inserts the given value at the given index in the given array.\r\n            If the input is a reference to an array in a variable, the variable is updated.\r\n            If the index is out of bounds, an error is returned.\r\n        \",\r\n        examples: \"\r\n            assert_eq(insert([1, 2, 3], 1, 4), [1, 4, 2, 3]);\r\n            assert_eq(insert([1, 2, 3], 3, 4), [1, 2, 3, 4]);\r\n            assert_eq(insert([1, 2, 3], 0, 4), [4, 1, 2, 3]);\r\n\r\n            would_err('insert([1, 2, 3], 4, 4)') // Index out of bounds\r\n            \r\n            a = [1, 2, 3];\r\n            assert_eq(insert(a, 1, 4), [1, 4, 2, 3]);\r\n            assert_eq(a, [1, 4, 2, 3]);\r\n        \",\r\n    },\r\n    handler = (state, reference) {\r\n        let input = required_arg!(state::input);\r\n        let input_type = input.own_type();\r\n        let mut input = input.as_a::\u003cArray\u003e()?.clone();\r\n\r\n        let index = required_arg!(state::index);\r\n        let value = required_arg!(state::value);\r\n\r\n        input.insert_at(\u0026index, value.clone())?;\r\n\r\n        // Update the array if it references a variable containing an array\r\n        if let Some(reference) = reference {\r\n            if input_type == ValueType::Array {\r\n                reference.update_value_in_parent(state, input.clone().into())?;\r\n            }\r\n        };\r\n\r\n        Ok(input.into())\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    remove {\r\n        input: Standard::Array,\r\n        index: Standard::Int\r\n    },\r\n    returns = Array,\r\n    docs = {\r\n        category: \"Collections\",\r\n        description: \"Removes the element at the given index in the given array, and returns value\",\r\n        ext_description: \"\r\n            Removes the element at the given index in the given array.\r\n            If the input is a reference to an array in a variable, the variable is updated.\r\n            If the index is out of bounds, an error is returned.\r\n        \",\r\n        examples: \"\r\n            assert_eq(remove([1, 2, 3], 1), 2);\r\n            assert_eq(remove([1, 2, 3], 2), 3);\r\n            assert_eq(remove([1, 2, 3], 0), 1);\r\n\r\n            would_err('remove([1, 2, 3], 3)') // Index out of bounds\r\n            \r\n            a = [1, 2, 3];\r\n            assert_eq(remove(a, 1), 2);\r\n            assert_eq(a, [1, 3]);\r\n        \",\r\n    },\r\n    handler = (state, reference) {\r\n        let input = required_arg!(state::input);\r\n        let input_type = input.own_type();\r\n        let mut input = input.as_a::\u003cArray\u003e()?.clone();\r\n\r\n        let index = required_arg!(state::index);\r\n\r\n        let removed = input.delete_index(\u0026index)?;\r\n\r\n        // Update the array if it references a variable containing an array\r\n        if let Some(reference) = reference {\r\n            if input_type == ValueType::Array {\r\n                reference.update_value_in_parent(state, input.clone().into())?;\r\n            }\r\n        };\r\n\r\n        Ok(removed)\r\n    },\r\n);\r\n\r\n/**********************************************\r\n *\r\n * Object Manipulation Functions\r\n *\r\n *********************************************/\r\n\r\ndefine_stdfunction!(\r\n    keys { input: Standard::Object },\r\n    returns = Array,\r\n    docs = {\r\n        category: \"Collections\",\r\n        description: \"Returns an array of the keys of the given object\",\r\n        ext_description: \"\r\n            Returns an array of the keys of the given object.\r\n            The order of the keys is not guaranteed.\r\n        \",\r\n        examples: \"\r\n            assert_eq(\r\n                keys({'a': 1, 'b': 2}).sort(),\r\n                ['a', 'b']\r\n            );\r\n            assert_eq(keys({}), []);\r\n        \",\r\n    },\r\n    handler = (state, _reference) {\r\n        let input = required_arg!(state::input).as_a::\u003cObject\u003e()?;\r\n        Ok(Value::from(\r\n            input.keys().iter().cloned().cloned().collect::\u003cVec\u003c_\u003e\u003e()\r\n        ))\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    values { input: Standard::Object },\r\n    returns = Array,\r\n    docs = {\r\n        category: \"Collections\",\r\n        description: \"Returns an array of the values of the given object\",\r\n        ext_description: \"\r\n            Returns an array of the values of the given object.\r\n            The order of the values is not guaranteed.\r\n        \",\r\n        examples: \"\r\n            assert_eq(\r\n                values({'a': 1, 'b': 2}).sort(), \r\n                [1, 2]\r\n            );\r\n            assert_eq(values({}), []);\r\n        \",\r\n    },\r\n    handler = (state, _reference) {\r\n        let input = required_arg!(state::input).as_a::\u003cObject\u003e()?;\r\n        Ok(Value::from(\r\n            input.values().iter().cloned().cloned().collect::\u003cVec\u003c_\u003e\u003e()\r\n        ))\r\n    },\r\n);\r\n\r\n/**********************************************\r\n *\r\n * Array Query Functions\r\n *\r\n *********************************************/\r\n\r\ndefine_stdfunction!(\r\n    all { input: Standard::Array },\r\n    returns = Bool,\r\n    docs = {\r\n        category: \"Collections\",\r\n        description: \"Returns true if all elements of the given array are truthy\",\r\n        ext_description: \"\r\n            Returns true if all elements of the given array evaluate to true.\r\n            If the array is empty, true is returned.\r\n        \",\r\n        examples: \"\r\n            assert_eq(all([true, true, true]), true);\r\n            assert_eq(all([0, 1, 2]), false);\r\n            assert_eq(all([]), true);\r\n        \",\r\n    },\r\n    handler = (state, _reference) {\r\n        let input = required_arg!(state::input).as_a::\u003cArray\u003e()?;\r\n        Ok(Value::bool(input.iter().all(|v| v.is_truthy())))\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    any { input: Standard::Array },\r\n    returns = Bool,\r\n    docs = {\r\n        category: \"Collections\",\r\n        description: \"Returns true if any element of the given array is truthy\",\r\n        ext_description: \"\r\n            Returns true if any element of the given array evaluates to true.\r\n            If the array is empty, false is returned.\r\n        \",\r\n        examples: \"\r\n            assert_eq(any([true, true, true]), true);\r\n            assert_eq(any([0, 1, 2]), true);\r\n            assert_eq(any([]), false);\r\n        \",\r\n    },\r\n    handler = (state, _reference) {\r\n        let input = required_arg!(state::input).as_a::\u003cArray\u003e()?;\r\n        Ok(Value::bool(input.iter().any(|v| v.is_truthy())))\r\n    },\r\n);\r\n\r\n/**********************************************\r\n *\r\n * Array Combinators\r\n *\r\n *********************************************/\r\n\r\n// sort, reverse\r\n\r\ndefine_stdfunction!(\r\n    split {\r\n        input: Standard::Array,\r\n        index: Standard::Int\r\n    },\r\n    returns = Array,\r\n    docs = {\r\n        category: \"Collections\",\r\n        description: \"Splits the given array at the given index, and returns the two resulting arrays\",\r\n        ext_description: \"\r\n            If the index is out of bounds, an error is returned.\r\n            Returns start-to-index (excluding index) and index-to-end (including index) arrays.\r\n        \",\r\n        examples: \"\r\n            assert_eq(split([1, 2, 3, 4], 2), [[1, 2], [3, 4]]);\r\n            assert_eq(split([1, 2, 3, 4], 0), [[], [1, 2, 3, 4]]);\r\n            assert_eq(split([1, 2, 3, 4], 4), [[1, 2, 3, 4], []]);\r\n\r\n            would_err('split([1, 2, 3, 4], 5)') // Index out of bounds\r\n        \",\r\n    },\r\n    handler = (state, _reference) {\r\n        let input = required_arg!(state::input).as_a::\u003cArray\u003e()?.clone();\r\n        let index = required_arg!(state::index).as_a::\u003ci64\u003e()?;\r\n\r\n        let left = Value::range(0i64 ..= (index - 1i64));\r\n        let left = input.get_indices(\u0026left)?;\r\n\r\n        let right = Value::range(index ..= (input.len() as i64 - 1));\r\n        let right = input.get_indices(\u0026right)?;\r\n\r\n        Ok(Value::from(vec![left, right]))\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    merge {\r\n        left: Standard::Array,\r\n        right: Standard::Array\r\n    },\r\n    returns = Array,\r\n    docs = {\r\n        category: \"Collections\",\r\n        description: \"Merges the two given arrays into a single array, and returns the result\",\r\n        ext_description: \"\r\n            The two input arrays are concatenated into a single new array.\r\n            The input arrays are not updated.\r\n        \",\r\n        examples: \"\r\n            assert_eq(merge([1, 2], [3, 4]), [1, 2, 3, 4]);\r\n            assert_eq(merge([], [3, 4]), [3, 4]);\r\n            assert_eq(merge([1, 2], []), [1, 2]);\r\n        \",\r\n    },\r\n    handler = (state, _reference) {\r\n        let left = required_arg!(state::left).as_a::\u003cArray\u003e()?.clone();\r\n        let right = required_arg!(state::right).as_a::\u003cArray\u003e()?.clone();\r\n        Ok(Value::from(left.iter().chain(right.iter()).cloned().collect::\u003cVec\u003c_\u003e\u003e()))\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    extend {\r\n        left: Standard::Array,\r\n        right: Standard::Array\r\n    },\r\n    returns = Array,\r\n    docs = {\r\n        category: \"Collections\",\r\n        description: \"Appends the elements of the second array to the first array, and returns the result\",\r\n        ext_description: \"\r\n            The elements of the second array are appended to the first array.\r\n            The first array is updated.\r\n        \",\r\n        examples: \"\r\n            assert_eq(extend([1, 2], [3, 4]), [1, 2, 3, 4]);\r\n            assert_eq(extend([], [3, 4]), [3, 4]);\r\n            assert_eq(extend([1, 2], []), [1, 2]);\r\n\r\n            a = [1, 2];\r\n            extend(a, [3, 4])\r\n            assert_eq(a, [1, 2, 3, 4]);\r\n        \",\r\n    },\r\n    handler = (state, reference) {\r\n        let left = required_arg!(state::left);\r\n        let input_type = left.own_type();\r\n        let mut left = left.as_a::\u003cArray\u003e()?.clone();\r\n        let right = required_arg!(state::right).as_a::\u003cArray\u003e()?.clone();\r\n\r\n        left.extend(right.iter().cloned());\r\n\r\n        // Update the array if it references a variable containing an array\r\n        if let Some(reference) = reference {\r\n            if input_type == ValueType::Array {\r\n                reference.update_value_in_parent(state, left.clone().into())?;\r\n            }\r\n        };\r\n\r\n        Ok(left.into())\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    chunks {\r\n        input: Standard::Array,\r\n        size: Standard::Int\r\n    },\r\n    returns = Array,\r\n    docs = {\r\n        category: \"Collections\",\r\n        description: \"Splits the given array into chunks of the given size, and returns the resulting array of arrays\",\r\n        ext_description: \"\r\n            Splits the given array into chunks of the given size.\r\n            The last chunk may be smaller than the given size.\r\n        \",\r\n        examples: \"\r\n            assert_eq(chunks([1, 2, 3, 4, 5], 2), [[1, 2], [3, 4], [5]]);\r\n            assert_eq(chunks([1, 2, 3, 4, 5], 3), [[1, 2, 3], [4, 5]]);\r\n            assert_eq(chunks([1, 2, 3, 4, 5], 5), [[1, 2, 3, 4, 5]]);\r\n        \",\r\n    },\r\n    handler = (state, _reference) {\r\n        let input = required_arg!(state::input).as_a::\u003cArray\u003e()?.clone();\r\n        let size = required_arg!(state::size).as_a::\u003ci64\u003e()?;\r\n\r\n        let result = input.chunks(size as usize).map(|c| Value::from(c.to_vec())).collect::\u003cVec\u003c_\u003e\u003e();\r\n        Ok(Value::from(result))\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    flatten { input: Standard::Array },\r\n    returns = Array,\r\n    docs = {\r\n        category: \"Collections\",\r\n        description: \"Flattens the given array of arrays into a single array, and returns the result\",\r\n        ext_description: \"\r\n            Flattens the given array of arrays into a single array.\r\n            The input array is not updated.\r\n        \",\r\n        examples: \"\r\n            assert_eq(flatten([[1, 2], [3, 4]]), [1, 2, 3, 4]);\r\n            assert_eq(flatten([[1, 2], []]), [1, 2]);\r\n            assert_eq(flatten([[], []]), []);\r\n        \",\r\n    },\r\n    handler = (state, _reference) {\r\n        let input = required_arg!(state::input).as_a::\u003cArray\u003e()?.clone();\r\n        let result = input.iter().flat_map(|v| v.clone().as_a::\u003cArray\u003e().unwrap().iter().cloned().collect::\u003cVec\u003c_\u003e\u003e()).collect::\u003cVec\u003c_\u003e\u003e();\r\n        Ok(Value::from(result))\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    zip {\r\n        left: Standard::Array,\r\n        right: Standard::Array\r\n    },\r\n    returns = Array,\r\n    docs = {\r\n        category: \"Collections\",\r\n        description: \"Zips the two given arrays into an array of pairs, and returns the result\",\r\n        ext_description: \"\r\n            Zips the two given arrays into an array of pairs.\r\n            If the input arrays are of different lengths, the resulting array will have the length of the shortest input array.\r\n        \",\r\n        examples: \"\r\n            assert_eq(zip([1, 2, 3], [4, 5, 6]), [[1, 4], [2, 5], [3, 6]]);\r\n            assert_eq(zip([1, 2], [4, 5, 6]), [[1, 4], [2, 5]]);\r\n            assert_eq(zip([1, 2, 3], [4, 5]), [[1, 4], [2, 5]]);\r\n        \",\r\n    },\r\n    handler = (state, _reference) {\r\n        let left = required_arg!(state::left).as_a::\u003cArray\u003e()?.clone();\r\n        let right = required_arg!(state::right).as_a::\u003cArray\u003e()?.clone();\r\n\r\n        let result = left.iter().zip(right.iter()).map(|(l, r)| Value::from(vec![l.clone(), r.clone()])).collect::\u003cVec\u003c_\u003e\u003e();\r\n        Ok(Value::from(result))\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    zop {\r\n        left: Standard::Array,\r\n        right: Standard::Array\r\n    },\r\n    returns = Array,\r\n    docs = {\r\n        category: \"Collections\",\r\n        description: \"Zips the two given arrays into an array of pairs, and converts in to an object\",\r\n        ext_description: \"\r\n            Zips the two given arrays into an array of pairs, then converts the result to object\r\n            If the input arrays are of different lengths, the result will have the length of the shortest input array.\r\n            Will fail if any resulting keys would be invalid (collections cannot be used as object keys)\r\n        \",\r\n        examples: \"\r\n            assert_eq(zop(['a', 'b', 'c'], [1, 2, 3]), {'a': 1, 'b': 2, 'c': 3});\r\n        \",\r\n    },\r\n    handler = (state, _reference) {\r\n        let left = required_arg!(state::left).as_a::\u003cArray\u003e()?.clone();\r\n        let right = required_arg!(state::right).as_a::\u003cArray\u003e()?.clone();\r\n\r\n        let result = left.iter().zip(right.iter()).map(|(l, r)| (l.clone(), r.clone())).collect::\u003cVec\u003c(_,_)\u003e\u003e();\r\n        let result = Object::try_from(result)?;\r\n        Ok(Value::from(result))\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    sort { input: Standard::Array },\r\n    returns = Array,\r\n    docs = {\r\n        category: \"Collections\",\r\n        description: \"Sorts the given array, and returns the result\",\r\n        ext_description: \"\r\n            The resulting array is sorted in ascending order by value.\r\n            The original array is not updated.\r\n        \",\r\n        examples: \"\r\n            assert_eq(sort([3, 1, 2]), [1, 2, 3]);\r\n            assert_eq(sort(['c', 'a', 'b']), ['a', 'b', 'c']);\r\n        \",\r\n    },\r\n    handler = (state, _reference) {\r\n        let input = required_arg!(state::input).as_a::\u003cArray\u003e()?.clone();\r\n        let mut result = input.clone();\r\n        result.sort();\r\n        Ok(result.into())\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    reverse { input: Standard::Array },\r\n    returns = Array,\r\n    docs = {\r\n        category: \"Collections\",\r\n        description: \"Reverses the given array, and returns the result\",\r\n        ext_description: \"\r\n            The resulting array is the reverse of the input array.\r\n            The original array is not updated.\r\n        \",\r\n        examples: \"\r\n            assert_eq(reverse([1, 2, 3]), [3, 2, 1]);\r\n            assert_eq(reverse(['a', 'b', 'c']), ['c', 'b', 'a']);\r\n        \",\r\n    },\r\n    handler = (state, _reference) {\r\n        let input = required_arg!(state::input).as_a::\u003cArray\u003e()?.clone();\r\n        let mut result = input.clone();\r\n        result.reverse();\r\n        Ok(result.into())\r\n    },\r\n);\r\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":38},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":34},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":38},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":34},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":281,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":290,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":298,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":303,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":306,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":307,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":313,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":316,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":46},"fn_name":null},{"line":318,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":46},"fn_name":null},{"line":321,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":322,"address":[],"length":0,"stats":{"Line":46},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":328,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":329,"address":[],"length":0,"stats":{"Line":37},"fn_name":null},{"line":333,"address":[],"length":0,"stats":{"Line":40},"fn_name":null},{"line":337,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":338,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":339,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":340,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":342,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":344,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":345,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":346,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":347,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":348,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":351,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":352,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":354,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":356,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":358,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":359,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":360,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":361,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":363,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":364,"address":[],"length":0,"stats":{"Line":34},"fn_name":null},{"line":365,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":366,"address":[],"length":0,"stats":{"Line":34},"fn_name":null},{"line":368,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":370,"address":[],"length":0,"stats":{"Line":34},"fn_name":null},{"line":373,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":374,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":375,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":379,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":389,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":390,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":391,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":392,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":393,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":394,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":395,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":396,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":397,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":398,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":399,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":400,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":401,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":402,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":404,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":405,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":407,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":408,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":409,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":410,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":415,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":416,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":417,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":418,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":419,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":420,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":421,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":422,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":423,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":424,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":425,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":426,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":427,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":428,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":430,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":431,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":433,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":434,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":435,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":436,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":447,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":448,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":449,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":450,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":451,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":452,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":453,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":454,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":455,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":456,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":457,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":458,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":459,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":460,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":461,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":463,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":464,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":465,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":469,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":470,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":471,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":472,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":473,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":474,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":475,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":476,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":477,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":478,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":479,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":480,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":481,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":482,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":483,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":485,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":486,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":487,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":499,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":500,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":501,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":502,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":504,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":505,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":506,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":507,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":508,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":509,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":510,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":511,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":512,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":513,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":514,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":515,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":517,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":518,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":520,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":521,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":522,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":524,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":525,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":527,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":528,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":530,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":534,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":535,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":536,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":537,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":539,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":540,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":541,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":542,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":543,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":544,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":545,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":546,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":547,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":548,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":549,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":550,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":551,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":553,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":554,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":555,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":556,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":560,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":561,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":562,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":563,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":565,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":566,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":567,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":568,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":569,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":570,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":571,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":572,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":573,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":574,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":575,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":576,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":578,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":579,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":580,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":581,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":583,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":584,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":585,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":586,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":587,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":589,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":592,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":593,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":594,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":598,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":602,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":603,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":604,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":605,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":607,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":608,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":609,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":610,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":611,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":612,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":613,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":614,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":615,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":616,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":617,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":618,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":619,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":621,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":622,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":623,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":625,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":626,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":630,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":631,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":632,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":633,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":634,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":635,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":636,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":637,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":638,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":639,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":640,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":641,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":642,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":643,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":644,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":646,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":647,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":648,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":649,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":653,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":654,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":655,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":656,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":658,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":659,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":660,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":661,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":662,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":663,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":664,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":665,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":666,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":667,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":668,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":669,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":670,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":672,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":673,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":674,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":676,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":677,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":681,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":682,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":683,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":684,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":686,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":687,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":688,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":689,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":690,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":691,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":692,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":693,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":694,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":695,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":696,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":697,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":699,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":700,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":701,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":703,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":704,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":705,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":709,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":710,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":711,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":712,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":713,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":714,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":715,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":716,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":717,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":718,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":719,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":720,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":721,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":722,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":724,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":725,"address":[],"length":0,"stats":{"Line":37},"fn_name":null},{"line":726,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":727,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":728,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":732,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":733,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":734,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":735,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":736,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":737,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":738,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":739,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":740,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":741,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":742,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":743,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":744,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":745,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":747,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":748,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":749,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":750,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":751,"address":[],"length":0,"stats":{"Line":6},"fn_name":null}],"covered":538,"coverable":538},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","functions","stdlib","decorators_currency.rs"],"content":"use crate::define_stddecorator;\r\nuse polyvalue::types::{CurrencyInner, Fixed};\r\n\r\ndefine_stddecorator!(\r\n    usd { input: Numeric },\r\n    docs = {\r\n        description: \"Interprets a number as a USD amount\",\r\n        ext_description: \"Includes a dollar sign and two decimal places.\",\r\n        examples: \"\r\n            assert_eq(\r\n                100 @usd,\r\n                '$100.00'\r\n            )\r\n        \"\r\n    },\r\n    handler = (input) {\r\n        let input = input.as_a::\u003cFixed\u003e()?;\r\n        Ok(CurrencyInner::as_dollars(input).to_string())\r\n    }\r\n);\r\n\r\ndefine_stddecorator!(\r\n    eur { input: Numeric },\r\n    docs = {\r\n        description: \"Interprets a number as a Euro amount\",\r\n        ext_description: \"Includes a euro sign and two decimal places.\",\r\n        examples: \"\r\n            assert_eq(\r\n                100 @eur,\r\n                '100.00'\r\n            )\r\n        \"\r\n    },\r\n    handler = (input) {\r\n        let input = input.as_a::\u003cFixed\u003e()?;\r\n        Ok(CurrencyInner::as_euros(input).to_string())\r\n    }\r\n);\r\n\r\ndefine_stddecorator!(\r\n    cad { input: Numeric },\r\n    docs = {\r\n        description: \"Interprets a number as a CAD amount\",\r\n        ext_description: \"Includes a dollar sign and two decimal places.\",\r\n        examples: \"\r\n            assert_eq(\r\n                100 @cad,\r\n                '$100.00'\r\n            )\r\n        \"\r\n    },\r\n    handler = (input) {\r\n        let input = input.as_a::\u003cFixed\u003e()?;\r\n        Ok(CurrencyInner::as_dollars(input).to_string())\r\n    }\r\n);\r\n\r\ndefine_stddecorator!(\r\n    aud { input: Numeric },\r\n    docs = {\r\n        description: \"Interprets a number as a AUD amount\",\r\n        ext_description: \"Includes a dollar sign and two decimal places.\",\r\n        examples: \"\r\n            assert_eq(\r\n                100 @aud,\r\n                '$100.00'\r\n            )\r\n        \"\r\n    },\r\n    handler = (input) {\r\n        let input = input.as_a::\u003cFixed\u003e()?;\r\n        Ok(CurrencyInner::as_dollars(input).to_string())\r\n    }\r\n);\r\n\r\ndefine_stddecorator!(\r\n    gbp { input: Numeric },\r\n    docs = {\r\n        description: \"Interprets a number as a GBP amount\",\r\n        ext_description: \"Includes a pound sign and two decimal places.\",\r\n        examples: \"\r\n            assert_eq(\r\n                100 @gbp,\r\n                '100.00'\r\n            )\r\n        \"\r\n    },\r\n    handler = (input) {\r\n        let input = input.as_a::\u003cFixed\u003e()?;\r\n        Ok(CurrencyInner::as_pounds(input).to_string())\r\n    }\r\n);\r\n\r\ndefine_stddecorator!(\r\n    jpy { input: Numeric },\r\n    docs = {\r\n        description: \"Interprets a number as a JPY amount\",\r\n        ext_description: \"Includes a yen sign and no decimal places.\",\r\n        examples: \"\r\n            assert_eq(\r\n                100 @jpy,\r\n                '100'\r\n            )\r\n        \"\r\n    },\r\n    handler = (input) {\r\n        let input = input.as_a::\u003cFixed\u003e()?;\r\n        Ok(CurrencyInner::as_yen(input).to_string())\r\n    }\r\n);\r\n\r\ndefine_stddecorator!(\r\n    cny { input: Numeric },\r\n    docs = {\r\n        description: \"Interprets a number as a CNY amount\",\r\n        ext_description: \"Includes a yuan sign and two decimal places.\",\r\n        examples: \"\r\n            assert_eq(\r\n                100 @cny,\r\n                '100.00'\r\n            )\r\n        \"\r\n    },\r\n    handler = (input) {\r\n        let input = input.as_a::\u003cFixed\u003e()?;\r\n        Ok(CurrencyInner::as_yuan(input).to_string())\r\n    }\r\n);\r\n\r\ndefine_stddecorator!(\r\n    inr { input: Numeric },\r\n    docs = {\r\n        description: \"Interprets a number as a INR amount\",\r\n        ext_description: \"Includes a rupee sign and two decimal places.\",\r\n        examples: \"\r\n            assert_eq(\r\n                100 @inr,\r\n                '100.00'\r\n            )\r\n        \"\r\n    },\r\n    handler = (input) {\r\n        let input = input.as_a::\u003cFixed\u003e()?;\r\n        Ok(CurrencyInner::as_rupees(input).to_string())\r\n    }\r\n);\r\n\r\ndefine_stddecorator!(\r\n    rub { input: Numeric },\r\n    docs = {\r\n        description: \"Interprets a number as a RUB amount\",\r\n        ext_description: \"Includes a ruble sign and two decimal places.\",\r\n        examples: \"\r\n            assert_eq(\r\n                100 @rub,\r\n                '100.00'\r\n            )\r\n        \"\r\n    },\r\n    handler = (input) {\r\n        let input = input.as_a::\u003cFixed\u003e()?;\r\n        Ok(CurrencyInner::as_rubles(input).to_string())\r\n    }\r\n);\r\n","traces":[{"line":4,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":5,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":6,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":7,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":8,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":9,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":10,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":11,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":3},"fn_name":null}],"covered":117,"coverable":117},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","functions","stdlib","decorators_numeric.rs"],"content":"use crate::define_stddecorator;\r\nuse polyvalue::{operations::ArithmeticOperationExt, types::I64, ValueTrait};\r\n\r\ndefine_stddecorator!(\r\n    roman { input: Numeric },\r\n    docs = {\r\n        description: \"Interprets an integer as a roman numeral\",\r\n        ext_description: \"Like the roman system before it; this function only supports numbers up to 3999.\",\r\n        examples: \"\r\n            assert_eq(\r\n                123 @roman,\r\n                'CXXIII'\r\n            )\r\n        \"\r\n    },\r\n    handler = (input) {\r\n        let mut input = input.as_a::\u003ci64\u003e()?;\r\n        if input \u003e 3999 {\r\n            return oops!(Overflow);\r\n        }\r\n\r\n        let roman_numerals = vec![\r\n            (1000, \"M\"),\r\n            (900, \"CM\"),\r\n            (500, \"D\"),\r\n            (400, \"CD\"),\r\n            (100, \"C\"),\r\n            (90, \"XC\"),\r\n            (50, \"L\"),\r\n            (40, \"XL\"),\r\n            (10, \"X\"),\r\n            (9, \"IX\"),\r\n            (5, \"V\"),\r\n            (4, \"IV\"),\r\n            (1, \"I\"),\r\n        ];\r\n        let mut roman_numeral = String::new();\r\n        for (n, r) in roman_numerals {\r\n            while input \u003e= n {\r\n                roman_numeral.push_str(r);\r\n                input -= n;\r\n            }\r\n        }\r\n        Ok(roman_numeral)\r\n    }\r\n);\r\n\r\ndefine_stddecorator!(\r\n    ord { input: Numeric },\r\n    docs = {\r\n        description: \"Interprets an integer as an ordinal number\",\r\n        ext_description: \"This function will append the appropriate suffix to the input number.\",\r\n        examples: \"\r\n            assert_eq(\r\n                123 @ord,\r\n                '123rd'\r\n            )\r\n        \"\r\n    },\r\n    handler = (input) {\r\n        let input = input.as_a::\u003ci64\u003e()?;\r\n        let ordinal = match input % 10 {\r\n            1 =\u003e format!(\"{}st\", input),\r\n            2 =\u003e format!(\"{}nd\", input),\r\n            3 =\u003e format!(\"{}rd\", input),\r\n            _ =\u003e format!(\"{}th\", input),\r\n        };\r\n        Ok(ordinal)\r\n    }\r\n);\r\n\r\ndefine_stddecorator!(\r\n    utc { input: Numeric },\r\n    docs = {\r\n        description: \"Interprets an integer as a timestamp, and formats it in UTC standard\",\r\n        ext_description: \"This function will convert the input number to a UTC timestamp.\",\r\n        examples: \"\r\n            assert_eq(\r\n                123 @utc,\r\n                '1970-01-01T00:02:03Z'\r\n            )\r\n        \"\r\n    },\r\n    handler = (input) {\r\n        let input = input.as_a::\u003cI64\u003e()?;\r\n        let input = *input.arithmetic_op(I64::new(1000),\r\n            polyvalue::operations::ArithmeticOperation::Multiply,\r\n        )?.inner();\r\n\r\n        match chrono::DateTime::from_timestamp_millis(input) {\r\n            Some(datetime) =\u003e Ok(datetime.format(\"%Y-%m-%dT%H:%M:%SZ\").to_string()),\r\n            None =\u003e oops!(Range { input: input.to_string() }),\r\n        }\r\n    }\r\n);\r\n\r\ndefine_stddecorator!(\r\n    percent { input: Numeric },\r\n    docs = {\r\n        description: \"Interprets a number as a percentage\",\r\n        ext_description: \"This function will append a percentage sign to the input number times 100\",\r\n        examples: \"\r\n            assert_eq(\r\n                0.123 @percent,\r\n                '12.3%'\r\n            \r\n            )\r\n        \"\r\n    },\r\n    handler = (input) {\r\n        let input = input.as_a::\u003cf64\u003e()?;\r\n        Ok(format!(\"{}%\", input * 100.0))\r\n    }\r\n);\r\n","traces":[{"line":4,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":5,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":6,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":7,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":8,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":9,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":10,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":11,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":3},"fn_name":null}],"covered":83,"coverable":83},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","functions","stdlib","decorators_types.rs"],"content":"use crate::define_stddecorator;\r\nuse polyvalue::{\r\n    types::{Bool, Float, I64},\r\n    InnerValue, ValueTrait,\r\n};\r\n\r\ndefine_stddecorator!(\r\n    hex { input: Numeric },\r\n    docs = {\r\n        description: \"Base 16 number formatting, such as 0xFF\",\r\n        ext_description: \"Converts a number to a hexadecimal string. The output will be prefixed with '0x' with a length based on the input type.\",\r\n        examples: \"\r\n            assert_eq(\r\n                255 @hex,\r\n                '0xff'\r\n            )\r\n        \"\r\n    },\r\n    handler = (input) {\r\n        match input.inner() {\r\n            InnerValue::U8(v) =\u003e Ok(format!(\"{:#0x}\", v.inner())),\r\n            InnerValue::I8(v) =\u003e Ok(format!(\"{:#0x}\", v.inner())),\r\n            InnerValue::U16(v) =\u003e Ok(format!(\"{:#0x}\", v.inner())),\r\n            InnerValue::I16(v) =\u003e Ok(format!(\"{:#0x}\", v.inner())),\r\n            InnerValue::U32(v) =\u003e Ok(format!(\"{:#0x}\", v.inner())),\r\n            InnerValue::I32(v) =\u003e Ok(format!(\"{:#0x}\", v.inner())),\r\n            InnerValue::U64(v) =\u003e Ok(format!(\"{:#0x}\", v.inner())),\r\n            _ =\u003e {\r\n                let input = input.as_a::\u003ci64\u003e()?;\r\n                Ok(format!(\"{:#0x}\", input))\r\n            }\r\n        }\r\n    }\r\n);\r\n\r\ndefine_stddecorator!(\r\n    oct { input: Numeric },\r\n    docs = {\r\n        description: \"Base 8 number formatting, such as 0o77\",\r\n        ext_description: \"Converts a number to an octal string. The output will be prefixed with '0o' with a length based on the input type.\",\r\n        examples: \"\r\n            assert_eq(\r\n                255 @oct,\r\n                '0o377'\r\n            )\r\n        \"\r\n    },\r\n    handler = (input) {\r\n        match input.inner() {\r\n            InnerValue::U8(v) =\u003e Ok(format!(\"{:#0o}\", v.inner())),\r\n            InnerValue::I8(v) =\u003e Ok(format!(\"{:#0o}\", v.inner())),\r\n            InnerValue::U16(v) =\u003e Ok(format!(\"{:#0o}\", v.inner())),\r\n            InnerValue::I16(v) =\u003e Ok(format!(\"{:#0o}\", v.inner())),\r\n            InnerValue::U32(v) =\u003e Ok(format!(\"{:#0o}\", v.inner())),\r\n            InnerValue::I32(v) =\u003e Ok(format!(\"{:#0o}\", v.inner())),\r\n            InnerValue::U64(v) =\u003e Ok(format!(\"{:#0o}\", v.inner())),\r\n            _ =\u003e {\r\n                let input = input.as_a::\u003ci64\u003e()?;\r\n                Ok(format!(\"{:#0o}\", input))\r\n            }\r\n        }\r\n    }\r\n);\r\n\r\ndefine_stddecorator!(\r\n    bin { input: Numeric },\r\n    docs = {\r\n        description: \"Base 2 number formatting, such as 0b101\",\r\n        ext_description: \"Converts a number to a binary string. The output will be prefixed with '0b' with a length based on the input type.\",\r\n        examples: \"\r\n            assert_eq(\r\n                255 @bin,\r\n                '0b11111111'\r\n            )\r\n        \"\r\n    },\r\n    handler = (input) {\r\n        match input.inner() {\r\n            InnerValue::U8(v) =\u003e Ok(format!(\"{:#0b}\", v.inner())),\r\n            InnerValue::I8(v) =\u003e Ok(format!(\"{:#0b}\", v.inner())),\r\n            InnerValue::U16(v) =\u003e Ok(format!(\"{:#0b}\", v.inner())),\r\n            InnerValue::I16(v) =\u003e Ok(format!(\"{:#0b}\", v.inner())),\r\n            InnerValue::U32(v) =\u003e Ok(format!(\"{:#0b}\", v.inner())),\r\n            InnerValue::I32(v) =\u003e Ok(format!(\"{:#0b}\", v.inner())),\r\n            InnerValue::U64(v) =\u003e Ok(format!(\"{:#0b}\", v.inner())),\r\n            _ =\u003e {\r\n                let input = input.as_a::\u003ci64\u003e()?;\r\n                Ok(format!(\"{:#0b}\", input))\r\n            }\r\n        }\r\n    }\r\n);\r\n\r\ndefine_stddecorator!(\r\n    sci { input: Numeric },\r\n    docs = {\r\n        description: \"Scientific notation\",\r\n        ext_description: \"Converts a floating point number to sci notation.\",\r\n        examples: \"\r\n            assert_eq(\r\n                1000000.0 @sci,\r\n                '1e6'\r\n            )\r\n        \"\r\n    },\r\n    handler = (input) {\r\n        let input = input.as_a::\u003cf64\u003e()?;\r\n        Ok(format!(\"{:e}\", input))\r\n    }\r\n);\r\n\r\ndefine_stddecorator!(\r\n    float { input: Numeric },\r\n    docs = {\r\n        description: \"Floating point number formatting\",\r\n        ext_description: \"Converts a number to a floating point string.\",\r\n        examples: \"\r\n            assert_eq(\r\n                1.0 @float,\r\n                '1.0'\r\n            )\r\n        \"\r\n    },\r\n    handler = (input) {\r\n        let input = input.as_a::\u003cFloat\u003e()?;\r\n        Ok(input.to_string())\r\n    }\r\n);\r\n\r\ndefine_stddecorator!(\r\n    int { input: Numeric },\r\n    docs = {\r\n        description: \"Integer number formatting\",\r\n        ext_description: \"Converts a number to an integer string.\",\r\n        examples: \"\r\n            assert_eq(\r\n                1000000 @int,\r\n                '1000000'\r\n            )\r\n        \"\r\n    },\r\n    handler = (input) {\r\n        let input = input.as_a::\u003cI64\u003e()?;\r\n        Ok(input.to_string())\r\n    }\r\n);\r\n\r\ndefine_stddecorator!(\r\n    bool { input: Any },\r\n    docs = {\r\n        description: \"Boolean formatting\",\r\n        ext_description: \"Converts a number to a boolean string.\",\r\n        examples: \"\r\n            assert_eq(\r\n                1 @bool,\r\n                'true'\r\n            \r\n            )\r\n        \"\r\n    },\r\n    handler = (input) {\r\n        let input = Bool::from(input.is_truthy());\r\n        Ok(input.to_string())\r\n    }\r\n);\r\n","traces":[{"line":7,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":8,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":9,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":10,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":11,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":3},"fn_name":null}],"covered":118,"coverable":118},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","functions","stdlib","dev.rs"],"content":"use crate::{define_stdfunction, Error};\r\nuse polyvalue::Value;\r\nuse std::io::BufRead;\r\n\r\ndefine_stdfunction!(\r\n    time { },\r\n    returns = Float,\r\n    docs = {\r\n        category: \"Development\",\r\n        description: \"Returns a unix timestamp for the current system time\",\r\n        ext_description: \"\r\n            Returns a unix timestamp for the current system time.\r\n            The timestamp is a floating point number representing the number of seconds since the Unix epoch.\",\r\n        examples: \"\r\n            assert(\r\n                time() \u003e 0\r\n            )\r\n        \"\r\n    },\r\n    handler = (_state, _reference) {\r\n        Ok(Value::from(\r\n            std::time::SystemTime::now()\r\n                .duration_since(std::time::UNIX_EPOCH)\r\n                .unwrap_or_else(|_| std::time::Duration::ZERO)\r\n                .as_secs_f64(),\r\n        ))\r\n    }\r\n);\r\n\r\ndefine_stdfunction!(\r\n    tail {\r\n        file: Standard::String,\r\n        lines: Optional::Int\r\n    },\r\n    returns = Array,\r\n    docs = {\r\n        category: \"Development\",\r\n        description: \"Returns the last \u003clines\u003e lines from a given file\",\r\n        ext_description: \"\r\n            If \u003clines\u003e is not specified, the function will return the last line of the file.\",\r\n        examples: \"\r\n            lines = tail('.gitignore')\r\n            assert_eq(\r\n                lines,\r\n                ['/Cargo.lock']\r\n            )\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let n = optional_arg!(state::lines).unwrap_or(1.into()).as_a::\u003ci64\u003e()?;\r\n        let file = required_arg!(state::file).to_string();\r\n\r\n        let file = std::fs::File::open(file)?;\r\n        let lines = std::io::BufReader::new(file)\r\n            .lines()\r\n            .map(|f| Ok::\u003cValue, Error\u003e(Value::from(f?)))\r\n            .collect::\u003cResult\u003cVec\u003c_\u003e, _\u003e\u003e()?;\r\n\r\n        // return last n\r\n        Ok(Value::from(lines.iter().rev().take(n as usize).rev().cloned().collect::\u003cVec\u003c_\u003e\u003e()))\r\n    }\r\n);\r\n","traces":[{"line":5,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":6,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":7,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":8,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":9,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":10,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":11,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":6},"fn_name":null}],"covered":31,"coverable":44},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","functions","stdlib","math.rs"],"content":"use crate::{\r\n    define_stdfunction,\r\n    error::{ErrorDetails, WrapOption},\r\n};\r\nuse polyvalue::{fpdec::Round, types::CurrencyInner, InnerValue, Value, ValueTrait};\r\n\r\ndefine_stdfunction!(\r\n    min {\r\n        options: Standard::Array\r\n    },\r\n    returns = Numeric,\r\n    docs = {\r\n        category: \"Math\",\r\n        description: \"Returns the smallest value in the given array\",\r\n        ext_description: \"\r\n            The array can contain any number of elements, and they can be of any type.\r\n            Since all values in lavendeux are comparable, the function will work with any type of array.\r\n        \",\r\n        examples: \"\r\n            assert_eq(\r\n                min([1, 2, 3, 4, 5]),\r\n                1\r\n            )\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let options = required_arg!(state::options).as_a::\u003cVec\u003cValue\u003e\u003e()?;\r\n        let min = options.iter().min().or_error(ErrorDetails::ArrayEmpty)?;\r\n        Ok(min.clone())\r\n    }\r\n);\r\n\r\ndefine_stdfunction!(\r\n    max {\r\n        options: Standard::Array\r\n    },\r\n    returns = Numeric,\r\n    docs = {\r\n        category: \"Math\",\r\n        description: \"Returns the largest value in the given array\",\r\n        ext_description: \"\r\n            The array can contain any number of elements, and they can be of any type.\r\n            Since all values in lavendeux are comparable, the function will work with any type of array.\r\n        \",\r\n        examples: \"\r\n            assert_eq(\r\n                max([1, 2, 3, 4, 5]),\r\n                5\r\n            )\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let options = required_arg!(state::options).as_a::\u003cVec\u003cValue\u003e\u003e()?;\r\n        if options.is_empty() {\r\n            return oops!(ArrayEmpty)\r\n        }\r\n        let max = options.iter().max().or_error(ErrorDetails::ArrayEmpty)?;\r\n        Ok(max.clone())\r\n    }\r\n);\r\n\r\ndefine_stdfunction!(\r\n    ceil {\r\n        value: Standard::Numeric\r\n    },\r\n    returns = Numeric,\r\n    docs = {\r\n        category: \"Math\",\r\n        description: \"Rounds a number up to the nearest whole number\",\r\n        ext_description: \"\r\n            The function will round the input number up to the nearest whole number.\r\n            If the input number is already a whole number, the function will return the input number.\r\n        \",\r\n        examples: \"\r\n            assert_eq(\r\n                ceil(1.5),\r\n                2.0\r\n            )\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let value = required_arg!(state::value).as_a::\u003cf64\u003e()?;\r\n        Ok(value.ceil().into())\r\n    }\r\n);\r\n\r\ndefine_stdfunction!(\r\n    floor {\r\n        value: Standard::Numeric\r\n    },\r\n    returns = Numeric,\r\n    docs = {\r\n        category: \"Math\",\r\n        description: \"Rounds a number down to the nearest whole number\",\r\n        ext_description: \"\r\n            The function will round the input number down to the nearest whole number.\r\n            If the input number is already a whole number, the function will return the input number.\r\n        \",\r\n        examples: \"\r\n            assert_eq(\r\n                floor(1.5),\r\n                1.0\r\n            )\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let value = required_arg!(state::value).as_a::\u003cf64\u003e()?;\r\n        Ok(value.floor().into())\r\n    }\r\n);\r\n\r\ndefine_stdfunction!(\r\n    abs {\r\n        value: Standard::Numeric\r\n    },\r\n    returns = Numeric,\r\n    docs = {\r\n        category: \"Math\",\r\n        description: \"Returns the absolute value of a number\",\r\n        ext_description: \"\r\n            The function will return the absolute value of the input number.\r\n        \",\r\n        examples: \"\r\n            assert_eq(\r\n                abs(-5),\r\n                5\r\n            )\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let value = required_arg!(state::value);\r\n        match value.inner() {\r\n            InnerValue::Fixed(n) =\u003e Ok(Value::fixed(n.inner().abs())),\r\n            InnerValue::Currency(n) =\u003e {\r\n                let symbol = n.symbol().clone();\r\n                let precision = n.precision();\r\n                let value = n.inner().value().inner().abs();\r\n                Ok(CurrencyInner::new(symbol, precision, value.into()).into())\r\n            },\r\n\r\n            InnerValue::Float(n) =\u003e Ok(Value::from(n.inner().abs())),\r\n\r\n            InnerValue::U8(n) =\u003e Ok(Value::from(n.clone())),\r\n            InnerValue::U16(n) =\u003e Ok(Value::from(n.clone())),\r\n            InnerValue::U32(n) =\u003e Ok(Value::from(n.clone())),\r\n            InnerValue::U64(n) =\u003e Ok(Value::from(n.clone())),\r\n\r\n            InnerValue::I8(n) =\u003e Ok(Value::from(n.abs())),\r\n            InnerValue::I16(n) =\u003e Ok(Value::from(n.abs())),\r\n            InnerValue::I32(n) =\u003e Ok(Value::from(n.abs())),\r\n            InnerValue::I64(n) =\u003e Ok(Value::from(n.abs())),\r\n\r\n            _ =\u003e oops!(\r\n                Internal {\r\n                    msg: \"Invalid argument type\".to_string()\r\n                }\r\n            ),\r\n\r\n        }\r\n    }\r\n);\r\n\r\ndefine_stdfunction!(\r\n    round {\r\n        value: Standard::Numeric,\r\n        precision: Optional::Int\r\n    },\r\n    returns = Numeric,\r\n    docs = {\r\n        category: \"Math\",\r\n        description: \"Rounds a number to the nearest whole number\",\r\n        ext_description: \"\r\n            The function will round the input number to the nearest whole number.\r\n            If the input number is already a whole number, the function will return the input number.\r\n        \",\r\n        examples: \"\r\n            assert_eq(\r\n                round(1.5),\r\n                2.0\r\n            )\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let value = required_arg!(state::value);\r\n        let precision = optional_arg!(state::precision).unwrap_or(0.into()).as_a::\u003ci64\u003e()?;\r\n\r\n        match value.inner() {\r\n            InnerValue::Fixed(n) =\u003e Ok(Value::from(n.inner().clone().round(precision as i8))),\r\n            InnerValue::Currency(n) =\u003e {\r\n                let symbol = n.symbol().clone();\r\n                let precision = n.precision();\r\n                let value = n.inner().value().inner().clone().round(precision);\r\n                Ok(CurrencyInner::new(symbol, precision, value.into()).into())\r\n            },\r\n\r\n            InnerValue::Float(n) =\u003e {\r\n                let n = n.inner();\r\n                let n = n * 10.0_f64.powi(precision as i32);\r\n                let n = n.round();\r\n                let n = n / 10.0_f64.powi(precision as i32);\r\n                Ok(Value::from(n))\r\n            }\r\n            _ =\u003e oops!(\r\n                Internal {\r\n                    msg: \"Invalid argument type\".to_string()\r\n                }\r\n            ),\r\n        }\r\n    }\r\n);\r\n\r\ndefine_stdfunction!(\r\n    log2 {\r\n        value: Standard::Numeric\r\n    },\r\n    returns = Numeric,\r\n    docs = {\r\n        category: \"Math\",\r\n        description: \"Returns the base-2 logarithm of a number\",\r\n        ext_description: \"\",\r\n        examples: \"\r\n            assert_eq(\r\n                log2(8),\r\n                3\r\n            )\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let value = required_arg!(state::value);\r\n        let type_name = value.own_type();\r\n        let value = value.as_a::\u003cf64\u003e()?;\r\n        Ok(Value::from(value.log2()).as_type(type_name)?)\r\n    }\r\n);\r\n\r\ndefine_stdfunction!(\r\n    ilog2 {\r\n        value: Standard::Int\r\n    },\r\n    returns = Numeric,\r\n    docs = {\r\n        category: \"Math\",\r\n        description: \"Returns the base-2 logarithm of a number, rounded down to the nearest whole number\",\r\n        ext_description: \"\",\r\n        examples: \"\r\n            assert_eq(\r\n                ilog2(8),\r\n                3\r\n            )\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let value = required_arg!(state::value);\r\n        let type_name = value.own_type();\r\n        let value = value.as_a::\u003ci64\u003e()?;\r\n        Ok(Value::from(value.ilog2()).as_type(type_name)?)\r\n    }\r\n);\r\n\r\ndefine_stdfunction!(\r\n    log10 {\r\n        value: Standard::Numeric\r\n    },\r\n    returns = Numeric,\r\n    docs = {\r\n        category: \"Math\",\r\n        description: \"Returns the base-10 logarithm of a number\",\r\n        ext_description: \"\",\r\n        examples: \"\r\n            assert_eq(\r\n                log10(100),\r\n                2\r\n            )\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let value = required_arg!(state::value);\r\n        let type_name = value.own_type();\r\n        let value = value.as_a::\u003cf64\u003e()?;\r\n        Ok(Value::from(value.log10()).as_type(type_name)?)\r\n    }\r\n);\r\n\r\ndefine_stdfunction!(\r\n    ln {\r\n        value: Standard::Numeric\r\n    },\r\n    returns = Numeric,\r\n    docs = {\r\n        category: \"Math\",\r\n        description: \"Returns the natural logarithm of a number\",\r\n        ext_description: \"\",\r\n        examples: \"\r\n            assert_eq(\r\n                ln(2.718281828459045),\r\n                1.0\r\n            )\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let value = required_arg!(state::value);\r\n        let type_name = value.own_type();\r\n        let value = value.as_a::\u003cf64\u003e()?;\r\n        Ok(Value::from(value.ln()).as_type(type_name)?)\r\n    }\r\n);\r\n\r\ndefine_stdfunction!(\r\n    log {\r\n        value: Standard::Numeric,\r\n        base: Optional::Numeric\r\n    },\r\n    returns = Numeric,\r\n    docs = {\r\n        category: \"Math\",\r\n        description: \"Returns the logarithm of a number to a given base\",\r\n        ext_description: \"\",\r\n        examples: \"\r\n            assert_eq(\r\n                log(8, 2),\r\n                3.0\r\n            )\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let value = required_arg!(state::value).as_a::\u003cf64\u003e()?;\r\n        let base = optional_arg!(state::base).unwrap_or(10.into()).as_a::\u003cf64\u003e()?;\r\n        Ok(value.log(base).into())\r\n    }\r\n);\r\n\r\ndefine_stdfunction!(\r\n    sqrt {\r\n        value: Standard::Numeric\r\n    },\r\n    returns = Numeric,\r\n    docs = {\r\n        category: \"Math\",\r\n        description: \"Returns the square root of a number\",\r\n        ext_description: \"\",\r\n        examples: \"\r\n            assert_eq(\r\n                sqrt(9),\r\n                3.0\r\n            )\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let value = required_arg!(state::value).as_a::\u003cf64\u003e()?;\r\n        Ok(value.sqrt().into())\r\n    }\r\n);\r\n\r\ndefine_stdfunction!(\r\n    root {\r\n        value: Standard::Numeric,\r\n        root: Standard::Numeric\r\n    },\r\n    returns = Numeric,\r\n    docs = {\r\n        category: \"Math\",\r\n        description: \"Returns the nth root of a number\",\r\n        ext_description: \"\",\r\n        examples: \"\r\n            assert_eq(\r\n                root(8, 3),\r\n                2.0\r\n            )\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let value = required_arg!(state::value).as_a::\u003cf64\u003e()?;\r\n        let root = required_arg!(state::root).as_a::\u003cf64\u003e()?;\r\n        Ok(value.powf(1.0 / root).into())\r\n    }\r\n);\r\n","traces":[{"line":7,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":8,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":9,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":11,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":288,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":290,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":298,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":303,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":310,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":313,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":316,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":318,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":321,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":323,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":326,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":328,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":333,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":334,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":336,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":337,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":338,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":339,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":340,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":341,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":342,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":344,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":346,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":348,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":354,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":356,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":357,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":359,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":360,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":361,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":362,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":363,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":364,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":365,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":366,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":367,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":369,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":371,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":372,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":373,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":374,"address":[],"length":0,"stats":{"Line":6},"fn_name":null}],"covered":276,"coverable":276},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","functions","stdlib","network.rs"],"content":"use crate::{\r\n    define_stdfunction,\r\n    error::{ErrorDetails, WrapExternalError, WrapOption},\r\n    network::{request, resolve, ApiDefinition, ApiRegistry},\r\n};\r\nuse polyvalue::{types::Object, Value};\r\nuse serde_json::json;\r\nuse std::collections::HashMap;\r\n\r\n/**********************************************\r\n *\r\n * Network IO\r\n *\r\n *********************************************/\r\n\r\ndefine_stdfunction!(\r\n    resolve {\r\n        hostname: Standard::String\r\n    },\r\n    returns = String,\r\n    docs = {\r\n        category: \"Network\",\r\n        description: \"Resolves a hostname to an IP address\",\r\n        ext_description: \"\r\n            This function uses the system's DNS resolver to resolve a hostname to an IP address.\r\n            If the hostname cannot be resolved, this function will return an error, or time out\r\n        \",\r\n        examples: \"#skip\r\n            resolve('example.com')\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let hostname = required_arg!(state::hostname).to_string();\r\n        Ok(resolve(\u0026hostname).unwrap())\r\n    }\r\n);\r\n\r\ndefine_stdfunction!(\r\n    get {\r\n        url: Standard::String,\r\n        headers: Optional::Object\r\n    },\r\n    returns = String,\r\n    docs = {\r\n        category: \"Network\",\r\n        description: \"Performs an HTTP GET request\",\r\n        ext_description: \"\r\n            This function performs an HTTP GET request to the specified URL.\r\n            If the request fails, this function will return an error or time out\r\n        \",\r\n        examples: \"#skip\r\n            str_out = get('https://jsonplaceholder.typicode.com/users')\r\n            obj_out = get('https://jsonplaceholder.typicode.com/users', {\r\n                'Content-Type': 'application/json'\r\n            })\r\n            assert(str_out is string)\r\n            assert(obj_out is array)\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let url = required_arg!(state::url).to_string();\r\n        let headers = optional_arg!(state::headers).unwrap_or(Value::from(Object::default())).as_a::\u003cObject\u003e()?;\r\n        let headers = headers.iter().map(|(k, v)| (k.to_string(), v.to_string())).collect::\u003cHashMap\u003c_, _\u003e\u003e();\r\n        request(\u0026url, None, headers).without_context()\r\n    }\r\n);\r\n\r\ndefine_stdfunction!(\r\n    post {\r\n        url: Standard::String,\r\n        body: Standard::String,\r\n        headers: Optional::Object\r\n    },\r\n    returns = String,\r\n    docs = {\r\n        category: \"Network\",\r\n        description: \"Performs an HTTP POST request\",\r\n        ext_description: \"\r\n            This function performs an HTTP POST request to the specified URL.\r\n            If the request fails, this function will return an error or time out\r\n        \",\r\n        examples: \"#skip\r\n            obj_out = post(\r\n                'https://jsonplaceholder.typicode.com/users', \r\n                '{\\\"name\\\": \\\"John Doe\\\"}',\r\n                {'Content-Type': 'application/json'}\r\n            )\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let url = required_arg!(state::url).to_string();\r\n        let body = required_arg!(state::body).to_string();\r\n        let headers = optional_arg!(state::headers).unwrap_or(Value::from(Object::default())).as_a::\u003cObject\u003e()?;\r\n        let headers = headers.iter().map(|(k, v)| (k.to_string(), v.to_string())).collect::\u003cHashMap\u003c_, _\u003e\u003e();\r\n        request(\u0026url, Some(body), headers).without_context()\r\n    }\r\n);\r\n\r\n/**********************************************\r\n *\r\n * API Registry\r\n *\r\n *********************************************/\r\n\r\ndefine_stdfunction!(\r\n    api_add {\r\n        name: Standard::String,\r\n        endpoint: Standard::Any\r\n    },\r\n    returns = String,\r\n    docs = {\r\n        category: \"API\",\r\n        description: \"Registers an API\",\r\n        ext_description: \"\r\n            This function registers an API with the system. The API can then be used to make requests to the specified endpoint.\r\n            The endpoint can be a string, or an object with the properties [ base_url, headers, description, examples, auth_key]\r\n            Use the 'api_get' and 'api_post' functions to make requests to the registered API\r\n        \",\r\n        examples: \"\r\n            api_add('ipify', 'https://api.ipify.org')\r\n            assert( api_list() contains 'ipify' )\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let name = required_arg!(state::name).to_string();\r\n        let endpoint = required_arg!(state::endpoint);\r\n\r\n        let api = ApiDefinition::try_from(endpoint.clone())?;\r\n\r\n        ApiRegistry::new(state).add(state, \u0026name, api);\r\n        Ok(Value::from(name))\r\n    }\r\n);\r\n\r\ndefine_stdfunction!(\r\n    api_rem {name: Standard::String},\r\n    returns = String,\r\n    docs = {\r\n        category: \"API\",\r\n        description: \"Unregisters an API\",\r\n        ext_description: \"\r\n            This function unregisters an API with the system, and returns its name\r\n            The API can no longer be used to make requests\r\n        \",\r\n        examples: \"\r\n            api_rem('ipify')\r\n            assert( !(api_list() contains 'ipify') )\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let name = required_arg!(state::name).to_string();\r\n        ApiRegistry::new(state).remove(state, \u0026name);\r\n        Ok(Value::from(name))\r\n    }\r\n);\r\n\r\ndefine_stdfunction!(\r\n    api_all {},\r\n    returns = Object,\r\n    docs = {\r\n        category: \"API\",\r\n        description: \"Details all registered APIs\",\r\n        ext_description: \"\r\n            This function returns an object containing the names and endpoints of all registered APIs\r\n        \",\r\n        examples: \"\r\n            api_all()['chatgpt']['base_url']\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        Ok(ApiRegistry::raw(state))\r\n    }\r\n);\r\n\r\ndefine_stdfunction!(\r\n    api_list {},\r\n    returns = Object,\r\n    docs = {\r\n        category: \"API\",\r\n        description: \"Lists all registered APIs\",\r\n        ext_description: \"\r\n            This function returns an array containing the names of all registered APIs\r\n        \",\r\n        examples: \"\r\n            assert( api_list() contains 'chatgpt' )\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        Ok(ApiRegistry::new(state).all().keys().cloned().map(Value::from).collect::\u003cVec\u003c_\u003e\u003e().into())\r\n    }\r\n);\r\n\r\ndefine_stdfunction!(\r\n    api_get {\r\n        name: Standard::String,\r\n        path: Optional::String\r\n    },\r\n    returns = String,\r\n    docs = {\r\n        category: \"API\",\r\n        description: \"Performs a GET request to a registered API\",\r\n        ext_description: \"\r\n            This function performs a GET request to the specified path of a registered API.\r\n            The path is appended to the base URL of the API.\r\n        \",\r\n        examples: \"#skip\r\n            api_get('ipify')\r\n            api_get('ipify', '/?format=json')\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let name = required_arg!(state::name).to_string();\r\n        let path = optional_arg!(state::path).map(|v| v.to_string());\r\n\r\n        let registry = ApiRegistry::new(state);\r\n        let api = registry.get(\u0026name).or_error(ErrorDetails::Custom {\r\n            msg: format!(\"API '{}' not found\", name),\r\n        })?;\r\n\r\n        api.call(path.as_deref(), None, Default::default())\r\n    }\r\n);\r\n\r\ndefine_stdfunction!(\r\n    api_post {\r\n        name: Standard::String,\r\n        body: Standard::String,\r\n        path: Optional::String\r\n    },\r\n    returns = String,\r\n    docs = {\r\n        category: \"API\",\r\n        description: \"Performs a POST request to a registered API\",\r\n        ext_description: \"\r\n            This function performs a POST request to the specified path of a registered API.\r\n            The path is appended to the base URL of the API.\r\n        \",\r\n        examples: \"#skip\r\n            api_post('ipify', '{\\\"name\\\"=\\\"john\\\"}', 'format=json')\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let name = required_arg!(state::name).to_string();\r\n        let path = optional_arg!(state::path).map(|v| v.to_string());\r\n        let body = required_arg!(state::body).to_string();\r\n\r\n        let registry = ApiRegistry::new(state);\r\n        let api = registry.get(\u0026name).or_error(ErrorDetails::Custom {\r\n            msg: format!(\"API '{}' not found\", name),\r\n        })?;\r\n\r\n        api.call(path.as_deref(), Some(body), Default::default())\r\n    }\r\n);\r\n\r\ndefine_stdfunction!(\r\n    api_key {\r\n        name: Standard::String,\r\n        auth_key: Standard::String\r\n    },\r\n    returns = String,\r\n    docs = {\r\n        category: \"API\",\r\n        description: \"Sets an authentication key for a registered API\",\r\n        ext_description: \"\r\n            This function sets an authentication key for a registered API.\r\n            The key will be used in the 'Authorization' header of requests to the API.\r\n        \",\r\n        examples: \"\r\n            api_key('chatgpt', 'my_super_secret_api_key')\r\n            assert_eq( api_all()['chatgpt']['auth_key'], 'my_super_secret_api_key' )\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let name = required_arg!(state::name).to_string();\r\n        let auth_key = required_arg!(state::auth_key).to_string();\r\n\r\n        let mut registry = ApiRegistry::new(state);\r\n        let mut api = registry.get(\u0026name).or_error(ErrorDetails::Custom {\r\n            msg: format!(\"API '{}' not found\", name),\r\n        })?.clone();\r\n\r\n        api.auth_key = Some(auth_key);\r\n        registry.add(state, \u0026name, api);\r\n        Ok(Value::from(name))\r\n    }\r\n);\r\n\r\ndefine_stdfunction!(\r\n    chatgpt {\r\n        prompt: Standard::String\r\n    },\r\n    returns = String,\r\n    docs = {\r\n        category: \"API\",\r\n        description: \"Performs a request to the ChatGPT API\",\r\n        ext_description: \"\r\n            This function performs a request to the ChatGPT 3.5 API, using the specified prompt.\r\n        \",\r\n        examples: \"#skip\r\n            api_key('chatgpt', 'my_super_secret_api_key')\r\n            chatgpt('What is the meaning of life?')\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let prompt = required_arg!(state::prompt).to_string();\r\n        let registry = ApiRegistry::new(state);\r\n        let api = registry.get(\"chatgpt\").or_error(ErrorDetails::Custom {\r\n            msg: \"API 'chatgpt' not found\".to_string(),\r\n        })?;\r\n\r\n        if api.auth_key.is_none() {\r\n            return oops!(ValueFormat {\r\n                expected_format: \"API key for chatgpt is not set. You can set one with api_key('chatgpt', '\u003ckey\u003e')\".to_string()\r\n            });\r\n        }\r\n\r\n        use serde::{Deserialize, Serialize};\r\n        #[derive(Serialize, Deserialize)]\r\n        struct GPTMsg {\r\n            role: String,\r\n            content: String,\r\n        }\r\n        #[derive(Serialize, Deserialize)]\r\n        struct GPTQuery {\r\n            model: String,\r\n            messages: Vec\u003cGPTMsg\u003e,\r\n        }\r\n\r\n        let query = GPTQuery {\r\n            model: \"gpt-3.5-turbo\".to_string(),\r\n            messages: vec![\r\n                GPTMsg {\r\n                    role: \"system\".to_string(),\r\n                    content:\r\n                        \"You are a chatbot that must respond in concise, single-line messages.\"\r\n                            .to_string(),\r\n                },\r\n                GPTMsg {\r\n                    role: \"user\".to_string(),\r\n                    content: prompt,\r\n                },\r\n            ],\r\n        };\r\n        let query = serde_json::to_string(\u0026query)?;\r\n\r\n        let result = api\r\n            .call(Some(\u0026query), None, Default::default())?.to_string();\r\n\r\n        let json = json!(result);\r\n        let result = json[\"choices\"][0][\"message\"][\"content\"].clone();\r\n\r\n        Ok(Value::from(result.to_string()))\r\n    }\r\n);\r\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":281,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":290,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":298,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":303,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":306,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":307,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":313,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":318,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":321,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":322,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":326,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":330,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":331,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":333,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":334,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":335,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":336,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":337,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":339,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":340,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":341,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":345,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":347,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":348,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":351,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":232,"coverable":256},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","functions","stdlib","random.rs"],"content":"use crate::define_stdfunction;\r\nuse polyvalue::{types::Range, Value, ValueTrait};\r\n\r\ndefine_stdfunction!(\r\n    sha256 {\r\n        input: Standard::String\r\n    },\r\n    returns = String,\r\n    docs = {\r\n        category: \"Cryptographic\",\r\n        description: \"Returns the sha256 hash of a given string\",\r\n        ext_description: \"Will return an unsalted sha256 hash of the input string.\",\r\n        examples: \"\r\n            assert_eq(\r\n                sha256('hello'),\r\n                '2CF24DBA5FB0A30E26E83B2AC5B9E29E1B161E5C1FA7425E73043362938B9824'\r\n            )\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let input = required_arg!(state::input).to_string();\r\n\r\n        use sha2::{Digest, Sha256};\r\n        let mut hasher = Sha256::new();\r\n        hasher.update(input);\r\n\r\n        let s = format!(\"{:X}\", hasher.finalize());\r\n        Ok(Value::from(s))\r\n    }\r\n);\r\n\r\ndefine_stdfunction!(\r\n    sha512 {\r\n        input: Standard::String\r\n    },\r\n    returns = String,\r\n    docs = {\r\n        category: \"Cryptographic\",\r\n        description: \"Returns the sha512 hash of a given string\",\r\n        ext_description: \"Will return an unsalted sha512 hash of the input string.\",\r\n        examples: \"\r\n            assert_eq(\r\n                sha512('hello'),\r\n                '9B71D224BD62F3785D96D46AD3EA3D73319BFBC2890CAADAE2DFF72519673CA72323C3D99BA5C11D7C7ACC6E14B8C5DA0C4663475C2E5C3ADEF46F73BCDEC043'\r\n            )\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let input = required_arg!(state::input).to_string();\r\n\r\n        use sha2::{Digest, Sha512};\r\n        let mut hasher = Sha512::new();\r\n        hasher.update(input);\r\n\r\n        let s = format!(\"{:X}\", hasher.finalize());\r\n        Ok(Value::from(s))\r\n    }\r\n);\r\n\r\ndefine_stdfunction!(\r\n    md5 {\r\n        input: Standard::String\r\n    },\r\n    returns = String,\r\n    docs = {\r\n        category: \"Cryptographic\",\r\n        description: \"Returns the md5 hash of a given string\",\r\n        ext_description: \"Will return an unsalted md5 hash of the input string.\",\r\n        examples: \"\r\n            assert_eq(\r\n                md5('hello'),\r\n                '5D41402ABC4B2A76B9719D911017C592'\r\n            )\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let input = required_arg!(state::input).to_string();\r\n\r\n        use md5::{Digest, Md5};\r\n        let mut hasher = Md5::new();\r\n        hasher.update(input);\r\n\r\n        let s = format!(\"{:X}\", hasher.finalize());\r\n        Ok(Value::from(s))\r\n    }\r\n);\r\n\r\ndefine_stdfunction!(\r\n    choose {\r\n        options: Standard::Array\r\n    },\r\n    returns = String,\r\n    docs = {\r\n        category: \"Random\",\r\n        description: \"Returns a random element from a given array\",\r\n        ext_description: \"Uses a uniform distribution to select a random element from the input array.\",\r\n        examples: \"\r\n            s = ['a', 'b', 'c']\r\n            assert(\r\n                s contains choose(s)\r\n            )\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let options = required_arg!(state::options).as_a::\u003cVec\u003cValue\u003e\u003e()?;\r\n        if options.is_empty() {\r\n            return oops!(ArrayEmpty);\r\n        }\r\n\r\n        use rand::seq::SliceRandom;\r\n        let mut rng = rand::thread_rng();\r\n        Ok(options.choose(\u0026mut rng).unwrap().to_string().into())\r\n    }\r\n);\r\n\r\ndefine_stdfunction!(\r\n    rand {\r\n        range: Optional::Range\r\n    },\r\n    returns = Numeric,\r\n    docs = {\r\n        category: \"Random\",\r\n        description: \"Returns a random number within a given range, or between 0 and 1 if no range is specified.\",\r\n        ext_description: \"\r\n            If no range is specified, the function will return a random number between 0 and 1.\r\n            If a range is specified, the function will return a random number within that range.\r\n        \",\r\n        examples: \"\r\n            r = rand(0..10)\r\n            assert(\r\n                r \u003e= 0 \u0026\u0026 r \u003c= 10\r\n            )\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        use rand::Rng;\r\n\r\n        if let Some(range) = optional_arg!(state::range) {\r\n            let range = range.as_a::\u003cRange\u003e()?.inner().clone();\r\n            Ok(rand::thread_rng().gen_range(range).into())\r\n        } else {\r\n            Ok(rand::random::\u003cf64\u003e().into())\r\n        }\r\n    }\r\n);\r\n","traces":[{"line":4,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":5,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":6,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":8,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":9,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":10,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":11,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":4},"fn_name":null}],"covered":102,"coverable":102},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","functions","stdlib","string.rs"],"content":"use crate::define_stdfunction;\r\nuse polyvalue::{Value, ValueType};\r\n\r\n/**********************************************\r\n *\r\n * Character functions\r\n *\r\n *********************************************/\r\n\r\ndefine_stdfunction!(\r\n    ord { c: Standard::String },\r\n    returns = I64,\r\n    docs = {\r\n        category: \"String\",\r\n        description: \"Returns the Unicode code point of the character at the specified index.\",\r\n        ext_description: \"\r\n            Will always return a 32bit value, regardless of the width of the character.\r\n            This is the complement of chr(); Output from one is valid input for the other.\r\n        \",\r\n        examples: \"\r\n            assert_eq(97u32, ord('a'))\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let input = required_arg!(state::c).to_string();\r\n        if input.len() != 1 {\r\n            return oops!(Custom {\r\n                msg: \"ord() expected a single character\".to_string()\r\n            });\r\n        }\r\n        let c = input.chars().next().unwrap();\r\n        Ok(Value::from(c as u32))\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    chr { i: Standard::I64 },\r\n    returns = String,\r\n    docs = {\r\n        category: \"String\",\r\n        description: \"Returns a string containing the character represented by the Unicode code point.\",\r\n        ext_description: \"\r\n            This is the complement of ord(); Output from one is valid input for the other.\r\n        \",\r\n        examples: \"\r\n            assert_eq('a', chr(97))\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let input = required_arg!(state::i).as_a::\u003cu32\u003e()?;\r\n        match std::char::from_u32(input) {\r\n            Some(c) =\u003e Ok(Value::from(c.to_string())),\r\n            None =\u003e oops!(Custom {\r\n                msg: \"chr() expected a valid Unicode code point\".to_string()\r\n            }),\r\n        }\r\n    },\r\n);\r\n\r\n/**********************************************\r\n *\r\n * String Manipulation\r\n *********************************************/\r\n\r\ndefine_stdfunction!(\r\n    uppercase { s: Standard::String },\r\n    returns = String,\r\n    docs = {\r\n        category: \"String\",\r\n        description: \"Converts a string to uppercase.\",\r\n        ext_description: \"This function is locale-insensitive and will handle all Unicode characters.\",\r\n        examples: \"\r\n            assert_eq('HELLO', uppercase('hello'))\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let input = required_arg!(state::s).to_string();\r\n        Ok(Value::from(input.to_uppercase().to_string()))\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    lowercase { s: Standard::String },\r\n    returns = String,\r\n    docs = {\r\n        category: \"String\",\r\n        description: \"Converts a string to lowercase.\",\r\n        ext_description: \"This function is locale-insensitive and will handle all Unicode characters.\",\r\n        examples: \"\r\n            assert_eq('hello', lowercase('HELLO'))\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let input = required_arg!(state::s).to_string();\r\n        Ok(Value::from(input.to_lowercase().to_string()))\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    trim { s: Standard::String },\r\n    returns = String,\r\n    docs = {\r\n        category: \"String\",\r\n        description: \"Removes leading and trailing whitespace from a string.\",\r\n        ext_description: \"This function is locale-insensitive and will handle all Unicode characters.\",\r\n        examples: \"\r\n            assert_eq('hello', trim('  hello  '))\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let input = required_arg!(state::s).to_string();\r\n        Ok(Value::from(input.trim().to_string()))\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    trim_start { s: Standard::String },\r\n    returns = String,\r\n    docs = {\r\n        category: \"String\",\r\n        description: \"Removes leading whitespace from a string.\",\r\n        ext_description: \"This function is locale-insensitive and will handle all Unicode characters.\",\r\n        examples: \"\r\n            assert_eq('hello  ', trim_start('  hello  '))\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let input = required_arg!(state::s).to_string();\r\n        Ok(Value::from(input.trim_start().to_string()))\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    trim_end { s: Standard::String },\r\n    returns = String,\r\n    docs = {\r\n        category: \"String\",\r\n        description: \"Removes trailing whitespace from a string.\",\r\n        ext_description: \"This function is locale-insensitive and will handle all Unicode characters.\",\r\n        examples: \"\r\n            assert_eq('  hello', trim_end('  hello  '))\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let input = required_arg!(state::s).to_string();\r\n        Ok(Value::from(input.trim_end().to_string()))\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    replace {\r\n        s: Standard::String,\r\n        from: Standard::String,\r\n        to: Standard::String\r\n    },\r\n    returns = String,\r\n    docs = {\r\n        category: \"String\",\r\n        description: \"Replaces all occurrences of a substring within a string with another string.\",\r\n        ext_description: \"This function is locale-insensitive and will handle all Unicode characters.\",\r\n        examples: \"\r\n            assert_eq('hello world', replace('hello there', 'there', 'world'))\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let input = required_arg!(state::s).to_string();\r\n        let from = required_arg!(state::from).to_string();\r\n        let to = required_arg!(state::to).to_string();\r\n        Ok(Value::from(input.replace(\u0026from, \u0026to)))\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    repeat {\r\n        s: Standard::String,\r\n        n: Standard::I64\r\n    },\r\n    returns = String,\r\n    docs = {\r\n        category: \"String\",\r\n        description: \"Repeats a string a specified number of times.\",\r\n        ext_description: \"This function is locale-insensitive and will handle all Unicode characters.\",\r\n        examples: \"\r\n            assert_eq('hellohellohello', repeat('hello', 3))\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let input = required_arg!(state::s).to_string();\r\n        let n = required_arg!(state::n).as_a::\u003ci32\u003e()?;\r\n        Ok(Value::from(input.repeat(n as usize)))\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    chars {\r\n        s: Standard::String\r\n    },\r\n    returns = Array,\r\n    docs = {\r\n        category: \"String\",\r\n        description: \"Splits a string into its individual characters.\",\r\n        ext_description: \"This function will handle all Unicode characters.\",\r\n        examples: \"\r\n            assert_eq(['h', 'e', 'l', 'l', 'o'], chars('hello'))\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let input = required_arg!(state::s).to_string();\r\n        let chars: Vec\u003cValue\u003e = input.chars().map(|c| c.to_string().into()).collect();\r\n        Ok(Value::from(chars))\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    escape {\r\n        s: Standard::String\r\n    },\r\n    returns = String,\r\n    docs = {\r\n        category: \"String\",\r\n        description: \"Escapes special characters in a string.\",\r\n        ext_description: \"This function will handle all Unicode characters.\",\r\n        examples: \"\r\n            assert_eq('hello\\\\\\\\nworld', escape('hello\\nworld'))\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let input = required_arg!(state::s).to_string();\r\n        let mut output = String::new();\r\n        for c in input.chars() {\r\n            match c {\r\n                '\\n' =\u003e output.push_str(\"\\\\n\"),\r\n                '\\r' =\u003e output.push_str(\"\\\\r\"),\r\n                '\\t' =\u003e output.push_str(\"\\\\t\"),\r\n                '\\\\' =\u003e output.push_str(\"\\\\\\\\\"),\r\n                '\"' =\u003e output.push_str(\"\\\\\\\"\"),\r\n                _ =\u003e output.push(c),\r\n            }\r\n        }\r\n        Ok(Value::from(output))\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    pad_right {\r\n        s: Standard::String,\r\n        length: Standard::I64,\r\n        pad: Optional::String\r\n    },\r\n    returns = String,\r\n    docs = {\r\n        category: \"String\",\r\n        description: \"Pads a string to a specified length with a specified character.\",\r\n        ext_description: \"This function will handle all Unicode characters.\",\r\n        examples: \"\r\n            assert_eq('hello!!!!!!', pad_right('hello', 11, '!'))\r\n            assert_eq('hello      ', pad_right('hello', 11))\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let input = required_arg!(state::s).to_string();\r\n        let length = required_arg!(state::length).as_a::\u003ci64\u003e()?;\r\n        let pad = optional_arg!(state::pad).unwrap_or(Value::string(\" \")).to_string().chars().next().unwrap_or(' ').to_string();\r\n\r\n        let padding: i64 = length - input.len() as i64;\r\n        if padding \u003c= 0 {\r\n            Ok(Value::from(input))\r\n        } else {\r\n            let pad = pad.repeat(padding as usize);\r\n            Ok((input + \u0026pad).into())\r\n        }\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    pad_left {\r\n        s: Standard::String,\r\n        length: Standard::I64,\r\n        pad: Optional::String\r\n    },\r\n    returns = String,\r\n    docs = {\r\n        category: \"String\",\r\n        description: \"Pads a string to a specified length with a specified character.\",\r\n        ext_description: \"This function will handle all Unicode characters.\",\r\n        examples: \"\r\n            assert_eq('!!!!!!hello', pad_left('hello', 11, '!'))\r\n            assert_eq('      hello', pad_left('hello', 11))\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let input = required_arg!(state::s).to_string();\r\n        let length = required_arg!(state::length).as_a::\u003ci64\u003e()?;\r\n        let pad = optional_arg!(state::pad).unwrap_or(Value::string(\" \")).to_string().chars().next().unwrap_or(' ').to_string();\r\n\r\n        let padding: i64 = length - input.len() as i64;\r\n        if padding \u003c= 0 {\r\n            Ok(Value::from(input))\r\n        } else {\r\n            let pad = pad.repeat(padding as usize);\r\n            Ok((pad + \u0026input).into())\r\n        }\r\n    },\r\n);\r\n\r\n/**********************************************\r\n *\r\n * String Formatting\r\n *\r\n *********************************************/\r\n\r\ndefine_stdfunction!(\r\n    format {\r\n        s: Standard::String,\r\n        args: Standard::Array\r\n    },\r\n    returns = String,\r\n    docs = {\r\n        category: \"String\",\r\n        description: \"Formats a string using positional arguments.\",\r\n        ext_description: \"The 2nd argument is an array of values to be consumed in order\",\r\n        examples: \"\r\n            assert_eq('hello world', format('hello {}', ['world']))\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let input = required_arg!(state::s).to_string();\r\n        let args = required_arg!(state::args).as_a::\u003cVec\u003cValue\u003e\u003e()?;\r\n        let args: Vec\u003cString\u003e = args\r\n            .iter()\r\n            .map(|v| v.to_string())\r\n            .collect();\r\n\r\n        let mut result = input;\r\n        for arg in args {\r\n            let arg = arg.clone().to_string();\r\n            // Replace first instance of {} with arg\r\n            result = result.replacen(\"{}\", \u0026arg, 1);\r\n        }\r\n\r\n        Ok(result.into())\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    prettyjson { s: Standard::Object },\r\n    returns = String,\r\n    docs = {\r\n        category: \"String\",\r\n        description: \"Formats a JSON string for human readability.\",\r\n        ext_description: \"This function will handle all Unicode characters.\",\r\n        examples: \"\r\n            assert_eq(\r\n                '{\\n  \\\"hello\\\": \\\"world\\\"\\n}',\r\n                prettyjson({\\\"hello\\\": \\\"world\\\"})\r\n            )\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let input = required_arg!(state::s).as_type(ValueType::Object)?.to_json_string();\r\n        let input = serde_json::from_str::\u003cserde_json::Value\u003e(\u0026input)?;\r\n        Ok(Value::from(serde_json::to_string_pretty(\u0026input)?))\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    join {\r\n        parts: Standard::Array,\r\n        joiner: Optional::String\r\n    },\r\n    returns = String,\r\n    docs = {\r\n        category: \"String\",\r\n        description: \"Concatenates an array of values into a single string.\",\r\n        ext_description: \"\r\n            Converts all its arguments to strings and then concatenates them.\r\n            If a joiner is provided, it will be used to separate the parts.\r\n        \",\r\n        examples: \"\r\n            assert_eq('hello world', join(['hello', ' ', 'world']))\r\n            assert_eq('hello world', ['hello', 'world'].join(' '))\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let joiner = optional_arg!(state::joiner).unwrap_or(Value::string(\"\")).to_string();\r\n        let parts = required_arg!(state::parts).as_a::\u003cVec\u003cValue\u003e\u003e()?;\r\n        let parts: Vec\u003cString\u003e = parts\r\n            .iter()\r\n            .map(|v| v.to_string())\r\n            .collect();\r\n        Ok(Value::from(parts.join(\u0026joiner)))\r\n    },\r\n);\r\n\r\n/**********************************************\r\n *\r\n * String Encoding\r\n * urlencode, urldecode, atob, btoa\r\n *********************************************/\r\n\r\n#[cfg(feature = \"encoding-functions\")]\r\ndefine_stdfunction!(\r\n    url_encode { s: Standard::String },\r\n    returns = String,\r\n    docs = {\r\n        category: \"String\",\r\n        description: \"Encodes a string as a URL-safe string.\",\r\n        ext_description: \"This function will handle all Unicode characters.\",\r\n        examples: \"\r\n            assert_eq('hello%20world', url_encode('hello world'))\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let input = required_arg!(state::s).to_string();\r\n        Ok(Value::from(urlencoding::encode(\u0026input).into_owned()))\r\n    },\r\n);\r\n\r\n#[cfg(feature = \"encoding-functions\")]\r\ndefine_stdfunction!(\r\n    url_decode { s: Standard::String },\r\n    returns = String,\r\n    docs = {\r\n        category: \"String\",\r\n        description: \"Decodes a URL-safe string into a normal string.\",\r\n        ext_description: \"This function will handle all Unicode characters.\",\r\n        examples: \"\r\n            assert_eq('hello world', url_decode('hello%20world'))\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let input = required_arg!(state::s).to_string();\r\n        Ok(Value::from(urlencoding::decode(\u0026input)?.into_owned()))\r\n    },\r\n);\r\n\r\n#[cfg(feature = \"encoding-functions\")]\r\ndefine_stdfunction!(\r\n    base64_encode { s: Standard::String },\r\n    returns = String,\r\n    docs = {\r\n        category: \"String\",\r\n        description: \"Encodes a string into base64\",\r\n        ext_description: \"This function will handle all Unicode characters.\",\r\n        examples: \"\r\n            assert_eq('aGVsbG8gd29ybGQ=', base64_encode('hello world'))\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let input = required_arg!(state::s).to_string();\r\n\r\n        use base64::{engine::general_purpose, Engine as _};\r\n        let mut buf = String::new();\r\n        general_purpose::STANDARD.encode_string(\u0026input, \u0026mut buf);\r\n        Ok(Value::from(buf))\r\n    },\r\n);\r\n\r\n#[cfg(feature = \"encoding-functions\")]\r\ndefine_stdfunction!(\r\n    base64_decode { s: Standard::String },\r\n    returns = String,\r\n    docs = {\r\n        category: \"String\",\r\n        description: \"Decodes a base64 string into a string.\",\r\n        ext_description: \"This function will handle all Unicode characters.\",\r\n        examples: \"\r\n            assert_eq('hello world', base64_decode('aGVsbG8gd29ybGQ='))\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let input = required_arg!(state::s).to_string();\r\n\r\n        use base64::{engine::general_purpose, Engine as _};\r\n        if let Ok(bytes) = general_purpose::STANDARD.decode(input) {\r\n            if let Ok(s) = std::str::from_utf8(\u0026bytes) {\r\n                return Ok(Value::from(s));\r\n            }\r\n        }\r\n\r\n        oops!(\r\n            ValueFormat {\r\n                expected_format: \"base64\".to_string()\r\n            }\r\n        )\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    from_json {\r\n        s: Standard::String\r\n    },\r\n    returns = Any,\r\n    docs = {\r\n        category: \"String\",\r\n        description: \"Parses a JSON string into a value.\",\r\n        ext_description: \"This function will handle all Unicode characters.\",\r\n        examples: \"\r\n            assert_eq({\\\"hello\\\": \\\"world\\\"}, from_json('{\\\"hello\\\": \\\"world\\\"}'))\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let input = required_arg!(state::s).to_string();\r\n        let input = serde_json::from_str::\u003cserde_json::Value\u003e(\u0026input)?;\r\n        Ok(Value::try_from(input)?)\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    to_json {\r\n        v: Standard::Any\r\n    },\r\n    returns = String,\r\n    docs = {\r\n        category: \"String\",\r\n        description: \"Converts a value into a JSON string.\",\r\n        ext_description: \"\r\n            Objects will be encoded as (key, value) pairs, due to differences between JSON and lavendeux.\r\n        \",\r\n        examples: \"\r\n            assert_eq('{\\\"hello\\\":\\\"world\\\"}', to_json({'hello': 'world'}))\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let input = required_arg!(state::v).to_json_string();\r\n        Ok(Value::from(input))\r\n    },\r\n);\r\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":63},"fn_name":null},{"line":11,"address":[],"length":0,"stats":{"Line":63},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":63},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":63},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":63},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":63},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":63},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":63},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":63},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":63},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":63},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":63},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":63},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":94},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":156},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":94},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":63},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":63},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":94},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":94},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":63},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":63},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":63},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":63},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":63},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":63},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":63},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":63},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":63},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":63},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":63},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":63},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":94},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":156},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":63},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":94},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":63},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":63},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":31},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":106},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":281,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":282,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":288,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":298,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":313,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":318,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":321,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":322,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":323,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":326,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":328,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":329,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":330,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":331,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":334,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":335,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":336,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":338,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":341,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":345,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":346,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":347,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":348,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":351,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":352,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":354,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":357,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":359,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":360,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":361,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":362,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":366,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":367,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":368,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":369,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":371,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":372,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":373,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":374,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":375,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":376,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":377,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":379,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":380,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":381,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":382,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":384,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":385,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":386,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":387,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":388,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":389,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":390,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":391,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":402,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":403,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":404,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":405,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":406,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":407,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":408,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":409,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":410,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":411,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":413,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":414,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":415,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":420,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":421,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":422,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":423,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":424,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":425,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":426,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":427,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":428,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":429,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":431,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":432,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":433,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":438,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":439,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":440,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":441,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":442,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":443,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":444,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":445,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":446,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":447,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":449,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":450,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":452,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":453,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":454,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":455,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":460,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":461,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":462,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":463,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":464,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":465,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":466,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":467,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":468,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":469,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":471,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":472,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":474,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":475,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":476,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":477,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":481,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":482,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":483,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":489,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":490,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":491,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":493,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":494,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":495,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":496,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":497,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":498,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":499,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":500,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":502,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":503,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":504,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":505,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":509,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":510,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":511,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":513,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":514,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":515,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":516,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":517,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":518,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":519,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":520,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":521,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":522,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":524,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":525,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":526,"address":[],"length":0,"stats":{"Line":4},"fn_name":null}],"covered":377,"coverable":377},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","functions","stdlib","system.rs"],"content":"use crate::{\r\n    define_stdfunction,\r\n    documentation::{DocumentationTemplate, MarkdownFormatter},\r\n    error::{ErrorDetails, WrapOption},\r\n    syntax_tree::traits::NodeExt,\r\n    Lavendeux,\r\n};\r\nuse polyvalue::{types::Object, Value};\r\n\r\n/**********************************************\r\n *\r\n * Code and Evaluation\r\n *\r\n *********************************************/\r\n\r\ndefine_stdfunction!(\r\n   call_function {\r\n       name: Standard::String,\r\n       args: Standard::Array\r\n   },\r\n   returns = Any,\r\n\r\n   docs = {\r\n       category: \"System\",\r\n       description: \"Calls a function or @decorator by name with the given arguments\",\r\n       ext_description: \"\r\n            If the name begins with '@', it will be treated as a decorator.\r\n            Maps the given object to the function's arguments and calls the function.\r\n            Important note: Functions that take in a _reference, such as pop/push etc, will act by-value and not modify the original object.\r\n        \",\r\n       examples: \"\r\n            @test(x) = x\r\n            assert_eq('5', call_function('@test', {'x': 5}))\r\n        \",\r\n   },\r\n\r\n    handler = (state, _reference) {\r\n         let name = required_arg!(state::name).to_string();\r\n         let args = required_arg!(state::args).as_a::\u003cVec\u003cValue\u003e\u003e()?;\r\n\r\n         state.call_function(\u0026name, args, None)\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    eval {\r\n        expression: Standard::String\r\n    },\r\n    returns = Any,\r\n\r\n    docs = {\r\n        category: \"System\",\r\n        description: \"Evaluates a string as a Lavendeux expression and returns the result\",\r\n        ext_description: \"\r\n            The string will be interpreted as a script and evaluated in it's own scope.\r\n            If there are multiple lines, an array of values will be returned.\r\n        \",\r\n        examples: \"\r\n            assert_eq(5, eval('2 + 3'))\r\n            assert_eq([6, 6], eval('x = 6; x'))\r\n            assert_eq([1, 2, 3], eval('1\\\\n2\\\\n3'))\r\n        \",\r\n    },\r\n    handler = (state, _reference) {\r\n        let expression = required_arg!(state::expression).to_string();\r\n\r\n        state.scope_into()?;\r\n        state.lock_scope();\r\n        let res = Lavendeux::eval(\u0026expression, state).map(|n| n.evaluate(state));\r\n\r\n        let mut values = match res {\r\n            Ok(r) =\u003e {\r\n                match r {\r\n                    Ok(v) =\u003e v,\r\n                    Err(e) =\u003e {\r\n                        state.scope_out();\r\n                        return Err(e);\r\n                    }\r\n                }\r\n            },\r\n            Err(e) =\u003e {\r\n                state.scope_out();\r\n                return Err(e);\r\n            }\r\n        };\r\n\r\n        state.scope_out();\r\n        if values.len() == 1 {\r\n            values = values.as_a::\u003cVec\u003cValue\u003e\u003e()?.into_iter().next().unwrap();\r\n        }\r\n        Ok(values)\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    include {\r\n        filename: Standard::String\r\n    },\r\n    returns = Any,\r\n\r\n    docs = {\r\n        category: \"System\",\r\n        description: \"Evaluates a file as a Lavendeux expression and returns the result\",\r\n        ext_description: \"\r\n            The file will be interpreted as a script and evaluated in it's own scope.\r\n            Returns an empty string in all cases.\r\n        \",\r\n        examples: \"\r\n            include('example_scripts/stdlib.lav')\r\n        \",\r\n    },\r\n    handler = (state, _reference) {\r\n        let script = required_arg!(state::filename).to_string();\r\n        let script = std::fs::read_to_string(script)?;\r\n\r\n        state.scope_into()?;\r\n        state.lock_scope();\r\n        let res = Lavendeux::eval(\u0026script, state).map(|n| n.evaluate(state));\r\n        match res {\r\n            Ok(r) =\u003e {\r\n                match r {\r\n                    Ok(v) =\u003e v,\r\n                    Err(e) =\u003e {\r\n                        state.scope_out();\r\n                        return Err(e);\r\n                    }\r\n                }\r\n            },\r\n            Err(e) =\u003e {\r\n                state.scope_out();\r\n                return Err(e);\r\n            }\r\n        };\r\n\r\n        state.scope_out();\r\n        Ok(Value::from(\"\"))\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    __exec_tests {\r\n    },\r\n    returns = Any,\r\n\r\n    docs = {\r\n        category: \"System\",\r\n        description: \"Evaluates all functions beginning with __test_, and reports a list of failed tests\",\r\n        ext_description: \"\r\n            Designed to be used mostly for internal testing, could be useful to testing scripts.\r\n            Throws an error if a test fails, otherwise returns a string with the number of tests run and the number of tests failed.\r\n        \",\r\n        examples: \"#skip\r\n            __test_will_fail() = assert_eq(1, 2)\r\n            __test_will_pass() = assert_eq(1, 1)\r\n            __exec_tests()\r\n            /* Output:\r\n            Errors:\r\n\r\n            In __test_will_fail: \r\n            Line 1: assert_eq (1, 2)\r\n                Assertion failed: 1 != 2\r\n                \r\n            2 tests run, 1 failed\r\n             */\r\n        \",\r\n    },\r\n    handler = (state, _reference) {\r\n        let matching_functions = state\r\n            .all_functions()\r\n            .iter()\r\n            .filter(|(name, _)| name.starts_with(\"__test_\"))\r\n            .map(|(name, _)| name.clone())\r\n            .collect::\u003cVec\u003c_\u003e\u003e();\r\n\r\n        let mut errors = vec![];\r\n        for test_case in matching_functions.iter() {\r\n            state.scope_into()?;\r\n            state.lock_scope();\r\n            let res = state.call_function(test_case, vec![], None);\r\n            state.scope_out();\r\n\r\n            if let Err(e) = res {\r\n                errors.push((test_case, e));\r\n            }\r\n        }\r\n\r\n        let mut output = String::new();\r\n        if !errors.is_empty() {\r\n            output.push_str(\"Errors:\\n\\n\");\r\n            for (name, e) in errors.iter() {\r\n                output.push_str(\u0026format!(\"In {}:\\n{}\\n\\n\", name, e));\r\n            }\r\n        }\r\n\r\n        output.push_str(\u0026format!(\r\n            \"{} tests run, {} failed\",\r\n            matching_functions.len(),\r\n            errors.len()\r\n        ));\r\n\r\n        if errors.is_empty() {\r\n            Ok(Value::from(format!(\"{} tests run, all passed\", matching_functions.len())))\r\n        } else {\r\n            oops!(Custom { msg: output })\r\n        }\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    generate_documentation {},\r\n    returns = String,\r\n    docs = {\r\n        category: \"System\",\r\n        description: \"Generates documentation for all standard library functions\",\r\n        ext_description: \"\r\n            Returns a markdown-formatted string containing documentation for all standard library functions.\r\n        \",\r\n        examples: \"\r\n            generate_documentation()\r\n        \",\r\n    },\r\n    handler = (state, _reference) {\r\n        Ok(DocumentationTemplate::new(MarkdownFormatter).render(state).into())\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    document_function {\r\n        name: Standard::String,\r\n        docs: Standard::Object\r\n    },\r\n    returns = String,\r\n    docs = {\r\n        category: \"System\",\r\n        description: \"Adds documentation to a user-defined function\",\r\n        ext_description: \"\r\n            Adds documentation to a function, which will be displayed help()\r\n            The documentation object should contain the keys 'category', 'description', 'ext_description', and 'examples'.\r\n        \",\r\n        examples: \"\r\n            a() = 5\r\n            document_function('a', {\r\n                'category': 'System',\r\n                'description': 'Adds documentation to a function',\r\n                'ext_description': 'Adds documentation to a function, which will be displayed in the documentation.',\r\n                'examples': 'document_function(\\\"document_function\\\", {\\\"category\\\": \\\"System\\\", \\\"description\\\": \\\"Adds documentation to a function\\\", \\\"ext_description\\\": \\\"Adds documentation to a function, which will be displayed in the documentation.\\\"})'\r\n            })\r\n        \",\r\n    },\r\n    handler = (state, _reference) {\r\n        let name = required_arg!(state::name).to_string();\r\n        let docs = required_arg!(state::docs).as_a::\u003cObject\u003e()?;\r\n\r\n        let function = state.get_function_mut(\u0026name).or_error(ErrorDetails::FunctionName { name: name.clone() })?;\r\n        if function.is_readonly() {\r\n            return oops!(Custom {\r\n                msg: \"Cannot modify a readonly function\".to_string()\r\n            })\r\n        }\r\n\r\n        if let Some(category) = docs.get(\u0026\"category\".into()) {\r\n            function.documentation_mut().set_category(\u0026category.to_string());\r\n        }\r\n\r\n        let ext_desc: Option\u003cString\u003e = docs.get(\u0026\"description\".into()).map(|v| v.to_string());\r\n        function.documentation_mut().set_description(ext_desc.as_deref());\r\n\r\n        let ext_desc: Option\u003cString\u003e = docs.get(\u0026\"ext_description\".into()).map(|v| v.to_string());\r\n        function.documentation_mut().set_ext_description(ext_desc.as_deref());\r\n\r\n        let ext_desc: Option\u003cString\u003e = docs.get(\u0026\"examples\".into()).map(|v| v.to_string());\r\n        function.documentation_mut().set_examples(ext_desc.as_deref());\r\n\r\n        Ok(state.help(Some(name)).into())\r\n    },\r\n);\r\n\r\n/**********************************************\r\n *\r\n * Assertions and Errors\r\n *\r\n *********************************************/\r\n\r\ndefine_stdfunction!(\r\n    assert {\r\n        condition: Standard::Any\r\n    },\r\n    returns = Any,\r\n\r\n    docs = {\r\n        category: \"System\",\r\n        description: \"Throws an error if the condition is false\",\r\n        ext_description: \"\r\n            Does a weak-comparison to boolean, so 0, '', [], etc. are all considered false.\r\n            Returns the value otherwise\r\n        \",\r\n        examples: \"\r\n            assert(true)\r\n            assert( would_err('assert(false)') )\r\n        \",\r\n    },\r\n    handler = (state, _reference) {\r\n        let cond = required_arg!(state::condition);\r\n        if cond.is_truthy() {\r\n            Ok(cond.clone())\r\n        } else {\r\n            oops!(Custom {\r\n                msg: \"Assertion failed\".to_string()\r\n            })\r\n        }\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    assert_eq {\r\n        condition: Standard::Any,\r\n        expected: Standard::Any\r\n    },\r\n    returns = Any,\r\n\r\n    docs = {\r\n        category: \"System\",\r\n        description: \"Asserts that 2 values are equal\",\r\n        ext_description: \"\r\n            Raises an error if the condition is not equal to the expected value.\r\n            Also verifies type, as opposed to the `==` operator, which uses weak typing.\r\n            use assert(a == b) if you want to compare values without checking their types.\r\n        \",\r\n        examples: \"\r\n            assert_eq(true, true)\r\n            assert_eq( true, would_err('assert_eq(1, true)') )\r\n        \",\r\n    },\r\n    handler = (state, _reference) {\r\n        let cond = required_arg!(state::condition);\r\n        let expected = required_arg!(state::expected);\r\n\r\n        if cond == expected {\r\n            Ok(cond.clone())\r\n        } else {\r\n            let message = format!(\"Assertion failed: {:?} != {:?}\", cond, expected);\r\n            oops!(Custom { msg: message })\r\n        }\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    would_err {\r\n        expression: Standard::String\r\n    },\r\n    returns = Bool,\r\n\r\n    docs = {\r\n        category: \"System\",\r\n        description: \"Returns true if the given expression would raise an error\",\r\n        ext_description: \"\r\n            Returns true if expression given by the string would raise an error, false otherwise.\r\n            This is useful for testing error messages.\r\n        \",\r\n        examples: \"\r\n            assert_eq( false, would_err('1 + 1') )\r\n            assert_eq( true, would_err('1 + asparagus') )\r\n        \",\r\n    },\r\n    handler = (state, _reference) {\r\n        let expression = required_arg!(state::expression).to_string();\r\n        let res = crate::Lavendeux::eval(\u0026expression, state).map(|n| n.evaluate(state));\r\n        match res {\r\n            Ok(r) if r.is_ok() =\u003e Ok(Value::from(false)),\r\n            _ =\u003e Ok(Value::from(true))\r\n        }\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    error {\r\n        msg: Standard::String\r\n    },\r\n    returns = Any,\r\n\r\n    docs = {\r\n        category: \"System\",\r\n        description: \"Throws an error with the given message\",\r\n        ext_description: \"\r\n            Throws an exception with a custom message. The error's source will be the line where the error was thrown.\r\n        \",\r\n        examples: \"\r\n            would_err('error(\\\"This is an error\\\")')\r\n        \",\r\n    },\r\n    handler = (state, _reference) {\r\n        let message = required_arg!(state::msg).to_string();\r\n        oops!(Custom { msg: message })\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    debug {\r\n        msg: Standard::String\r\n    },\r\n    returns = Any,\r\n\r\n    docs = {\r\n        category: \"System\",\r\n        description: \"Prints a debug message to the console\",\r\n        ext_description: \"\r\n            The message will be both written to stdout, and returned as a string.\r\n            If the parser is not attached to a console, it will not be visible.\r\n        \",\r\n        examples: \"\r\n            debug(\\\"This is a debug message\\\")\r\n        \",\r\n    },\r\n    handler = (state, _reference) {\r\n        let message = required_arg!(state::msg).to_string();\r\n        println!(\"{message}\");\r\n        Ok(Value::string(message))\r\n    },\r\n);\r\n\r\n/**********************************************\r\n *\r\n * Assignments and Variables\r\n *\r\n *********************************************/\r\n\r\ndefine_stdfunction!(\r\n    assign {\r\n        name: Standard::String,\r\n        value: Standard::Any\r\n    },\r\n    returns = Any,\r\n\r\n    docs = {\r\n        category: \"System\",\r\n        description: \"Assigns a variable in the current scope\",\r\n        ext_description: \"\r\n            Writes a value to the current scope, leaving other scopes unchanged.\r\n        \",\r\n        examples: \"\r\n            x = 5\r\n            if true then {\r\n                assign('x', 6)\r\n                assert_eq(6, x)\r\n            } else nil\r\n            assert_eq(5, x)\r\n        \",\r\n    },\r\n    handler = (state, _reference) {\r\n        let name = required_arg!(state::name).to_string();\r\n        let value = required_arg!(state::value);\r\n        state.set_variable_in_offset(1, \u0026name, value.clone());\r\n        Ok(value)\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    assign_global {\r\n        name: Standard::String,\r\n        value: Standard::Any\r\n    },\r\n    returns = Any,\r\n\r\n    docs = {\r\n        category: \"System\",\r\n        description: \"Assigns a variable in the top-level scope\",\r\n        ext_description: \"\r\n            Writes a value to the top-level scope, leaving other scopes unchanged.\r\n        \",\r\n        examples: \"\r\n            x = 5\r\n            if true then {\r\n                assign_global('x', 6)\r\n                assert_eq(6, x)\r\n            } else { 0 }\r\n            assert_eq(6, x)\r\n        \",\r\n    },\r\n    handler = (state, _reference) {\r\n        let name = required_arg!(state::name).to_string();\r\n        let value = required_arg!(state::value);\r\n        state.global_assign_variable(\u0026name, value.clone());\r\n        Ok(value.clone())\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    global {\r\n        name: Standard::String\r\n    },\r\n    returns = Any,\r\n\r\n    docs = {\r\n        category: \"System\",\r\n        description: \"Returns a variable from the top-level scope\",\r\n        ext_description: \"\r\n            Searches for the variable in the top-level scope only\r\n        \",\r\n        examples: \"\r\n            assign_global('x', 6)\r\n            assert_eq(6, global('x'))\r\n        \",\r\n    },\r\n    handler = (state, _reference) {\r\n        let name = required_arg!(state::name).to_string();\r\n        let value = state.global_get_variable(\u0026name).or_error(ErrorDetails::VariableName {\r\n            name\r\n        })?;\r\n        Ok(value.clone())\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    variables { },\r\n    returns = Object,\r\n\r\n    docs = {\r\n        category: \"System\",\r\n        description: \"Returns the currently defined variables\",\r\n        ext_description: \"\r\n            Returns a map of all the variables currently defined in the current scope.\r\n        \",\r\n        examples: \"\r\n            x = 5; y = 6\r\n            state = variables()\r\n            assert_eq(5, state['x'])\r\n            assert_eq(6, state['y'])\r\n        \",\r\n    },\r\n    handler = (state, _reference) {\r\n        let obj = Object::try_from(\r\n            state.all_variables_unscoped()\r\n                .iter()\r\n                .map(|(k, v)| (Value::from(k.to_string()), (*v).clone()))\r\n                .collect::\u003cVec\u003c(Value, Value)\u003e\u003e(),\r\n        )?;\r\n\r\n        Ok(obj.into())\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    typeof {\r\n        value: Standard::Any\r\n    },\r\n    returns = String,\r\n\r\n    docs = {\r\n        category: \"System\",\r\n        description: \"Returns the type of its input\",\r\n        ext_description: \"\r\n            Returns the type of the given value as a string.\r\n        \",\r\n        examples: \"\r\n            assert_eq('string', typeof('hello'))\r\n            assert_eq('i64', typeof(5))\r\n            assert_eq('object', typeof({}))\r\n        \",\r\n    },\r\n    handler = (state, _reference) {\r\n        let value = required_arg!(state::value);\r\n        Ok(Value::string(value.own_type().to_string()))\r\n    },\r\n);\r\n\r\n#[cfg(test)]\r\nmod test {\r\n    use crate::lav;\r\n\r\n    lav!(test_exec_tests_bad(Error) r#\"\r\n        __test_will_fail() = assert_eq(1, 2)\r\n        __test_will_pass() = assert_eq(1, 1)\r\n        __exec_tests()\r\n    \"#);\r\n\r\n    lav!(test_exec_tests_good r#\"\r\n        __test_will_pass() = assert_eq(1, 1)\r\n        __exec_tests()\r\n    \"#);\r\n}\r\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":31},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":431},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":39},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":288,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":290,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":298,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":40},"fn_name":null},{"line":303,"address":[],"length":0,"stats":{"Line":53},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":40},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":39},"fn_name":null},{"line":307,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":1674},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":1674},"fn_name":null},{"line":316,"address":[],"length":0,"stats":{"Line":1674},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":1674},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":1674},"fn_name":null},{"line":321,"address":[],"length":0,"stats":{"Line":1674},"fn_name":null},{"line":322,"address":[],"length":0,"stats":{"Line":1674},"fn_name":null},{"line":323,"address":[],"length":0,"stats":{"Line":1674},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":1674},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":1674},"fn_name":null},{"line":326,"address":[],"length":0,"stats":{"Line":1674},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":1674},"fn_name":null},{"line":328,"address":[],"length":0,"stats":{"Line":1674},"fn_name":null},{"line":329,"address":[],"length":0,"stats":{"Line":1674},"fn_name":null},{"line":330,"address":[],"length":0,"stats":{"Line":1674},"fn_name":null},{"line":331,"address":[],"length":0,"stats":{"Line":1674},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":1674},"fn_name":null},{"line":334,"address":[],"length":0,"stats":{"Line":2092},"fn_name":null},{"line":335,"address":[],"length":0,"stats":{"Line":2510},"fn_name":null},{"line":336,"address":[],"length":0,"stats":{"Line":2510},"fn_name":null},{"line":338,"address":[],"length":0,"stats":{"Line":2092},"fn_name":null},{"line":339,"address":[],"length":0,"stats":{"Line":2090},"fn_name":null},{"line":341,"address":[],"length":0,"stats":{"Line":1676},"fn_name":null},{"line":342,"address":[],"length":0,"stats":{"Line":1676},"fn_name":null},{"line":347,"address":[],"length":0,"stats":{"Line":49},"fn_name":null},{"line":348,"address":[],"length":0,"stats":{"Line":49},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":49},"fn_name":null},{"line":351,"address":[],"length":0,"stats":{"Line":49},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":49},"fn_name":null},{"line":354,"address":[],"length":0,"stats":{"Line":49},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":49},"fn_name":null},{"line":356,"address":[],"length":0,"stats":{"Line":49},"fn_name":null},{"line":357,"address":[],"length":0,"stats":{"Line":49},"fn_name":null},{"line":358,"address":[],"length":0,"stats":{"Line":49},"fn_name":null},{"line":359,"address":[],"length":0,"stats":{"Line":49},"fn_name":null},{"line":360,"address":[],"length":0,"stats":{"Line":49},"fn_name":null},{"line":361,"address":[],"length":0,"stats":{"Line":49},"fn_name":null},{"line":362,"address":[],"length":0,"stats":{"Line":49},"fn_name":null},{"line":363,"address":[],"length":0,"stats":{"Line":49},"fn_name":null},{"line":365,"address":[],"length":0,"stats":{"Line":73},"fn_name":null},{"line":366,"address":[],"length":0,"stats":{"Line":121},"fn_name":null},{"line":367,"address":[],"length":0,"stats":{"Line":118},"fn_name":null},{"line":368,"address":[],"length":0,"stats":{"Line":70},"fn_name":null},{"line":369,"address":[],"length":0,"stats":{"Line":50},"fn_name":null},{"line":370,"address":[],"length":0,"stats":{"Line":72},"fn_name":null},{"line":375,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":376,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":377,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":379,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":381,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":382,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":383,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":384,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":385,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":386,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":387,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":388,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":389,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":391,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":392,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":393,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":397,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":398,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":399,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":401,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":403,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":404,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":405,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":406,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":407,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":408,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":409,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":410,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":411,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":412,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":414,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":415,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":416,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":417,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":427,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":428,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":429,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":430,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":432,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":434,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":435,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":436,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":437,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":438,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":439,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":440,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":441,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":442,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":443,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":444,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":445,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":446,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":447,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":449,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":450,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":451,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":452,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":453,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":457,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":458,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":459,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":460,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":462,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":464,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":465,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":466,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":467,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":468,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":469,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":470,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":471,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":472,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":473,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":474,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":475,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":476,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":477,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":479,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":480,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":481,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":482,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":483,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":487,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":488,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":489,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":491,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":493,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":494,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":495,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":496,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":497,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":498,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":499,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":500,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":501,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":502,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":504,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":505,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":506,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":507,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":509,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":513,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":514,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":515,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":517,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":518,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":519,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":520,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":521,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":522,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":523,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":524,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":525,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":526,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":527,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":528,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":530,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":531,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":532,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":533,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":534,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":535,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":538,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":542,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":543,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":544,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":546,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":548,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":549,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":550,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":551,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":552,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":553,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":554,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":555,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":556,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":557,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":558,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":560,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":561,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":562,"address":[],"length":0,"stats":{"Line":19},"fn_name":null}],"covered":343,"coverable":394},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","functions","stdlib","trig.rs"],"content":"use crate::define_stdfunction;\r\nuse polyvalue::Value;\r\n\r\nmacro_rules! define_trigfunction {\r\n    ($name:ident, examples = $examples:literal) =\u003e {\r\n        define_stdfunction!(\r\n            $name {\r\n                n: Standard::Numeric\r\n            },\r\n            returns = Float,\r\n            docs = {\r\n                category: \"Trigonometry\",\r\n                description: concat!(\"Calculate the \", stringify!($name), \" of n\"),\r\n                ext_description: \"\r\n                    Returns a result for the angle n (in radians).\r\n                    You can use the `to_degrees` and `to_radians` functions to convert between degrees and radians.\r\n                \",\r\n                examples: $examples,\r\n            },\r\n            handler = (state, _reference) {\r\n                let n = required_arg!(state::n).as_a::\u003cf64\u003e()?;\r\n                Ok(Value::from(n.$name()))\r\n            }\r\n        );\r\n    };\r\n}\r\n\r\ndefine_trigfunction!(sin, examples = \"assert_eq( 0.0, sin(0) )\");\r\ndefine_trigfunction!(asin, examples = \"assert_eq( 0.0, asin(0) )\");\r\ndefine_trigfunction!(sinh, examples = \"assert_eq( 0.0, sinh(0) )\");\r\ndefine_trigfunction!(asinh, examples = \"assert_eq( 0.0, asinh(0) )\");\r\n\r\ndefine_trigfunction!(cos, examples = \"assert_eq( 1.0, cos(0) )\");\r\ndefine_trigfunction!(acos, examples = \"assert_eq( 0.0, acos(1) )\");\r\ndefine_trigfunction!(cosh, examples = \"assert_eq( 1.0, cosh(0) )\");\r\ndefine_trigfunction!(acosh, examples = \"assert_eq( 0.0, acosh(1) )\");\r\n\r\ndefine_trigfunction!(tan, examples = \"assert_eq( 0.0, tan(0) )\");\r\ndefine_trigfunction!(atan, examples = \"assert_eq( 0.0, atan(0) )\");\r\ndefine_trigfunction!(tanh, examples = \"assert_eq( 0.0, tanh(0) )\");\r\ndefine_trigfunction!(atanh, examples = \"assert_eq( 0.0, atanh(0) )\");\r\n","traces":[{"line":20,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":3},"fn_name":null}],"covered":14,"coverable":14},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","functions","stdlib.rs"],"content":"use super::std_function::ParserFunction;\r\nuse std::collections::HashMap;\r\n\r\nmod bitwise;\r\nmod collections;\r\nmod dev;\r\nmod math;\r\nmod string;\r\nmod system;\r\nmod trig;\r\n\r\n#[cfg(feature = \"crypto-functions\")]\r\nmod random;\r\n\r\nmod decorators_currency;\r\nmod decorators_numeric;\r\nmod decorators_types;\r\n\r\n#[cfg(feature = \"network-functions\")]\r\nmod network;\r\n\r\ninventory::collect!(\u0026'static dyn ParserFunction);\r\n/// Returns a map of all standard library functions\r\n/// Used by the state to load stdlib\r\npub fn all() -\u003e HashMap\u003cString, Box\u003cdyn ParserFunction\u003e\u003e {\r\n    inventory::iter::\u003c\u0026'static dyn ParserFunction\u003e\r\n        .into_iter()\r\n        .map(|f| (f.name().to_string(), f.clone_self()))\r\n        .collect()\r\n}\r\n\r\n#[cfg(test)]\r\nmod test {\r\n    use crate::{error::ErrorDetails, Error};\r\n\r\n    use super::*;\r\n\r\n    #[test]\r\n    fn test_stdlib_documentation() {\r\n        let mut parser = crate::Lavendeux::new(Default::default());\r\n        let stdlib = all();\r\n\r\n        let mut errors = vec![];\r\n\r\n        for (name, function) in stdlib {\r\n            let examples = function.documentation().examples().unwrap();\r\n            let skip_example = examples.starts_with(\"#skip\");\r\n            let examples = examples.trim_start_matches(\"#skip\").trim();\r\n            if examples.is_empty() {\r\n                errors.push(Error {\r\n                    details: ErrorDetails::Custom {\r\n                        msg: format!(\r\n                            \"No examples for function {}::{name}\",\r\n                            function.documentation().category()\r\n                        ),\r\n                    },\r\n                    source: None,\r\n                    context: None,\r\n                });\r\n                continue;\r\n            }\r\n\r\n            if skip_example {\r\n                continue;\r\n            }\r\n\r\n            match parser.parse(\u0026examples) {\r\n                Ok(_) =\u003e {}\r\n                Err(e) =\u003e {\r\n                    errors.push(Error {\r\n                        details: ErrorDetails::Custom {\r\n                            msg: format!(\r\n                                \"Failed to parse example for function {}::{name}\",\r\n                                function.documentation().category()\r\n                            ),\r\n                        },\r\n                        source: Some(Box::new(e)),\r\n                        context: None,\r\n                    });\r\n                }\r\n            }\r\n        }\r\n\r\n        for e in errors.iter() {\r\n            eprintln!(\"\\n{}\\n\", e);\r\n        }\r\n\r\n        assert!(\r\n            errors.is_empty(),\r\n            \"Some documentation tests failed. See output for details.\"\r\n        );\r\n    }\r\n}\r\n","traces":[{"line":25,"address":[],"length":0,"stats":{"Line":290},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":290},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":38280},"fn_name":null}],"covered":3,"coverable":3},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","functions","user_function.rs"],"content":"use std::borrow::Cow;\r\n\r\nuse crate::{\r\n    error::ErrorDetails,\r\n    syntax_tree::{\r\n        traits::{IntoOwned, NodeExt},\r\n        AssignmentTarget, Node,\r\n    },\r\n    Error, Lavendeux, Rule, State,\r\n};\r\nuse polyvalue::{Value, ValueType};\r\n\r\nuse super::{\r\n    documentation::UserFunctionDocumentation,\r\n    std_function::{FunctionArgument, FunctionArgumentType, ParserFunction},\r\n    FunctionDocumentation,\r\n};\r\n\r\n/// A user-defined function\r\n/// This is a function defined in lavendish, and is not a part of the standard library\r\n#[derive(Debug, Clone)]\r\npub struct UserDefinedFunction\u003c'i\u003e {\r\n    name: String,\r\n    args: Vec\u003c(String, ValueType)\u003e,\r\n    returns: ValueType,\r\n    src: String,\r\n    body: Node\u003c'i\u003e,\r\n\r\n    src_line_offset: usize,\r\n\r\n    own_docs: UserFunctionDocumentation,\r\n}\r\nimpl ParserFunction for UserDefinedFunction\u003c'_\u003e {\r\n    fn name(\u0026self) -\u003e \u0026str {\r\n        \u0026self.name\r\n    }\r\n\r\n    fn documentation(\u0026self) -\u003e \u0026dyn FunctionDocumentation {\r\n        \u0026self.own_docs\r\n    }\r\n\r\n    fn documentation_mut(\u0026mut self) -\u003e \u0026mut dyn FunctionDocumentation {\r\n        \u0026mut self.own_docs\r\n    }\r\n\r\n    fn return_type(\u0026self) -\u003e ValueType {\r\n        self.returns\r\n    }\r\n\r\n    fn expected_arguments(\u0026self) -\u003e Vec\u003c(Cow\u003c'static, str\u003e, FunctionArgument)\u003e {\r\n        // map self.args to FunctionArgument Standard/All\r\n        self.args\r\n            .iter()\r\n            .map(|(name, expects)| {\r\n                (\r\n                    Cow::Owned(name.clone()),\r\n                    FunctionArgument {\r\n                        expected_type: *expects,\r\n                        meta: FunctionArgumentType::Standard,\r\n                    },\r\n                )\r\n            })\r\n            .collect()\r\n    }\r\n\r\n    fn clone_self(\u0026self) -\u003e Box\u003cdyn ParserFunction\u003e {\r\n        Box::new(UserDefinedFunction {\r\n            name: self.name.clone(),\r\n            args: self.args.clone(),\r\n            returns: self.returns,\r\n            src: self.src.clone(),\r\n            body: UserDefinedFunction::compile(\u0026self.src, \u0026mut Default::default()).unwrap(), // This is safe because the function is already checked\r\n\r\n            src_line_offset: self.src_line_offset,\r\n\r\n            own_docs: self.own_docs.clone(),\r\n        })\r\n    }\r\n\r\n    fn call(\r\n        \u0026self,\r\n        state: \u0026mut State,\r\n        _reference: Option\u003c\u0026AssignmentTarget\u003e,\r\n    ) -\u003e Result\u003cValue, Error\u003e {\r\n        // Execute the body - this is checked in the constructor\r\n        // so we can unwrap here\r\n        match self.body.evaluate(state) {\r\n            Ok(v) =\u003e Ok(v.as_type(self.returns)?),\r\n            Err(e) =\u003e {\r\n                if let ErrorDetails::Return { value } = e.details {\r\n                    return Ok(value.as_type(self.returns)?);\r\n                } else {\r\n                    let e = e.offset_linecount(self.src_line_offset);\r\n                    return Err(e);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nimpl UserDefinedFunction\u003c'_\u003e {\r\n    /// Create a new user-defined function\r\n    pub fn new(name: \u0026str, src: String, state: \u0026mut State) -\u003e Result\u003cSelf, Error\u003e {\r\n        let body = Self::compile(\u0026src, state)?;\r\n        Ok(UserDefinedFunction {\r\n            name: name.to_string(),\r\n            args: vec![],\r\n            returns: ValueType::Any,\r\n            body,\r\n            src,\r\n            src_line_offset: 0,\r\n            own_docs: UserFunctionDocumentation {\r\n                category: \"User-Defined Functions\".to_string(),\r\n                description: None,\r\n                ext_description: None,\r\n                examples: None,\r\n            },\r\n        })\r\n    }\r\n\r\n    fn compile(src: \u0026str, state: \u0026mut State) -\u003e Result\u003cNode\u003c'static\u003e, Error\u003e {\r\n        Lavendeux::eval_rule(src, state, Rule::BLOCK).map(|n| n.into_owned())\r\n    }\r\n\r\n    /// Add a required argument to the function\r\n    pub fn add_arg(\u0026mut self, name: \u0026str, t: ValueType) {\r\n        self.args.push((name.to_string(), t));\r\n    }\r\n\r\n    /// Set the return type of the function\r\n    pub fn set_returns(\u0026mut self, t: ValueType) {\r\n        self.returns = t;\r\n    }\r\n\r\n    /// Offset the location in source-code for errors\r\n    pub fn set_src_line_offset(\u0026mut self, offset: usize) {\r\n        self.src_line_offset = offset;\r\n    }\r\n\r\n    /// Get the source code of the function\r\n    pub fn src(\u0026self) -\u003e \u0026str {\r\n        \u0026self.src\r\n    }\r\n\r\n    /// Remove the lifetime from the function\r\n    pub fn into_owned(self) -\u003e UserDefinedFunction\u003c'static\u003e {\r\n        UserDefinedFunction {\r\n            name: self.name,\r\n            args: self.args,\r\n            returns: self.returns,\r\n            body: self.body.into_owned(),\r\n            src: self.src,\r\n            src_line_offset: self.src_line_offset,\r\n            own_docs: self.own_docs,\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":34,"address":[],"length":0,"stats":{"Line":312},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":312},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":236},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":236},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":392},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":392},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":769},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":377},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":377},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":377},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":377},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":232},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":232},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":232},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":232},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":232},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":232},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":232},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":232},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":232},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":156},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":156},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":151},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":76},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":152},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":308},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":924},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":53},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":53},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":76},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":76},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":39,"coverable":52},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","language_docs.rs"],"content":"#![allow(rustdoc::invalid_html_tags)]\r\n#![allow(rustdoc::broken_intra_doc_links)]\r\n#![doc = include_str!(\"../documentation.md\")]\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","lavendeux.rs"],"content":"use crate::documentation::{DocumentationTemplate, MarkdownFormatter};\r\nuse crate::functions::ParserFunction;\r\nuse crate::pest::LavendeuxParser;\r\nuse crate::syntax_tree::traits::NodeExt;\r\nuse crate::syntax_tree::Node;\r\nuse crate::{Error, Rule, State, Value};\r\nuse std::num::NonZeroUsize;\r\nuse std::time::Duration;\r\n\r\n/// Available options for the parser\r\n/// timeout - The timeout for the parser\r\n/// stack_size - The stack size in bytes for the parsing thread\r\n#[derive(Debug, Clone)]\r\npub struct ParserOptions {\r\n    /// Timeout value to use when building the [State]\r\n    pub timeout: Duration,\r\n\r\n    /// The maximum number of calls to the pest parser\r\n    /// This is used to prevent stack overflows\r\n    pub pest_call_limit: usize,\r\n}\r\nimpl Default for ParserOptions {\r\n    fn default() -\u003e Self {\r\n        Self {\r\n            timeout: Duration::from_secs(0),\r\n            pest_call_limit: 0,\r\n        }\r\n    }\r\n}\r\n\r\n/// The main parser, and the entrypoint for the library\r\n#[derive(Debug)]\r\npub struct Lavendeux {\r\n    state: State,\r\n    options: ParserOptions,\r\n}\r\nimpl Lavendeux {\r\n    /// Create a new Lavendeux instance\r\n    /// The instance will have a new state\r\n    pub fn new(options: ParserOptions) -\u003e Self {\r\n        Self::with_state(options.clone(), State::with_timeout(options.timeout))\r\n    }\r\n\r\n    /// Create a new Lavendeux instance with a given state\r\n    pub fn with_state(options: ParserOptions, state: State) -\u003e Self {\r\n        Self { state, options }\r\n    }\r\n\r\n    /// Register a function with the parser\r\n    pub fn register_function(\u0026mut self, function: impl ParserFunction) -\u003e Result\u003c(), Error\u003e {\r\n        self.state.register_function(function)\r\n    }\r\n\r\n    /// Get a reference to the state\r\n    pub fn state(\u0026self) -\u003e \u0026State {\r\n        \u0026self.state\r\n    }\r\n\r\n    /// Get a mutable reference to the state\r\n    pub fn state_mut(\u0026mut self) -\u003e \u0026mut State {\r\n        \u0026mut self.state\r\n    }\r\n\r\n    /// Evaluate input against a given state, bypassing the normal checks for\r\n    /// threading, timeout, and without sanitizing scope depth\r\n    pub(crate) fn eval\u003c'i\u003e(input: \u0026'i str, state: \u0026mut State) -\u003e Result\u003cNode\u003c'i\u003e, Error\u003e {\r\n        Self::eval_rule(input, state, Rule::SCRIPT)\r\n    }\r\n\r\n    /// Evaluate input against a given state, bypassing the normal checks for\r\n    /// threading, timeout, and without sanitizing scope depth\r\n    pub(crate) fn eval_rule\u003c'i\u003e(\r\n        input: \u0026'i str,\r\n        state: \u0026mut State,\r\n        rule: Rule,\r\n    ) -\u003e Result\u003cNode\u003c'i\u003e, Error\u003e {\r\n        let root = LavendeuxParser::parse2(input, rule)?;\r\n        LavendeuxParser::compile_ast(root, state)\r\n    }\r\n\r\n    /// Parses the given input\r\n    /// Returns an array of values, one for each line in the input\r\n    pub fn parse(\u0026mut self, input: \u0026str) -\u003e Result\u003cVec\u003cValue\u003e, Error\u003e {\r\n        self.state.sanitize_scopes();\r\n        pest::set_call_limit(NonZeroUsize::new(self.options.pest_call_limit));\r\n        self.state.start_timer();\r\n\r\n        let value = Self::eval(input, \u0026mut self.state)?.evaluate(\u0026mut self.state)?;\r\n        let lines = value.as_a::\u003cVec\u003cValue\u003e\u003e()?;\r\n        Ok(lines)\r\n    }\r\n\r\n    /// Run the parser on the given file\r\n    /// Returns an array of values, one for each line in the input\r\n    pub fn run(\u0026mut self, filename: \u0026str) -\u003e Result\u003cVec\u003cValue\u003e, Error\u003e {\r\n        let input = std::fs::read_to_string(filename)?;\r\n        self.parse(\u0026input)\r\n    }\r\n\r\n    /// Generates markdown formatted documentation for the parser\r\n    /// Returns it as a string\r\n    pub fn generate_documentation(\u0026self) -\u003e String {\r\n        DocumentationTemplate::new(MarkdownFormatter).render(\u0026self.state)\r\n    }\r\n}\r\n\r\n// Tests mostly related to the fuzzer\r\n#[cfg(test)]\r\nmod test {\r\n    use super::*;\r\n\r\n    #[test]\r\n    fn test_slow_brackets() {\r\n        let mut parser = Lavendeux::new(ParserOptions {\r\n            timeout: Duration::from_millis(500),\r\n            pest_call_limit: 25000000,\r\n            ..Default::default()\r\n        });\r\n        parser\r\n            .parse(\"X[[[]3[4[bri[z[eeg(e4?estarts_witheHoAs(tX[[[]3[4[bri[z[eee(e4?estarts_\u003ca\")\r\n            .unwrap_err();\r\n        parser\r\n            .parse(\"X[[[]3[4[bri[z[eee(e4?estarts_witheHAso(tX[[[]3[4[bri[z[eee(e4?estarts_\u003ca\")\r\n            .unwrap_err();\r\n        parser\r\n            .parse(\"eeeeeeeA(e5[[4^A(e5[[4^A^eA(e5[[4^A(e5[[4^A^A^\")\r\n            .unwrap_err();\r\n        parser\r\n            .parse(\"eeeeeeA(peeeeeA(eeeeA(peeeeeA(eeA(pA(peeA(pA(pi^A\")\r\n            .unwrap_err();\r\n        parser\r\n                  .parse(\"forirPP[forPorP[f\u0026r[forPorP[ffororPP[forororPP[forPorP[f\u0026r[forPorP[ffororPP[forororPP[forPorP[f\u0026r[forPorP[f\u0026\u0004Br[PP]/b@\u0010]][f\u0026r[P;;P]]]^d]f\u0006\u0026[]P[f\u0026r[forPorP[f\u0026r[PP]-b@]]]^d]PP]][PorP[f\u0026\u0004Br[PP]/b@\u0010]][f\u0026r[P;;P]]]^d]f\u0006\u0026[]P[f\u0026r[forPorP[f\u0026r[PP]-b@]]]^d]PP]][f\u0026r[P;;P]]]^d]f\u0006\u0026[]\")\r\n                 .unwrap_err();\r\n    }\r\n\r\n    #[test]\r\n    fn test_large_fixed_convert() {\r\n        let mut parser = Lavendeux::new(Default::default());\r\n        parser.parse(\r\n            \"1$1666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666662.11\",\r\n        ).unwrap_err();\r\n        parser.parse(\"e8**82asin\").unwrap_err();\r\n        parser.parse(\"e85**88d**e8**8\").unwrap_err();\r\n    }\r\n}\r\n","traces":[{"line":23,"address":[],"length":0,"stats":{"Line":54},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":54},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":54},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":54},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":54},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":215},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":215},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":523},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":1046},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":182},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":182},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":182},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":182},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":537},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":164},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":164},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":20,"coverable":27},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","lib.rs"],"content":"//!\n#![warn(missing_docs)]\n\n// Language documentation\n// Regenerate this using:\n// `cargo run --bin generate_docs`\npub mod language_docs;\n\n// Utitlity functions for the network related functions in stdlib\n#[cfg(feature = \"network-functions\")]\nmod network;\n\n// Docgen utilities\n#[macro_use]\nmod documentation;\n\n// Errors and error-adjacent gubbins\n#[macro_use]\npub mod error;\npub use error::Error;\n\n// The core parser. Builds the AST and evaluates it.\npub mod pest;\npub use pest::Rule; // exported for Token\nmod syntax_tree;\npub use syntax_tree::AssignmentTarget;\n\n/// Function related definitions\n/// Home of the stdlib, user-functions, and function docs\npub mod functions;\n\n// The main parser state\nmod state;\npub use state::State;\n\n// A token parsed from the input\n// Comes up in error handling\nmod token;\npub use token::Token;\n\n// Main entrypoint for the parser\nmod lavendeux;\npub use lavendeux::{Lavendeux, ParserOptions};\n\n// Experimental memory manager\n//mod memory_manager;\n\n// Public re-export of the polyvalue crate\npub use polyvalue;\npub use polyvalue::Value;\n\n/// A few critical tests for common grammar issues post-update\n#[cfg(test)]\nmod test {\n    use crate::Lavendeux;\n\n    #[test]\n    fn test_empty_input() {\n        let mut lav = Lavendeux::new(Default::default());\n        lav.parse(\"\").expect(\"Failed to parse empty input\");\n    }\n\n    #[test]\n    fn test_stackoverflow() {\n        let mut lav = Lavendeux::new(Default::default());\n        let input = \"[[[[[[[[[[99-7[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[99-7[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[99-7[[[[[[[[[[W[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[9[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[99-7[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[99-7[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[K[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[99-7[[[[[[[[[[[[[[[[[[[[[[[[[9-7[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[99-7[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[K[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[99-7[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[z-0\u0026z\u0026oo]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]\";\n        lav.parse(\u0026input).expect_err(\"this should fail\");\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","memory_manager.rs"],"content":"#![allow(dead_code)]\r\nuse crate::{Error, Value};\r\nuse std::collections::HashMap;\r\n\r\n/// Implementation of the stack of scopes for the parser state\r\n#[derive(Debug, Clone, Default)]\r\npub struct MemoryManager {\r\n    globals: HashMap\u003cString, Value\u003e,\r\n    frames: Vec\u003c(String, Option\u003cValue\u003e)\u003e,\r\n    locks: Vec\u003cusize\u003e,\r\n    frame_starts: Vec\u003cusize\u003e,\r\n}\r\nimpl MemoryManager {\r\n    const GC_STACKSIZE: usize = 1024;\r\n    const MAX_DEPTH: usize = 15000;\r\n\r\n    /// Creates a blank stack\r\n    pub fn new() -\u003e Self {\r\n        Self::default()\r\n    }\r\n\r\n    /// Prune invalid frames from the stack without affecting references\r\n    fn prune_frames(\u0026mut self) {\r\n        loop {\r\n            if match self.frames.last() {\r\n                Some((_, v)) =\u003e v.is_none(),\r\n                None =\u003e false,\r\n            } {\r\n                self.frames.pop();\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /// Returns the size of the stack in bytes\r\n    fn stack_size(\u0026self) -\u003e usize {\r\n        self.frames.len() * std::mem::size_of::\u003c(String, Option\u003cValue\u003e)\u003e()\r\n    }\r\n\r\n    /// Sorts the stack contents such that all empty values at the top, then removes them\r\n    /// This is unsafe because it can cause references to be invalidated. It also probably\r\n    /// isn't very fast.\r\n    /// Only runs if the stack is larger than `GC_STACKSIZE` and we are in the global frame\r\n    fn unsafely_sort_compress_stack(\u0026mut self) {\r\n        if self.frame_starts.is_empty() \u0026\u0026 self.stack_size() \u003e Self::GC_STACKSIZE {\r\n            self.frames.sort_by_key(|(_, v)| v.is_none());\r\n            // find the first empty value\r\n            let first_empty = self.frames.iter().position(|(_, v)| v.is_none());\r\n            if let Some(first_empty) = first_empty {\r\n                self.frames.truncate(first_empty);\r\n            }\r\n        }\r\n    }\r\n\r\n    /// Release all locks, and clear all frames\r\n    /// Leaves the global frame intact\r\n    pub fn reset(\u0026mut self) {\r\n        self.frames\r\n            .truncate(self.frame_starts.first().map(|s| *s).unwrap_or_default());\r\n        self.locks.clear();\r\n        self.frame_starts.clear();\r\n\r\n        self.unsafely_sort_compress_stack();\r\n    }\r\n\r\n    /// Returns the size of the stack, in frames\r\n    pub fn stack_len(\u0026self) -\u003e usize {\r\n        self.frames.len()\r\n    }\r\n\r\n    /// Increases the depth of the stack\r\n    pub fn scope_into(\u0026mut self) -\u003e Result\u003c(), Error\u003e {\r\n        if self.frame_starts.len() \u003e= Self::MAX_DEPTH {\r\n            oops!(StackOverflow)\r\n        } else {\r\n            self.frame_starts.push(self.stack_len());\r\n            Ok(())\r\n        }\r\n    }\r\n\r\n    /// Decreases the depth of the stack\r\n    pub fn scope_out(\u0026mut self) {\r\n        if !self.frame_starts.is_empty() {\r\n            self.frames.truncate(self.frame_starts.pop().unwrap());\r\n            if self.stack_len() \u003c self.last_valid_scope(0) {\r\n                self.unlock_scope();\r\n            }\r\n        }\r\n        self.prune_frames();\r\n    }\r\n\r\n    /// Locks the current scope, preventing access to variables in higher scopes\r\n    pub fn lock_scope(\u0026mut self) {\r\n        self.locks.push(self.stack_len());\r\n    }\r\n\r\n    /// Unlocks the current scope, granting access to variables in higher scopes\r\n    pub fn unlock_scope(\u0026mut self) {\r\n        self.locks.pop();\r\n    }\r\n\r\n    /// Returns the index from the bottom of the last frame valid for reading\r\n    /// Will act as if the stack is frame_offset frames up from the current frame\r\n    fn last_valid_scope(\u0026self, frame_offset: usize) -\u003e usize {\r\n        for lock in self.locks.iter().rev() {\r\n            if *lock \u003c= self.stack_len() - frame_offset {\r\n                return *lock;\r\n            }\r\n        }\r\n        0\r\n    }\r\n\r\n    /// Get a reference to the all valid scopes\r\n    /// Will act as if the stack is frame_offset frames up from the current frame\r\n    fn get_valid_scopes(\u0026self, frame_offset: usize) -\u003e \u0026[(String, Option\u003cValue\u003e)] {\r\n        let start = self.last_valid_scope(frame_offset);\r\n        let end = self.stack_len() - frame_offset;\r\n        \u0026self.frames[start..end]\r\n    }\r\n\r\n    /// Get a reference to the all valid scopes\r\n    /// Will act as if the stack is frame_offset frames up from the current frame\r\n    fn get_valid_scopes_mut(\u0026mut self, frame_offset: usize) -\u003e \u0026mut [(String, Option\u003cValue\u003e)] {\r\n        let start = self.last_valid_scope(frame_offset);\r\n        let end = self.stack_len() - frame_offset;\r\n        \u0026mut self.frames[start..end]\r\n    }\r\n\r\n    /// Set a global variable in the bottom of the stack\r\n    pub fn set_global(\u0026mut self, name: \u0026str, value: Value) {\r\n        self.globals.insert(name.to_string(), value);\r\n    }\r\n\r\n    /// Get a global variable from the bottom of the stack\r\n    pub fn get_global(\u0026self, name: \u0026str) -\u003e Option\u003c\u0026Value\u003e {\r\n        self.globals.get(name)\r\n    }\r\n\r\n    /// Get a value from the stack\r\n    /// Will act as if the stack is frame_offset frames up from the current frame\r\n    pub fn get(\u0026self, name: \u0026str, frame_offset: usize) -\u003e Option\u003c\u0026Value\u003e {\r\n        for (k, v) in self.get_valid_scopes(frame_offset).iter().rev() {\r\n            if name == k {\r\n                return v.as_ref();\r\n            }\r\n        }\r\n        self.get_global(name)\r\n    }\r\n\r\n    /// Get a value from the stack\r\n    pub fn get_mut(\u0026mut self, name: \u0026str, frame_offset: usize) -\u003e Option\u003c\u0026mut Value\u003e {\r\n        let _self: *mut Self = self;\r\n        for (k, v) in unsafe { \u0026mut *_self }\r\n            .get_valid_scopes_mut(frame_offset)\r\n            .iter_mut()\r\n            .rev()\r\n        {\r\n            if name == k {\r\n                return v.as_mut();\r\n            }\r\n        }\r\n\r\n        unsafe { \u0026mut *_self }.globals.get_mut(name)\r\n    }\r\n\r\n    /// Write a value to the stack\r\n    pub fn set(\u0026mut self, name: \u0026str, frame_offset: usize, value: Value) {\r\n        if let Some(v) = self.get_mut(name, frame_offset) {\r\n            *v = value;\r\n        } else {\r\n            self.set_top(name, value);\r\n        }\r\n    }\r\n\r\n    /// Write a value to the top of the stack\r\n    /// Will prioritize writing to existing empty slots over expanding the stack\r\n    fn set_top(\u0026mut self, name: \u0026str, value: Value) {\r\n        let current_framestart = self.frame_starts.last().map(|s| *s).unwrap_or_default();\r\n        let total_entries = self.frames.len();\r\n        for (k, v) in self\r\n            .frames\r\n            .iter_mut()\r\n            .rev()\r\n            .take(total_entries - current_framestart)\r\n        {\r\n            if v.is_none() {\r\n                *k = name.to_string();\r\n                *v = Some(value);\r\n                return;\r\n            }\r\n        }\r\n        self.frames.push((name.to_string(), Some(value)));\r\n    }\r\n\r\n    /// Deletes a value from the stack\r\n    pub fn delete(\u0026mut self, name: \u0026str, frame_offset: usize) -\u003e Option\u003cValue\u003e {\r\n        self.prune_frames();\r\n        for (k, v) in self.get_valid_scopes_mut(frame_offset).iter_mut().rev() {\r\n            if name == k {\r\n                return v.take();\r\n            }\r\n        }\r\n        self.globals.remove(name)\r\n    }\r\n\r\n    /// Returns all variables in the state that are valid for reading\r\n    pub fn all_variables_in_scope(\u0026self, frame_offset: usize) -\u003e HashMap\u003c\u0026str, \u0026Value\u003e {\r\n        let mut variables = HashMap::new();\r\n        variables.extend(self.globals.iter().map(|(k, v)| (k.as_str(), v)));\r\n        for (k, v) in self.get_valid_scopes(frame_offset) {\r\n            if let Some(v) = v {\r\n                variables.insert(k.as_str(), v);\r\n            }\r\n        }\r\n        variables\r\n    }\r\n\r\n    /// Returns all variables in the state, regardless of locks\r\n    pub fn all_variables(\u0026self) -\u003e HashMap\u003c\u0026str, \u0026Value\u003e {\r\n        let mut variables = HashMap::new();\r\n        variables.extend(self.globals.iter().map(|(k, v)| (k.as_str(), v)));\r\n        for (k, v) in \u0026self.frames {\r\n            if let Some(v) = v {\r\n                variables.insert(k.as_str(), v);\r\n            }\r\n        }\r\n        variables\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod test {\r\n    use super::*;\r\n\r\n    #[test]\r\n    fn test_samescope() {\r\n        let mut mm = MemoryManager::new();\r\n\r\n        // {a:0} [1]\r\n        mm.set(\"a\", 0, Value::from(1));\r\n        mm.set_global(\"a\", Value::from(0));\r\n        assert_eq!(mm.get(\"a\", 0), Some(\u0026Value::from(1)));\r\n\r\n        // {a:0} [1]\r\n        mm.scope_into().unwrap();\r\n        assert_eq!(mm.get(\"a\", 0), Some(\u0026Value::from(1)));\r\n\r\n        // {a:0} [1, 2]\r\n        mm.set(\"a\", 0, Value::from(2));\r\n        assert_eq!(mm.get(\"a\", 0), Some(\u0026Value::from(2)));\r\n\r\n        // {a:0} [1]\r\n        mm.scope_out();\r\n        assert_eq!(mm.get(\"a\", 0), Some(\u0026Value::from(1)));\r\n\r\n        // {a:0} []\r\n        mm.scope_out();\r\n        assert_eq!(mm.get(\"a\", 0), Some(\u0026Value::from(0)));\r\n    }\r\n\r\n    #[test]\r\n    fn prune_frames() {}\r\n\r\n    #[test]\r\n    fn stack_size() {}\r\n\r\n    #[test]\r\n    fn test_unsafely_sort_compress_stack() {}\r\n\r\n    #[test]\r\n    fn test_reset() {}\r\n\r\n    #[test]\r\n    fn test_stack_len() {}\r\n\r\n    #[test]\r\n    fn test_scope_into() {}\r\n\r\n    #[test]\r\n    fn test_scope_out() {}\r\n\r\n    #[test]\r\n    fn test_last_valid_scope() {}\r\n\r\n    #[test]\r\n    fn test_get_valid_scopes() {}\r\n\r\n    #[test]\r\n    fn test_get_valid_scopes_mut() {}\r\n\r\n    #[test]\r\n    fn test_set_global() {}\r\n\r\n    #[test]\r\n    fn test_get_global() {}\r\n\r\n    #[test]\r\n    fn test_get() {}\r\n\r\n    #[test]\r\n    fn test_get_mut() {}\r\n\r\n    #[test]\r\n    fn test_set() {}\r\n\r\n    #[test]\r\n    fn test_set_top() {}\r\n\r\n    #[test]\r\n    fn test_delete() {\r\n        let mut mm = MemoryManager::new();\r\n        mm.set(\"a\", 0, Value::from(1));\r\n        mm.scope_into().unwrap();\r\n        mm.lock_scope();\r\n        mm.set(\"b\", 0, Value::from(2));\r\n        mm.scope_into().unwrap();\r\n        mm.set_global(\"c\", Value::from(3));\r\n        mm.set_global(\"a\", Value::from(3));\r\n\r\n        assert_eq!(mm.delete(\"a\", 2), Some(Value::from(1)));\r\n        assert_eq!(mm.delete(\"b\", 0), Some(Value::from(2)));\r\n        assert_eq!(mm.delete(\"c\", 0), Some(Value::from(3)));\r\n        assert_eq!(mm.delete(\"a\", 0), Some(Value::from(3)));\r\n    }\r\n\r\n    #[test]\r\n    fn test_all_variables_in_scope() {\r\n        let mut mm = MemoryManager::new();\r\n        mm.set(\"a\", 0, Value::from(1));\r\n        mm.scope_into().unwrap();\r\n        mm.lock_scope();\r\n        mm.set(\"b\", 0, Value::from(2));\r\n        mm.scope_into().unwrap();\r\n        mm.set_global(\"c\", Value::from(3));\r\n        mm.set_global(\"a\", Value::from(3));\r\n\r\n        let vars = mm.all_variables_in_scope(0);\r\n        assert_eq!(vars.len(), 3);\r\n        assert_eq!(vars.get(\"a\"), Some(\u0026\u0026Value::from(3)));\r\n        assert_eq!(vars.get(\"b\"), Some(\u0026\u0026Value::from(2)));\r\n        assert_eq!(vars.get(\"c\"), Some(\u0026\u0026Value::from(3)));\r\n    }\r\n\r\n    #[test]\r\n    fn test_all_variables() {\r\n        let mut mm = MemoryManager::new();\r\n        mm.set(\"a\", 0, Value::from(1));\r\n        mm.scope_into().unwrap();\r\n        mm.lock_scope();\r\n        mm.set(\"b\", 0, Value::from(2));\r\n        mm.scope_into().unwrap();\r\n        mm.set_global(\"c\", Value::from(3));\r\n        mm.set_global(\"a\", Value::from(3));\r\n\r\n        let vars = mm.all_variables();\r\n        assert_eq!(vars.len(), 3);\r\n        assert_eq!(vars.get(\"a\"), Some(\u0026\u0026Value::from(1)));\r\n        assert_eq!(vars.get(\"b\"), Some(\u0026\u0026Value::from(2)));\r\n        assert_eq!(vars.get(\"c\"), Some(\u0026\u0026Value::from(3)));\r\n    }\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","network","api.rs"],"content":"use super::request;\r\nuse crate::{error::ErrorDetails, Error};\r\nuse polyvalue::{types::Object, Value, ValueTrait, ValueType};\r\nuse std::collections::HashMap;\r\n\r\n#[derive(Debug, Clone, Default)]\r\npub struct ApiDefinition {\r\n    pub base_url: String,\r\n    pub additional_headers: HashMap\u003cString, String\u003e,\r\n    pub description: String,\r\n    pub examples: String,\r\n    pub auth_key: Option\u003cString\u003e,\r\n}\r\n\r\nimpl ApiDefinition {\r\n    pub fn call(\r\n        \u0026self,\r\n        endpoint: Option\u003c\u0026str\u003e,\r\n        body: Option\u003cString\u003e,\r\n        mut headers: HashMap\u003cString, String\u003e,\r\n    ) -\u003e Result\u003cValue, Error\u003e {\r\n        let endpoint = endpoint.unwrap_or_default().trim_start_matches('/');\r\n        let target = format!(\"{}/{}\", \u0026self.base_url, endpoint);\r\n        if let Some(auth_key) = \u0026self.auth_key {\r\n            headers.insert(\"Authorization\".to_string(), format!(\"Bearer {}\", auth_key));\r\n        }\r\n\r\n        request(\u0026target, body, headers)\r\n    }\r\n}\r\n\r\nimpl TryFrom\u003cValue\u003e for ApiDefinition {\r\n    type Error = ErrorDetails;\r\n    fn try_from(value: Value) -\u003e Result\u003cSelf, Self::Error\u003e {\r\n        let value = if value.is_a(ValueType::String) {\r\n            Object::try_from(vec![(\r\n                Value::from(\"base_url\"),\r\n                Value::from(value.to_string()),\r\n            )])?\r\n        } else {\r\n            value.as_a::\u003cObject\u003e()?\r\n        };\r\n\r\n        let mut base_url =\r\n        value\r\n            .get(\u0026Value::from(\"base_url\"))\r\n            .ok_or(ErrorDetails::ValueFormat {\r\n                expected_format: \"\u003cbase_url: string\u003e | {\u003cbase_url: string\u003e, \u003cdescription: string\u003e, \u003cexamples: string\u003e, \u003cauth_key: string\u003e, \u003cheaders: object\u003e}\".to_string(),\r\n            })?.to_string();\r\n\r\n        base_url = base_url.trim_end_matches('/').to_string();\r\n\r\n        Ok(Self {\r\n            base_url,\r\n\r\n            description: value\r\n                .get(\u0026(\"description\".into()))\r\n                .unwrap_or(\u0026Value::from(\"\"))\r\n                .to_string(),\r\n            examples: value\r\n                .get(\u0026(\"examples\".into()))\r\n                .unwrap_or(\u0026Value::from(\"\"))\r\n                .to_string(),\r\n\r\n            auth_key: value\n                .get(\u0026(\"auth_key\".into())).map(|v| v.to_string()),\r\n\r\n            additional_headers: value\r\n                .get(\u0026(\"additional_headers\".into()))\r\n                .unwrap_or(\u0026Value::from(Object::new(Default::default())))\r\n                .clone()\r\n                .as_a::\u003cObject\u003e()?\r\n                .iter()\r\n                .map(|(k, v)| (k.to_string(), v.to_string()))\r\n                .collect(),\r\n        })\r\n    }\r\n}\r\n\r\nimpl From\u003cApiDefinition\u003e for Value {\r\n    fn from(val: ApiDefinition) -\u003e Self {\r\n        let mut obj = Object::new(Default::default());\r\n        obj.insert(\"base_url\".into(), Value::from(val.base_url))\r\n            .ok();\r\n        obj.insert(\"description\".into(), Value::from(val.description))\r\n            .ok();\r\n        obj.insert(\"examples\".into(), Value::from(val.examples))\r\n            .ok();\r\n\r\n        if let Some(auth_key) = val.auth_key {\r\n            obj.insert(\"auth_key\".into(), Value::from(auth_key)).ok();\r\n        }\r\n\r\n        obj.insert(\r\n            \"additional_headers\".into(),\r\n            Value::try_from(\r\n                val.additional_headers\r\n                    .iter()\r\n                    .map(|(k, v)| (Value::from(k.as_str()), Value::from(v.as_str())))\r\n                    .collect::\u003cVec\u003c(_, _)\u003e\u003e(),\r\n            )\r\n            .unwrap(),\r\n        )\r\n        .ok();\r\n        Value::from(obj)\r\n    }\r\n}\r\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":58},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":64},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":1459},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":1459},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":1459},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":1459},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":1459},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":1462},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":1459},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":1459},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":1459},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":1459},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":1459},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":1751},"fn_name":null}],"covered":23,"coverable":30},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","network","defaults.rs"],"content":"use super::ApiDefinition;\r\nuse std::collections::HashMap;\r\n\r\npub fn default_apis() -\u003e HashMap\u003cString, ApiDefinition\u003e {\r\n    let mut apis = HashMap::new();\r\n\r\n    apis.insert(\r\n        \"httpbin\".to_string(),\r\n        ApiDefinition {\r\n            base_url: \"https://httpbin.org\".to_string(),\r\n            description: \"A simple HTTP Request \u0026 Response Service.\".to_string(),\r\n            examples: \"https://httpbin.org\".to_string(),\r\n            ..Default::default()\r\n        },\r\n    );\r\n\r\n    apis.insert(\r\n        \"ipify\".to_string(),\r\n        ApiDefinition {\r\n            base_url: \"https://api.ipify.org\".to_string(),\r\n            description: \"A simple public IP address API.\".to_string(),\r\n            examples: \"https://api.ipify.org\".to_string(),\r\n            ..Default::default()\r\n        },\r\n    );\r\n\r\n    apis.insert(\r\n        \"ipinfo\".to_string(),\r\n        ApiDefinition {\r\n            base_url: \"https://ipinfo.io\".to_string(),\r\n            description: \"Find out your public and private IP addresses.\".to_string(),\r\n            examples: \"https://ipinfo.io\".to_string(),\r\n            ..Default::default()\r\n        },\r\n    );\r\n\r\n    apis.insert(\r\n        \"ipapi\".to_string(),\r\n        ApiDefinition {\r\n            base_url: \"https://ipapi.co\".to_string(),\r\n            description: \"IP address location API and geolocation service.\".to_string(),\r\n            examples: \"https://ipapi.co\".to_string(),\r\n            ..Default::default()\r\n        },\r\n    );\r\n\r\n    apis.insert(\r\n        \"chatgpt\".to_string(),\r\n        ApiDefinition {\r\n            base_url: \"https://api.openai.com/v1/chat/completions\".to_string(),\r\n            description: \"Chat with GPT-3.5\".to_string(),\r\n            examples: \"chatgpt('hello world')\".to_string(),\r\n            additional_headers: vec![(\"Content-Type\".to_string(), \"application/json\".to_string())]\r\n                .into_iter()\r\n                .collect(),\r\n            ..Default::default()\r\n        },\r\n    );\r\n\r\n    apis\r\n}\r\n","traces":[{"line":4,"address":[],"length":0,"stats":{"Line":289},"fn_name":null},{"line":5,"address":[],"length":0,"stats":{"Line":289},"fn_name":null},{"line":7,"address":[],"length":0,"stats":{"Line":289},"fn_name":null},{"line":8,"address":[],"length":0,"stats":{"Line":289},"fn_name":null},{"line":9,"address":[],"length":0,"stats":{"Line":289},"fn_name":null},{"line":10,"address":[],"length":0,"stats":{"Line":289},"fn_name":null},{"line":11,"address":[],"length":0,"stats":{"Line":289},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":289},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":289},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":289},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":289},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":289},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":289},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":289},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":289},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":289},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":289},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":289},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":289},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":289},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":289},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":289},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":289},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":289},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":289},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":289},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":289},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":289},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":289},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":289},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":289},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":289},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":289},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":289},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":289},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":289},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":289},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":289},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":289},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":289},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":289},"fn_name":null}],"covered":41,"coverable":41},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","network","mod.rs"],"content":"mod api;\r\npub use api::ApiDefinition;\r\n\r\nmod util;\r\npub use util::*;\r\n\r\nmod registry;\r\npub use registry::ApiRegistry;\r\n\r\nmod defaults;\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","network","registry.rs"],"content":"use super::{defaults::default_apis, ApiDefinition};\r\nuse crate::State;\r\nuse polyvalue::{types::Object, Value};\r\nuse std::collections::HashMap;\r\n\r\npub struct ApiRegistry(HashMap\u003cString, ApiDefinition\u003e);\r\nimpl ApiRegistry {\r\n    const STORE_NAME: \u0026'static str = \"__api_definitions\";\r\n\r\n    /// Create a new instance of the registry, loading the APIs\r\n    /// from the state object\r\n    pub fn new(state: \u0026State) -\u003e Self {\r\n        let mut inst = Self(HashMap::new());\r\n        inst.load(state);\r\n        inst\r\n    }\r\n\r\n    /// Populate the state with the default APIs\r\n    pub fn populate_defaults(state: \u0026mut State) {\r\n        Self(default_apis()).save(state);\r\n    }\r\n\r\n    /// Get the raw value of the registry from the state object\r\n    pub fn raw(state: \u0026State) -\u003e Value {\r\n        state\r\n            .global_get_variable(Self::STORE_NAME)\r\n            .cloned()\r\n            .unwrap_or(Object::default().into())\r\n    }\r\n\r\n    /// Load the APIs from the state object\r\n    fn load(\u0026mut self, state: \u0026State) {\r\n        self.0.clear();\r\n        let state = Self::raw(state).as_a::\u003cObject\u003e().unwrap_or_default();\r\n        for (k, v) in state.iter() {\r\n            if let Ok(api) = ApiDefinition::try_from(v.clone()) {\r\n                self.0.insert(k.to_string(), api);\r\n            }\r\n        }\r\n    }\r\n\r\n    /// Save the APIs to the state object\r\n    fn save(\u0026self, state: \u0026mut State) {\r\n        let obj = self\r\n            .0\r\n            .iter()\r\n            .map(|(k, v)| (k.to_string(), v.clone()))\r\n            .collect::\u003cVec\u003c(_, _)\u003e\u003e();\r\n        state.global_assign_variable(Self::STORE_NAME, Value::try_from(obj).unwrap());\r\n    }\r\n\r\n    /// Add a new API to the registry\r\n    pub fn add(\u0026mut self, state: \u0026mut State, name: \u0026str, api: ApiDefinition) {\r\n        self.0.insert(name.to_string(), api);\r\n        self.save(state);\r\n    }\r\n\r\n    /// Remove an API from the registry\r\n    pub fn remove(\u0026mut self, state: \u0026mut State, name: \u0026str) {\r\n        self.0.remove(name);\r\n        self.save(state);\r\n    }\r\n\r\n    /// Get an API from the registry\r\n    pub fn get(\u0026self, name: \u0026str) -\u003e Option\u003c\u0026ApiDefinition\u003e {\r\n        self.0.get(name)\r\n    }\r\n\r\n    /// Get all APIs from the registry\r\n    pub fn all(\u0026self) -\u003e \u0026HashMap\u003cString, ApiDefinition\u003e {\r\n        \u0026self.0\r\n    }\r\n}\r\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":289},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":289},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":34},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":292},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":292},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":292},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":2043},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":292},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":3},"fn_name":null}],"covered":30,"coverable":30},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","network","util.rs"],"content":"use polyvalue::Value;\r\nuse std::collections::HashMap;\r\nuse std::net::ToSocketAddrs;\r\nuse std::str::FromStr;\r\nuse std::time::Duration;\r\n\r\nuse crate::{oops, Error};\r\n\r\npub fn resolve(hostname: \u0026str) -\u003e Result\u003cValue, Error\u003e {\r\n    match (hostname, 0).to_socket_addrs() {\r\n        Ok(mut addresses) =\u003e {\r\n            if let Some(addr) = addresses.next() {\r\n                return Ok(Value::from(addr.ip().to_string()));\r\n            } else {\r\n                return oops!(Custom {\r\n                    msg: format!(\"No addresses found for `{hostname}`\")\r\n                });\r\n            }\r\n        }\r\n        Err(e) =\u003e Err(e.into()),\r\n    }\r\n}\r\n\r\nfn decode_response(response: \u0026str, headers: \u0026HashMap\u003cString, String\u003e) -\u003e Value {\r\n    let json_decode = headers.get(\"Content-Type\").cloned().unwrap_or_default()\r\n        == \"application/json\"\r\n        || headers.get(\"content-type\").cloned().unwrap_or_default() == \"application/json\";\r\n    if json_decode {\r\n        if let Ok(v) = serde_json::Value::from_str(response) {\r\n            if let Ok(v) = Value::try_from(v) {\r\n                return v;\r\n            }\r\n        }\r\n    }\r\n\r\n    Value::from(response)\r\n}\r\n\r\n/// Fetch from a given URL\r\n///\r\n/// # Arguments\r\n/// * `url` - Target URL\r\n/// * `body` - Body if POST\r\n/// * `headers` - Array of header=value strings\r\npub fn request(\r\n    url: \u0026str,\r\n    body: Option\u003cString\u003e,\r\n    headers: HashMap\u003cString, String\u003e,\r\n) -\u003e Result\u003cValue, Error\u003e {\r\n    match reqwest::blocking::Client::builder()\r\n        .timeout(Duration::from_millis(1500))\r\n        .build()\r\n    {\r\n        Ok(client) =\u003e {\r\n            let mut request = match body {\r\n                None =\u003e client.get(url),\r\n                Some(s) =\u003e client.post(url).body(s),\r\n            };\r\n\r\n            for (header, value) in headers.iter() {\r\n                request = request.header(header, value);\r\n            }\r\n\r\n            match request.send() {\r\n                Ok(res) =\u003e match res.text() {\r\n                    Ok(s) =\u003e {\r\n                        let value = decode_response(\u0026s, \u0026headers);\r\n                        Ok(value)\r\n                    }\r\n                    Err(e) =\u003e Err(e.into()),\r\n                },\r\n                Err(e) =\u003e Err(e.into()),\r\n            }\r\n        }\r\n        Err(e) =\u003e Err(e.into()),\r\n    }\r\n}\r\n","traces":[{"line":9,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":10,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":11,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":34},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","pest.rs"],"content":"//! This module contains the underlying PEST parser for Lavendeux\r\n//! It is not intended to be used directly, but instead is used to parse the input into a syntax tree\r\n//! Use [Lavendeux] to parse input instead\r\n#![allow(missing_docs)]\r\nuse crate::{error::WrapSyntaxError, Error, State};\r\nuse pest::Parser;\r\nuse pest_derive::Parser;\r\n\r\n/// Re-export for use with the internal Lavendeux::eval compiler function\r\npub use crate::syntax_tree::Node;\r\n\r\n/// Re-export for use with the internal Lavendeux::eval compiler function\r\npub use crate::syntax_tree::traits::NodeExt;\r\n\r\n/// Lavendeux's parser\r\n/// We will not directly expose this to the user, but instead use it to\r\n/// parse the input into a syntax tree\r\n#[derive(Parser)]\r\n#[grammar = \"grammar.pest\"]\r\npub struct LavendeuxParser;\r\nimpl LavendeuxParser {\r\n    pub fn compile_ast\u003c'i\u003e(\r\n        root_pair: pest::iterators::Pair\u003c'i, Rule\u003e,\r\n        state: \u0026mut State,\r\n    ) -\u003e Result\u003cNode\u003c'i\u003e, Error\u003e {\r\n        Node::from_pair(root_pair, state)\r\n    }\r\n\r\n    pub fn parse2\u003c'i\u003e(\r\n        input: \u0026'i str,\r\n        rule: Rule,\r\n    ) -\u003e Result\u003cpest::iterators::Pair\u003c'i, Rule\u003e, Error\u003e {\r\n        let pairs = stacker::maybe_grow(Node::STACK_EXP * 10, Node::STACK_EXP * 10, || {\r\n            Self::parse(rule, input).wrap_syntax_error(input)\r\n        })?;\r\n        if let Some(pair) = pairs.flatten().next() {\r\n            Ok(pair)\r\n        } else {\r\n            oops!(Internal {\r\n                msg: format!(\"No instance of rule {:?} found in input\", rule)\r\n            })\r\n        }\r\n    }\r\n}\r\n\r\n/// Runs a single expression through the parser and tests the last value\r\n/// This is a convenience function for testing\r\n/// # Example\r\n/// ```rust\r\n/// use lavendeux_parser::assert_expr;\r\n/// assert_expr!(\"1 + 1\", 2i64);\r\n/// ```\r\n#[cfg(test)]\r\n#[macro_export]\r\nmacro_rules! assert_expr {\r\n    ($e:literal, $v:expr) =\u003e {\r\n        assert_eq!(\r\n            $crate::Lavendeux::new(Default::default())\r\n                .parse($e)\r\n                .expect(\u0026format!(\"Error parsing `{}`\", $e))\r\n                .into_iter()\r\n                .last()\r\n                .expect(\"No values returned from expression\"),\r\n            $crate::Value::from($v),\r\n        )\r\n    };\r\n}\r\n\r\n/// Runs a single expression through the parser and matches the result\r\n/// This is a convenience function for testing\r\n/// # Example\r\n/// ```rust\r\n/// use lavendeux_parser::match_expr;\r\n/// match_expr!(\"foo + bar\", Err(_));\r\n/// ```\r\n#[cfg(test)]\r\n#[macro_export]\r\nmacro_rules! match_expr {\r\n    ($e:literal, $v:pat) =\u003e {\r\n        matches!(\r\n            $crate::Lavendeux::new(Default::default())\r\n                .parse($e)\r\n            $v\r\n        )\r\n    };\r\n}\r\n\r\n/// Runs a single expression through the parser and matches on the details of the error\r\n/// This is a convenience function for testing\r\n/// # Example\r\n/// ```rust\r\n/// use lavendeux_parser::match_expr_err;\r\n/// match_expr!(\"foo + bar\", VariableName {..});\r\n/// ```\r\n#[cfg(test)]\r\n#[macro_export]\r\nmacro_rules! match_expr_err {\r\n    ($e:literal, $v:pat) =\u003e {\r\n        matches!(\r\n            $crate::Lavendeux::new(Default::default())\r\n                .parse($e)\r\n                .expect_err(\u0026format!(\"Expected an error from `{}`\", $e))\r\n                .details,\r\n            $v\r\n        )\r\n    };\r\n}\r\n\r\n/// Generates a test case sent to the parser\r\n/// # Example\r\n///  ```rust\r\n/// use lavendeux_parser::lav;\r\n/// use lavendeux_parser::{error::ErrorDetails, Error};\r\n///\r\n/// lav!(test_isok r#\"\r\n/// 1 + 1\r\n/// \"#);\r\n///\r\n/// lav!(test_isvar(a = 1, b = 2) r#\"\r\n/// a=1, b=2\r\n/// \"#);\r\n///\r\n/// lav!(test_iserr(Error) r#\"\r\n/// asparagus\r\n/// \"#);\r\n///\r\n/// lav!(test_whaterr(Error = |e: \u0026Error| matches!(e.details, ErrorDetails::VariableName {..})) r#\"\r\n/// asparagus\r\n/// \"#);\r\n/// ```\r\n#[cfg(test)]\r\n#[macro_export]\r\nmacro_rules! lav {\r\n    ($test_name:ident $body:literal) =\u003e {\r\n        #[test]\r\n        fn $test_name() {\r\n            $crate::Lavendeux::new(Default::default()).parse($body).expect(\"Error parsing expression\");\r\n        }\r\n    };\r\n    ($test_name:ident(Error) $body:literal) =\u003e {\r\n        #[test]\r\n        fn $test_name() {\r\n            $crate::Lavendeux::new(Default::default()).parse($body).expect_err(\"Expected expression to fail\");\r\n        }\r\n    };\r\n\r\n    ($test_name:ident(Error = $pattern:expr) $body:literal) =\u003e {\r\n        #[test]\r\n        fn $test_name() {\r\n            let mut lav = $crate::Lavendeux::new(Default::default());\r\n            let e = lav.parse($body).expect_err(\"Expected expression to fail\");\r\n            if !( $pattern(\u0026e) ) {\r\n                panic!(\"Error did not match pattern: {:#?}\", e)\r\n            }\r\n        }\r\n    };\r\n\r\n    ($test_name:ident($($n:ident = $v:expr),+$(,)?) $body:literal) =\u003e {\r\n        #[test]\r\n        fn $test_name() {\r\n            let mut lav = $crate::Lavendeux::new(Default::default());\r\n            lav.parse($body).expect(\"Error parsing expression\");\r\n            $( assert_eq!(lav.state().get_variable(stringify!($n)).expect(\u0026format!(\"`{}` was not set\", stringify!($n))), \u0026$crate::Value::from($v)); )+\r\n        }\r\n    };\r\n}\r\n\r\n#[cfg(test)]\r\nmod test {\r\n    use crate::{error::ErrorDetails, Error};\r\n\r\n    lav!(test_isok r#\"\r\n        1 + 1\r\n    \"#);\r\n\r\n    lav!(test_isvar(a = 1i64, b = 2i64) r#\"\r\n        a=1; b=2\r\n    \"#);\r\n\r\n    lav!(test_iserr(Error) r#\"\r\n        asparagus\r\n    \"#);\r\n\r\n    lav!(test_whaterr(Error = |e: \u0026Error| matches!(e.details, ErrorDetails::VariableName {..})) r#\"\r\n        asparagus\r\n    \"#);\r\n}\r\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":514},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":514},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":523},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":1560},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":523},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":514},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":514},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":3},"fn_name":null}],"covered":19,"coverable":22},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","state.rs"],"content":"use crate::{\r\n    documentation::{DocumentationFormatter, PlaintextFormatter},\r\n    error::ErrorDetails,\r\n    functions::{stdlib, ParserFunction},\r\n    network::ApiRegistry,\r\n    syntax_tree::AssignmentTarget,\r\n    Error, Value,\r\n};\r\nuse std::{\r\n    collections::HashMap,\r\n    time::{Duration, Instant},\r\n};\r\n\r\n/// The main parser state\r\n/// Stores variables, scoping data, functions, and metadata about the current parse\r\n#[derive(Debug)]\r\npub struct State {\r\n    /// Current depth of the parser\r\n    /// This is used to prevent infinite recursion\r\n    /// while parsing user_functions\r\n    depth: usize,\r\n    locked: Vec\u003cusize\u003e,\r\n\r\n    /// The time that the current parse started\r\n    /// This is used to prevent infinite loops\r\n    /// and implement a timeout\r\n    parse_starttime: Instant,\r\n    timeout: Duration,\r\n\r\n    /// Registered variables\r\n    /// Used as a stack for scoping\r\n    variables: Vec\u003cHashMap\u003cString, Value\u003e\u003e,\r\n\r\n    /// Registered functions\r\n    functions: HashMap\u003cString, Box\u003cdyn ParserFunction\u003e\u003e,\r\n}\r\n\r\nimpl Default for State {\r\n    fn default() -\u003e Self {\r\n        let stdlib_fns = stdlib::all();\r\n        let mut instance = Self {\r\n            depth: 0,\r\n            locked: Vec::new(),\r\n            parse_starttime: std::time::Instant::now(),\r\n            timeout: Duration::from_secs(0),\r\n            variables: vec![HashMap::new()],\r\n\r\n            functions: stdlib_fns,\r\n        };\r\n\r\n        ApiRegistry::populate_defaults(\u0026mut instance);\r\n\r\n        instance\r\n    }\r\n}\r\n\r\nimpl State {\r\n    const MAX_DEPTH: usize = 15000;\r\n\r\n    /// Creates a new parser state\r\n    pub fn new() -\u003e Self {\r\n        Self::default()\r\n    }\r\n\r\n    /**\r\n     *\r\n     * Timeout handling functions\r\n     *\r\n     */\r\n\r\n    /// Creates a new parser state with a timeout\r\n    /// Parsing will fail with `ErrorDetails::Timeout` if the timeout is exceeded\r\n    /// The timer does not begin until `start_timer` is called\r\n    /// And is checked with `check_timer` (which is called internally by the parser)\r\n    pub fn with_timeout(timeout: Duration) -\u003e Self {\r\n        Self {\r\n            timeout,\r\n            ..Self::default()\r\n        }\r\n    }\r\n\r\n    /// Sets the timeout of the parser\r\n    /// Used on parse start\r\n    pub fn start_timer(\u0026mut self) {\r\n        self.parse_starttime = Instant::now();\r\n    }\r\n\r\n    /// Checks the timeout of the parser\r\n    pub fn check_timer(\u0026self) -\u003e Result\u003c(), Error\u003e {\r\n        if !self.timeout.is_zero() \u0026\u0026 self.parse_starttime.elapsed() \u003e self.timeout {\r\n            Err(ErrorDetails::Timeout.into())\r\n        } else {\r\n            Ok(())\r\n        }\r\n    }\r\n\r\n    /**\r\n     *\r\n     * Scope handling functions\r\n     *\r\n     */\r\n\r\n    /// Returns the current depth of the parser\r\n    pub fn current_depth(\u0026self) -\u003e usize {\r\n        self.depth\r\n    }\r\n\r\n    /// Sets the depth to 0, and destroys all scopes but the root scope\r\n    pub fn sanitize_scopes(\u0026mut self) {\r\n        self.depth = 0;\r\n        self.locked = Vec::new();\r\n        self.variables.truncate(1);\r\n    }\r\n\r\n    /// Creates a new scope from this state\r\n    /// A limit is placed on the depth of scopes that can be created\r\n    /// This is to prevent infinite recursion\r\n    pub fn scope_into(\u0026mut self) -\u003e Result\u003c(), Error\u003e {\r\n        // If stacker reports \u003c 1MB of stack remaining, then we need to stop\r\n        if self.depth \u003e= Self::MAX_DEPTH\r\n            || stacker::remaining_stack() \u003c Some(crate::pest::Node::MIN_STACK)\r\n        {\r\n            return Err(ErrorDetails::StackOverflow.into());\r\n        }\r\n\r\n        self.depth += 1;\r\n        self.variables.push(HashMap::new());\r\n\r\n        Ok(())\r\n    }\r\n\r\n    /// Locks the current scope, preventing access to variables in higher scopes\r\n    pub fn lock_scope(\u0026mut self) {\r\n        self.locked.push(self.depth);\r\n    }\r\n\r\n    /// Unlocks the current scope, granting access to variables in higher scopes\r\n    pub fn unlock_scope(\u0026mut self) {\r\n        self.locked.pop();\r\n    }\r\n\r\n    /// Returns the last valid scope\r\n    fn last_valid_scope(\u0026self) -\u003e usize {\r\n        if let Some(lock) = self.locked.last() {\r\n            *lock\r\n        } else {\r\n            0\r\n        }\r\n    }\r\n\r\n    /// Returns the last valid scope for the parent caller\r\n    fn last_valid_parent_scope(\u0026self) -\u003e usize {\r\n        if let Some(lock) = self.locked.iter().rev().nth(1) {\r\n            *lock\r\n        } else {\r\n            0\r\n        }\r\n    }\r\n\r\n    /// Removes the current scope from this state\r\n    pub fn scope_out(\u0026mut self) {\r\n        if self.depth == 0 {\r\n            return;\r\n        }\r\n        self.depth -= 1;\r\n        self.variables.pop();\r\n\r\n        if self.depth \u003c self.last_valid_scope() {\r\n            self.unlock_scope();\r\n        }\r\n    }\r\n\r\n    fn get_valid_scopes(\u0026self) -\u003e impl Iterator\u003cItem = \u0026HashMap\u003cString, polyvalue::Value\u003e\u003e {\r\n        self.variables\r\n            .iter()\r\n            .rev()\r\n            .take(self.depth - self.last_valid_scope() + 1)\r\n    }\r\n\r\n    fn get_valid_scopes_mut(\r\n        \u0026mut self,\r\n    ) -\u003e impl Iterator\u003cItem = \u0026mut HashMap\u003cString, polyvalue::Value\u003e\u003e {\r\n        let lock = self.last_valid_scope();\r\n        self.variables.iter_mut().rev().take(self.depth - lock + 1)\r\n    }\r\n\r\n    fn get_valid_parent_scopes(\u0026self) -\u003e impl Iterator\u003cItem = \u0026HashMap\u003cString, polyvalue::Value\u003e\u003e {\r\n        self.variables\r\n            .iter()\r\n            .rev()\r\n            .skip(1)\r\n            .take(self.depth - self.last_valid_parent_scope())\r\n    }\r\n\r\n    fn get_valid_parent_scopes_mut(\r\n        \u0026mut self,\r\n    ) -\u003e impl Iterator\u003cItem = \u0026mut HashMap\u003cString, polyvalue::Value\u003e\u003e {\r\n        let lock = self.last_valid_parent_scope();\r\n        self.variables\r\n            .iter_mut()\r\n            .rev()\r\n            .skip(1)\r\n            .take(self.depth - lock)\r\n    }\r\n\r\n    /**\r\n     *\r\n     * Variable handling functions\r\n     *\r\n     */\r\n\r\n    /// Assigns a variable in the state, in the root scope\r\n    pub fn global_assign_variable(\u0026mut self, name: \u0026str, value: Value) {\r\n        self.variables[0].insert(name.to_string(), value);\r\n    }\r\n\r\n    /// Gets a variable from the root scope\r\n    pub fn global_get_variable(\u0026self, name: \u0026str) -\u003e Option\u003c\u0026Value\u003e {\r\n        self.variables[0].get(name)\r\n    }\r\n\r\n    /// Sets a variable in the a scope offset levels from the current scope\r\n    /// If that scope does not exist, the variable is not set\r\n    pub fn set_variable_in_offset(\u0026mut self, offset: usize, name: \u0026str, value: Value) {\r\n        if let Some(scope) = self.variables.iter_mut().rev().nth(offset) {\r\n            scope.insert(name.to_string(), value);\r\n        }\r\n    }\r\n\r\n    /// Sets a variable as if it were in the parent scope\r\n    /// Bypasses the scope lock\r\n    pub fn set_variable_as_parent(\u0026mut self, name: \u0026str, value: Value) {\r\n        let mut scopes = self.get_valid_scopes_mut();\r\n        scopes.next();\r\n        for scope in scopes {\r\n            if scope.contains_key(name) {\r\n                scope.insert(name.to_string(), value);\r\n                return;\r\n            }\r\n        }\r\n\r\n        // If the variable is not found, assign it in the current scope\r\n        self.set_variable_in_offset(1, name, value)\r\n    }\r\n\r\n    /// Sets a variable in the state\r\n    pub fn set_variable(\u0026mut self, name: \u0026str, value: Value) {\r\n        for scope in self.get_valid_scopes_mut() {\r\n            if scope.contains_key(name) {\r\n                scope.insert(name.to_string(), value);\r\n                return;\r\n            }\r\n        }\r\n\r\n        // If the variable is not found, assign it in the root scope\r\n        self.set_variable_in_scope(name, value)\r\n    }\r\n\r\n    /// Sets a variable in the current scope\r\n    pub fn set_variable_in_scope(\u0026mut self, name: \u0026str, value: Value) {\r\n        if let Some(scope) = self.variables.last_mut() {\r\n            scope.insert(name.to_string(), value);\r\n        }\r\n    }\r\n\r\n    /// Returns the value of a variable\r\n    pub fn get_variable(\u0026self, name: \u0026str) -\u003e Option\u003c\u0026Value\u003e {\r\n        for scope in self.get_valid_scopes() {\r\n            if let Some(value) = scope.get(name) {\r\n                return Some(value);\r\n            }\r\n        }\r\n        None\r\n    }\r\n\r\n    /// Returns the value of a variable, mutably\r\n    pub fn get_variable_mut(\u0026mut self, name: \u0026str) -\u003e Option\u003c\u0026mut Value\u003e {\r\n        for scope in self.get_valid_scopes_mut() {\r\n            if let Some(value) = scope.get_mut(name) {\r\n                return Some(value);\r\n            }\r\n        }\r\n        None\r\n    }\r\n\r\n    /// Returns the value of a variable from the parent scope\r\n    pub fn get_variable_as_parent(\u0026self, name: \u0026str) -\u003e Option\u003c\u0026Value\u003e {\r\n        let scopes = self.get_valid_parent_scopes();\r\n        for scope in scopes {\r\n            if let Some(value) = scope.get(name) {\r\n                return Some(value);\r\n            }\r\n        }\r\n        None\r\n    }\r\n\r\n    /// Returns the value of a variable, mutably from the parent scope\r\n    pub fn get_variable_mut_as_parent(\u0026mut self, name: \u0026str) -\u003e Option\u003c\u0026mut Value\u003e {\r\n        let scopes = self.get_valid_parent_scopes_mut();\r\n        for scope in scopes {\r\n            if let Some(value) = scope.get_mut(name) {\r\n                return Some(value);\r\n            }\r\n        }\r\n        None\r\n    }\r\n\r\n    /// Deletes a variable from the state\r\n    pub fn delete_variable(\u0026mut self, name: \u0026str) -\u003e Option\u003cValue\u003e {\r\n        for scope in self.get_valid_scopes_mut() {\r\n            if let Some(value) = scope.remove(name) {\r\n                return Some(value);\r\n            }\r\n        }\r\n        None\r\n    }\r\n\r\n    /// Returns all variables in the state\r\n    pub fn all_variables(\u0026self) -\u003e HashMap\u003c\u0026str, \u0026Value\u003e {\r\n        let mut variables = HashMap::new();\r\n        for scope in self.get_valid_scopes() {\r\n            variables.extend(scope.iter().map(|(k, v)| (k.as_str(), v)));\r\n        }\r\n\r\n        variables\r\n    }\r\n\r\n    /// Returns all variables in the state\r\n    /// Ignores the scope lock\r\n    pub fn all_variables_unscoped(\u0026self) -\u003e HashMap\u003c\u0026str, \u0026Value\u003e {\r\n        let mut variables = HashMap::new();\r\n        for scope in self.variables.iter().rev() {\r\n            variables.extend(scope.iter().map(|(k, v)| (k.as_str(), v)));\r\n        }\r\n\r\n        variables\r\n    }\r\n\r\n    /**\r\n     *\r\n     * Function handling functions\r\n     *\r\n     */\r\n\r\n    /// Returns true if the given function is a read-only system function\r\n    pub fn is_system_function(\u0026self, name: \u0026str) -\u003e bool {\r\n        if let Some(function) = self.functions.get(name) {\r\n            function.is_readonly()\r\n        } else {\r\n            false\r\n        }\r\n    }\r\n\r\n    /// Registers a function in the state\r\n    /// See [crate::define_stdfunction] for an example of how to define a function\r\n    pub fn register_function(\u0026mut self, function: impl ParserFunction) -\u003e Result\u003c(), Error\u003e {\r\n        let name = function.name();\r\n        if self.is_system_function(name) {\r\n            oops!(ReadOnlyFunction {\r\n                name: name.to_string()\r\n            })\r\n        } else {\r\n            self.functions\r\n                .insert(name.to_string(), function.clone_self());\r\n            Ok(())\r\n        }\r\n    }\r\n\r\n    /// Unregisters a function from the state\r\n    pub fn unregister_function(\r\n        \u0026mut self,\r\n        name: \u0026str,\r\n    ) -\u003e Result\u003cOption\u003cBox\u003cdyn ParserFunction\u003e\u003e, Error\u003e {\r\n        if self.is_system_function(name) {\r\n            oops!(ReadOnlyFunction {\r\n                name: name.to_string()\r\n            })\r\n        } else {\r\n            Ok(self.functions.remove(name))\r\n        }\r\n    }\r\n\r\n    /// Returns a function from the state\r\n    pub fn get_function(\u0026self, name: \u0026str) -\u003e Option\u003c\u0026dyn ParserFunction\u003e {\r\n        self.functions.get(name).map(|f| f.as_ref())\r\n    }\r\n\r\n    /// Returns a function from the state\r\n    pub fn get_function_mut(\u0026mut self, name: \u0026str) -\u003e Option\u003c\u0026mut Box\u003cdyn ParserFunction\u003e\u003e {\r\n        self.functions.get_mut(name)\r\n    }\r\n\r\n    /// List all functions in the state\r\n    pub fn all_functions(\u0026self) -\u003e \u0026HashMap\u003cString, Box\u003cdyn ParserFunction\u003e\u003e {\r\n        \u0026self.functions\r\n    }\r\n\r\n    /// Calls a function in the state\r\n    /// arg1_references maps to the references field of the source [crate::Token]\r\n    pub fn call_function(\r\n        \u0026mut self,\r\n        name: \u0026str,\r\n        args: Vec\u003cValue\u003e,\r\n        reference: Option\u003c\u0026AssignmentTarget\u003e,\r\n    ) -\u003e Result\u003cValue, Error\u003e {\r\n        let function = self.get_function(name).ok_or(ErrorDetails::FunctionName {\r\n            name: name.to_string(),\r\n        })?;\r\n        let function = function.clone_self();\r\n        function.exec(\u0026args, self, reference)\r\n    }\r\n\r\n    /// Calls a decorator function\r\n    pub fn decorate(\u0026mut self, name: \u0026str, value: Value) -\u003e Result\u003cString, Error\u003e {\r\n        let name = format!(\"@{name}\");\r\n        match self.call_function(\u0026name, vec![value], None) {\r\n            Ok(value) =\u003e Ok(value.to_string()),\r\n            Err(e) if matches!(e.details, ErrorDetails::FunctionName { .. }) =\u003e {\r\n                oops!(DecoratorName {\r\n                    name: name.to_string()\r\n                })\r\n            }\r\n            Err(e) =\u003e Err(e),\r\n        }\r\n    }\r\n\r\n    /// Returns a string containing the help for all functions\r\n    pub fn help(\u0026self, filter: Option\u003cString\u003e) -\u003e String {\r\n        PlaintextFormatter.format_functions(self, filter.as_deref())\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod test {\r\n    use super::*;\r\n    #[test]\r\n    fn test_scope() {\r\n        let mut state = State::new();\r\n        state.set_variable(\"a\", Value::from(2.0));\r\n        state.scope_into().ok();\r\n        assert_eq!(state.delete_variable(\"a\"), Some(Value::from(2.0)));\r\n        assert_eq!(state.delete_variable(\"a\"), None);\r\n\r\n        state.global_assign_variable(\"b\", Value::from(2.0));\r\n\r\n        assert_eq!(state.current_depth(), 1);\r\n        state.scope_out();\r\n        assert_eq!(state.current_depth(), 0);\r\n\r\n        state.scope_out();\r\n        assert_eq!(state.current_depth(), 0);\r\n\r\n        assert_eq!(state.get_variable(\"a\"), None);\r\n        assert_eq!(state.get_variable(\"b\"), Some(\u0026Value::from(2.0)));\r\n\r\n        state.depth = State::MAX_DEPTH;\r\n        assert!(matches!(\r\n            state.scope_into().unwrap_err().details,\r\n            ErrorDetails::StackOverflow { .. }\r\n        ));\r\n    }\r\n\r\n    #[test]\r\n    fn test_timer() {\r\n        let mut state = State::with_timeout(Duration::from_millis(100));\r\n        state.start_timer();\r\n        std::thread::sleep(std::time::Duration::from_millis(250));\r\n        assert!(matches!(\r\n            state.check_timer().unwrap_err().details,\r\n            ErrorDetails::Timeout\r\n        ));\r\n    }\r\n\r\n    #[test]\r\n    fn test_all_variables() {\r\n        let mut state = State::new();\r\n        state.set_variable(\"a\", Value::from(2.0));\r\n        state.scope_into().ok();\r\n        state.set_variable(\"b\", Value::from(3.0));\r\n\r\n        let variables = state.all_variables();\r\n        assert!(variables.contains_key(\"a\"));\r\n        assert!(variables.contains_key(\"b\"));\r\n    }\r\n}\r\n","traces":[{"line":39,"address":[],"length":0,"stats":{"Line":289},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":289},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":289},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":289},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":289},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":289},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":289},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":289},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":55},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":183},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":183},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":389},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":390},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":388},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":182},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":182},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":182},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":182},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":1535},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":1535},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":1534},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":1534},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":1534},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":1534},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":924},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":924},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":924},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":924},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":5959},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":11524},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":394},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":1534},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":1534},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":1533},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":1533},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":2457},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":924},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":2389},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":2389},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":2389},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":2037},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":2037},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":2037},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":295},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":295},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":1986},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":4483},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":2497},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":240},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":240},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":1746},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":1746},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":3492},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":2388},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":5698},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":5681},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":2371},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":84},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":84},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":288,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":290,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":298,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":310,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":321,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":322,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":330,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":331,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":333,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":336,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":346,"address":[],"length":0,"stats":{"Line":79},"fn_name":null},{"line":347,"address":[],"length":0,"stats":{"Line":84},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":74},"fn_name":null},{"line":356,"address":[],"length":0,"stats":{"Line":76},"fn_name":null},{"line":357,"address":[],"length":0,"stats":{"Line":76},"fn_name":null},{"line":358,"address":[],"length":0,"stats":{"Line":76},"fn_name":null},{"line":359,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":360,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":363,"address":[],"length":0,"stats":{"Line":76},"fn_name":null},{"line":364,"address":[],"length":0,"stats":{"Line":76},"fn_name":null},{"line":365,"address":[],"length":0,"stats":{"Line":76},"fn_name":null},{"line":370,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":374,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":375,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":376,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":379,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":384,"address":[],"length":0,"stats":{"Line":1014},"fn_name":null},{"line":385,"address":[],"length":0,"stats":{"Line":3041},"fn_name":null},{"line":389,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":390,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":394,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":395,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":400,"address":[],"length":0,"stats":{"Line":882},"fn_name":null},{"line":406,"address":[],"length":0,"stats":{"Line":1764},"fn_name":null},{"line":407,"address":[],"length":0,"stats":{"Line":882},"fn_name":null},{"line":414,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":415,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":416,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":417,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":418,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":419,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":420,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":423,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":428,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":429,"address":[],"length":0,"stats":{"Line":3},"fn_name":null}],"covered":132,"coverable":153},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","syntax_tree","assignment_target.rs"],"content":"use crate::{\r\n    error::{ErrorDetails, WrapOption},\r\n    Error, State,\r\n};\r\n\r\nuse super::{\r\n    traits::{IntoOwned, NodeExt},\r\n    Node,\r\n};\r\nuse polyvalue::{\r\n    operations::{IndexingMutationExt, IndexingOperationExt},\r\n    Value, ValueType,\r\n};\r\n\r\n/// The target for a RW operation on a value\r\n#[derive(Debug, Clone)]\r\npub enum AssignmentTarget\u003c'i\u003e {\r\n    /// Directly assign to a variable ( a )\r\n    Identifier(String),\r\n\r\n    /// Assign to an index of a value ( a[0] )\r\n    Index(String, Vec\u003cOption\u003cNode\u003c'i\u003e\u003e\u003e), // None = last-entry index\r\n\r\n    /// Destructure a value into multiple targets ( [a, b, c] )\r\n    Destructure(Vec\u003cAssignmentTarget\u003c'i\u003e\u003e),\r\n}\r\n\r\nimpl std::fmt::Display for AssignmentTarget\u003c'_\u003e {\r\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\r\n        match self {\r\n            Self::Identifier(id) =\u003e write!(f, \"{}\", id),\r\n            Self::Index(base, indices) =\u003e {\r\n                write!(f, \"{}\", base)?;\r\n                for index in indices {\r\n                    write!(\r\n                        f,\r\n                        \"[{}]\",\r\n                        if let Some(i) = index {\r\n                            \u0026i.token().input\r\n                        } else {\r\n                            \"\"\r\n                        }\r\n                    )?;\r\n                }\r\n                Ok(())\r\n            }\r\n            Self::Destructure(targets) =\u003e {\r\n                write!(\r\n                    f,\r\n                    \"[{}]\",\r\n                    targets\r\n                        .iter()\r\n                        .map(|t| t.to_string())\r\n                        .collect::\u003cVec\u003c_\u003e\u003e()\r\n                        .join(\",\")\r\n                )\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nimpl IntoOwned for AssignmentTarget\u003c'_\u003e {\r\n    type Owned = AssignmentTarget\u003c'static\u003e;\r\n    fn into_owned(self) -\u003e Self::Owned {\r\n        match self {\r\n            Self::Identifier(id) =\u003e Self::Owned::Identifier(id),\r\n            Self::Index(base, indices) =\u003e Self::Owned::Index(\r\n                base,\r\n                indices\r\n                    .into_iter()\r\n                    .map(|i| i.map(|i| i.into_owned()))\r\n                    .collect(),\r\n            ),\r\n            Self::Destructure(targets) =\u003e {\r\n                Self::Owned::Destructure(targets.into_iter().map(|t| t.into_owned()).collect())\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003c'i\u003e AssignmentTarget\u003c'i\u003e {\r\n    pub(crate) fn get_index_handle(base: Value, indices: \u0026[Option\u003cValue\u003e]) -\u003e Result\u003cValue, Error\u003e {\r\n        let mut base = base;\r\n        for index in indices {\r\n            let default_idx = Value::from(if base.len() == 0 { 0 } else { base.len() - 1 });\r\n            let index = index.as_ref().unwrap_or(\u0026default_idx);\r\n\r\n            if index.is_a(ValueType::Collection) \u0026\u0026 !index.is_a(ValueType::String) {\r\n                base = base.get_indices(index)?;\r\n            } else {\r\n                base = base.get_index(index)?;\r\n            }\r\n        }\r\n        Ok(base)\r\n    }\r\n\r\n    pub(crate) fn get_mut_index_handle\u003c'v\u003e(\r\n        base: \u0026'v mut Value,\r\n        indices: \u0026[Option\u003cValue\u003e],\r\n    ) -\u003e Result\u003c\u0026'v mut Value, Error\u003e {\r\n        let mut base = base;\r\n        for index in indices {\r\n            let default_idx = Value::from(if base.len() == 0 { 0 } else { base.len() - 1 });\r\n            let index = index.as_ref().unwrap_or(\u0026default_idx);\r\n            base = base.get_index_mut(index)?;\r\n        }\r\n        Ok(base)\r\n    }\r\n\r\n    /// Evaluate the target to get the value it points to\r\n    pub fn get_value(\u0026self, state: \u0026mut State) -\u003e Result\u003cValue, Error\u003e {\r\n        match self {\r\n            Self::Identifier(id) =\u003e state\r\n                .get_variable(id)\r\n                .cloned()\r\n                .or_error(ErrorDetails::VariableName { name: id.clone() }),\r\n            Self::Index(base, indices) =\u003e {\r\n                let mut idx = vec![];\r\n                for index in indices {\r\n                    idx.push(index.as_ref().map(|i| i.evaluate(state)).transpose()?);\r\n                }\r\n\r\n                let base = state\r\n                    .get_variable(base)\r\n                    .cloned()\r\n                    .or_error(ErrorDetails::VariableName { name: base.clone() })?;\r\n                Self::get_index_handle(base, \u0026idx)\r\n            }\r\n            Self::Destructure(targets) =\u003e targets\r\n                .iter()\r\n                .map(|t| t.get_value(state))\r\n                .collect::\u003cResult\u003cVec\u003c_\u003e, _\u003e\u003e()\r\n                .map(Value::from),\r\n        }\r\n    }\r\n\r\n    /// Evaluate the target to get the value it points to\r\n    /// This version of the function will look for the variable in the parent scope\r\n    pub fn get_value_in_parent(\u0026self, state: \u0026mut State) -\u003e Result\u003cValue, Error\u003e {\r\n        match self {\r\n            Self::Identifier(id) =\u003e state\r\n                .get_variable_as_parent(id)\r\n                .cloned()\r\n                .or_error(ErrorDetails::VariableName { name: id.clone() }),\r\n            Self::Index(base, indices) =\u003e {\r\n                let mut idx = vec![];\r\n                for index in indices {\r\n                    idx.push(index.as_ref().map(|i| i.evaluate(state)).transpose()?);\r\n                }\r\n\r\n                let base = state\r\n                    .get_variable_as_parent(base)\r\n                    .cloned()\r\n                    .or_error(ErrorDetails::VariableName { name: base.clone() })?;\r\n                Self::get_index_handle(base, \u0026idx)\r\n            }\r\n            Self::Destructure(targets) =\u003e targets\r\n                .iter()\r\n                .map(|t| t.get_value_in_parent(state))\r\n                .collect::\u003cResult\u003cVec\u003c_\u003e, _\u003e\u003e()\r\n                .map(Value::from),\r\n        }\r\n    }\r\n\r\n    /// Update the value the target points to\r\n    pub fn update_value(\u0026self, state: \u0026mut State, value: Value) -\u003e Result\u003c(), Error\u003e {\r\n        match self {\r\n            Self::Identifier(id) =\u003e {\r\n                state.set_variable(id, value);\r\n                Ok(())\r\n            }\r\n            Self::Index(base, indices) =\u003e {\r\n                let mut idx = vec![];\r\n                for index in indices {\r\n                    idx.push(index.as_ref().map(|i| i.evaluate(state)).transpose()?);\r\n                }\r\n\r\n                let mut base = state\r\n                    .get_variable_mut(base)\r\n                    .or_error(ErrorDetails::VariableName { name: base.clone() })?;\r\n\r\n                if idx.is_empty() {\r\n                    *base = value;\r\n                    return Ok(());\r\n                }\r\n\r\n                let target_idx = idx.pop().unwrap();\r\n                base = Self::get_mut_index_handle(base, \u0026idx)?;\r\n\r\n                let target_idx = target_idx.unwrap_or(base.len().into());\r\n\r\n                base.set_index(\u0026target_idx, value)?;\r\n                Ok(())\r\n            }\r\n            Self::Destructure(targets) =\u003e {\r\n                if targets.len() != value.len() {\r\n                    oops!(DestructuringAssignment {\r\n                        expected_length: targets.len(),\r\n                        actual_length: value.len()\r\n                    })\r\n                } else {\r\n                    let values = value.as_a::\u003cVec\u003cValue\u003e\u003e()?;\r\n                    for (target, value) in targets.iter().zip(values.into_iter()) {\r\n                        target.update_value(state, value)?;\r\n                    }\r\n                    Ok(())\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /// Get a handle to the target value, if it exists.\r\n    /// This function will look for the variable in the parent scope\r\n    pub fn get_target_mut_in_parent\u003c's\u003e(\r\n        \u0026self,\r\n        state: \u0026's mut State,\r\n    ) -\u003e Result\u003cOption\u003c\u0026's mut Value\u003e, Error\u003e {\r\n        match self {\r\n            Self::Identifier(id) =\u003e Some(\r\n                state\r\n                    .get_variable_mut_as_parent(id)\r\n                    .or_error(ErrorDetails::VariableName { name: id.clone() }),\r\n            )\r\n            .transpose(),\r\n            Self::Index(base, indices) =\u003e {\r\n                let mut idx = vec![];\r\n                for index in indices {\r\n                    idx.push(index.as_ref().map(|i| i.evaluate(state)).transpose()?);\r\n                }\r\n\r\n                let base = state\r\n                    .get_variable_mut_as_parent(base)\r\n                    .or_error(ErrorDetails::VariableName { name: base.clone() })?;\r\n                Some(Self::get_mut_index_handle(base, \u0026idx)).transpose()\r\n            }\r\n            Self::Destructure(_) =\u003e Ok(None),\r\n        }\r\n    }\r\n\r\n    /// Update the value the target points to\r\n    /// This version of the function will look for the variable in the parent scope\r\n    pub fn update_value_in_parent(\u0026self, state: \u0026mut State, value: Value) -\u003e Result\u003c(), Error\u003e {\r\n        match self {\r\n            Self::Identifier(id) =\u003e {\r\n                state.set_variable_as_parent(id, value);\r\n                Ok(())\r\n            }\r\n            Self::Index(base, indices) =\u003e {\r\n                let mut idx = vec![];\r\n                for index in indices {\r\n                    idx.push(index.as_ref().map(|i| i.evaluate(state)).transpose()?);\r\n                }\r\n\r\n                let mut base = state\r\n                    .get_variable_mut_as_parent(base)\r\n                    .or_error(ErrorDetails::VariableName { name: base.clone() })?;\r\n                base = Self::get_mut_index_handle(base, \u0026idx)?;\r\n\r\n                if idx.is_empty() {\r\n                    *base = value;\r\n                    return Ok(());\r\n                }\r\n\r\n                let target_idx = idx.pop().unwrap();\r\n                base = Self::get_mut_index_handle(base, \u0026idx)?;\r\n\r\n                let target_idx = target_idx.unwrap_or(base.len().into());\r\n                base.set_index(\u0026target_idx, value)?;\r\n                Ok(())\r\n            }\r\n            Self::Destructure(targets) =\u003e {\r\n                if targets.len() != value.len() {\r\n                    oops!(DestructuringAssignment {\r\n                        expected_length: targets.len(),\r\n                        actual_length: value.len()\r\n                    })\r\n                } else {\r\n                    let values = value.as_a::\u003cVec\u003cValue\u003e\u003e()?;\r\n                    for (target, value) in targets.iter().zip(values.into_iter()) {\r\n                        target.update_value_in_parent(state, value)?;\r\n                    }\r\n                    Ok(())\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /// Delete the value the target points to\r\n    pub fn delete(\u0026self, state: \u0026mut State) -\u003e Result\u003cValue, Error\u003e {\r\n        match self {\r\n            Self::Identifier(id) =\u003e {\r\n                if let Some(value) = state.delete_variable(id) {\r\n                    Ok(value)\r\n                } else if let Some(function) = state.unregister_function(id)? {\r\n                    Ok(function.signature().into())\r\n                } else {\r\n                    oops!(VariableName { name: id.clone() })\r\n                }\r\n            }\r\n\r\n            AssignmentTarget::Index(base, indices) =\u003e {\r\n                let mut idx = vec![];\r\n                for index in indices {\r\n                    idx.push(index.as_ref().map(|i| i.evaluate(state)).transpose()?);\r\n                }\r\n\r\n                if indices.is_empty() {\r\n                    return oops!(ArrayEmpty);\r\n                }\r\n\r\n                let mut base = state\r\n                    .get_variable_mut(base)\r\n                    .or_error(ErrorDetails::VariableName { name: base.clone() })?;\r\n                let target_idx = idx.pop().unwrap();\r\n                base = Self::get_mut_index_handle(base, \u0026idx)?;\r\n\r\n                let target_idx = target_idx.unwrap_or((base.len() - 1).into());\r\n\r\n                Ok(base.delete_index(\u0026target_idx)?)\r\n            }\r\n\r\n            AssignmentTarget::Destructure(ids) =\u003e {\r\n                let results = ids\r\n                    .iter()\r\n                    .map(|id| id.delete(state))\r\n                    .collect::\u003cResult\u003cVec\u003c_\u003e, _\u003e\u003e()?;\r\n                Ok(Value::from(results))\r\n            }\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":29,"address":[],"length":0,"stats":{"Line":207},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":207},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":207},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":1774},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":1774},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":1565},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":188},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":188},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":188},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":1030},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":188},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":96},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":69},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":69},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":235},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":166},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":31},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":148},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":69},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":59},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":1187},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":1187},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":1110},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":1110},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":1110},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":67},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":67},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":224},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":67},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":127},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":64},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":65},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":63},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":46},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":386},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":386},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":367},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":367},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":367},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":77},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":38},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":282,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":290,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":303,"address":[],"length":0,"stats":{"Line":43},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":307,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":313,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":322,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":323,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":3},"fn_name":null}],"covered":95,"coverable":174},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","syntax_tree","macros.rs"],"content":"macro_rules! define_astnode {\r\n    (\r\n        outer = $oname:ident,\r\n        $name:ident $({$($param:ident : $param_t:ty),*})?,\r\n        build = ($pairsvar:ident, $btokvar:ident, $bstatevar:ident) $build_hnd:block,\r\n        eval  = ($selfvar:ident, $estatevar:ident) $eval_hnd:block,\r\n        owned = ($oselfvar:ident) $owned_hnd:block\r\n        $(\r\n                ,docs  = {\r\n                name: $docs_name:literal,\r\n                symbols = [$($docs_symbols:literal),*],\r\n                description: $docs_desc:literal,\r\n                examples: $docs_examples:literal,\r\n            }\r\n        )?\r\n    ) =\u003e {\r\n        $(\r\n            document_operator! {\r\n                name = $docs_name,\r\n                rules = [],\r\n                symbols = [$($docs_symbols),*],\r\n                description = $docs_desc,\r\n                examples = $docs_examples,\r\n            }\r\n        )?\r\n\r\n        #[allow(missing_docs)]\r\n        #[derive(Debug, Clone)]\r\n        pub struct $name\u003c'i\u003e {\r\n            $($(pub $param: $param_t,)*)?\r\n            token: crate::Token\u003c'i\u003e,\r\n        }\r\n        impl crate::syntax_tree::traits::IntoOwned for $name\u003c'_\u003e {\r\n            type Owned = $name\u003c'static\u003e;\r\n            fn into_owned(self) -\u003e Self::Owned {\r\n                let $oselfvar = self;\r\n                $owned_hnd\r\n            }\r\n        }\r\n        impl\u003c'i\u003e crate::syntax_tree::traits::NodeExt\u003c'i\u003e for $name\u003c'i\u003e {\r\n            fn evaluate(\u0026self, $estatevar: \u0026mut crate::State) -\u003e Result\u003ccrate::Value, crate::Error\u003e {\r\n                let $selfvar = self;\r\n                $eval_hnd\r\n            }\r\n\r\n            fn token(\u0026self) -\u003e \u0026crate::Token\u003c'i\u003e {\r\n                \u0026self.token\r\n            }\r\n        }\r\n        #[allow(unused_mut)]\r\n        impl\u003c'i\u003e crate::syntax_tree::traits::SyntaxNodeBuilderExt\u003c'i\u003e for $name\u003c'i\u003e {\r\n            fn build(mut $pairsvar: crate::syntax_tree::pair::InnerPestIterator\u003c'i\u003e, $btokvar: crate::Token\u003c'i\u003e, $bstatevar: \u0026mut crate::State) -\u003e Result\u003ccrate::syntax_tree::Node\u003c'i\u003e, crate::Error\u003e\r\n            $build_hnd\r\n        }\r\n        /// Simplify conversion from node to AST node\r\n        impl\u003c'i\u003e From\u003c$name\u003c'i\u003e\u003e for crate::syntax_tree::Node\u003c'i\u003e {\r\n            fn from(node: $name\u003c'i\u003e) -\u003e Self {\r\n                Self::$oname(Box::new($oname::$name(node)))\r\n            }\r\n        }\r\n    };\r\n}\r\n\r\nmacro_rules! define_ast {\r\n    (\r\n        $name:ident {\r\n            $($iname:ident $(($($param:ident : $param_t:ty),*))? {\r\n                build = ($pairsvar:ident, $btokvar:ident, $bstatevar:ident) $build_hnd:block,\r\n                eval  = ($selfvar:ident, $estatevar:ident) $eval_hnd:block,\r\n                owned = ($oselfvar:ident) $owned_hnd:block\r\n                $(\r\n                        ,docs  = {\r\n                        name: $docs_name:literal,\r\n                        symbols = [$($docs_symbols:literal),*],\r\n                        description: $docs_desc:literal,\r\n                        examples: $docs_examples:literal,\r\n                    }\r\n                )?\r\n            }),+\r\n        }\r\n    ) =\u003e {\r\n        #[enum_dispatch::enum_dispatch]\r\n        #[derive(Debug, Clone)]\r\n        pub enum $name\u003c'i\u003e {\r\n            $( $iname($iname\u003c'i\u003e), )+\r\n        }\r\n        impl crate::syntax_tree::traits::IntoOwned for $name\u003c'_\u003e {\r\n            type Owned = $name\u003c'static\u003e;\r\n            fn into_owned(self) -\u003e Self::Owned {\r\n                match self {\r\n                    $(\r\n                        $name::$iname(node) =\u003e $name::$iname(node.into_owned()),\r\n                    )+\r\n                }\r\n            }\r\n        }\r\n        impl\u003c'i\u003e crate::syntax_tree::traits::NodeExt\u003c'i\u003e for $name\u003c'i\u003e {\r\n            fn evaluate(\u0026self, state: \u0026mut crate::State) -\u003e Result\u003cpolyvalue::Value, crate::Error\u003e {\r\n                match self {\r\n                    $(\r\n                        $name::$iname(node) =\u003e node.evaluate(state),\r\n                    )+\r\n                }\r\n            }\r\n            fn token(\u0026self) -\u003e \u0026crate::Token\u003c'i\u003e {\r\n                match self {\r\n                    $(\r\n                        $name::$iname(node) =\u003e node.token(),\r\n                    )+\r\n                }\r\n            }\r\n        }\r\n\r\n        $(\r\n            define_astnode! {\r\n                outer = $name,\r\n                $iname $({$($param: $param_t),*})?,\r\n                build = ($pairsvar, $btokvar, $bstatevar) $build_hnd,\r\n                eval  = ($selfvar, $estatevar) $eval_hnd,\r\n                owned = ($oselfvar) $owned_hnd\r\n                $(,docs  = {\r\n                    name: $docs_name,\r\n                    symbols = [$($docs_symbols),*],\r\n                    description: $docs_desc,\r\n                    examples: $docs_examples,\r\n                })?\r\n            }\r\n        )+\r\n    };\r\n}\r\n\r\nmacro_rules! define_handler {\r\n    ($name:ident ($pairsvar:ident, $btokvar:ident, $bstatevar:ident) $build_hnd:block) =\u003e {\r\n        pub struct $name;\r\n        #[allow(unused_mut)]\r\n        impl\u003c'i\u003e crate::syntax_tree::traits::SyntaxNodeBuilderExt\u003c'i\u003e for $name {\r\n            fn build(mut $pairsvar: crate::syntax_tree::pair::InnerPestIterator\u003c'i\u003e, $btokvar: crate::Token\u003c'i\u003e, $bstatevar: \u0026mut crate::State) -\u003e Result\u003ccrate::syntax_tree::Node\u003c'i\u003e, crate::Error\u003e\r\n            $build_hnd\r\n        }\r\n    };\r\n}\r\n\r\nmacro_rules! as_assignment_target {\r\n    ($value:expr) =\u003e {\r\n        match $value {\r\n            $crate::syntax_tree::Node::Values(node) =\u003e {\r\n                if let $crate::syntax_tree::nodes::Values::Reference(node) = *node {\r\n                    Some(node.target)\r\n                } else {\r\n                    None\r\n                }\r\n            }\r\n            $crate::syntax_tree::Node::Collections(node) =\u003e {\r\n                if let $crate::syntax_tree::nodes::Collections::Array(array) = *node {\r\n                    match array\r\n                        .elements\r\n                        .into_iter()\r\n                        .map(|e| match e {\r\n                            $crate::syntax_tree::Node::Values(node) =\u003e {\r\n                                if let $crate::syntax_tree::nodes::Values::Reference(node) = *node {\r\n                                    Some(node.target)\r\n                                } else {\r\n                                    None\r\n                                }\r\n                            }\r\n                            _ =\u003e None,\r\n                        })\r\n                        .collect::\u003cOption\u003cVec\u003c_\u003e\u003e\u003e()\r\n                    {\r\n                        Some(t) =\u003e Some(AssignmentTarget::Destructure(t)),\r\n                        None =\u003e None,\r\n                    }\r\n                } else {\r\n                    None\r\n                }\r\n            }\r\n            _ =\u003e None,\r\n        }\r\n    };\r\n}\r\n\r\nmacro_rules! as_reference {\r\n    ($value:expr) =\u003e {\r\n        match $value {\r\n            $crate::syntax_tree::Node::Values(node) =\u003e {\r\n                if let $crate::syntax_tree::nodes::Values::Reference(node) = *node {\r\n                    Some(node.target)\r\n                } else {\r\n                    None\r\n                }\r\n            }\r\n            _ =\u003e None,\r\n        }\r\n    };\r\n}\r\n\r\nmacro_rules! unwrap_next {\r\n    ($pairs:expr, $context:expr) =\u003e {\r\n        $pairs.next().unwrap_or_else(|| {\r\n            panic!(\r\n                \"Rule {:?} expected a token; Grammar bug - please report this.\",\r\n                $context.rule,\r\n            )\r\n        })\r\n    };\r\n}\r\n\r\nmacro_rules! unwrap_last {\r\n    ($pairs:expr, $context:expr) =\u003e {\r\n        $pairs.last_child().unwrap_or_else(|| {\r\n            panic!(\r\n                \"Rule {:?} expected a token; Grammar bug - please report this.\",\r\n                $context.rule,\r\n            )\r\n        })\r\n    };\r\n}\r\n\r\nmacro_rules! unwrap_node {\r\n    ($pairs:expr, $state:expr, $context:expr) =\u003e {\r\n        unwrap_next!($pairs, $context)\r\n            .into_node($state)\r\n            .with_context(\u0026$context)\r\n    };\r\n}\r\n","traces":[{"line":28,"address":[],"length":0,"stats":{"Line":940},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":4553},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":4553},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":4553},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":5287},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":5287},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":39},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":8235},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":8235},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":7422},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":7422},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":1880},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":4553},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":4553},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":2490},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":5287},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":5287},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":2556},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":126},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":126},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":20,"coverable":21},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","syntax_tree","mod.rs"],"content":"#[macro_use]\r\nmod macros;\r\n\r\nmod assignment_target;\r\npub mod nodes;\r\nmod pair;\r\nmod pratt;\r\npub mod traits;\r\n\r\npub use assignment_target::AssignmentTarget;\r\npub use nodes::Node;\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","syntax_tree","nodes","arithmetic.rs"],"content":"use super::Node;\r\nuse crate::{\r\n    error::{ErrorDetails, WrapExternalError, WrapOption},\r\n    syntax_tree::{assignment_target::AssignmentTarget, traits::IntoNode},\r\n    Rule,\r\n};\r\nuse polyvalue::{\r\n    operations::{ArithmeticOperation, ArithmeticOperationExt},\r\n    Value,\r\n};\r\n\r\n#[derive(Clone, Debug)]\r\npub enum IncDecType {\r\n    PreI,\r\n    PreD,\r\n    PostI,\r\n    PostD,\r\n}\r\nimpl IncDecType {\r\n    fn is_pre(\u0026self) -\u003e bool {\r\n        matches!(self, Self::PreI | Self::PreD)\r\n    }\r\n    fn operation(\u0026self) -\u003e ArithmeticOperation {\r\n        if matches!(self, Self::PreI | Self::PostI) {\r\n            ArithmeticOperation::Add\r\n        } else {\r\n            ArithmeticOperation::Subtract\r\n        }\r\n    }\r\n}\r\n\r\ndefine_ast!(\r\n    Arithmetic {\r\n        IncDec(target: AssignmentTarget\u003c'i\u003e, variant: IncDecType) {\r\n            build = (pairs, token, state) {\r\n                let (op, value) = if matches!(token.rule, Rule::PREFIX_INC | Rule::PREFIX_DEC) {\r\n                    (unwrap_next!(pairs, token).as_rule(), unwrap_node!(pairs, state, token)?)\r\n                } else {\r\n                    (token.rule, unwrap_node!(pairs, state, token)?)\r\n                };\r\n\r\n                let target = as_reference!(value).or_error(ErrorDetails::ConstantValue).with_context(\u0026token)?;\r\n                let variant = match op {\r\n                    Rule::PREFIX_INC =\u003e IncDecType::PreI,\r\n                    Rule::PREFIX_DEC =\u003e IncDecType::PreD,\r\n                    Rule::POSTFIX_INC =\u003e IncDecType::PostI,\r\n                    _ =\u003e IncDecType::PostD,\r\n                };\r\n\r\n                Ok(Self {\r\n                    target,\r\n                    variant,\r\n                    token,\r\n                }.into())\r\n            },\r\n            eval = (this, state) {\r\n                let value = this.target.get_value(state).with_context(this.token())?;\r\n                let increment = Value::from(1).as_type(value.own_type()).with_context(this.token())?;\r\n                let operation = this.variant.operation();\r\n\r\n                let new_value = value.clone().arithmetic_op(increment, operation)?;\r\n                this.target.update_value(state, new_value.clone()).with_context(this.token())?;\r\n\r\n                if this.variant.is_pre() {\r\n                    Ok(new_value)\r\n                } else {\r\n                    Ok(value)\r\n                }\r\n            },\r\n            owned = (this) {\r\n                Self::Owned {\r\n                    target: this.target.into_owned(),\r\n                    variant: this.variant,\r\n                    token: this.token.into_owned(),\r\n                }\r\n            },\r\n\r\n            docs = {\r\n                name: \"Increment/Decrement\",\r\n                symbols = [\"++\", \"--\"],\r\n                description: \"\r\n                    Increments or decrements a value.\r\n                    If used as a prefix, the value is updated before the expression is evaluated.\r\n                    If used as a postfix, the value is updated after the expression is evaluated.\r\n                \",\r\n                examples: \"\r\n                    a = 1; assert_eq(a++, 1);\r\n                    a = 1; assert_eq(--a, 0);\r\n                \",\r\n            }\r\n        },\r\n\r\n        ArithmeticNeg(value: Node\u003c'i\u003e) {\r\n            build = (pairs, token, state) {\r\n                pairs.next(); // Skip the operator\r\n                let value = unwrap_node!(pairs, state, token)?;\r\n                Ok(Self {\r\n                    value: value,\r\n                    token,\r\n                }\r\n                .into())\r\n            },\r\n            eval = (this, state) {\r\n                let value = this.value.evaluate(state).with_context(this.token())?;\r\n                value.arithmetic_neg().with_context(this.token())\r\n            },\r\n            owned = (this) {\r\n                Self::Owned {\r\n                    value: this.value.into_owned(),\r\n                    token: this.token.into_owned(),\r\n                }\r\n            },\r\n\r\n            docs = {\r\n                name: \"Unary Negation\",\r\n                symbols = [\"-\"],\r\n                description: \"Negates a value.\",\r\n                examples: \"-1\",\r\n            }\r\n        },\r\n\r\n        ArithmeticExpr(lhs: Node\u003c'i\u003e, op: ArithmeticOperation, rhs: Node\u003c'i\u003e) {\r\n            build = (pairs, token, state) {\r\n                let lhs = unwrap_node!(pairs, state, token)?;\r\n\r\n                let op = unwrap_next!(pairs, token);\r\n                let op = match op.as_rule() {\r\n                    Rule::OP_ADD =\u003e ArithmeticOperation::Add,\r\n                    Rule::OP_SUB =\u003e ArithmeticOperation::Subtract,\r\n                    Rule::OP_POW =\u003e ArithmeticOperation::Exponentiate,\r\n                    Rule::OP_DIV =\u003e ArithmeticOperation::Divide,\r\n                    Rule::OP_MOD =\u003e ArithmeticOperation::Modulo,\r\n                    Rule::OP_MUL =\u003e ArithmeticOperation::Multiply,\r\n                    _ =\u003e {\r\n                        return oops!(\r\n                            Internal {\r\n                                msg: format!(\"Unrecognize arithmetic operator {}\", op.as_str())\r\n                            },\r\n                            token\r\n                        )\r\n                    }\r\n                };\r\n\r\n                let rhs = unwrap_node!(pairs, state, token)?;\r\n\r\n                Ok(Self {\r\n                    lhs: lhs,\r\n                    op,\r\n                    rhs: rhs,\r\n                    token,\r\n                }\r\n                .into())\r\n            },\r\n            eval = (this, state) {\r\n                let lhs = this.lhs.evaluate(state).with_context(this.token())?;\r\n                let rhs = this.rhs.evaluate(state).with_context(this.token())?;\r\n                lhs.arithmetic_op(rhs, this.op).with_context(this.token())\r\n            },\r\n            owned = (this) {\r\n                Self::Owned {\r\n                    lhs: this.lhs.into_owned(),\r\n                    op: this.op,\r\n                    rhs: this.rhs.into_owned(),\r\n                    token: this.token.into_owned(),\r\n                }\r\n            },\r\n\r\n            docs = {\r\n                name: \"Arithmetic Expression\",\r\n                symbols = [\"+\", \"-\", \"*\", \"/\", \"%\", \"**\"],\r\n                description: \"\r\n                    Performs arithmetic operations on two values.\r\n                    All but exponentiation are left-associative.\r\n                \",\r\n                examples: \"\r\n                    1 + 2 / 3\r\n                    2 ** 3\r\n                \",\r\n            }\r\n        }\r\n    }\r\n);\r\n\r\n#[cfg(test)]\r\nmod test {\r\n    use crate::lav;\r\n\r\n    lav!(test_negation(a = -1i64, b = 1i64) r#\"\r\n        a = -1;\r\n        b = -a\r\n    \"#);\r\n\r\n    lav!(test_expr(a = 8i64, b = 0i64, c = 8i64) r#\"\r\n        a = 2 + 3 * 2;\r\n        b = 2 - 4 / 2;\r\n        c = 2 ** 3;\r\n    \"#);\r\n}\r\n","traces":[{"line":20,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":65},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":52},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":54},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":54},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":54},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":328},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":328},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":328},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":127},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":96},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":64},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":328},"fn_name":null}],"covered":29,"coverable":34},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","syntax_tree","nodes","assignment.rs"],"content":"use super::Node;\r\nuse crate::{\r\n    error::{ErrorDetails, WrapExternalError, WrapOption},\r\n    syntax_tree::{\r\n        assignment_target::AssignmentTarget,\r\n        traits::{IntoNode, NodeExt, SyntaxNodeBuilderExt},\r\n    },\r\n    Error, Rule, State,\r\n};\r\nuse polyvalue::{\r\n    operations::{\r\n        ArithmeticOperation, ArithmeticOperationExt, BitwiseOperation, BitwiseOperationExt,\r\n        BooleanOperation, BooleanOperationExt,\r\n    },\r\n    Value,\r\n};\r\n\r\n#[derive(Debug, Clone, Copy)]\r\n#[rustfmt::skip]\r\npub enum AssignmentOperation {\r\n    Add, Sub, Mul, Div, Mod, Pow,\r\n    BitAnd, BitOr, BitXor, BitSl, BitSr,\r\n    And, Or, None\r\n}\r\nimpl AssignmentOperation {\r\n    pub fn is_none(\u0026self) -\u003e bool {\r\n        matches!(self, Self::None)\r\n    }\r\n\r\n    pub fn is_some(\u0026self) -\u003e bool {\r\n        !self.is_none()\r\n    }\r\n\r\n    pub fn apply_to(\r\n        \u0026self,\r\n        state: \u0026mut State,\r\n        target: \u0026AssignmentTarget,\r\n        rhs: Value,\r\n    ) -\u003e Result\u003cValue, Error\u003e {\r\n        let value = if self.is_none() {\r\n            rhs\r\n        } else {\r\n            let lhs = target.get_value(state)?.clone();\r\n            let rhs = rhs.as_type(lhs.own_type())?;\r\n\r\n            match self {\r\n                Self::Add =\u003e lhs.arithmetic_op(rhs, ArithmeticOperation::Add)?,\r\n                Self::Sub =\u003e lhs.arithmetic_op(rhs, ArithmeticOperation::Subtract)?,\r\n                Self::Mul =\u003e lhs.arithmetic_op(rhs, ArithmeticOperation::Multiply)?,\r\n                Self::Div =\u003e lhs.arithmetic_op(rhs, ArithmeticOperation::Divide)?,\r\n                Self::Mod =\u003e lhs.arithmetic_op(rhs, ArithmeticOperation::Modulo)?,\r\n                Self::Pow =\u003e lhs.arithmetic_op(rhs, ArithmeticOperation::Exponentiate)?,\r\n\r\n                Self::BitAnd =\u003e lhs.bitwise_op(rhs, BitwiseOperation::And)?,\r\n                Self::BitOr =\u003e lhs.bitwise_op(rhs, BitwiseOperation::Or)?,\r\n                Self::BitXor =\u003e lhs.bitwise_op(rhs, BitwiseOperation::Xor)?,\r\n                Self::BitSl =\u003e lhs.bitwise_op(rhs, BitwiseOperation::LeftShift)?,\r\n                Self::BitSr =\u003e lhs.bitwise_op(rhs, BitwiseOperation::RightShift)?,\r\n\r\n                Self::And =\u003e lhs.boolean_op(rhs, BooleanOperation::And)?,\r\n                Self::Or =\u003e lhs.boolean_op(rhs, BooleanOperation::Or)?,\r\n\r\n                Self::None =\u003e rhs,\r\n            }\r\n        };\r\n\r\n        target.update_value(state, value.clone())?;\r\n        Ok(value)\r\n    }\r\n\r\n    pub fn apply(\r\n        \u0026self,\r\n        state: \u0026mut State,\r\n        target: \u0026AssignmentTarget,\r\n        rhs: Value,\r\n    ) -\u003e Result\u003cValue, Error\u003e {\r\n        match \u0026target {\r\n            // Assign a single value to multiple targets\r\n            AssignmentTarget::Destructure(targets) if rhs.len() == 1 =\u003e {\r\n                for target in targets {\r\n                    self.apply_to(state, target, rhs.clone())?;\r\n                }\r\n                target.get_value(state)\r\n            }\r\n\r\n            // Assign multiple values to multiple targets\r\n            AssignmentTarget::Destructure(targets) if rhs.len() == targets.len() =\u003e {\r\n                let rhs = rhs.as_a::\u003cVec\u003cValue\u003e\u003e()?;\r\n                for (target, value) in targets.into_iter().zip(rhs) {\r\n                    self.apply_to(state, target, value)?;\r\n                }\r\n                target.get_value(state)\r\n            }\r\n\r\n            // Target count mismatch\r\n            AssignmentTarget::Destructure(targets) =\u003e oops!(DestructuringAssignment {\r\n                expected_length: targets.len(),\r\n                actual_length: rhs.len()\r\n            }),\r\n\r\n            // Assign a single value to a single target\r\n            _ =\u003e self.apply_to(state, \u0026target, rhs),\r\n        }\r\n    }\r\n}\r\nimpl From\u003cRule\u003e for AssignmentOperation {\r\n    fn from(value: Rule) -\u003e Self {\r\n        match value {\r\n            Rule::OP_ASSIGN_ADD =\u003e Self::Add,\r\n            Rule::OP_ASSIGN_SUB =\u003e Self::Sub,\r\n            Rule::OP_ASSIGN_POW =\u003e Self::Pow,\r\n            Rule::OP_ASSIGN_MUL =\u003e Self::Mul,\r\n            Rule::OP_ASSIGN_DIV =\u003e Self::Div,\r\n            Rule::OP_ASSIGN_MOD =\u003e Self::Mod,\r\n            Rule::OP_BASSIGN_AND =\u003e Self::And,\r\n            Rule::OP_BASSIGN_OR =\u003e Self::Or,\r\n            Rule::OP_ASSIGN_AND =\u003e Self::BitAnd,\r\n            Rule::OP_ASSIGN_XOR =\u003e Self::BitXor,\r\n            Rule::OP_ASSIGN_OR =\u003e Self::BitOr,\r\n            Rule::OP_ASSIGN_SL =\u003e Self::BitSl,\r\n            Rule::OP_ASSIGN_SR =\u003e Self::BitSr,\r\n            _ =\u003e Self::None,\r\n        }\r\n    }\r\n}\r\n\r\ndefine_ast!(\r\n    Assignment {\r\n        DeleteExpression(target: AssignmentTarget\u003c'i\u003e) {\r\n            build = (pairs, token, state) {\r\n                let op = unwrap_next!(pairs, token);\r\n                let is_decorator = op.as_str().ends_with('@');\r\n                let target = unwrap_next!(pairs, token);\r\n\r\n                let target = target.into_node(state).with_context(\u0026token)?;\r\n                let mut target = as_assignment_target!(target).or_error(ErrorDetails::ConstantValue).with_context(\u0026token)?;\r\n\r\n                match target {\r\n                    AssignmentTarget::Identifier(ref mut id) =\u003e {\r\n                        if is_decorator {\r\n                            *id = format!(\"@{id}\");\r\n                        }\r\n                    }\r\n                    _ if is_decorator =\u003e {\r\n                        return oops!(\r\n                            DecoratorName {\r\n                                name: target.to_string()\r\n                            },\r\n                            token\r\n                        );\r\n                    }\r\n                    _ =\u003e {}\r\n                }\r\n\r\n                Ok(Self { target, token }.into())\r\n            },\r\n            eval = (this, state) {\r\n                this.target.delete(state).with_context(this.token())\r\n            },\r\n            owned = (this) {\r\n                Self::Owned {\r\n                    target: this.target.into_owned(),\r\n                    token: this.token.into_owned()\r\n                }\r\n            },\r\n            docs = {\r\n                name: \"Deletion Keyword\",\r\n                symbols = [\"del\", \"delete\", \"unset\"],\r\n                description: \"\r\n                    Deletes a value, function, @decorator, or index\r\n                    Will return the value deleted (or the function signature if a function was deleted)\r\n                    Index can be blank to delete the last value in an array, or negative to count from the end\r\n                    Indices can also be a collection to delete multiple values at once\r\n                \",\r\n                examples: \"\r\n                    a = 2; del a        // Deletes the variable a\r\n                    a = [1]; del a[]    // Deletes the last value in the array\r\n\r\n                    // Deletes the key 'test' from an object\r\n                    a = {'test': 1}\r\n                    del a['test']   \r\n\r\n                    a=1;b=2; del [a,b] // Deletes both a and b\r\n        \r\n                    @dec(x) = 2\r\n                    del @dec    // Deletes the decorator\r\n                \",\r\n            }\r\n        },\r\n\r\n        AssignmentExpression(target: AssignmentTarget\u003c'i\u003e, op: AssignmentOperation, rhs: Node\u003c'i\u003e) {\r\n            build = (pairs, token, state) {\r\n\r\n                let lhs = unwrap_next!(pairs, token);\r\n                let lhs = lhs.into_node(state).with_context(\u0026token)?;\r\n                let op = AssignmentOperation::from(unwrap_next!(pairs, token).as_rule());\r\n                let rhs = unwrap_node!(pairs, state, token)?;\r\n\r\n                let target = as_assignment_target!(lhs).or_error(ErrorDetails::ConstantValue).with_context(\u0026token)?;\r\n                Ok(Self { target, op, rhs, token }.into())\r\n            },\r\n            eval = (this, state) {\r\n                let rhs = this.rhs.evaluate(state).with_context(this.token())?;\r\n                this.op.apply(state, \u0026this.target, rhs).with_context(this.token())\r\n            },\r\n            owned = (this) {\r\n                Self::Owned {\r\n                    target: this.target.into_owned(),\r\n                    op: this.op,\r\n                    rhs: this.rhs.into_owned(),\r\n                    token: this.token.into_owned(),\r\n                }\r\n            },\r\n            docs = {\r\n                name: \"Assignment Operator\",\r\n                symbols = [\"=\", \"+=\", \"-=\", \"*=\", \"/=\", \"%=\", \"**=\", \"\u0026=\", \"|=\", \"^=\", \"\u003c\u003c=\", \"\u003e\u003e=\"],\r\n                description: \"\r\n                    Assigns a value to a variable, index, or destructuring assignment\r\n                    Target is either a literal with optional indices, or a destructuring assignment\r\n                    If an index is empty, a new value will be appended to the array\r\n                    If the target is a destructuring assignment, the value must be a collection of the same length\r\n                    If the operator is present, the value will be transformed before assignment\r\n\r\n                    Operators:\r\n                    - Arithmetic: `+=, -=, *=, /=, %=, **=`\r\n                    - Bitwise: `\u0026=, |=, ^=, \u003c\u003c=, \u003e\u003e=`\r\n                    - Boolean: `\u0026\u0026=, ||=`\r\n\r\n                    Note: Operators are not supported for destructuring assignments\r\n                \",\r\n                examples: \"\r\n                    [a, b] = [1, 2]     // Destructuring assignment\r\n                    a = 1; a += 1       // Arithmetic assignment\r\n                    a = [1]; a[] = 2    // Array index assignment (appends to array)\r\n                \",\r\n            }\r\n        }\r\n    }\r\n);\r\n\r\n#[cfg(test)]\r\nmod test {\r\n    use crate::lav;\r\n\r\n    lav!(test_del_ident r#\"\r\n        a=1; del a\r\n    \"#);\r\n\r\n    lav!(test_del_const(Error) r#\"\r\n        del 1\r\n    \"#);\r\n\r\n    lav!(test_del_const_arr(Error) r#\"\r\n        a=1; del [a,1]\r\n    \"#);\r\n\r\n    lav!(test_del_const_idx(Error) r#\"\r\n        a=1; del a[1]\r\n    \"#);\r\n\r\n    lav!(test_assign_ops r#\"\r\n        a=1; a+=1; assert_eq(a, 2)\r\n        b=1; b-=1; assert_eq(b, 0)\r\n        c=1; c*=2; assert_eq(c, 2)\r\n        d=4; d/=2; assert_eq(d, 2)\r\n        ee=4; ee%=2; assert_eq(ee, 0)\r\n        f=2; f**=3; assert_eq(f, 8)\r\n        g=2; g\u0026=3; assert_eq(g, 2)\r\n        h=2; h|=3; assert_eq(h, 3)\r\n        i=2; i^=3; assert_eq(i, 1)\r\n        j=2; j\u003c\u003c=3; assert_eq(j, 16)\r\n        k=2; k\u003e\u003e=3; assert_eq(k, 0)\r\n        l=true ; l\u0026\u0026=false; assert_eq(l, false)\r\n        m=true ; m||=false; assert_eq(m, true)\r\n    \"#);\r\n\r\n    lav!(test_assign_destructure r#\"\r\n        [a, b] = [1, [1,2]]\r\n        assert_eq(a, 1)\r\n        assert_eq(b, [1,2])\r\n\r\n        a = 1; b = 2;\r\n        [a, b] = [1, 1]\r\n        assert_eq(a, 1)\r\n        assert_eq(b, 1)\r\n        \r\n        [a, b] = 1\r\n        assert_eq(a, 1)\r\n        assert_eq(b, 1)\r\n    \"#);\r\n\r\n    lav!(test_assign_destructure_error(Error) r#\"\r\n        [a, b] = [1, 2, 3]\r\n    \"#);\r\n\r\n    lav!(test_buggy_push r#\"\r\n        save = {'choices':[]}; choice = 5\r\n        save['choices'].push(choice)\r\n        assert_eq(save['choices'], [5])\r\n    \"#);\r\n\r\n    lav!(test_assign_idx r#\"\r\n        a = [1, 2, 3]\r\n        a[0] = 2\r\n        assert_eq(a, [2, 2, 3])\r\n\r\n        assert_eq(a[], 3)\r\n        assert_eq(a[-1], 3)\r\n\r\n        a[] = [[[3]]]\r\n        assert_eq(a[][][0][], 3)\r\n    \"#);\r\n\r\n    lav!(test_assign_idx_error(Error) r#\"\r\n        a = [1, 2, 3]\r\n        a[4] = 2\r\n    \"#);\r\n\r\n    lav!(test_assign_idx_error2(Error) r#\"\r\n        a = [1, 2, 3]\r\n        a[0][1] = [1, 2]\r\n    \"#);\r\n}\r\n","traces":[{"line":26,"address":[],"length":0,"stats":{"Line":379},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":547},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":379},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":758},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":211},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":336},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":168},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":149},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":377},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":365},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":353},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":438},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":438},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":73},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":335},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":46},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":46},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":46},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":46},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":92},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":106},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":44},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":438},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":438},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":876},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":438},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":937},"fn_name":null}],"covered":69,"coverable":79},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","syntax_tree","nodes","bitwise.rs"],"content":"use super::Node;\r\nuse crate::{error::WrapExternalError, syntax_tree::traits::IntoNode, Rule};\r\nuse polyvalue::operations::{BitwiseOperation, BitwiseOperationExt};\r\n\r\ndefine_ast!(Bitwise {\r\n    BitwiseNot(value: Node\u003c'i\u003e) {\r\n        build = (pairs, token, state) {\r\n            pairs.next(); // Skip the operator\r\n            let value = unwrap_node!(pairs, state, token)?;\r\n            Ok(Self {\r\n                value: value,\r\n                token,\r\n            }\r\n            .into())\r\n        },\r\n        eval = (this, state) {\r\n            let value = this.value.evaluate(state).with_context(this.token())?;\r\n            value.bitwise_not().with_context(this.token())\r\n        },\r\n        owned = (this) {\r\n            Self::Owned {\r\n                value: this.value.into_owned(),\r\n                token: this.token.into_owned(),\r\n            }\r\n        },\r\n\r\n        docs = {\r\n            name: \"Unary Bitwise Not\",\r\n            symbols = [\"~\"],\r\n            description: \"\r\n                A prefix operator that performs bitwise NOT on a value.\r\n                The value is first converted to an integer.\r\n                A larger set of bitwise operations are available in the 'bitwise' category of the standard library.\r\n            \",\r\n            examples: \"~5\",\r\n        }\r\n    },\r\n\r\n    BitwiseExpr(lhs: Node\u003c'i\u003e, op: BitwiseOperation, rhs: Node\u003c'i\u003e) {\r\n        build = (pairs, token, state) {\r\n            let lhs = unwrap_node!(pairs, state, token)?;\r\n\r\n            let op = unwrap_next!(pairs, token);\r\n            let op = match op.as_rule() {\r\n                Rule::OP_BIT_OR =\u003e BitwiseOperation::Or,\r\n                Rule::OP_BIT_XOR =\u003e BitwiseOperation::Xor,\r\n                Rule::OP_BIT_AND =\u003e BitwiseOperation::And,\r\n                Rule::OP_BIT_SL =\u003e BitwiseOperation::LeftShift,\r\n                Rule::OP_BIT_SR =\u003e BitwiseOperation::RightShift,\r\n                _ =\u003e {\r\n                    return oops!(\r\n                        Internal {\r\n                            msg: format!(\"Unrecognize bitwise operator {}\", op.as_str())\r\n                        },\r\n                        token\r\n                    )\r\n                }\r\n            };\r\n\r\n            let rhs = unwrap_node!(pairs, state, token)?;\r\n\r\n            Ok(Self {lhs, op, rhs, token}.into())\r\n        },\r\n        eval = (this, state) {\r\n            let lhs = this.lhs.evaluate(state).with_context(this.token())?;\r\n            let rhs = this.rhs.evaluate(state).with_context(this.token())?;\r\n            lhs.bitwise_op(rhs, this.op).with_context(this.token())\r\n        },\r\n        owned = (this) {\r\n            Self::Owned {\r\n                lhs: this.lhs.into_owned(),\r\n                op: this.op,\r\n                rhs: this.rhs.into_owned(),\r\n                token: this.token.into_owned(),\r\n            }\r\n        },\r\n\r\n        docs = {\r\n            name: \"Bitwise\",\r\n            symbols = [\"|\", \"^\", \"\u0026\", \"\u003c\u003c\", \"\u003e\u003e\"],\r\n            description: \"\r\n                A left-associative infix operator that performs bitwise operations on two values.\r\n                Values are first converted to integers.\r\n                Shifts are arithmetic for signed integers and logical for unsigned integers.\r\n                A larger set of bitwise operations are available in the 'bitwise' category of the standard library.\r\n            \",\r\n            examples: \"\r\n                5 | 3 \u0026 3\r\n                5 ^ 3\r\n                5 \u003c\u003c 3 \u003e\u003e 3\r\n            \",\r\n        }\r\n    }\r\n});\r\n","traces":[{"line":7,"address":[],"length":0,"stats":{"Line":44},"fn_name":null},{"line":8,"address":[],"length":0,"stats":{"Line":44},"fn_name":null},{"line":9,"address":[],"length":0,"stats":{"Line":44},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":65},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":65},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":65},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":49},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":65},"fn_name":null}],"covered":12,"coverable":17},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","syntax_tree","nodes","boolean.rs"],"content":"use super::Node;\r\nuse crate::{error::WrapExternalError, syntax_tree::traits::IntoNode, Rule};\r\nuse polyvalue::operations::{BooleanOperation, BooleanOperationExt};\r\n\r\ndefine_ast!(Boolean {\r\n    BooleanNot(value: Node\u003c'i\u003e) {\r\n        build = (pairs, token, state) {\r\n            pairs.next(); // Skip the operator\r\n            let value = unwrap_node!(pairs, state, token)?;\r\n            Ok(Self {\r\n                value,\r\n                token,\r\n            }\r\n            .into())\r\n        },\r\n        eval = (this, state) {\r\n            let value = this.value.evaluate(state).with_context(this.token())?;\r\n            value.boolean_not().with_context(this.token())\r\n        },\r\n        owned = (this) {\r\n            Self::Owned {\r\n                value: this.value.into_owned(),\r\n                token: this.token.into_owned(),\r\n            }\r\n        },\r\n\r\n        docs = {\r\n            name: \"Unary Boolean Not\",\r\n            symbols = [\"not\"],\r\n            description: \"\r\n                Negates a boolean value.\r\n                If the value is not a boolean, it is cooerced to boolean first.\r\n            \",\r\n            examples: \"\r\n                !true == false\r\n                !'test' == false\r\n                !0 == true\r\n            \",\r\n        }\r\n    },\r\n\r\n    BooleanExpr(lhs: Node\u003c'i\u003e, op: BooleanOperation, rhs: Node\u003c'i\u003e) {\r\n        build = (pairs, token, state) {\r\n            let lhs = unwrap_node!(pairs, state, token)?;\r\n\r\n            let op = unwrap_next!(pairs, token);\r\n            let op = match op.as_rule() {\r\n                Rule::OP_BOOL_OR =\u003e BooleanOperation::Or,\r\n                Rule::OP_BOOL_AND =\u003e BooleanOperation::And,\r\n                Rule::OP_BOOL_EQ =\u003e BooleanOperation::EQ,\r\n                Rule::OP_BOOL_NE =\u003e BooleanOperation::NEQ,\r\n                Rule::OP_BOOL_LE =\u003e BooleanOperation::LTE,\r\n                Rule::OP_BOOL_GE =\u003e BooleanOperation::GTE,\r\n                Rule::OP_BOOL_LT =\u003e BooleanOperation::LT,\r\n                Rule::OP_BOOL_GT =\u003e BooleanOperation::GT,\r\n                _ =\u003e {\r\n                    return oops!(\r\n                        Internal {\r\n                            msg: format!(\"Unrecognize boolean operator {}\", op.as_str())\r\n                        },\r\n                        token\r\n                    )\r\n                }\r\n            };\r\n\r\n            let rhs = unwrap_node!(pairs, state, token)?;\r\n\r\n            Ok(Self { lhs, op, rhs, token }.into())\r\n        },\r\n        eval = (this, state) {\r\n            let lhs = this.lhs.evaluate(state).with_context(this.token())?;\r\n\r\n            // Short-circuiting\r\n            if this.op == BooleanOperation::Or \u0026\u0026 lhs.is_truthy() {\r\n                return Ok(true.into())\r\n            } else if this.op == BooleanOperation::And \u0026\u0026 !lhs.is_truthy() {\r\n                return Ok(false.into())\r\n            }\r\n\r\n            let rhs = this.rhs.evaluate(state).with_context(this.token())?;\r\n            lhs.boolean_op(rhs, this.op).with_context(this.token())\r\n        },\r\n        owned = (this) {\r\n            Self::Owned {\r\n                lhs: this.lhs.into_owned(),\r\n                op: this.op,\r\n                rhs: this.rhs.into_owned(),\r\n                token: this.token.into_owned(),\r\n            }\r\n        },\r\n\r\n        docs = {\r\n            name: \"Boolean\",\r\n            symbols = [\"or\", \"and\", \"==\", \"!=\", \"\u003c=\", \"\u003e=\", \"\u003c\", \"\u003e\"],\r\n            description: \"\r\n                Performs an infix boolean comparison between two values.\r\n                Comparisons are weak, meaning that the types of the values are not checked.\r\n                Result are always a boolean value.\r\n                And and Or are short-circuiting.\r\n                All are left-associative.\r\n            \",\r\n            examples: \"\r\n                true || false\r\n                1 \u003c 2\r\n            \",\r\n        }\r\n    }\r\n});\r\n","traces":[{"line":7,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":8,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":9,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":199},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":199},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":199},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":110},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":199},"fn_name":null}],"covered":15,"coverable":20},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","syntax_tree","nodes","collections.rs"],"content":"use super::{values::Reference, Node};\r\nuse crate::{\r\n    error::{ErrorDetails, WrapExternalError, WrapOption},\r\n    syntax_tree::{assignment_target::AssignmentTarget, traits::IntoNode},\r\n    Error, Rule,\r\n};\r\nuse polyvalue::{Value, ValueType};\r\n\r\ndefine_ast!(\r\n    Collections {\r\n        Array(elements: Vec\u003cNode\u003c'i\u003e\u003e) {\r\n            build = (pairs, token, state) {\r\n                pairs.next(); // Skip the bracket\r\n                let elements = pairs\r\n                    .map(|pair| pair.into_node(state))\r\n                    .collect::\u003cResult\u003cVec\u003c_\u003e, _\u003e\u003e().with_context(\u0026token)?;\r\n                Ok(Self { elements, token }.into())\r\n            },\r\n            eval = (this, state) {\r\n                let elements = this\r\n                    .elements\r\n                    .iter()\r\n                    .map(|element| element.evaluate(state))\r\n                    .collect::\u003cResult\u003cVec\u003c_\u003e, _\u003e\u003e().with_context(this.token())?;\r\n                Ok(Value::array(elements))\r\n            },\r\n            owned = (this) {\r\n                Self::Owned {\r\n                    elements: this.elements.into_iter().map(|e| e.into_owned()).collect(),\r\n                    token: this.token.into_owned(),\r\n                }\r\n            },\r\n\r\n            docs = {\r\n                name: \"Array Literals\",\r\n                symbols = [\"[ a, b, ... ]\"],\r\n                description: \"\r\n                    A collection of values.\r\n                    Arrays can contain any type of value, including other arrays.\r\n                    Arrays are 0-indexed, meaning the first element is at index 0.\r\n                    The indexing operator (a[b]) can be used to access elements of an array.\r\n                \",\r\n                examples: \"\r\n                    [1, 2, 3, 4, 5]\r\n                    [\\\"Hello\\\", \\\"World\\\"]\r\n                    [1, [2, 3], 4]\r\n                \",\r\n            }\r\n        },\r\n\r\n        Object(entries: Vec\u003c(Node\u003c'i\u003e, Node\u003c'i\u003e)\u003e) {\r\n            build = (pairs, token, state) {\r\n                let mut entries: Vec\u003c(_, _)\u003e = Vec::new();\r\n                while let Some(key) = pairs.next() {\r\n                    let key = key.into_node(state).with_context(\u0026token)?;\r\n                    let value = unwrap_node!(pairs, state, token)?;\r\n                    entries.push((key, value));\r\n                }\r\n\r\n                Ok(Self { entries, token }.into())\r\n            },\r\n            eval = (this, state) {\r\n                let values = this.entries.iter()\r\n                    .map(|(key, value)| Ok::\u003c(_, _), Error\u003e((key.evaluate(state).with_context(this.token())?, value.evaluate(state).with_context(this.token())?)))\r\n                    .collect::\u003cResult\u003cVec\u003c(_, _)\u003e, _\u003e\u003e().with_context(this.token())?;\r\n                Value::try_from(values).with_context(this.token())\r\n            },\r\n            owned = (this) {\r\n                Self::Owned {\r\n                    entries: this.entries.into_iter().map(|(k, v)| (k.into_owned(), v.into_owned())).collect(),\r\n                    token: this.token.into_owned(),\r\n                }\r\n            },\r\n\r\n            docs = {\r\n                name: \"Object Literals\",\r\n                symbols = [\"{ key: value, ... }\"],\r\n                description: \"\r\n                    A collection of key-value pairs.\r\n                    Values can contain any type, including other objects.\r\n                    Keys can be any non-collection type\r\n                    The indexing operator (a[b]) can be used to access elements of an object.\r\n                \",\r\n                examples: \"\r\n                    { \\\"name\\\": \\\"John\\\", \\\"age\\\": 25 }\r\n                    { \\\"name\\\": \\\"John\\\", \\\"address\\\": { \\\"city\\\": \\\"New York\\\", \\\"state\\\": \\\"NY\\\" } }\r\n                \",\r\n            }\r\n        },\r\n\r\n        Range(\r\n            start: Node\u003c'i\u003e,\r\n            end: Node\u003c'i\u003e\r\n        ) {\r\n            build = (pairs, token, state) {\r\n                let start = unwrap_node!(pairs, state, token)?;\r\n                pairs.next(); // Skip the '..'\r\n                let end = unwrap_node!(pairs, state, token)?;\r\n                Ok(Self { start, end, token }.into())\r\n            },\r\n\r\n            eval = (this, state) {\r\n                let start = this.start.evaluate(state).with_context(this.token())?;\r\n                let end = this.end.evaluate(state).with_context(this.token())?;\r\n\r\n                let (start, end) = start.resolve(end).with_context(this.token())?;\r\n                match start.own_type() {\r\n                    ValueType::String =\u003e {\r\n                        let start = start.as_a::\u003cString\u003e()?;\r\n                        let end = end.as_a::\u003cString\u003e()?;\r\n                        if start.len() != 1 || end.len() != 1 {\r\n                            return oops!(\r\n                                InvalidRange {\r\n                                    start: start.to_string(),\r\n                                    end: end.to_string()\r\n                                },\r\n                                this.token.clone()\r\n                            );\r\n                        }\r\n\r\n                        let start = start.chars().next().unwrap();\r\n                        let end = end.chars().next().unwrap();\r\n\r\n                        if start \u003e end {\r\n                            return oops!(\r\n                                RangeStartGT {\r\n                                    start: start.to_string(),\r\n                                    end: end.to_string()\r\n                                },\r\n                                this.token.clone()\r\n                            );\r\n                        }\r\n\r\n                        // as array spanning the range inclusively\r\n                        let array = (start..=end)\r\n                            .map(|i| Value::from(i.to_string()))\r\n                            .collect::\u003cVec\u003c_\u003e\u003e();\r\n                        Ok(Value::from(array))\r\n                    }\r\n\r\n                    _ if start.is_a(ValueType::Int) =\u003e {\r\n                        let start = start.as_a::\u003ci64\u003e()?;\r\n                        let end = end.as_a::\u003ci64\u003e()?;\r\n\r\n                        if start \u003e end {\r\n                            return oops!(\r\n                                RangeStartGT {\r\n                                    start: start.to_string(),\r\n                                    end: end.to_string()\r\n                                },\r\n                                this.token.clone()\r\n                            );\r\n                        }\r\n\r\n                        Ok(Value::range(start..=end))\r\n                    }\r\n\r\n                    _ =\u003e {\r\n                        oops!(RangeTypeMismatch, this.token.clone())\r\n                    }\r\n                }\r\n            },\r\n\r\n            owned = (this) {\r\n                Self::Owned {\r\n                    start: this.start.into_owned(),\r\n                    end: this.end.into_owned(),\r\n                    token: this.token.into_owned(),\r\n                }\r\n            },\r\n\r\n            docs = {\r\n                name: \"Range Literals\",\r\n                symbols = [\"first..last\"],\r\n                description: \"\r\n                    A range of values.\r\n                    Ranges can be used to create arrays of numbers or characters.\r\n                    Ranges are inclusive, meaning the start and end values are included in the array.\r\n                    Start and end values must be of the same type, and start must be \u003c= end.\r\n                    Character ranges are inclusive and can only be used with single-character strings.\r\n                \",\r\n                examples: \"\r\n                    1..5\r\n                    'a'..'z'\r\n                \",\r\n            }\r\n        },\r\n\r\n        IndexingExpression(base: Node\u003c'i\u003e, indices: Vec\u003cOption\u003cNode\u003c'i\u003e\u003e\u003e) {\r\n            build = (pairs, token, state) {\r\n                let base = unwrap_node!(pairs, state, token)?;\r\n                let indices = unwrap_next!(pairs, token);\r\n                let indices = indices\r\n                    .map(|pair| {\r\n                    if pair.as_rule() == Rule::POSTFIX_EMPTYINDEX {\r\n                        Ok::\u003c_, Error\u003e(None)\r\n                    } else {\r\n                        Ok(Some(pair.into_node(state).with_context(\u0026token)?))\r\n                    }\r\n                })\r\n                .collect::\u003cResult\u003cVec\u003c_\u003e, _\u003e\u003e().with_context(\u0026token)?;\r\n\r\n                let is_reference = match base {\r\n                    Node::Values(ref node) =\u003e match \u0026**node {\r\n                        super::Values::Reference(_) =\u003e true,\r\n                        _ =\u003e false,\r\n\r\n                    },\r\n                    _ =\u003e false,\r\n                };\r\n\r\n                if is_reference {\r\n                    let target = as_reference!(base).or_error(ErrorDetails::ConstantValue).with_context(\u0026token)?;\r\n                    Ok(Reference::new(AssignmentTarget::Index(target.to_string(), indices), token).into())\r\n                } else {\r\n                    Ok(Self { base, indices, token }.into())\r\n                }\r\n            },\r\n\r\n            eval = (this, state) {\r\n                let base = this.base.evaluate(state).with_context(this.token())?;\r\n                let indices = this\r\n                    .indices\r\n                    .iter()\r\n                    .map(|index| {\r\n                        if let Some(index) = index {\r\n                            Ok::\u003c_, Error\u003e(Some(index.evaluate(state).with_context(this.token())?))\r\n                        } else {\r\n                            Ok(None)\r\n                        }\r\n                    })\r\n                    .collect::\u003cResult\u003cVec\u003c_\u003e, _\u003e\u003e().with_context(this.token())?;\r\n                let value = AssignmentTarget::get_index_handle(base, \u0026indices).with_context(this.token())?;\r\n                Ok(value.clone())\r\n            },\r\n\r\n            owned = (this) {\r\n                Self::Owned {\r\n                    base: this.base.into_owned(),\r\n                    indices: this.indices.into_iter().map(|i| i.map(|i| i.into_owned())).collect(),\r\n                    token: this.token.into_owned(),\r\n                }\r\n            },\r\n\r\n            docs = {\r\n                name: \"Indexing\",\r\n                symbols = [\"a[b]\", \"a[]\"],\r\n                description: \"\r\n                    Accessing elements of a collection.\r\n                    The indexing operator can be used to access elements of a collection or string.\r\n                    If the index is a collection, it is used to access multiple elements.\r\n                    If the index is a string, it is used to access a character.\r\n                    If the index is blank, it is used to access the last element of the collection.\r\n                    Negative indices can be used to access elements from the end of the collection.\r\n                \",\r\n                examples: \"\r\n                    [1, 2, 3][0]\r\n                    [1, 2, 3][0..1]\r\n                    { \\\"name\\\": \\\"John\\\", \\\"age\\\": 25 }[\\\"name\\\"]\r\n                \",\r\n            }\r\n        }\r\n    }\r\n);\r\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":1132},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":1132},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":2264},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":3927},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":1132},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":1362},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":337},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":45},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":45},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":235},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":95},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":95},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":95},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":45},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":213},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":77},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":77},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":77},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":1383},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":225},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":225},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":225},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":275},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":275},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":34},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":241},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":225},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":207},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":207},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":621},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":38},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":18},"fn_name":null}],"covered":37,"coverable":41},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","syntax_tree","nodes","conditionals.rs"],"content":"use super::Node;\r\nuse crate::{\r\n    error::{ErrorDetails, WrapExternalError},\r\n    functions::{ParserFunction, UserDefinedFunction},\r\n    syntax_tree::traits::{IntoNode, IntoOwned},\r\n    Error, Rule, Token,\r\n};\r\nuse polyvalue::{\r\n    types::{Object, Range},\r\n    Value, ValueTrait, ValueType,\r\n};\r\n\r\ndefine_ast!(\r\n    Conditionals {\r\n        IfExpression(\r\n            condition: Node\u003c'i\u003e,\r\n            then_branch: Node\u003c'i\u003e,\r\n            else_branch: Node\u003c'i\u003e\r\n        ) {\r\n            build = (pairs, token, state) {\r\n                if pairs.len() % 2 == 0 {\r\n                    // We parse as a set of (if, then) pairs ending with an else\r\n                    // if the number of children is even, we have no else\r\n                    return oops!(NoElseBlock, token.clone());\r\n                }\r\n\r\n                // We will begin at the end, the final right-side expression\r\n                // Then we will work backwards, grabbing pairs of expressions\r\n                // And turning them into ternary expressions with the previous\r\n                // iteration as the false side until we run out of children\r\n                let mut else_branch = unwrap_last!(pairs, token).into_node(state).with_context(\u0026token)?;\r\n                while pairs.peek().is_some() {\r\n                    let then_branch = unwrap_last!(pairs, token).into_node(state).with_context(\u0026token)?;\r\n                    let condition = unwrap_last!(pairs, token).into_node(state).with_context(\u0026token)?;\r\n\r\n                    else_branch = Self {\r\n                        condition,\r\n                        then_branch,\r\n                        else_branch,\r\n                        token: token.clone(),\r\n                    }.into();\r\n                }\r\n\r\n                Ok(else_branch)\r\n            },\r\n            eval = (this, state) {\r\n                let condition = this.condition.evaluate(state).with_context(this.token())?;\r\n                state.scope_into().with_context(this.token())?;\r\n                let result = if condition.is_truthy() {\r\n                    this.then_branch.evaluate(state)\r\n                } else {\r\n                    this.else_branch.evaluate(state)\r\n                };\r\n\r\n                state.scope_out();\r\n                result\r\n            },\r\n            owned = (this) {\r\n                Self::Owned {\r\n                    condition: this.condition.into_owned(),\r\n                    then_branch: this.then_branch.into_owned(),\r\n                    else_branch: this.else_branch.into_owned(),\r\n                    token: this.token.into_owned(),\r\n                }\r\n            },\r\n\r\n            docs = {\r\n                name: \"If\",\r\n                symbols = [\"if \u003ccondition\u003e then \u003cblock\u003e else \u003cblock\u003e\", \"if \u003ccondition\u003e {block} else {block}\"],\r\n                description: \"\r\n                    A conditional expression that evaluates a condition and then one of two branches.\r\n                    body can be either a block or a single expression. The last expression is returned from a block.\r\n                    Since all expressions in lavendeux return a value, the if expression will return the value of the branch that is executed.\r\n                    As such, all if expressions must have both a then and an else branch.\r\n                    If a condition doesn't need to return a value (side-effect `if`s for example), use `nil`\r\n                \",\r\n                examples: \"\r\n                    a = 6\r\n                    if a \u003e 5 { a } else { 5 }\r\n                    if a == 4 {\r\n                        a\r\n                    } else if a == 5 {\r\n                        5\r\n                    } else nil\r\n                \",\r\n            }\r\n        },\r\n\r\n        SwitchExpression(\r\n            match_on: Node\u003c'i\u003e,\r\n            cases: Vec\u003cSwitchCase\u003c'i\u003e\u003e\r\n        ) {\r\n            build = (pairs, token, state) {\r\n                let match_on = unwrap_node!(pairs, state, token)?;\r\n                let mut cases = vec![];\r\n\r\n                while let Some(case) = pairs.next()  {\r\n                    let body = unwrap_node!(pairs, state, token)?;\r\n\r\n                    if case.as_str() == \"_\" {\r\n                        cases.push(SwitchCase::Default(body));\r\n                        if pairs.next().is_some() {\r\n                            return oops!(UnreachableSwitchCase, token);\r\n                        }\r\n\r\n                        break;\r\n                    } else {\r\n                        cases.push(SwitchCase::Case(case.into_node(state).with_context(\u0026token)?, body));\r\n                    }\r\n                }\r\n\r\n                Ok(Self {\r\n                    match_on,\r\n                    cases,\r\n                    token,\r\n                }.into())\r\n            },\r\n            eval = (this, state) {\r\n                let match_on = this.match_on.evaluate(state).with_context(this.token())?;\r\n\r\n                for case in \u0026this.cases {\r\n                    match case {\r\n                        SwitchCase::Default(body) =\u003e {\r\n                            state.scope_into().with_context(this.token())?;\r\n                            let result = body.evaluate(state);\r\n\r\n                            state.scope_out();\r\n                            return result;\r\n                        },\r\n\r\n                        SwitchCase::Case(value, body) =\u003e {\r\n                            let value = value.evaluate(state).with_context(this.token())?;\r\n\r\n                            if value.own_type() != match_on.own_type() {\r\n                                return oops!(SwitchCaseTypeMismatch {\r\n                                    case: value,\r\n                                    expected_type: match_on.own_type()\r\n                                }, this.token.clone());\r\n                            }\r\n\r\n                            if value == match_on {\r\n                                state.scope_into().with_context(this.token())?;\r\n                                let result = body.evaluate(state);\r\n\r\n                                state.scope_out();\r\n                                return result;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                oops!(NonExhaustiveSwitch, this.token.clone())\r\n            },\r\n            owned = (this) {\r\n                Self::Owned {\r\n                    match_on: this.match_on.into_owned(),\r\n                    cases: this.cases.into_iter().map(|c| c.into_owned()).collect(),\r\n                    token: this.token.into_owned(),\r\n                }\r\n            },\r\n            docs = {\r\n                name: \"match\",\r\n                symbols = [\"match \u003cvalue\u003e { \u003ccondition\u003e =\u003e \u003cblock\u003e, _ =\u003e \u003cblock\u003e }\"],\r\n                description: \"\r\n                    A conditional expression that evaluates a value and then one of several cases.\r\n                    match blocks must be exhaustive, and therefore must end in a default case\r\n                \",\r\n                examples: \"\r\n                    a = 6\r\n                    match a {\r\n                        5 =\u003e { 'five' },\r\n                        6 =\u003e { 'six' },\r\n                        _ =\u003e { 'other' }\r\n                    }\r\n                \",\r\n            }\r\n        }\r\n    }\r\n);\r\n\r\n#[derive(Debug, Clone)]\r\npub enum SwitchCase\u003c'i\u003e {\r\n    Default(Node\u003c'i\u003e),\r\n    Case(Node\u003c'i\u003e, Node\u003c'i\u003e),\r\n}\r\nimpl IntoOwned for SwitchCase\u003c'_\u003e {\r\n    type Owned = SwitchCase\u003c'static\u003e;\r\n    fn into_owned(self) -\u003e Self::Owned {\r\n        match self {\r\n            Self::Default(node) =\u003e Self::Owned::Default(node.into_owned()),\r\n            Self::Case(condition, body) =\u003e {\r\n                Self::Owned::Case(condition.into_owned(), body.into_owned())\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ndefine_handler!(\r\n    TernaryExpression(pairs, token, state) {\r\n        let condition = unwrap_node!(pairs, state, token)?;\r\n\r\n        let mut then_pair = unwrap_next!(pairs, token);\r\n        let then_branch = unwrap_node!(then_pair, state, token)?;\r\n        let else_branch = unwrap_node!(pairs, state, token)?;\r\n\r\n        Ok(IfExpression {\r\n            condition: condition,\r\n            then_branch: then_branch,\r\n            else_branch: else_branch,\r\n            token,\r\n        }.into())\r\n    }\r\n);\r\ndocument_operator!(\r\n    name = \"Ternary\",\r\n    rules = [],\r\n    symbols = [\"condition ? then : else\"],\r\n    description = \"\r\n        A right-associative ternary operator.\r\n        The condition is evaluated first, then either the then or else branch is evaluated.\r\n    \",\r\n    examples = \"true ? 1 : 2\",\r\n);\r\n","traces":[{"line":20,"address":[],"length":0,"stats":{"Line":93},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":93},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":92},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":277},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":370},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":185},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":185},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":185},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":185},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":185},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":185},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":185},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":92},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":167},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":80},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":142},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":75},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":75},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":75},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":67},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":67},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":65},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":65},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":65},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":65},"fn_name":null}],"covered":37,"coverable":39},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","syntax_tree","nodes","core.rs"],"content":"use crate::{\r\n    error::WrapExternalError,\r\n    syntax_tree::{pratt, traits::IntoNode},\r\n    Token,\r\n};\r\n\r\nuse super::Node;\r\nuse polyvalue::Value;\r\n\r\ndefine_ast!(\r\n    Core {\r\n        Script(statements: Vec\u003cNode\u003c'i\u003e\u003e) {\r\n            build = (pairs, token, state) {\r\n                let statements = pairs\r\n                    .map(|pair| pair.into_node(state))\r\n                    .collect::\u003cResult\u003cVec\u003c_\u003e, _\u003e\u003e()?;\r\n                let node = Self { statements, token };\r\n                Ok(node.into())\r\n            },\r\n            eval = (this, state) {\r\n                Ok(\r\n                    Value::array(\r\n                        this.statements\r\n                            .iter()\r\n                            .map(|s| s.evaluate(state))\r\n                            .collect::\u003cResult\u003cVec\u003c_\u003e, _\u003e\u003e()?\r\n                    )\r\n                )\r\n            },\r\n            owned = (this) {\r\n                Self::Owned {\r\n                    statements: this.statements\r\n                        .into_iter()\r\n                        .map(|s| s.into_owned())\r\n                        .collect(),\r\n                    token: this.token.into_owned(),\r\n                }\r\n            },\r\n            docs = {\r\n                name: \"Script\",\r\n                symbols = [\"\u003cstatement\u003e [ ; | \\\\n ] \u003cstatement\u003e\"],\r\n                description: \"\r\n                    A series of expressions or function definitions that are executed in order, and are separated by semicolons or linebreaks.\r\n                \",\r\n                examples: \"\r\n                    1 + 2 ; 3 @hex\r\n                    min([1, 2, 3])\r\n                \",\r\n            }\r\n        },\r\n\r\n        Block(statements: Vec\u003cNode\u003c'i\u003e\u003e) {\r\n            build = (pairs, token, state) {\r\n                let statements = pairs\r\n                    .map(|pair| pair.into_node(state))\r\n                    .collect::\u003cResult\u003cVec\u003c_\u003e, _\u003e\u003e()?;\r\n\r\n                if statements.is_empty() {\r\n                    return oops!(EmptyBlock, token);\r\n                }\r\n\r\n                let node = Self { statements, token };\r\n                Ok(node.into())\r\n            },\r\n            eval = (this, state) {\r\n                let mut value = None;\r\n                for statement in \u0026this.statements {\r\n                    value = Some(statement.evaluate(state)?);\r\n                }\r\n                Ok(value.unwrap_or_else(|| Value::from(false)))\r\n            },\r\n            owned = (this) {\r\n                Self::Owned {\r\n                    statements: this.statements\r\n                        .into_iter()\r\n                        .map(|s| s.into_owned())\r\n                        .collect(),\r\n                    token: this.token.into_owned(),\r\n                }\r\n            },\r\n            docs = {\r\n                name: \"Block\",\r\n                symbols = [\"{ \u003cstatements\u003e }\"],\r\n                description: \"\r\n                    A series of expressions that are executed in order, and are separated by semicolons or linebreaks.\r\n                    The last statement's value is returned.\r\n                    A block must return a value, and thus cannot be empty.\r\n                    If a block doesn't need to return a value (side-effect `if`s for example), use `nil`\r\n                \",\r\n                examples: \"\r\n                    if true {\r\n                        1; 2\r\n                    } else nil\r\n                \",\r\n            }\r\n        }\r\n    }\r\n);\r\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":206},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":409},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":978},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":209},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":562},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":789},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":1578},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":3164},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":789},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":789},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":789},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":1556},"fn_name":null}],"covered":12,"coverable":15},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","syntax_tree","nodes","functions.rs"],"content":"use super::Node;\r\nuse crate::{\r\n    error::{ErrorDetails, WrapExternalError},\r\n    functions::{ParserFunction, UserDefinedFunction},\r\n    syntax_tree::traits::IntoNode,\r\n    Error, Rule, Token,\r\n};\r\nuse polyvalue::{Value, ValueType};\r\n\r\ndefine_ast!(\r\n    Functions {\r\n        KeywordReturn(value: Node\u003c'i\u003e) {\r\n            build = (pairs, token, state) {\r\n                let value = unwrap_node!(pairs, state, token)?;\r\n                Ok(Self { value, token }.into())\r\n            },\r\n            eval = (this, state) {\r\n                let value = this.value.evaluate(state).with_context(this.token())?;\r\n                oops!(Return { value }, this.token().clone())\r\n            },\r\n            owned = (this) {\r\n                Self::Owned {\r\n                    value: this.value.into_owned(),\r\n                    token: this.token.into_owned(),\r\n                }\r\n            },\r\n            docs = {\r\n                name: \"Return\",\r\n                symbols = [\"return \u003cvalue\u003e\"],\r\n                description: \"\r\n                    Returns a value from a function.\r\n                    By default, the last expression is returned, unless a return statement is used.\r\n                \",\r\n                examples: \"\r\n                    a() = { return 5 ; 2 }\r\n                    b() = { 5 ; 2 }\r\n                    \r\n                    assert_eq( a(), 5 )\r\n                    assert_eq( b(), 2 )\r\n                \",\r\n            }\r\n        },\r\n\r\n        FunctionCall(name: String, arguments: Vec\u003cNode\u003c'i\u003e\u003e) {\r\n            build = (pairs, token, state) {\r\n                let lhs = unwrap_next!(pairs, token); // Function name, or the first argument of an object mode call\r\n                let mut rhs = unwrap_next!(\r\n                    unwrap_next!(pairs, token),\r\n                    token\r\n                ); // Arguments, or function name and arguments in object mode\r\n\r\n                let mut node = match rhs.as_rule() {\r\n                    Rule::POSTFIX_NORMALMODE =\u003e {\r\n                        let name = lhs.as_str().to_string();\r\n                        let arguments = if \u0026name == \"help\" {\r\n                            match rhs.next() {\r\n                                Some(arg) =\u003e vec![Node::Literal(Value::from(arg.as_str().to_string()), token.clone())],\r\n                                None =\u003e Vec::new(),\r\n                            }\r\n                        } else {\r\n                            rhs.map(|p| p.into_node(state)).collect::\u003cResult\u003cVec\u003c_\u003e, _\u003e\u003e().with_context(\u0026token)?\r\n                        };\r\n\r\n                        Self { name, arguments, token }\r\n                    }\r\n\r\n                    // Rule::POSTFIX_OBJECTMODE\r\n                    _ =\u003e {\r\n                        let mut rhs = rhs;\r\n                        let name = unwrap_next!(rhs, token).as_str().to_string();\r\n\r\n                        let rhs = unwrap_next!(rhs, token);\r\n                        let arguments = vec![lhs.into_node(state)] // First argument\r\n                            .into_iter()\r\n                            .chain(rhs.map(|p| p.into_node(state)))\r\n                            .collect::\u003cResult\u003cVec\u003c_\u003e, _\u003e\u003e().with_context(\u0026token)?;\r\n\r\n                        Self { name, arguments, token }\r\n                    }\r\n                };\r\n\r\n                Ok(node.into())\r\n            },\r\n            eval = (this, state) {\r\n                if \u0026this.name == \"help\" {\r\n                    let filter = match this.arguments.first() {\r\n                        Some(n) =\u003e Some(n.evaluate(state).with_context(this.token())?.to_string()),\r\n                        None =\u003e None\r\n                    };\r\n\r\n                    let help_text = state.help(filter);\r\n                    return Ok(Value::from(help_text));\r\n                }\r\n\r\n                // Collect arguments\r\n                let mut arguments = Vec::new();\r\n                for argument in this.arguments.iter() {\r\n                    arguments.push(argument.evaluate(state).with_context(this.token())?);\r\n                }\r\n\r\n                // Update reference argument\r\n                let reference = this.arguments.first().and_then(|arg1| {\r\n                    as_reference!(arg1.clone())\r\n                });\r\n\r\n                let value = match state.call_function(\u0026this.name, arguments, reference.as_ref()) {\r\n                    Ok(value) =\u003e value,\r\n                    Err(e) =\u003e {\r\n                        if let ErrorDetails::Return { value, .. } = e.details {\r\n                            value\r\n                        } else {\r\n                            return Err(ErrorDetails::FunctionCall { name: this.name.clone() })\r\n                            .with_context(this.token())\r\n                            .with_source(e)\r\n                        }\r\n                    },\r\n                };\r\n\r\n                Ok(value)\r\n            },\r\n            owned = (this) {\r\n                Self::Owned {\r\n                    name: this.name,\r\n                    arguments: this.arguments\r\n                        .into_iter()\r\n                        .map(|s| s.into_owned())\r\n                        .collect(),\r\n                    token: this.token.into_owned(),\r\n                }\r\n            },\r\n\r\n            docs = {\r\n                name: \"Function Call\",\r\n                symbols = [\"name(arg1, arg2, ...)\", \"arg1.func(arg2, arg3, ...)\"],\r\n                description: \"\r\n                    Calls a function with the given arguments.\r\n                    The help() will list all available functions, and can filter by category or function name.\r\n\r\n                    Functions can be called as `name(arg1, arg2, ...)` or `arg1.func(arg2, arg3, ...)`.\r\n                    Some stdlib functions such as `push`, `pop`, etc take the 1st argument as a reference.\r\n                    In every other case, all arguments are passed by value.\r\n                \",\r\n                examples: \"\r\n                    arr = []\r\n                    push(arr, 3)\r\n                    arr.push(3)\r\n                    help(push)\r\n                    help(collections)\r\n                \",\r\n            }\r\n        }\r\n    }\r\n);\r\n\r\ndefine_handler!(\r\n    FunctionDefinition(pairs, token, state) {\r\n        let name = unwrap_next!(pairs, token).as_str().to_string();\r\n        let src = pairs.last_child().unwrap().as_str().to_string();\r\n\r\n        let mut returns = match pairs.peek_last() {\r\n            Some(p) if p.as_rule() == Rule::function_typespec =\u003e {\r\n                let t = pairs.last_child().unwrap().last_child().unwrap();\r\n                let t = t.as_str();\r\n                ValueType::try_from(t).with_context(\u0026token)?\r\n            },\r\n            _ =\u003e ValueType::Any\r\n        };\r\n\r\n        let arguments = pairs.map(|arg| {\r\n            let mut arg = arg;\r\n            let name = unwrap_next!(arg, token).as_str().to_string();\r\n            let t = match arg.next() {\r\n                Some(t) =\u003e {\r\n                    let t = t.as_str();\r\n                    ValueType::try_from(t).with_context(\u0026token)?\r\n                }\r\n                None =\u003e ValueType::Any\r\n            };\r\n            Ok((name, t))\r\n        }).collect::\u003cResult\u003cVec\u003c_\u003e, Error\u003e\u003e().with_context(\u0026token)?;\r\n\r\n        // Make sure decorators follow the `@name(in): string` signature\r\n        if name.starts_with('@') {\r\n            if arguments.len() != 1 {\r\n                return Err(ErrorDetails::DecoratorSignatureArgs { name: name.clone() })\r\n                .with_context(\u0026token);\r\n            } else if returns != ValueType::Any {\r\n                return Err(ErrorDetails::DecoratorSignatureReturn { name: name.clone() })\r\n                .with_context(\u0026token);\r\n            }\r\n\r\n            returns = ValueType::String;\r\n        }\r\n\r\n        let mut function = UserDefinedFunction::new(\u0026name, src.clone(), state).with_context(\u0026token)?;\r\n        function.set_returns(returns);\r\n      //  function.set_src_line_offset(token.line);\r\n\r\n        for (name, t) in arguments.iter() {\r\n            function.add_arg(name, *t);\r\n        }\r\n\r\n        let sig = function.signature();\r\n        state.register_function(function).with_context(\u0026token)?;\r\n        Ok(Node::Literal(Value::from(sig), token))\r\n    }\r\n);\r\ndocument_operator!(\r\n    name = \"Function Assignment\",\r\n    rules = [],\r\n    symbols = [\"name([arg1:type, arg2, ...]) = { ... }\"],\r\n    description = \"\r\n        Assigns a block of code to a function name.\r\n        The function can be called later in the code.\r\n        If the function name begins with `@`, it is a decorator and must take in one argument and return a string\r\n\r\n        Function body can be a block of code or a single expression. The last expression is returned, unless a return statement is used.\r\n        Return type or argued types can be specified with `: type`, but are optional.\r\n\r\n        Arguments will be cooerced to the specified type if provided, as will the return value.\r\n        Valid type names are: `u[8-64]`, `i[8-64]`, `float`, `int`, `numeric`, `string`, `array`, `object`, `bool`, `any`.\r\n    \",\r\n    examples = \"\r\n        // Decorator taking in a number and returning a string\r\n        @double(x:numeric) = 2*x\r\n        5 @double\r\n\r\n        // Takes in any 2 numeric values, and returns an integer (i64 by default)\r\n        add(a:numeric, b:numeric): int = {\r\n            a + b\r\n        }\r\n        add(3, 4.5)\r\n    \",\r\n);\r\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":1166},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":1166},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":1166},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":2332},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":1126},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":1126},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":3047},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":40},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":80},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":40},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":80},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":40},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":83},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":40},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":808},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":1401},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":1061},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":76},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":152},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":76},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":152},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":40},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":75},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":129},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":53},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":106},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":106},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":50},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":53},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":152},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":106},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":53},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":76},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":76},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":76},"fn_name":null}],"covered":45,"coverable":54},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","syntax_tree","nodes","iterators.rs"],"content":"use super::Node;\r\nuse crate::{\r\n    error::{ErrorDetails, WrapExternalError},\r\n    functions::{ParserFunction, UserDefinedFunction},\r\n    pest::NodeExt,\r\n    syntax_tree::traits::IntoNode,\r\n    Error, Rule, Token,\r\n};\r\nuse polyvalue::{\r\n    types::{Object, Range},\r\n    Value, ValueTrait, ValueType,\r\n};\r\n\r\ndefine_ast!(\r\n    Iterators {\r\n        KeywordContinue() {\r\n            build = (_pairs, token, _state) {\r\n                Ok(Self { token }.into())\r\n            },\r\n            eval = (this, _state) {\r\n                oops!(Skip, this.token.clone())\r\n            },\r\n            owned = (this) {\r\n                Self::Owned { token: this.token.into_owned() }\r\n            },\r\n            docs = {\r\n                name: \"Continue\",\r\n                symbols = [\"continue\"],\r\n                description: \"Skips the current iteration of a loop\",\r\n                examples: \"\r\n                    for i in 0..10 { if i == 5 { continue } else {i} } \r\n                \",\r\n            }\r\n        },\r\n\r\n        KeywordBreak() {\r\n            build = (_pairs, token, _state) {\r\n                Ok(Self { token }.into())\r\n            },\r\n            eval = (this, _state) {\r\n                oops!(Break, this.token.clone())\r\n            },\r\n            owned = (this) {\r\n                Self::Owned { token: this.token.into_owned() }\r\n            },\r\n            docs = {\r\n                name: \"Break\",\r\n                symbols = [\"break\"],\r\n                description: \"Breaks out of a loop\",\r\n                examples: \"\r\n                    for i in 0..10 { if i == 5 { break } else {i} }\r\n                \",\r\n            }\r\n        },\r\n\r\n        ForLoopExpression(\r\n            variable: Option\u003cString\u003e,\r\n            iterable: Node\u003c'i\u003e,\r\n            body: Node\u003c'i\u003e,\r\n            condition: Option\u003cNode\u003c'i\u003e\u003e\r\n        ) {\r\n            build = (pairs, token, state) {\r\n                let condition = match pairs.peek_last() {\r\n                    Some(p) if p.as_rule() == Rule::for_conditional =\u003e {\r\n                        Some(\r\n                            unwrap_node!(\r\n                                unwrap_last!(pairs, token),\r\n                                state,\r\n                                token\r\n                            )?\r\n                        )\r\n                    },\r\n                    _ =\u003e None,\r\n                };\r\n\r\n                let body = pairs.last_child().unwrap().into_node(state).with_context(\u0026token)?;\r\n                let iterable = pairs.last_child().unwrap().into_node(state).with_context(\u0026token)?;\r\n                let variable = pairs.last_child().map(|p| p.as_str().to_string());\r\n\r\n                Ok(Self { variable, iterable, body, condition, token }.into())\r\n            },\r\n\r\n            eval = (this, state) {\r\n                let iterable = this.iterable.evaluate(state).with_context(this.token())?;\r\n                match iterable.own_type() {\r\n                    ValueType::Range =\u003e {\r\n                        let iterable = iterable.as_a::\u003cRange\u003e().with_context(this.token())?.into_inner();\r\n                        let values = iterable.into_iter().map(|i| {\r\n                            state.check_timer()?;\r\n                            Ok::\u003c_, Error\u003e(Value::from(i))\r\n                        }).collect::\u003cResult\u003cVec\u003c_\u003e, _\u003e\u003e().with_context(this.token())?;\r\n                        iterate_over(values.into_iter(), state, this)\r\n                    },\r\n\r\n                    ValueType::Object =\u003e {\r\n                        let iterable = iterable.as_a::\u003cObject\u003e().with_context(this.token())?;\r\n                        let iterable = iterable.keys().into_iter().cloned();\r\n                        iterate_over(iterable, state, this)\r\n                    },\r\n\r\n                    _ =\u003e {\r\n                        let iterable = iterable.as_a::\u003cVec\u003cValue\u003e\u003e().with_context(this.token())?;\r\n                        iterate_over(iterable.into_iter(), state, this)\r\n                    }\r\n                }\r\n            },\r\n\r\n            owned = (this) {\r\n                Self::Owned {\r\n                    variable: this.variable,\r\n                    iterable: this.iterable.into_owned(),\r\n                    body: this.body.into_owned(),\r\n                    condition: this.condition.map(|c| c.into_owned()),\r\n                    token: this.token.into_owned(),\r\n                }\r\n            },\r\n\r\n            docs = {\r\n                name: \"For\",\r\n                symbols = [\"for \u003cvariable\u003e in \u003citerable\u003e { \u003cblock\u003e }\", \"for [\u003cvariable\u003e in] \u003citerable\u003e do \u003cblock\u003e [if \u003ccondition\u003e]\"],\r\n                description: \"\r\n                    For loops are finite value iterators. This means they map over a range, array, or object, \r\n                    and return a new array of values.\r\n                    The variable is optional, and if not provided, the loop will not bind a variable.\r\n                    The expression will return an array of the results of the block.\r\n                    Break and skip/continue can be used to exit the loop or skip the current iteration.\r\n                    A condition can be provided to filter the loop.\r\n                \",\r\n                examples: \"\r\n                    for i in 0..10 { i }\r\n                    for i in [1, 2, 3] { i }\r\n                    for i in {'a': 1, 'b': 2} { i }\r\n        \r\n                    for a in 0..10 do a if a % 2 == 0\r\n        \r\n                    for 0..10 do '!'\r\n                \",\r\n            }\r\n        }\r\n    }\r\n);\r\n\r\nfn iterate_over(\r\n    iterable: impl Iterator\u003cItem = Value\u003e,\r\n    state: \u0026mut crate::State,\r\n    this: \u0026ForLoopExpression,\r\n) -\u003e Result\u003cValue, Error\u003e {\r\n    let mut result = vec![];\r\n    for v in iterable {\r\n        state.check_timer().with_context(this.token())?; // Potentially long-running operation\r\n\r\n        state.scope_into().with_context(this.token())?;\r\n        if let Some(variable) = \u0026this.variable {\r\n            state.set_variable(variable, v);\r\n        }\r\n        if let Some(condition) = \u0026this.condition {\r\n            let condition = condition.evaluate(state).with_context(this.token());\r\n            match condition {\r\n                Ok(condition) if !condition.is_truthy() =\u003e {\r\n                    state.scope_out();\r\n                    continue;\r\n                }\r\n                Err(e) =\u003e {\r\n                    state.scope_out();\r\n                    return Err(e);\r\n                }\r\n                _ =\u003e {}\r\n            }\r\n        }\r\n\r\n        let value = this.body.evaluate(state);\r\n        state.scope_out();\r\n        match value {\r\n            Ok(value) =\u003e result.push(value),\r\n            Err(e) if error_matches!(e, Skip) =\u003e {}\r\n            Err(e) if error_matches!(e, Break) =\u003e {\r\n                break;\r\n            }\r\n\r\n            Err(e) =\u003e {\r\n                return Err(e);\r\n            }\r\n        }\r\n    }\r\n\r\n    Ok(Value::array(result))\r\n}\r\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":112},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":224},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":116},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":108},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":112},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":112},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":84},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":74},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":74},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":74},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":74},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":73},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":73},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":696},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":314},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":570},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":328},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":308},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":308},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":288},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":50},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":70},"fn_name":null}],"covered":38,"coverable":45},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","syntax_tree","nodes","literals.rs"],"content":"use super::{Node, Token};\r\nuse crate::{error::WrapExternalError, Rule};\r\nuse polyvalue::{types::*, Value};\r\nuse std::str::FromStr;\r\n\r\ndefine_handler!(\r\n    IntLiteral(pairs, token, _state) {\r\n        let literal = unwrap_next!(pairs, token);\r\n        let str = literal.as_str();\r\n        let size = pairs\r\n            .next()\r\n            .map(|v| v.as_rule());\r\n\r\n        let value = match size {\r\n            Some(Rule::intsize_i32) =\u003e I32::from_str(str).with_context(\u0026token)?.into(),\r\n            Some(Rule::intsize_i16) =\u003e I16::from_str(str).with_context(\u0026token)?.into(),\r\n            Some(Rule::intsize_i8) =\u003e I8::from_str(str).with_context(\u0026token)?.into(),\r\n            Some(Rule::intsize_u64) =\u003e U64::from_str(str).with_context(\u0026token)?.into(),\r\n            Some(Rule::intsize_u32) =\u003e U32::from_str(str).with_context(\u0026token)?.into(),\r\n            Some(Rule::intsize_u16) =\u003e U16::from_str(str).with_context(\u0026token)?.into(),\r\n            Some(Rule::intsize_u8) =\u003e U8::from_str(str).with_context(\u0026token)?.into(),\r\n            _ =\u003e I64::from_str(str).with_context(\u0026token)?.into()\r\n        };\r\n\r\n        Ok(Node::Literal(value, token))\r\n    }\r\n);\r\n\r\ndefine_handler!(\r\n    FloatLiteral(_pairs, token, _state) {\r\n        let value: Value = Float::from_str(\u0026token.input).with_context(\u0026token)?.into();\r\n        Ok(Node::Literal(value, token))\r\n    }\r\n);\r\n\r\ndefine_handler!(\r\n    StringLiteral(_pairs, token, _state) {\r\n        // Remove the first and last characters - the quotes around our string\r\n        // This would not work great with graphemes like , but we know that it's\r\n        // either ' or \" so this should be safe\r\n        let mut c = token.input.chars();\r\n        c.next();\r\n        c.next_back();\r\n\r\n        // Now we split along our \\\\ backslash escapes, and rejoin after\r\n        // to prevent going over them twice. This method isn't super\r\n        // neat, there's likely a better way\r\n        let mut out = String::new();\r\n        let mut await_escape = false;\r\n        for char in c {\r\n            match char {\r\n                '\\\\' =\u003e {\r\n                    if await_escape {\r\n                        out.push('\\\\');\r\n                        await_escape = false;\r\n                    } else {\r\n                        await_escape = true;\r\n                    }\r\n                }\r\n                _ =\u003e {\r\n                    if await_escape {\r\n                        out.push(match char {\r\n                            '\\'' =\u003e '\\'',\r\n                            '\"' =\u003e '\"',\r\n                            'n' =\u003e '\\n',\r\n                            'r' =\u003e '\\r',\r\n                            't' =\u003e '\\t',\r\n                            _ =\u003e char,\r\n                        });\r\n                        await_escape = false;\r\n                    } else {\r\n                        out.push(char);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        Ok(Node::Literal(Value::string(out), token))\r\n    }\r\n);\r\n\r\ndefine_handler!(\r\n    BoolLiteral(_pairs, token, _state) {\r\n        let value = Bool::from_str(\u0026token.input).with_context(\u0026token)?;\r\n        Ok(Node::Literal(Value::bool(value), token))\r\n    }\r\n);\r\n\r\ndefine_handler!(\r\n    RegexLiteral(_pairs, token, _state) {\r\n        Ok(Node::Literal(Value::string(token.input.as_ref()), token))\r\n    }\r\n);\r\n\r\ndefine_handler!(\r\n    FixedLiteral(_pairs, token, _state) {\r\n        // remove the D suffix first\r\n        let input = \u0026token.input[..token.input.len() - 1];\r\n\r\n        let value = Fixed::from_str(input).with_context(\u0026token)?;\r\n        Ok(Node::Literal(Value::fixed(value), token))\r\n    }\r\n);\r\n\r\ndefine_handler!(\r\n    CurrencyLiteral(_pairs, token, _state) {\r\n        let value = Currency::from_str(\u0026token.input).with_context(\u0026token)?;\r\n        Ok(Node::Literal(Value::currency(value), token))\r\n    }\r\n);\r\n\r\ndefine_handler!(\r\n    ConstLiteral(_pairs, token, _state) {\r\n        let value = match token.input.as_ref() {\r\n            \"pi\" =\u003e Value::from(std::f64::consts::PI),\r\n            \"e\" =\u003e Value::from(std::f64::consts::E),\r\n            \"tau\" =\u003e Value::from(std::f64::consts::TAU),\r\n            \"nil\" =\u003e Value::from(false),\r\n\r\n            _ =\u003e {\r\n                return oops!(Internal {\r\n                    msg: format!(\"Unexpected const literal\")\r\n                }, token);\r\n            }\r\n        };\r\n        Ok(Node::Literal(value, token))\r\n    }\r\n);\r\ndocument_operator!(\r\n    name = \"Constants\",\r\n    rules = [],\r\n    symbols = [\"pi\", \"e\", \"tau\", \"nil\"],\r\n    description = \"\r\n        A constant value.\r\n        A predefined set of values that are always available.\r\n\r\n        - `pi` - The mathematical constant \r\n        - `e` - The mathematical constant e\r\n        - `tau` - The mathematical constant \r\n        - `nil` - The nil value - used to represent nothing or an empty value, especially in the context of a side-effect conditional\r\n    \",\r\n    examples = \"\r\n        pi; e; tau; nil\r\n    \",\r\n);\r\n","traces":[{"line":7,"address":[],"length":0,"stats":{"Line":2435},"fn_name":null},{"line":8,"address":[],"length":0,"stats":{"Line":2435},"fn_name":null},{"line":9,"address":[],"length":0,"stats":{"Line":2435},"fn_name":null},{"line":10,"address":[],"length":0,"stats":{"Line":2435},"fn_name":null},{"line":11,"address":[],"length":0,"stats":{"Line":2435},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":4980},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":2545},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":68},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":46},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":4662},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":92},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":184},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":613},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":613},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":613},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":613},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":613},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":613},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":7811},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":52},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":44},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":3551},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":40},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":40},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":3511},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":613},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":198},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":396},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":34},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":44},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":53,"coverable":57},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","syntax_tree","nodes","values.rs"],"content":"use super::Node;\r\nuse crate::{\r\n    error::WrapExternalError,\r\n    syntax_tree::{assignment_target::AssignmentTarget, traits::IntoNode},\r\n    Error, Rule, State, Token,\r\n};\r\nuse polyvalue::{\r\n    operations::{MatchingOperation, MatchingOperationExt},\r\n    Value, ValueType,\r\n};\r\n\r\ndefine_handler!(\r\n    Identifier(_pairs, token, _state) {\r\n        let name = token.input.to_string();\r\n        Ok(Reference::new(AssignmentTarget::Identifier(name), token).into())\r\n    }\r\n);\r\ndocument_operator!(\r\n    name = \"Identifier\",\r\n    rules = [],\r\n    symbols = [\"a\", \"b\", \"c\"],\r\n    description = \"\r\n        A variable name.\r\n        The value of the variable is looked up in the state.\r\n    \",\r\n    examples = \"\r\n        [a, b, c] = [1, 2, 3]\r\n        a; b; c\r\n    \",\r\n);\r\n\r\ndefine_ast!(\r\n    Values {\r\n        Reference(target: AssignmentTarget\u003c'i\u003e) {\r\n            build = (_pairs, token, _state) {\r\n                oops!(Internal {\r\n                    msg: \"Reference node should not be built directly\".to_string()\r\n                }, token)\r\n            },\r\n\r\n            eval = (this, state) {\r\n                Ok(this.target.get_value(state).with_context(this.token())?)\r\n            },\r\n\r\n            owned = (this) {\r\n                Self::Owned {\r\n                    target: this.target.into_owned(),\r\n                    token: this.token.into_owned(),\r\n                }\r\n            }\r\n        },\r\n\r\n        CastExpression(value: Node\u003c'i\u003e, target: Node\u003c'i\u003e) {\r\n            build = (pairs, token, state) {\r\n                let mut pairs = pairs;\r\n                let value = unwrap_node!(pairs, state, token)?;\r\n                pairs.next(); // skip the operator\r\n                let target = unwrap_node!(pairs, state, token)?;\r\n\r\n                Ok(Self {\r\n                    value: value,\r\n                    target: target,\r\n                    token,\r\n                }\r\n                .into())\r\n            },\r\n            eval = (this, state) {\r\n                let value = this.value.evaluate(state).with_context(this.token())?;\r\n                let target = if this.target.token().rule == Rule::identifier {\r\n                    this.target.token().input.to_string()\r\n                } else {\r\n                    this.target.evaluate(state).with_context(this.token())?.to_string()\r\n                };\r\n\r\n                let target = ValueType::try_from(target.as_str()).with_context(this.token())?;\r\n                value.as_type(target).with_context(this.token())\r\n            },\r\n            owned = (this) {\r\n                Self::Owned {\r\n                    value: this.value.into_owned(),\r\n                    target: this.target.into_owned(),\r\n                    token: this.token.into_owned(),\r\n                }\r\n            },\r\n\r\n            docs = {\r\n                name: \"Cast\",\r\n                symbols = [\"as\"],\r\n                description: \"\r\n                    Casts a value to a different type.\r\n                    The type can be a string or an identifier.\r\n                    The operator is right-associative\r\n                \",\r\n                examples: \"\r\n                    5 as float\r\n                    5 as 'float'\r\n                    5 as i8\r\n                \",\r\n            }\r\n        },\r\n\r\n        DecoratorExpression(expression: Node\u003c'i\u003e, decorator: String) {\r\n            build = (pairs, token, state) {\r\n                let mut pairs = pairs;\r\n                let expression = unwrap_node!(pairs, state, token)?;\r\n\r\n                let mut decorator_pair = unwrap_next!(pairs, token);\r\n                let decorator = unwrap_next!(decorator_pair, token).as_str().to_string();\r\n\r\n                Ok(Self {\r\n                    expression: expression,\r\n                    decorator,\r\n                    token,\r\n                }\r\n                .into())\r\n            },\r\n            eval = (this, state) {\r\n                let value = this.expression.evaluate(state).with_context(this.token())?;\r\n                let result = state.decorate(\u0026this.decorator, value).with_context(this.token())?;\r\n                Ok(Value::from(result))\r\n            },\r\n            owned = (this) {\r\n                Self::Owned {\r\n                    expression: this.expression.into_owned(),\r\n                    decorator: this.decorator,\r\n                    token: this.token.into_owned(),\r\n                }\r\n            },\r\n\r\n            docs = {\r\n                name: \"Decorator\",\r\n                symbols = [\"@name\"],\r\n                description: \"\r\n                    Converts a value to a formatted string.\r\n                    It calls a function named '@name' with the value as an argument.\r\n                \",\r\n                examples: \"\r\n                    assert_eq(\r\n                        5 @float,\r\n                        '5.0'\r\n                    )\r\n                \",\r\n            }\r\n        },\r\n\r\n        MatchingExpression(\r\n            left: Node\u003c'i\u003e,\r\n            right: Node\u003c'i\u003e,\r\n            operator: MatchingOperation\r\n        ) {\r\n            build = (pairs, token, state) {\r\n                let mut pairs = pairs;\r\n                let left = unwrap_node!(pairs, state, token)?;\r\n                let operator = unwrap_next!(pairs, token).as_rule();\r\n                let right = unwrap_node!(pairs, state, token)?;\r\n\r\n                let operator = match operator {\r\n                    Rule::OP_MATCH_CONTAINS =\u003e MatchingOperation::Contains,\r\n                    Rule::OP_MATCH_MATCHES =\u003e MatchingOperation::Matches,\r\n                    Rule::OP_MATCH_IS =\u003e MatchingOperation::Is,\r\n                    Rule::OP_MATCH_STARTSWITH =\u003e MatchingOperation::StartsWith,\r\n                    Rule::OP_MATCH_ENDSWITH =\u003e MatchingOperation::EndsWith,\r\n                    _ =\u003e {\r\n                        return oops!(\r\n                            Internal {\r\n                                msg: format!(\"Unrecognize matching operator {operator:?}\")\r\n                            },\r\n                            token\r\n                        )\r\n                    }\r\n                };\r\n\r\n                Ok(Self {\r\n                    left: left,\r\n                    right: right,\r\n                    operator,\r\n                    token,\r\n                }\r\n                .into())\r\n            },\r\n            eval = (this, state) {\r\n                let left = this.left.evaluate(state).with_context(this.token())?;\r\n                let right = if this.operator == MatchingOperation::Is\r\n                    \u0026\u0026 this.right.token().rule == Rule::identifier\r\n                {\r\n                    Value::from(\u0026*this.right.token().input)\r\n                } else {\r\n                    this.right.evaluate(state).with_context(this.token())?\r\n                };\r\n\r\n                Value::matching_op(\u0026left, \u0026right, this.operator).with_context(this.token())\r\n            },\r\n            owned = (this) {\r\n                Self::Owned {\r\n                    left: this.left.into_owned(),\r\n                    right: this.right.into_owned(),\r\n                    operator: this.operator,\r\n                    token: this.token.into_owned(),\r\n                }\r\n            },\r\n\r\n            docs = {\r\n                name: \"Matching\",\r\n                symbols = [\"contains\", \"matches\", \"is\", \"starts_with\", \"ends_with\"],\r\n                description: \"\r\n                    A set of left-associative boolean operators comparing a collection with a pattern\r\n                    'is' is a special case that compares type (`value is string` is equivalent `typeof(value) == 'string'`)\r\n                    starts/ends with are not applicable to objects, which are not ordered\r\n                \",\r\n                examples: \"\r\n                    {'name': 'test'} contains 'name'\r\n                    'hello' matches 'ell'\r\n                    'hello' is string\r\n                    'hello' starts_with 'hel'\r\n                    [1, 2] endswith 2\r\n                \",\r\n            }\r\n        }\r\n    }\r\n);\r\n\r\nimpl\u003c'i\u003e Reference\u003c'i\u003e {\r\n    pub(crate) fn new(target: AssignmentTarget\u003c'i\u003e, token: Token\u003c'i\u003e) -\u003e Reference\u003c'i\u003e {\r\n        Self { target, token }\r\n    }\r\n\r\n    /// Get the reference's value from the state\r\n    pub fn get_value(\u0026self, state: \u0026mut State) -\u003e Result\u003cValue, Error\u003e {\r\n        self.target.get_value(state)\r\n    }\r\n\r\n    /// Get the reference's value from the state\r\n    /// Uses the parent scope (if a function defines a value of the same name)\r\n    pub fn get_value_in_parent(\u0026self, state: \u0026mut State) -\u003e Result\u003cValue, Error\u003e {\r\n        self.target.get_value_in_parent(state)\r\n    }\r\n\r\n    /// Update the reference's value in the state\r\n    pub fn update_value(\u0026self, state: \u0026mut State, value: Value) -\u003e Result\u003c(), Error\u003e {\r\n        self.target.update_value(state, value)\r\n    }\r\n\r\n    /// Update the reference's value in the state\r\n    /// Uses the parent scope (if a function defines a value of the same name)\r\n    pub fn update_value_in_parent(\u0026self, state: \u0026mut State, value: Value) -\u003e Result\u003c(), Error\u003e {\r\n        self.target.update_value_in_parent(state, value)\r\n    }\r\n\r\n    /// Get the reference's value from the state as a mutable reference\r\n    pub fn get_target_mut_in_parent\u003c's\u003e(\r\n        \u0026self,\r\n        state: \u0026's mut State,\r\n    ) -\u003e Result\u003cOption\u003c\u0026's mut Value\u003e, Error\u003e {\r\n        self.target.get_target_mut_in_parent(state)\r\n    }\r\n}\r\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":1952},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":1952},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":1952},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":83},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":83},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":83},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":83},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":99},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":99},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":99},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":99},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":99},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":83},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":2159},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":21,"coverable":42},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","syntax_tree","nodes.rs"],"content":"#![allow(unused_imports)]\r\nuse crate::{error::WrapExternalError, token, Error, Rule, State, Token};\r\nuse pest::iterators::Pair;\r\nuse polyvalue::Value;\r\n\r\nuse super::{\r\n    pair::PestIterator,\r\n    traits::{IntoOwned, NodeExt, SyntaxNodeBuilderExt},\r\n};\r\n\r\nmod assignment;\r\nuse assignment::Assignment;\r\n\r\nmod arithmetic;\r\nuse arithmetic::Arithmetic;\r\n\r\nmod bitwise;\r\nuse bitwise::Bitwise;\r\n\r\nmod boolean;\r\nuse boolean::Boolean;\r\n\r\nmod collections;\r\nuse collections::Collections;\r\n\r\nmod core;\r\nuse core::Core;\r\n\r\nmod functions;\r\nuse functions::Functions;\r\n\r\nmod iterators;\r\n\r\nmod conditionals;\r\nuse conditionals::Conditionals;\r\n\r\nmod values;\r\nuse values::Values;\r\n\r\nmod literals;\r\n\r\n/// Root type for AST nodes, split by class of node\r\n#[derive(Debug, Clone)]\r\npub enum Node\u003c'i\u003e {\r\n    /// Core syntax elements (script and block)\r\n    Core(Box\u003ccore::Core\u003c'i\u003e\u003e),\r\n\r\n    /// Variable storate (identifiers, assignment and deletion)\r\n    Assignment(Box\u003cassignment::Assignment\u003c'i\u003e\u003e),\r\n\r\n    /// Value manipulation (references, decorators, match, cast, etc.)\r\n    Values(Box\u003cvalues::Values\u003c'i\u003e\u003e),\r\n\r\n    /// Collections (arrays, objects, ranges, etc.)\r\n    Collections(Box\u003ccollections::Collections\u003c'i\u003e\u003e),\r\n\r\n    /// Conditional expressions (if, ternary, switch)\r\n    Conditionals(Box\u003cconditionals::Conditionals\u003c'i\u003e\u003e),\r\n\r\n    /// Iterators (for loops)\r\n    Iterators(Box\u003citerators::Iterators\u003c'i\u003e\u003e),\r\n\r\n    /// Function assignment and calling\r\n    Functions(Box\u003cfunctions::Functions\u003c'i\u003e\u003e),\r\n\r\n    /// Arithmetic expressions (add, sub, mul, div, etc.)\r\n    Arithmetic(Box\u003carithmetic::Arithmetic\u003c'i\u003e\u003e),\r\n\r\n    /// Bitwise expressions\r\n    Bitwise(Box\u003cbitwise::Bitwise\u003c'i\u003e\u003e),\r\n\r\n    /// Boolean expressions\r\n    Boolean(Box\u003cboolean::Boolean\u003c'i\u003e\u003e),\r\n\r\n    /// Literal constants\r\n    Literal(Value, Token\u003c'i\u003e),\r\n}\r\nimpl Node\u003c'_\u003e {\r\n    /// The minimum available stack size for the parser\r\n    /// We are guaranteed to have at least this much stack\r\n    pub const MIN_STACK: usize = 1024 * 1024;\r\n\r\n    /// The stack expansion size for the parser\r\n    /// This is the amount of stack to allocate when the parser runs out\r\n    pub const STACK_EXP: usize = 8 * 1024 * 1024;\r\n\r\n    /// This is where rules are matched to node-builder types\r\n    pub fn from_pair\u003c'i\u003e(pair: Pair\u003c'i, Rule\u003e, state: \u0026mut State) -\u003e Result\u003cNode\u003c'i\u003e, Error\u003e {\r\n        let pairs = PestIterator::from(pair);\r\n        Self::from_iterator(pairs, state)\r\n    }\r\n\r\n    pub(crate) fn from_iterator\u003c'i\u003e(\r\n        pairs: PestIterator\u003c'i\u003e,\r\n        state: \u0026mut State,\r\n    ) -\u003e Result\u003cNode\u003c'i\u003e, Error\u003e {\r\n        let (token, pairs) = pairs.decompose();\r\n\r\n        // println!(\"{:#?}\", pairs);\r\n\r\n        stacker::maybe_grow(Node::MIN_STACK, Node::STACK_EXP, || match token.rule {\r\n            //\r\n            // Core nodes\r\n            Rule::SCRIPT =\u003e core::Script::build(pairs, token, state),\r\n            Rule::BLOCK =\u003e core::Block::build(pairs, token, state),\r\n\r\n            //\r\n            // Value Literals\r\n            Rule::int_literal =\u003e literals::IntLiteral::build(pairs, token, state),\r\n            Rule::float_literal | Rule::sci_literal =\u003e {\r\n                literals::FloatLiteral::build(pairs, token, state)\r\n            }\r\n            Rule::string_literal =\u003e literals::StringLiteral::build(pairs, token, state),\r\n            Rule::bool_literal =\u003e literals::BoolLiteral::build(pairs, token, state),\r\n            Rule::regex_literal =\u003e literals::RegexLiteral::build(pairs, token, state),\r\n            Rule::fixed_literal =\u003e literals::FixedLiteral::build(pairs, token, state),\r\n            Rule::currency_literal =\u003e literals::CurrencyLiteral::build(pairs, token, state),\r\n            Rule::const_literal =\u003e literals::ConstLiteral::build(pairs, token, state),\r\n\r\n            //\r\n            // Value expressions\r\n            Rule::identifier =\u003e values::Identifier::build(pairs, token, state),\r\n            Rule::OP_CAST =\u003e values::CastExpression::build(pairs, token, state),\r\n            Rule::POSTFIX_DECORATE =\u003e values::DecoratorExpression::build(pairs, token, state),\r\n\r\n            //\r\n            // Matching expressions\r\n            Rule::OP_MATCH_CONTAINS\r\n            | Rule::OP_MATCH_MATCHES\r\n            | Rule::OP_MATCH_IS\r\n            | Rule::OP_MATCH_STARTSWITH\r\n            | Rule::OP_MATCH_ENDSWITH =\u003e values::MatchingExpression::build(pairs, token, state),\r\n\r\n            //\r\n            // Collection nodes\r\n            Rule::ARRAY_TERM =\u003e collections::Array::build(pairs, token, state),\r\n            Rule::OBJECT_TERM =\u003e collections::Object::build(pairs, token, state),\r\n            Rule::OP_RANGE =\u003e collections::Range::build(pairs, token, state),\r\n            Rule::POSTFIX_INDEX =\u003e collections::IndexingExpression::build(pairs, token, state),\r\n\r\n            //\r\n            // Iterator nodes\r\n            Rule::BREAK_KEYWORD =\u003e iterators::KeywordBreak::build(pairs, token, state),\r\n            Rule::SKIP_KEYWORD =\u003e iterators::KeywordContinue::build(pairs, token, state),\r\n            Rule::FOR_LOOP_EXPRESSION =\u003e iterators::ForLoopExpression::build(pairs, token, state),\r\n\r\n            //\r\n            // Conditional nodes\r\n            Rule::IF_EXPRESSION =\u003e conditionals::IfExpression::build(pairs, token, state),\r\n            Rule::OP_TERNARY =\u003e conditionals::TernaryExpression::build(pairs, token, state),\r\n            Rule::SWITCH_EXPRESSION =\u003e conditionals::SwitchExpression::build(pairs, token, state),\r\n\r\n            //\r\n            // Arithmetic\r\n            Rule::PREFIX_INC | Rule::PREFIX_DEC | Rule::POSTFIX_INC | Rule::POSTFIX_DEC =\u003e {\r\n                arithmetic::IncDec::build(pairs, token, state)\r\n            }\r\n            Rule::PREFIX_NEG =\u003e arithmetic::ArithmeticNeg::build(pairs, token, state),\r\n            Rule::OP_ADD\r\n            | Rule::OP_SUB\r\n            | Rule::OP_POW\r\n            | Rule::OP_DIV\r\n            | Rule::OP_MOD\r\n            | Rule::OP_MUL =\u003e arithmetic::ArithmeticExpr::build(pairs, token, state),\r\n\r\n            //\r\n            // Bitwise\r\n            Rule::PREFIX_BIT_NOT =\u003e bitwise::BitwiseNot::build(pairs, token, state),\r\n            Rule::OP_BIT_OR\r\n            | Rule::OP_BIT_XOR\r\n            | Rule::OP_BIT_AND\r\n            | Rule::OP_BIT_SL\r\n            | Rule::OP_BIT_SR =\u003e bitwise::BitwiseExpr::build(pairs, token, state),\r\n\r\n            //\r\n            // Boolean\r\n            Rule::PREFIX_BOOL_NOT =\u003e boolean::BooleanNot::build(pairs, token, state),\r\n            Rule::OP_BOOL_OR\r\n            | Rule::OP_BOOL_AND\r\n            | Rule::OP_BOOL_EQ\r\n            | Rule::OP_BOOL_NE\r\n            | Rule::OP_BOOL_LE\r\n            | Rule::OP_BOOL_GE\r\n            | Rule::OP_BOOL_LT\r\n            | Rule::OP_BOOL_GT =\u003e boolean::BooleanExpr::build(pairs, token, state),\r\n\r\n            //\r\n            // Functions\r\n            Rule::FUNCTION_ASSIGNMENT_STATEMENT =\u003e {\r\n                functions::FunctionDefinition::build(pairs, token, state)\r\n            }\r\n            Rule::POSTFIX_CALL =\u003e functions::FunctionCall::build(pairs, token, state),\r\n            Rule::RETURN_EXPRESSION =\u003e functions::KeywordReturn::build(pairs, token, state),\r\n\r\n            //\r\n            // Assignment\r\n            Rule::OP_ASSIGN_ADD\r\n            | Rule::OP_ASSIGN_SUB\r\n            | Rule::OP_ASSIGN_POW\r\n            | Rule::OP_ASSIGN_MUL\r\n            | Rule::OP_ASSIGN_DIV\r\n            | Rule::OP_ASSIGN_MOD\r\n            | Rule::OP_ASSIGN_AND\r\n            | Rule::OP_ASSIGN_XOR\r\n            | Rule::OP_ASSIGN_OR\r\n            | Rule::OP_ASSIGN_SL\r\n            | Rule::OP_ASSIGN_SR\r\n            | Rule::OP_BASSIGN_AND\r\n            | Rule::OP_BASSIGN_OR\r\n            | Rule::OP_ASSIGN =\u003e assignment::AssignmentExpression::build(pairs, token, state),\r\n            Rule::PREFIX_DEL =\u003e assignment::DeleteExpression::build(pairs, token, state),\r\n\r\n            //\r\n            // Errors\r\n            Rule::UNTERMINATED_BLOCK_COMMENT =\u003e oops!(UnterminatedComment),\r\n            Rule::UNTERMINATED_STRING_LITERAL =\u003e oops!(UnterminatedLiteral),\r\n            Rule::UNCLOSED_BRACKET =\u003e oops!(UnterminatedArray),\r\n            Rule::UNCLOSED_BRACE =\u003e oops!(UnterminatedObject),\r\n            Rule::UNCLOSED_PAREN =\u003e oops!(UnterminatedParen),\r\n            Rule::MISSING_LINEBREAK =\u003e oops!(UnterminatedLinebreak),\r\n\r\n            _ =\u003e panic!(\"No node builder for rule {:?}\", token.rule),\r\n        })\r\n    }\r\n}\r\nimpl IntoOwned for Node\u003c'_\u003e {\r\n    type Owned = Node\u003c'static\u003e;\r\n    fn into_owned(self) -\u003e Self::Owned {\r\n        match self {\r\n            Self::Core(node) =\u003e Self::Owned::Core(Box::new(node.into_owned())),\r\n            Self::Assignment(node) =\u003e Self::Owned::Assignment(Box::new(node.into_owned())),\r\n            Self::Collections(node) =\u003e Self::Owned::Collections(Box::new(node.into_owned())),\r\n            Self::Values(node) =\u003e Self::Owned::Values(Box::new(node.into_owned())),\r\n            Self::Arithmetic(node) =\u003e Self::Owned::Arithmetic(Box::new(node.into_owned())),\r\n            Self::Functions(node) =\u003e Self::Owned::Functions(Box::new(node.into_owned())),\r\n            Self::Iterators(node) =\u003e Self::Owned::Iterators(Box::new(node.into_owned())),\r\n            Self::Conditionals(node) =\u003e Self::Owned::Conditionals(Box::new(node.into_owned())),\r\n            Self::Bitwise(node) =\u003e Self::Owned::Bitwise(Box::new(node.into_owned())),\r\n            Self::Boolean(node) =\u003e Self::Owned::Boolean(Box::new(node.into_owned())),\r\n            Self::Literal(value, token) =\u003e Self::Owned::Literal(value.clone(), token.into_owned()),\r\n        }\r\n    }\r\n}\r\nimpl\u003c'i\u003e NodeExt\u003c'i\u003e for Node\u003c'i\u003e {\r\n    fn evaluate(\u0026self, state: \u0026mut State) -\u003e Result\u003cValue, Error\u003e {\r\n        stacker::maybe_grow(Node::MIN_STACK, Node::STACK_EXP, || match self {\r\n            Self::Core(node) =\u003e node.evaluate(state),\r\n            Self::Assignment(node) =\u003e node.evaluate(state),\r\n            Self::Collections(node) =\u003e node.evaluate(state),\r\n            Self::Values(node) =\u003e node.evaluate(state),\r\n            Self::Arithmetic(node) =\u003e node.evaluate(state),\r\n            Self::Functions(node) =\u003e node.evaluate(state),\r\n            Self::Iterators(node) =\u003e node.evaluate(state),\r\n            Self::Conditionals(node) =\u003e node.evaluate(state),\r\n            Self::Bitwise(node) =\u003e node.evaluate(state),\r\n            Self::Boolean(node) =\u003e node.evaluate(state),\r\n            Self::Literal(value, ..) =\u003e Ok(value.clone()),\r\n        })\r\n    }\r\n\r\n    fn token(\u0026self) -\u003e \u0026Token\u003c'i\u003e {\r\n        match self {\r\n            Self::Core(node) =\u003e node.token(),\r\n            Self::Assignment(node) =\u003e node.token(),\r\n            Self::Collections(node) =\u003e node.token(),\r\n            Self::Values(node) =\u003e node.token(),\r\n            Self::Arithmetic(node) =\u003e node.token(),\r\n            Self::Functions(node) =\u003e node.token(),\r\n            Self::Iterators(node) =\u003e node.token(),\r\n            Self::Conditionals(node) =\u003e node.token(),\r\n            Self::Bitwise(node) =\u003e node.token(),\r\n            Self::Boolean(node) =\u003e node.token(),\r\n            Self::Literal(.., token) =\u003e token,\r\n        }\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod test {\r\n    use crate::Lavendeux;\r\n\r\n    #[test]\r\n    fn run_lav_selftest() {\r\n        let mut lav = Lavendeux::new(Default::default());\r\n        lav.run(\"example_scripts/self_test.lav\")\r\n            .expect(\"Selftest failed\");\r\n    }\r\n}\r\n","traces":[{"line":88,"address":[],"length":0,"stats":{"Line":514},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":514},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":514},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":10806},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":10806},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":21612},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":206},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":789},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":2435},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":92},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":613},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":198},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":1952},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":83},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":99},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":1132},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":45},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":77},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":225},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":112},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":93},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":65},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":54},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":328},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":44},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":65},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":199},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":76},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":1166},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":438},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":46},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":6652},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":6652},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":762},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":390},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":251},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":1484},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":364},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":632},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":123},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":255},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":101},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":191},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":2099},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":7710},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":15420},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":840},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":387},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":1122},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":1126},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":221},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":828},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":90},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":295},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":357},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":2423},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":127},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":127},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":126},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":72,"coverable":124},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","syntax_tree","pair.rs"],"content":"use crate::{Error, Rule, State, Token};\r\nuse pest::iterators::Pair;\r\nuse std::collections::VecDeque;\r\n\r\nuse super::{pratt, traits::IntoNode, Node};\r\n\r\n#[derive(Clone, Debug)]\r\npub struct PestIterator\u003c'i\u003e {\r\n    token: Token\u003c'i\u003e,\r\n    inner: InnerPestIterator\u003c'i\u003e,\r\n}\r\n\r\n#[allow(dead_code)]\r\nimpl\u003c'i\u003e PestIterator\u003c'i\u003e {\r\n    pub fn from_pair(pair: Pair\u003c'i, Rule\u003e) -\u003e Self {\r\n        match pair.as_rule() {\r\n            Rule::EXPR =\u003e {\r\n                let mut inner = pair.into_inner();\r\n                if inner.len() == 1 {\r\n                    Self::from_pair(inner.next().unwrap())\r\n                } else {\r\n                    pratt::Parser::parse(inner)\r\n                }\r\n            }\r\n            _ =\u003e {\r\n                let token = Token::from(\u0026pair);\r\n                Self {\r\n                    inner: InnerPestIterator::from_pair(pair),\r\n                    token,\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    pub fn from_infix(left: PestIterator\u003c'i\u003e, op: Pair\u003c'i, Rule\u003e, right: PestIterator\u003c'i\u003e) -\u003e Self {\r\n        let mut token = Token::from(\u0026op);\r\n        token.input = format!(\"{} {} {}\", left.as_str(), token.input, right.as_str()).into();\r\n        let inner = InnerPestIterator::from_vec(vec![left, Self::from_pair(op), right]);\r\n        Self { token, inner }\r\n    }\r\n\r\n    pub fn from_prefix(op: Pair\u003c'i, Rule\u003e, right: PestIterator\u003c'i\u003e) -\u003e Self {\r\n        let mut token = Token::from(\u0026op);\r\n        token.input = format!(\"{} {}\", token.input, right.as_str()).into();\r\n        let inner = InnerPestIterator::from_vec(vec![Self::from_pair(op), right]);\r\n        Self { token, inner }\r\n    }\r\n\r\n    pub fn from_postfix(left: PestIterator\u003c'i\u003e, op: Pair\u003c'i, Rule\u003e) -\u003e Self {\r\n        let mut token = Token::from(\u0026op);\r\n        token.input = format!(\"{} {}\", left.as_str(), token.input).into();\r\n        let inner = InnerPestIterator::from_vec(vec![left, Self::from_pair(op)]);\r\n        Self { token, inner }\r\n    }\r\n\r\n    pub fn token(\u0026self) -\u003e \u0026Token\u003c'i\u003e {\r\n        \u0026self.token\r\n    }\r\n\r\n    pub fn next_child(\u0026mut self) -\u003e Option\u003cSelf\u003e {\r\n        self.inner.next_child()\r\n    }\r\n\r\n    pub fn last_child(\u0026mut self) -\u003e Option\u003cSelf\u003e {\r\n        self.inner.last_child()\r\n    }\r\n\r\n    pub fn peek(\u0026self) -\u003e Option\u003c\u0026Self\u003e {\r\n        self.inner.peek()\r\n    }\r\n\r\n    pub fn peek_last(\u0026self) -\u003e Option\u003c\u0026Self\u003e {\r\n        self.inner.peek_last()\r\n    }\r\n\r\n    pub fn as_str(\u0026self) -\u003e \u0026str {\r\n        \u0026self.token.input\r\n    }\r\n\r\n    pub fn as_rule(\u0026self) -\u003e Rule {\r\n        self.token.rule\r\n    }\r\n\r\n    pub fn into_inner(self) -\u003e InnerPestIterator\u003c'i\u003e {\r\n        self.inner\r\n    }\r\n\r\n    pub fn into_token(self) -\u003e Token\u003c'i\u003e {\r\n        self.token\r\n    }\r\n\r\n    pub fn decompose(self) -\u003e (Token\u003c'i\u003e, InnerPestIterator\u003c'i\u003e) {\r\n        (self.token, self.inner)\r\n    }\r\n}\r\n\r\nimpl\u003c'i\u003e IntoNode\u003c'i\u003e for PestIterator\u003c'i\u003e {\r\n    fn into_node(self, state: \u0026mut State) -\u003e Result\u003cNode\u003c'i\u003e, Error\u003e {\r\n        Node::from_iterator(self, state)\r\n    }\r\n}\r\n\r\nimpl\u003c'i\u003e From\u003cPair\u003c'i, Rule\u003e\u003e for PestIterator\u003c'i\u003e {\r\n    fn from(p: Pair\u003c'i, Rule\u003e) -\u003e Self {\r\n        Self::from_pair(p)\r\n    }\r\n}\r\n\r\nimpl\u003c'i\u003e Iterator for PestIterator\u003c'i\u003e {\r\n    type Item = Self;\r\n\r\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\r\n        self.next_child()\r\n    }\r\n}\r\n\r\nimpl\u003c'i\u003e DoubleEndedIterator for PestIterator\u003c'i\u003e {\r\n    fn next_back(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\r\n        self.last_child()\r\n    }\r\n}\r\n\r\nimpl\u003c'i\u003e ExactSizeIterator for PestIterator\u003c'i\u003e {\r\n    fn len(\u0026self) -\u003e usize {\r\n        self.inner.len()\r\n    }\r\n}\r\n\r\n#[derive(Clone, Debug)]\r\npub struct InnerPestIterator\u003c'i\u003e(VecDeque\u003cPestIterator\u003c'i\u003e\u003e);\r\nimpl\u003c'i\u003e InnerPestIterator\u003c'i\u003e {\r\n    pub fn from_pair(pair: Pair\u003c'i, Rule\u003e) -\u003e Self {\r\n        let inner = pair\r\n            .into_inner()\r\n            .filter(|p| !Token::is_symbol(p.as_rule()))\r\n            .map(PestIterator::from)\r\n            .collect();\r\n        Self(inner)\r\n    }\r\n\r\n    pub fn from_vec(pairs: Vec\u003cPestIterator\u003c'i\u003e\u003e) -\u003e Self {\r\n        Self(pairs.into())\r\n    }\r\n\r\n    pub fn next_child(\u0026mut self) -\u003e Option\u003cPestIterator\u003c'i\u003e\u003e {\r\n        self.0.pop_front()\r\n    }\r\n\r\n    pub fn last_child(\u0026mut self) -\u003e Option\u003cPestIterator\u003c'i\u003e\u003e {\r\n        self.0.pop_back()\r\n    }\r\n\r\n    pub fn peek(\u0026self) -\u003e Option\u003c\u0026PestIterator\u003c'i\u003e\u003e {\r\n        self.0.front()\r\n    }\r\n\r\n    pub fn peek_last(\u0026self) -\u003e Option\u003c\u0026PestIterator\u003c'i\u003e\u003e {\r\n        self.0.back()\r\n    }\r\n}\r\n\r\nimpl\u003c'i\u003e Iterator for InnerPestIterator\u003c'i\u003e {\r\n    type Item = PestIterator\u003c'i\u003e;\r\n\r\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\r\n        self.next_child()\r\n    }\r\n}\r\n\r\nimpl\u003c'i\u003e DoubleEndedIterator for InnerPestIterator\u003c'i\u003e {\r\n    fn next_back(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\r\n        self.last_child()\r\n    }\r\n}\r\n\r\nimpl\u003c'i\u003e ExactSizeIterator for InnerPestIterator\u003c'i\u003e {\r\n    fn len(\u0026self) -\u003e usize {\r\n        self.0.len()\r\n    }\r\n}\r\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":26946},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":26946},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":6854},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":6854},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":3934},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":2920},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":20092},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":20092},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":1633},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":1633},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":1633},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":1633},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":206},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":206},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":206},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":206},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":1691},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":1691},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":1691},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":1691},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":5045},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":5045},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":9217},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":9217},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":2844},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":2844},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":10806},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":10806},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":10292},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":10292},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":19482},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":19482},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":5045},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":5045},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":20092},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":20092},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":59879},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":20092},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":20092},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":3530},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":3530},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":24887},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":24887},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":880},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":880},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":277},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":277},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":188},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":188},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":19842},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":19842},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":93},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":93},"fn_name":null}],"covered":55,"coverable":73},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","syntax_tree","pratt.rs"],"content":"use crate::pest::Rule;\r\nuse pest::{\r\n    iterators::Pair,\r\n    pratt_parser::{Assoc, Op, PrattParser},\r\n};\r\n\r\nuse super::pair::PestIterator;\r\n\r\npub struct Parser;\r\nimpl Parser {\r\n    fn get_pratt_parser() -\u003e PrattParser\u003cRule\u003e {\r\n        let mut pratt = PrattParser::new();\r\n        for op_level in PRECEDENCE_MAP {\r\n            let mut r = op_level[0].to_pratt();\r\n            for op in *op_level {\r\n                r = r | op.to_pratt();\r\n            }\r\n            pratt = pratt.op(r);\r\n        }\r\n        pratt\r\n    }\r\n\r\n    pub fn parse\u003c'i, I\u003e(input: I) -\u003e PestIterator\u003c'i\u003e\r\n    where\r\n        I: Iterator\u003cItem = Pair\u003c'i, Rule\u003e\u003e + ExactSizeIterator,\r\n    {\r\n        let pratt = Self::get_pratt_parser();\r\n        let mut pratt = pratt\r\n            .map_primary(PestIterator::from)\r\n            .map_infix(PestIterator::from_infix)\r\n            .map_prefix(PestIterator::from_prefix)\r\n            .map_postfix(PestIterator::from_postfix);\r\n        pratt.parse(input)\r\n    }\r\n}\r\n\r\n#[derive(Clone, Debug)]\r\npub enum PrattOperatorType {\r\n    Prefix,\r\n    Infix,\r\n    Postfix,\r\n}\r\npub struct PrattOperator {\r\n    ty: PrattOperatorType,\r\n    rule: Rule,\r\n    asoc: Assoc,\r\n}\r\n\r\nimpl PrattOperator {\r\n    pub fn to_pratt(\u0026self) -\u003e Op\u003cRule\u003e {\r\n        match self.ty {\r\n            PrattOperatorType::Prefix =\u003e Op::prefix(self.rule),\r\n            PrattOperatorType::Infix =\u003e Op::infix(self.rule, self.asoc),\r\n            PrattOperatorType::Postfix =\u003e Op::postfix(self.rule),\r\n        }\r\n    }\r\n}\r\n\r\nmacro_rules! prefix {\r\n    ($rule:ident) =\u003e {\r\n        PrattOperator {\r\n            ty: PrattOperatorType::Prefix,\r\n            rule: Rule::$rule,\r\n            asoc: Assoc::Left,\r\n        }\r\n    };\r\n}\r\nmacro_rules! infix {\r\n    ($rule:ident, $asso:ident) =\u003e {\r\n        PrattOperator {\r\n            ty: PrattOperatorType::Infix,\r\n            rule: Rule::$rule,\r\n            asoc: Assoc::$asso,\r\n        }\r\n    };\r\n}\r\nmacro_rules! postfix {\r\n    ($rule:ident) =\u003e {\r\n        PrattOperator {\r\n            ty: PrattOperatorType::Postfix,\r\n            rule: Rule::$rule,\r\n            asoc: Assoc::Left,\r\n        }\r\n    };\r\n}\r\n\r\n/// The precedence map for the Pratt parser\r\n/// This is a list of lists of all EXPR operators, where each list is a level of precedence\r\n/// from lowest to highest precedence\r\npub const PRECEDENCE_MAP: \u0026[\u0026[PrattOperator]] = \u0026[\r\n    // Assignment\r\n    \u0026[\r\n        infix!(OP_ASSIGN_ADD, Right),\r\n        infix!(OP_ASSIGN_SUB, Right),\r\n        infix!(OP_ASSIGN_POW, Right),\r\n        infix!(OP_ASSIGN_MUL, Right),\r\n        infix!(OP_ASSIGN_DIV, Right),\r\n        infix!(OP_ASSIGN_MOD, Right),\r\n        infix!(OP_BASSIGN_AND, Right),\r\n        infix!(OP_BASSIGN_OR, Right),\r\n        infix!(OP_ASSIGN_OR, Right),\r\n        infix!(OP_ASSIGN_AND, Right),\r\n        infix!(OP_ASSIGN_XOR, Right),\r\n        infix!(OP_ASSIGN_SL, Right),\r\n        infix!(OP_ASSIGN_SR, Right),\r\n        infix!(OP_ASSIGN, Right),\r\n    ],\r\n    // Delete\r\n    \u0026[prefix!(PREFIX_DEL)],\r\n    // Range, Ternary\r\n    \u0026[infix!(OP_RANGE, Left)],\r\n    \u0026[infix!(OP_TERNARY, Right)],\r\n    // Decorator\r\n    \u0026[postfix!(POSTFIX_DECORATE)],\r\n    //\r\n    // Logical OR, Logical AND\r\n    \u0026[infix!(OP_BOOL_OR, Left)],\r\n    \u0026[infix!(OP_BOOL_AND, Left)],\r\n    //\r\n    // Pattern Matching\r\n    \u0026[\r\n        infix!(OP_MATCH_MATCHES, Left),\r\n        infix!(OP_MATCH_CONTAINS, Left),\r\n        infix!(OP_MATCH_IS, Left),\r\n        infix!(OP_MATCH_STARTSWITH, Left),\r\n        infix!(OP_MATCH_ENDSWITH, Left),\r\n    ],\r\n    //\r\n    // Bitwise OR, Bitwise XOR, Bitwise AND\r\n    \u0026[infix!(OP_BIT_OR, Left)],\r\n    \u0026[infix!(OP_BIT_XOR, Left)],\r\n    \u0026[infix!(OP_BIT_AND, Left)],\r\n    //\r\n    // == and !=, followed by \u003c, \u003c=, \u003e, \u003e=\r\n    \u0026[infix!(OP_BOOL_EQ, Left), infix!(OP_BOOL_NE, Left)],\r\n    \u0026[\r\n        infix!(OP_BOOL_LT, Left),\r\n        infix!(OP_BOOL_LE, Left),\r\n        infix!(OP_BOOL_GT, Left),\r\n        infix!(OP_BOOL_GE, Left),\r\n    ],\r\n    //\r\n    // \u003c\u003c and \u003e\u003e\r\n    \u0026[infix!(OP_BIT_SL, Left), infix!(OP_BIT_SR, Left)],\r\n    //\r\n    // Add and subtract, followed by multiply divide and mod, then pow\r\n    \u0026[infix!(OP_ADD, Left), infix!(OP_SUB, Left)],\r\n    \u0026[\r\n        infix!(OP_MUL, Left),\r\n        infix!(OP_DIV, Left),\r\n        infix!(OP_MOD, Left),\r\n    ],\r\n    \u0026[infix!(OP_POW, Right)],\r\n    //\r\n    // Cast, and prefix operators\r\n    \u0026[\r\n        infix!(OP_CAST, Right),\r\n        prefix!(PREFIX_NEG),\r\n        prefix!(PREFIX_INC),\r\n        prefix!(PREFIX_DEC),\r\n        prefix!(PREFIX_BOOL_NOT),\r\n        prefix!(PREFIX_BIT_NOT),\r\n    ],\r\n    //\r\n    // Postfix operators\r\n    \u0026[\r\n        postfix!(POSTFIX_INC),\r\n        postfix!(POSTFIX_DEC),\r\n        postfix!(POSTFIX_CALL),\r\n        postfix!(POSTFIX_INDEX),\r\n    ],\r\n];\r\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":2920},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":2920},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":113880},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":511000},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":151840},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":55480},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":2920},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":2920},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":2920},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":2920},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":2920},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":2920},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":2920},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":2920},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":2920},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":207320},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":207320},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":20440},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":166440},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":20440},"fn_name":null}],"covered":20,"coverable":20},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","syntax_tree","traits.rs"],"content":"use crate::{Error, State, Token};\r\nuse enum_dispatch::enum_dispatch;\r\nuse polyvalue::Value;\r\n\r\nuse crate::Rule;\r\n\r\nuse super::{nodes::Node, pair::InnerPestIterator};\r\n\r\npub trait IntoOwned {\r\n    type Owned;\r\n    fn into_owned(self) -\u003e Self::Owned;\r\n}\r\n\r\n/// Internal trait for use with the compiler, and AST manipulation\r\n#[enum_dispatch(CoreSyntaxNode)]\r\npub trait NodeExt\u003c'i\u003e\r\nwhere\r\n    Self: IntoOwned,\r\n{\r\n    /// Evaluate this tree\r\n    fn evaluate(\u0026self, state: \u0026mut State) -\u003e Result\u003cValue, Error\u003e;\r\n\r\n    /// Get the token for this node\r\n    fn token(\u0026self) -\u003e \u0026Token\u003c'i\u003e;\r\n}\r\n\r\n/// Tree construction trait\r\npub trait SyntaxNodeBuilderExt\u003c'i\u003e {\r\n    fn build(\r\n        pairs: InnerPestIterator\u003c'i\u003e,\r\n        token: Token\u003c'i\u003e,\r\n        state: \u0026mut State,\r\n    ) -\u003e Result\u003cNode\u003c'i\u003e, Error\u003e;\r\n}\r\n\r\npub trait IntoNode\u003c'i\u003e {\r\n    fn into_node(self, state: \u0026mut State) -\u003e Result\u003cNode\u003c'i\u003e, Error\u003e;\r\n}\r\nimpl\u003c'i\u003e IntoNode\u003c'i\u003e for pest::iterators::Pair\u003c'i, Rule\u003e {\r\n    fn into_node(self, state: \u0026mut State) -\u003e Result\u003cNode\u003c'i\u003e, Error\u003e {\r\n        Node::from_pair(self, state)\r\n    }\r\n}\r\n","traces":[{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":2},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","token.rs"],"content":"use crate::Rule;\r\nuse pest::iterators::Pair;\r\nuse std::borrow::Cow;\r\n\r\n/// A struct representing a token in the syntax tree\r\n/// It stores metadata about the token, such as the rule it was parsed from,\r\n/// the input it was parsed from, and the references to variables it contains\r\n#[derive(Debug, Clone)]\r\npub struct Token\u003c'i\u003e {\r\n    /// Source-code line number\r\n    pub line: usize,\r\n\r\n    /// Grammar-rule that this token was parsed from\r\n    /// See [crate::Rule]\r\n    pub rule: Rule,\r\n\r\n    /// The input that this token was parsed from\r\n    pub input: Cow\u003c'i, str\u003e,\r\n}\r\n\r\nimpl Token\u003c'_\u003e {\r\n    /// Creates a new root token from the input\r\n    pub fn dummy() -\u003e Self {\r\n        Token {\r\n            line: 0,\r\n            rule: Rule::SCRIPT,\r\n            input: Cow::Borrowed(\"\"),\r\n        }\r\n    }\r\n\r\n    /// Check if this token is a symbol\r\n    pub fn is_symbol(rule: Rule) -\u003e bool {\r\n        matches!(\r\n            rule,\r\n            Rule::symbol_questionmark\r\n                | Rule::symbol_colon\r\n                | Rule::symbol_comma\r\n                | Rule::symbol_arrow\r\n                | Rule::symbol_at\r\n                | Rule::symbol_eq\r\n                | Rule::symbol_opencurly\r\n                | Rule::symbol_closecurly\r\n                | Rule::symbol_opensquare\r\n                | Rule::symbol_closesquare\r\n                | Rule::EOL\r\n        )\r\n    }\r\n\r\n    /// Remove lifetime restrictions from this token\r\n    pub fn into_owned(self) -\u003e Token\u003c'static\u003e {\r\n        Token {\r\n            line: self.line,\r\n            rule: self.rule,\r\n            input: Cow::Owned(self.input.into_owned()),\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003c'i\u003e From\u003c\u0026Pair\u003c'i, Rule\u003e\u003e for Token\u003c'i\u003e {\r\n    fn from(pair: \u0026Pair\u003c'i, Rule\u003e) -\u003e Token\u003c'i\u003e {\r\n        Token {\r\n            line: pair.line_col().0,\r\n            rule: pair.as_rule(),\r\n            input: Cow::Borrowed(pair.as_str().trim()),\r\n        }\r\n    }\r\n}\r\n\r\nimpl std::fmt::Display for Token\u003c'_\u003e {\r\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\r\n        let lines = self\r\n            .input\r\n            .lines()\r\n            .map(|l| format!(\"| {l}\"))\r\n            .collect::\u003cVec\u003c_\u003e\u003e();\r\n        if lines.len() == 1 {\r\n            write!(f, \"Line {}: {}\", self.line, self.input)\r\n        } else {\r\n            write!(f, \"Line {}: \\n{}\", self.line, lines.join(\"\\n\"))\r\n        }\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod test {\r\n    use super::*;\r\n    use crate::pest::LavendeuxParser;\r\n    use pest::Parser;\r\n\r\n    fn get_pair() -\u003e Pair\u003c'static, Rule\u003e {\r\n        let mut pairs = LavendeuxParser::parse(Rule::SCRIPT, \"1\").unwrap();\r\n        pairs.next().unwrap()\r\n    }\r\n\r\n    #[test]\r\n    fn test_token_from_pair() {\r\n        let token = Token::from(\u0026get_pair());\r\n        assert_eq!(token.line, 1);\r\n        assert_eq!(token.rule, Rule::SCRIPT);\r\n        assert_eq!(token.input, \"1\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_token_display() {\r\n        let token = Token {\r\n            line: 1,\r\n            rule: Rule::symbol_arrow,\r\n            input: Cow::Borrowed(\"-\u003e\"),\r\n        };\r\n        assert_eq!(format!(\"{}\", token), \"Line 1: -\u003e\");\r\n\r\n        let token = Token {\r\n            line: 1,\r\n            rule: Rule::symbol_arrow,\r\n            input: Cow::Borrowed(\"-\u003e\\n-\u003e\"),\r\n        };\r\n        assert_eq!(format!(\"{}\", token), \"Line 1: \\n| -\u003e\\n| -\u003e\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_token_into_owned() {\r\n        let token = Token {\r\n            line: 1,\r\n            rule: Rule::symbol_arrow,\r\n            input: Cow::Borrowed(\"-\u003e\"),\r\n        };\r\n        let token = token.into_owned();\r\n        assert_eq!(token.line, 1);\r\n        assert_eq!(token.rule, Rule::symbol_arrow);\r\n        assert_eq!(token.input, \"-\u003e\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_token_is_symbol() {\r\n        assert!(Token::is_symbol(Rule::symbol_arrow));\r\n        assert!(!Token::is_symbol(Rule::OP_ADD));\r\n    }\r\n\r\n    #[test]\r\n    fn test_token_dummy() {\r\n        let token = Token::dummy();\r\n        assert_eq!(token.line, 0);\r\n        assert_eq!(token.rule, Rule::SCRIPT);\r\n        assert_eq!(token.input, \"\");\r\n    }\r\n}\r\n","traces":[{"line":23,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":19697},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":14416},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":19697},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":7451},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":7451},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":7451},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":7451},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":23623},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":23623},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":23623},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":23623},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":20,"coverable":20}]};
        var previousData = {"files":[{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","examples","interactive_console.rs"],"content":"use lavendeux_parser::{Lavendeux, ParserOptions};\r\nuse std::collections::VecDeque;\r\nuse std::env;\r\nuse std::io::{stdin, stdout, Write};\r\nuse std::time::Duration;\r\n\r\n/// Get the next command from the user\r\nfn next_command() -\u003e String {\r\n    let mut input = String::new();\r\n    print!(\"\u003e \");\r\n    let _ = stdout().flush();\r\n\r\n    loop {\r\n        stdin()\r\n            .read_line(\u0026mut input)\r\n            .expect(\"error: unable to read user input\");\r\n        if !input.trim().ends_with('\\\\') || input.trim().ends_with(\"\\\\\\\\\") {\r\n            break;\r\n        }\r\n    }\r\n\r\n    return input.trim().to_string();\r\n}\r\n\r\nfn main() {\r\n    let mut lavendeux = Lavendeux::new(ParserOptions {\r\n        timeout: Duration::from_secs(30),\r\n        pest_call_limit: 25000000,\r\n        ..Default::default()\r\n    });\r\n\r\n    // Load example scripts\r\n    //    lavendeux\r\n    //       .parse(\"include('example_scripts/zarbans_grotto.lav')\")\r\n    //       .expect(\"Could not load example scripts\");\r\n\r\n    // Preload command stack from arguments\r\n    let mut stack: VecDeque\u003cString\u003e = env::args().skip(1).collect();\r\n    if stack.is_empty() {\r\n        println!(\"Ready! Type expressions below!\");\r\n    } else {\r\n        stack.push_back(\"exit\".to_string());\r\n    }\r\n\r\n    loop {\r\n        // Make sure we have a command ready\r\n        if stack.is_empty() {\r\n            stack.push_back(next_command());\r\n        }\r\n        let cmd = stack.pop_front().unwrap();\r\n\r\n        if cmd.is_empty() {\r\n            continue;\r\n        } else if [\"exit\", \"quit\"].contains(\u0026cmd.as_str()) {\r\n            break;\r\n        } else {\r\n            // Process the commands\r\n            let t = std::time::Instant::now();\r\n            match lavendeux.parse(\u0026cmd) {\r\n                Ok(values) =\u003e {\r\n                    println!(\"Parsed in {}ms\", t.elapsed().as_millis());\r\n                    for value in values {\r\n                        println!(\"{}\", value);\r\n                    }\r\n                }\r\n                Err(e) =\u003e println!(\"Error:\\n{}\", e),\r\n            }\r\n        }\r\n    }\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","fuzz","fuzz_targets","parse.rs"],"content":"#![no_main]\n\nextern crate libfuzzer_sys;\n\nextern crate lavendeux_parser;\nuse lavendeux_parser::{Error, Lavendeux};\n\nuse libfuzzer_sys::fuzz_target;\n\nfuzz_target!(|data: \u0026[u8]| {\n    if let Ok(s) = std::str::from_utf8(data) {\n        let mut parser = Lavendeux::new(Default::default());\n        if let Err(e) = parser.parse(s) {\n            if let Error::Internal(msg) = e {\n                panic!(\"Internal error: {}\", msg);\n            }\n        }\n    }\n});\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","fuzz","target","x86_64-unknown-linux-gnu","release","build","num-bigint-1257680023a30f1c","out","radix_bases.rs"],"content":"#[deny(overflowing_literals)]\npub(crate) static BASES_16: [(u16, usize); 257] = [\n    (0, 0), // 0\n    (0, 0), // 1\n    (0, 0), // 2\n    (59049, 10), // 3\n    (0, 0), // 4\n    (15625, 6), // 5\n    (46656, 6), // 6\n    (16807, 5), // 7\n    (0, 0), // 8\n    (59049, 5), // 9\n    (10000, 4), // 10\n    (14641, 4), // 11\n    (20736, 4), // 12\n    (28561, 4), // 13\n    (38416, 4), // 14\n    (50625, 4), // 15\n    (0, 0), // 16\n    (4913, 3), // 17\n    (5832, 3), // 18\n    (6859, 3), // 19\n    (8000, 3), // 20\n    (9261, 3), // 21\n    (10648, 3), // 22\n    (12167, 3), // 23\n    (13824, 3), // 24\n    (15625, 3), // 25\n    (17576, 3), // 26\n    (19683, 3), // 27\n    (21952, 3), // 28\n    (24389, 3), // 29\n    (27000, 3), // 30\n    (29791, 3), // 31\n    (0, 0), // 32\n    (35937, 3), // 33\n    (39304, 3), // 34\n    (42875, 3), // 35\n    (46656, 3), // 36\n    (50653, 3), // 37\n    (54872, 3), // 38\n    (59319, 3), // 39\n    (64000, 3), // 40\n    (1681, 2), // 41\n    (1764, 2), // 42\n    (1849, 2), // 43\n    (1936, 2), // 44\n    (2025, 2), // 45\n    (2116, 2), // 46\n    (2209, 2), // 47\n    (2304, 2), // 48\n    (2401, 2), // 49\n    (2500, 2), // 50\n    (2601, 2), // 51\n    (2704, 2), // 52\n    (2809, 2), // 53\n    (2916, 2), // 54\n    (3025, 2), // 55\n    (3136, 2), // 56\n    (3249, 2), // 57\n    (3364, 2), // 58\n    (3481, 2), // 59\n    (3600, 2), // 60\n    (3721, 2), // 61\n    (3844, 2), // 62\n    (3969, 2), // 63\n    (0, 0), // 64\n    (4225, 2), // 65\n    (4356, 2), // 66\n    (4489, 2), // 67\n    (4624, 2), // 68\n    (4761, 2), // 69\n    (4900, 2), // 70\n    (5041, 2), // 71\n    (5184, 2), // 72\n    (5329, 2), // 73\n    (5476, 2), // 74\n    (5625, 2), // 75\n    (5776, 2), // 76\n    (5929, 2), // 77\n    (6084, 2), // 78\n    (6241, 2), // 79\n    (6400, 2), // 80\n    (6561, 2), // 81\n    (6724, 2), // 82\n    (6889, 2), // 83\n    (7056, 2), // 84\n    (7225, 2), // 85\n    (7396, 2), // 86\n    (7569, 2), // 87\n    (7744, 2), // 88\n    (7921, 2), // 89\n    (8100, 2), // 90\n    (8281, 2), // 91\n    (8464, 2), // 92\n    (8649, 2), // 93\n    (8836, 2), // 94\n    (9025, 2), // 95\n    (9216, 2), // 96\n    (9409, 2), // 97\n    (9604, 2), // 98\n    (9801, 2), // 99\n    (10000, 2), // 100\n    (10201, 2), // 101\n    (10404, 2), // 102\n    (10609, 2), // 103\n    (10816, 2), // 104\n    (11025, 2), // 105\n    (11236, 2), // 106\n    (11449, 2), // 107\n    (11664, 2), // 108\n    (11881, 2), // 109\n    (12100, 2), // 110\n    (12321, 2), // 111\n    (12544, 2), // 112\n    (12769, 2), // 113\n    (12996, 2), // 114\n    (13225, 2), // 115\n    (13456, 2), // 116\n    (13689, 2), // 117\n    (13924, 2), // 118\n    (14161, 2), // 119\n    (14400, 2), // 120\n    (14641, 2), // 121\n    (14884, 2), // 122\n    (15129, 2), // 123\n    (15376, 2), // 124\n    (15625, 2), // 125\n    (15876, 2), // 126\n    (16129, 2), // 127\n    (0, 0), // 128\n    (16641, 2), // 129\n    (16900, 2), // 130\n    (17161, 2), // 131\n    (17424, 2), // 132\n    (17689, 2), // 133\n    (17956, 2), // 134\n    (18225, 2), // 135\n    (18496, 2), // 136\n    (18769, 2), // 137\n    (19044, 2), // 138\n    (19321, 2), // 139\n    (19600, 2), // 140\n    (19881, 2), // 141\n    (20164, 2), // 142\n    (20449, 2), // 143\n    (20736, 2), // 144\n    (21025, 2), // 145\n    (21316, 2), // 146\n    (21609, 2), // 147\n    (21904, 2), // 148\n    (22201, 2), // 149\n    (22500, 2), // 150\n    (22801, 2), // 151\n    (23104, 2), // 152\n    (23409, 2), // 153\n    (23716, 2), // 154\n    (24025, 2), // 155\n    (24336, 2), // 156\n    (24649, 2), // 157\n    (24964, 2), // 158\n    (25281, 2), // 159\n    (25600, 2), // 160\n    (25921, 2), // 161\n    (26244, 2), // 162\n    (26569, 2), // 163\n    (26896, 2), // 164\n    (27225, 2), // 165\n    (27556, 2), // 166\n    (27889, 2), // 167\n    (28224, 2), // 168\n    (28561, 2), // 169\n    (28900, 2), // 170\n    (29241, 2), // 171\n    (29584, 2), // 172\n    (29929, 2), // 173\n    (30276, 2), // 174\n    (30625, 2), // 175\n    (30976, 2), // 176\n    (31329, 2), // 177\n    (31684, 2), // 178\n    (32041, 2), // 179\n    (32400, 2), // 180\n    (32761, 2), // 181\n    (33124, 2), // 182\n    (33489, 2), // 183\n    (33856, 2), // 184\n    (34225, 2), // 185\n    (34596, 2), // 186\n    (34969, 2), // 187\n    (35344, 2), // 188\n    (35721, 2), // 189\n    (36100, 2), // 190\n    (36481, 2), // 191\n    (36864, 2), // 192\n    (37249, 2), // 193\n    (37636, 2), // 194\n    (38025, 2), // 195\n    (38416, 2), // 196\n    (38809, 2), // 197\n    (39204, 2), // 198\n    (39601, 2), // 199\n    (40000, 2), // 200\n    (40401, 2), // 201\n    (40804, 2), // 202\n    (41209, 2), // 203\n    (41616, 2), // 204\n    (42025, 2), // 205\n    (42436, 2), // 206\n    (42849, 2), // 207\n    (43264, 2), // 208\n    (43681, 2), // 209\n    (44100, 2), // 210\n    (44521, 2), // 211\n    (44944, 2), // 212\n    (45369, 2), // 213\n    (45796, 2), // 214\n    (46225, 2), // 215\n    (46656, 2), // 216\n    (47089, 2), // 217\n    (47524, 2), // 218\n    (47961, 2), // 219\n    (48400, 2), // 220\n    (48841, 2), // 221\n    (49284, 2), // 222\n    (49729, 2), // 223\n    (50176, 2), // 224\n    (50625, 2), // 225\n    (51076, 2), // 226\n    (51529, 2), // 227\n    (51984, 2), // 228\n    (52441, 2), // 229\n    (52900, 2), // 230\n    (53361, 2), // 231\n    (53824, 2), // 232\n    (54289, 2), // 233\n    (54756, 2), // 234\n    (55225, 2), // 235\n    (55696, 2), // 236\n    (56169, 2), // 237\n    (56644, 2), // 238\n    (57121, 2), // 239\n    (57600, 2), // 240\n    (58081, 2), // 241\n    (58564, 2), // 242\n    (59049, 2), // 243\n    (59536, 2), // 244\n    (60025, 2), // 245\n    (60516, 2), // 246\n    (61009, 2), // 247\n    (61504, 2), // 248\n    (62001, 2), // 249\n    (62500, 2), // 250\n    (63001, 2), // 251\n    (63504, 2), // 252\n    (64009, 2), // 253\n    (64516, 2), // 254\n    (65025, 2), // 255\n    (0, 0), // 256\n];\n#[deny(overflowing_literals)]\npub(crate) static BASES_32: [(u32, usize); 257] = [\n    (0, 0), // 0\n    (0, 0), // 1\n    (0, 0), // 2\n    (3486784401, 20), // 3\n    (0, 0), // 4\n    (1220703125, 13), // 5\n    (2176782336, 12), // 6\n    (1977326743, 11), // 7\n    (0, 0), // 8\n    (3486784401, 10), // 9\n    (1000000000, 9), // 10\n    (2357947691, 9), // 11\n    (429981696, 8), // 12\n    (815730721, 8), // 13\n    (1475789056, 8), // 14\n    (2562890625, 8), // 15\n    (0, 0), // 16\n    (410338673, 7), // 17\n    (612220032, 7), // 18\n    (893871739, 7), // 19\n    (1280000000, 7), // 20\n    (1801088541, 7), // 21\n    (2494357888, 7), // 22\n    (3404825447, 7), // 23\n    (191102976, 6), // 24\n    (244140625, 6), // 25\n    (308915776, 6), // 26\n    (387420489, 6), // 27\n    (481890304, 6), // 28\n    (594823321, 6), // 29\n    (729000000, 6), // 30\n    (887503681, 6), // 31\n    (0, 0), // 32\n    (1291467969, 6), // 33\n    (1544804416, 6), // 34\n    (1838265625, 6), // 35\n    (2176782336, 6), // 36\n    (2565726409, 6), // 37\n    (3010936384, 6), // 38\n    (3518743761, 6), // 39\n    (4096000000, 6), // 40\n    (115856201, 5), // 41\n    (130691232, 5), // 42\n    (147008443, 5), // 43\n    (164916224, 5), // 44\n    (184528125, 5), // 45\n    (205962976, 5), // 46\n    (229345007, 5), // 47\n    (254803968, 5), // 48\n    (282475249, 5), // 49\n    (312500000, 5), // 50\n    (345025251, 5), // 51\n    (380204032, 5), // 52\n    (418195493, 5), // 53\n    (459165024, 5), // 54\n    (503284375, 5), // 55\n    (550731776, 5), // 56\n    (601692057, 5), // 57\n    (656356768, 5), // 58\n    (714924299, 5), // 59\n    (777600000, 5), // 60\n    (844596301, 5), // 61\n    (916132832, 5), // 62\n    (992436543, 5), // 63\n    (0, 0), // 64\n    (1160290625, 5), // 65\n    (1252332576, 5), // 66\n    (1350125107, 5), // 67\n    (1453933568, 5), // 68\n    (1564031349, 5), // 69\n    (1680700000, 5), // 70\n    (1804229351, 5), // 71\n    (1934917632, 5), // 72\n    (2073071593, 5), // 73\n    (2219006624, 5), // 74\n    (2373046875, 5), // 75\n    (2535525376, 5), // 76\n    (2706784157, 5), // 77\n    (2887174368, 5), // 78\n    (3077056399, 5), // 79\n    (3276800000, 5), // 80\n    (3486784401, 5), // 81\n    (3707398432, 5), // 82\n    (3939040643, 5), // 83\n    (4182119424, 5), // 84\n    (52200625, 4), // 85\n    (54700816, 4), // 86\n    (57289761, 4), // 87\n    (59969536, 4), // 88\n    (62742241, 4), // 89\n    (65610000, 4), // 90\n    (68574961, 4), // 91\n    (71639296, 4), // 92\n    (74805201, 4), // 93\n    (78074896, 4), // 94\n    (81450625, 4), // 95\n    (84934656, 4), // 96\n    (88529281, 4), // 97\n    (92236816, 4), // 98\n    (96059601, 4), // 99\n    (100000000, 4), // 100\n    (104060401, 4), // 101\n    (108243216, 4), // 102\n    (112550881, 4), // 103\n    (116985856, 4), // 104\n    (121550625, 4), // 105\n    (126247696, 4), // 106\n    (131079601, 4), // 107\n    (136048896, 4), // 108\n    (141158161, 4), // 109\n    (146410000, 4), // 110\n    (151807041, 4), // 111\n    (157351936, 4), // 112\n    (163047361, 4), // 113\n    (168896016, 4), // 114\n    (174900625, 4), // 115\n    (181063936, 4), // 116\n    (187388721, 4), // 117\n    (193877776, 4), // 118\n    (200533921, 4), // 119\n    (207360000, 4), // 120\n    (214358881, 4), // 121\n    (221533456, 4), // 122\n    (228886641, 4), // 123\n    (236421376, 4), // 124\n    (244140625, 4), // 125\n    (252047376, 4), // 126\n    (260144641, 4), // 127\n    (0, 0), // 128\n    (276922881, 4), // 129\n    (285610000, 4), // 130\n    (294499921, 4), // 131\n    (303595776, 4), // 132\n    (312900721, 4), // 133\n    (322417936, 4), // 134\n    (332150625, 4), // 135\n    (342102016, 4), // 136\n    (352275361, 4), // 137\n    (362673936, 4), // 138\n    (373301041, 4), // 139\n    (384160000, 4), // 140\n    (395254161, 4), // 141\n    (406586896, 4), // 142\n    (418161601, 4), // 143\n    (429981696, 4), // 144\n    (442050625, 4), // 145\n    (454371856, 4), // 146\n    (466948881, 4), // 147\n    (479785216, 4), // 148\n    (492884401, 4), // 149\n    (506250000, 4), // 150\n    (519885601, 4), // 151\n    (533794816, 4), // 152\n    (547981281, 4), // 153\n    (562448656, 4), // 154\n    (577200625, 4), // 155\n    (592240896, 4), // 156\n    (607573201, 4), // 157\n    (623201296, 4), // 158\n    (639128961, 4), // 159\n    (655360000, 4), // 160\n    (671898241, 4), // 161\n    (688747536, 4), // 162\n    (705911761, 4), // 163\n    (723394816, 4), // 164\n    (741200625, 4), // 165\n    (759333136, 4), // 166\n    (777796321, 4), // 167\n    (796594176, 4), // 168\n    (815730721, 4), // 169\n    (835210000, 4), // 170\n    (855036081, 4), // 171\n    (875213056, 4), // 172\n    (895745041, 4), // 173\n    (916636176, 4), // 174\n    (937890625, 4), // 175\n    (959512576, 4), // 176\n    (981506241, 4), // 177\n    (1003875856, 4), // 178\n    (1026625681, 4), // 179\n    (1049760000, 4), // 180\n    (1073283121, 4), // 181\n    (1097199376, 4), // 182\n    (1121513121, 4), // 183\n    (1146228736, 4), // 184\n    (1171350625, 4), // 185\n    (1196883216, 4), // 186\n    (1222830961, 4), // 187\n    (1249198336, 4), // 188\n    (1275989841, 4), // 189\n    (1303210000, 4), // 190\n    (1330863361, 4), // 191\n    (1358954496, 4), // 192\n    (1387488001, 4), // 193\n    (1416468496, 4), // 194\n    (1445900625, 4), // 195\n    (1475789056, 4), // 196\n    (1506138481, 4), // 197\n    (1536953616, 4), // 198\n    (1568239201, 4), // 199\n    (1600000000, 4), // 200\n    (1632240801, 4), // 201\n    (1664966416, 4), // 202\n    (1698181681, 4), // 203\n    (1731891456, 4), // 204\n    (1766100625, 4), // 205\n    (1800814096, 4), // 206\n    (1836036801, 4), // 207\n    (1871773696, 4), // 208\n    (1908029761, 4), // 209\n    (1944810000, 4), // 210\n    (1982119441, 4), // 211\n    (2019963136, 4), // 212\n    (2058346161, 4), // 213\n    (2097273616, 4), // 214\n    (2136750625, 4), // 215\n    (2176782336, 4), // 216\n    (2217373921, 4), // 217\n    (2258530576, 4), // 218\n    (2300257521, 4), // 219\n    (2342560000, 4), // 220\n    (2385443281, 4), // 221\n    (2428912656, 4), // 222\n    (2472973441, 4), // 223\n    (2517630976, 4), // 224\n    (2562890625, 4), // 225\n    (2608757776, 4), // 226\n    (2655237841, 4), // 227\n    (2702336256, 4), // 228\n    (2750058481, 4), // 229\n    (2798410000, 4), // 230\n    (2847396321, 4), // 231\n    (2897022976, 4), // 232\n    (2947295521, 4), // 233\n    (2998219536, 4), // 234\n    (3049800625, 4), // 235\n    (3102044416, 4), // 236\n    (3154956561, 4), // 237\n    (3208542736, 4), // 238\n    (3262808641, 4), // 239\n    (3317760000, 4), // 240\n    (3373402561, 4), // 241\n    (3429742096, 4), // 242\n    (3486784401, 4), // 243\n    (3544535296, 4), // 244\n    (3603000625, 4), // 245\n    (3662186256, 4), // 246\n    (3722098081, 4), // 247\n    (3782742016, 4), // 248\n    (3844124001, 4), // 249\n    (3906250000, 4), // 250\n    (3969126001, 4), // 251\n    (4032758016, 4), // 252\n    (4097152081, 4), // 253\n    (4162314256, 4), // 254\n    (4228250625, 4), // 255\n    (0, 0), // 256\n];\n#[deny(overflowing_literals)]\npub(crate) static BASES_64: [(u64, usize); 257] = [\n    (0, 0), // 0\n    (0, 0), // 1\n    (0, 0), // 2\n    (12157665459056928801, 40), // 3\n    (0, 0), // 4\n    (7450580596923828125, 27), // 5\n    (4738381338321616896, 24), // 6\n    (3909821048582988049, 22), // 7\n    (0, 0), // 8\n    (12157665459056928801, 20), // 9\n    (10000000000000000000, 19), // 10\n    (5559917313492231481, 18), // 11\n    (2218611106740436992, 17), // 12\n    (8650415919381337933, 17), // 13\n    (2177953337809371136, 16), // 14\n    (6568408355712890625, 16), // 15\n    (0, 0), // 16\n    (2862423051509815793, 15), // 17\n    (6746640616477458432, 15), // 18\n    (15181127029874798299, 15), // 19\n    (1638400000000000000, 14), // 20\n    (3243919932521508681, 14), // 21\n    (6221821273427820544, 14), // 22\n    (11592836324538749809, 14), // 23\n    (876488338465357824, 13), // 24\n    (1490116119384765625, 13), // 25\n    (2481152873203736576, 13), // 26\n    (4052555153018976267, 13), // 27\n    (6502111422497947648, 13), // 28\n    (10260628712958602189, 13), // 29\n    (15943230000000000000, 13), // 30\n    (787662783788549761, 12), // 31\n    (0, 0), // 32\n    (1667889514952984961, 12), // 33\n    (2386420683693101056, 12), // 34\n    (3379220508056640625, 12), // 35\n    (4738381338321616896, 12), // 36\n    (6582952005840035281, 12), // 37\n    (9065737908494995456, 12), // 38\n    (12381557655576425121, 12), // 39\n    (16777216000000000000, 12), // 40\n    (550329031716248441, 11), // 41\n    (717368321110468608, 11), // 42\n    (929293739471222707, 11), // 43\n    (1196683881290399744, 11), // 44\n    (1532278301220703125, 11), // 45\n    (1951354384207722496, 11), // 46\n    (2472159215084012303, 11), // 47\n    (3116402981210161152, 11), // 48\n    (3909821048582988049, 11), // 49\n    (4882812500000000000, 11), // 50\n    (6071163615208263051, 11), // 51\n    (7516865509350965248, 11), // 52\n    (9269035929372191597, 11), // 53\n    (11384956040305711104, 11), // 54\n    (13931233916552734375, 11), // 55\n    (16985107389382393856, 11), // 56\n    (362033331456891249, 10), // 57\n    (430804206899405824, 10), // 58\n    (511116753300641401, 10), // 59\n    (604661760000000000, 10), // 60\n    (713342911662882601, 10), // 61\n    (839299365868340224, 10), // 62\n    (984930291881790849, 10), // 63\n    (0, 0), // 64\n    (1346274334462890625, 10), // 65\n    (1568336880910795776, 10), // 66\n    (1822837804551761449, 10), // 67\n    (2113922820157210624, 10), // 68\n    (2446194060654759801, 10), // 69\n    (2824752490000000000, 10), // 70\n    (3255243551009881201, 10), // 71\n    (3743906242624487424, 10), // 72\n    (4297625829703557649, 10), // 73\n    (4923990397355877376, 10), // 74\n    (5631351470947265625, 10), // 75\n    (6428888932339941376, 10), // 76\n    (7326680472586200649, 10), // 77\n    (8335775831236199424, 10), // 78\n    (9468276082626847201, 10), // 79\n    (10737418240000000000, 10), // 80\n    (12157665459056928801, 10), // 81\n    (13744803133596058624, 10), // 82\n    (15516041187205853449, 10), // 83\n    (17490122876598091776, 10), // 84\n    (231616946283203125, 9), // 85\n    (257327417311663616, 9), // 86\n    (285544154243029527, 9), // 87\n    (316478381828866048, 9), // 88\n    (350356403707485209, 9), // 89\n    (387420489000000000, 9), // 90\n    (427929800129788411, 9), // 91\n    (472161363286556672, 9), // 92\n    (520411082988487293, 9), // 93\n    (572994802228616704, 9), // 94\n    (630249409724609375, 9), // 95\n    (692533995824480256, 9), // 96\n    (760231058654565217, 9), // 97\n    (833747762130149888, 9), // 98\n    (913517247483640899, 9), // 99\n    (1000000000000000000, 9), // 100\n    (1093685272684360901, 9), // 101\n    (1195092568622310912, 9), // 102\n    (1304773183829244583, 9), // 103\n    (1423311812421484544, 9), // 104\n    (1551328215978515625, 9), // 105\n    (1689478959002692096, 9), // 106\n    (1838459212420154507, 9), // 107\n    (1999004627104432128, 9), // 108\n    (2171893279442309389, 9), // 109\n    (2357947691000000000, 9), // 110\n    (2558036924386500591, 9), // 111\n    (2773078757450186752, 9), // 112\n    (3004041937984268273, 9), // 113\n    (3251948521156637184, 9), // 114\n    (3517876291919921875, 9), // 115\n    (3802961274698203136, 9), // 116\n    (4108400332687853397, 9), // 117\n    (4435453859151328768, 9), // 118\n    (4785448563124474679, 9), // 119\n    (5159780352000000000, 9), // 120\n    (5559917313492231481, 9), // 121\n    (5987402799531080192, 9), // 122\n    (6443858614676334363, 9), // 123\n    (6930988311686938624, 9), // 124\n    (7450580596923828125, 9), // 125\n    (8004512848309157376, 9), // 126\n    (8594754748609397887, 9), // 127\n    (0, 0), // 128\n    (9892530380752880769, 9), // 129\n    (10604499373000000000, 9), // 130\n    (11361656654439817571, 9), // 131\n    (12166492167065567232, 9), // 132\n    (13021612539908538853, 9), // 133\n    (13929745610903012864, 9), // 134\n    (14893745087865234375, 9), // 135\n    (15916595351771938816, 9), // 136\n    (17001416405572203977, 9), // 137\n    (18151468971815029248, 9), // 138\n    (139353667211683681, 8), // 139\n    (147578905600000000, 8), // 140\n    (156225851787813921, 8), // 141\n    (165312903998914816, 8), // 142\n    (174859124550883201, 8), // 143\n    (184884258895036416, 8), // 144\n    (195408755062890625, 8), // 145\n    (206453783524884736, 8), // 146\n    (218041257467152161, 8), // 147\n    (230193853492166656, 8), // 148\n    (242935032749128801, 8), // 149\n    (256289062500000000, 8), // 150\n    (270281038127131201, 8), // 151\n    (284936905588473856, 8), // 152\n    (300283484326400961, 8), // 153\n    (316348490636206336, 8), // 154\n    (333160561500390625, 8), // 155\n    (350749278894882816, 8), // 156\n    (369145194573386401, 8), // 157\n    (388379855336079616, 8), // 158\n    (408485828788939521, 8), // 159\n    (429496729600000000, 8), // 160\n    (451447246258894081, 8), // 161\n    (474373168346071296, 8), // 162\n    (498311414318121121, 8), // 163\n    (523300059815673856, 8), // 164\n    (549378366500390625, 8), // 165\n    (576586811427594496, 8), // 166\n    (604967116961135041, 8), // 167\n    (634562281237118976, 8), // 168\n    (665416609183179841, 8), // 169\n    (697575744100000000, 8), // 170\n    (731086699811838561, 8), // 171\n    (765997893392859136, 8), // 172\n    (802359178476091681, 8), // 173\n    (840221879151902976, 8), // 174\n    (879638824462890625, 8), // 175\n    (920664383502155776, 8), // 176\n    (963354501121950081, 8), // 177\n    (1007766734259732736, 8), // 178\n    (1053960288888713761, 8), // 179\n    (1101996057600000000, 8), // 180\n    (1151936657823500641, 8), // 181\n    (1203846470694789376, 8), // 182\n    (1257791680575160641, 8), // 183\n    (1313840315232157696, 8), // 184\n    (1372062286687890625, 8), // 185\n    (1432529432742502656, 8), // 186\n    (1495315559180183521, 8), // 187\n    (1560496482665168896, 8), // 188\n    (1628150074335205281, 8), // 189\n    (1698356304100000000, 8), // 190\n    (1771197285652216321, 8), // 191\n    (1846757322198614016, 8), // 192\n    (1925122952918976001, 8), // 193\n    (2006383000160502016, 8), // 194\n    (2090628617375390625, 8), // 195\n    (2177953337809371136, 8), // 196\n    (2268453123948987361, 8), // 197\n    (2362226417735475456, 8), // 198\n    (2459374191553118401, 8), // 199\n    (2560000000000000000, 8), // 200\n    (2664210032449121601, 8), // 201\n    (2772113166407885056, 8), // 202\n    (2883821021683985761, 8), // 203\n    (2999448015365799936, 8), // 204\n    (3119111417625390625, 8), // 205\n    (3242931408352297216, 8), // 206\n    (3371031134626313601, 8), // 207\n    (3503536769037500416, 8), // 208\n    (3640577568861717121, 8), // 209\n    (3782285936100000000, 8), // 210\n    (3928797478390152481, 8), // 211\n    (4080251070798954496, 8), // 212\n    (4236788918503437921, 8), // 213\n    (4398556620369715456, 8), // 214\n    (4565703233437890625, 8), // 215\n    (4738381338321616896, 8), // 216\n    (4916747105530914241, 8), // 217\n    (5100960362726891776, 8), // 218\n    (5291184662917065441, 8), // 219\n    (5487587353600000000, 8), // 220\n    (5690339646868044961, 8), // 221\n    (5899616690476974336, 8), // 222\n    (6115597639891380481, 8), // 223\n    (6338465731314712576, 8), // 224\n    (6568408355712890625, 8), // 225\n    (6805617133840466176, 8), // 226\n    (7050287992278341281, 8), // 227\n    (7302621240492097536, 8), // 228\n    (7562821648920027361, 8), // 229\n    (7831098528100000000, 8), // 230\n    (8107665808844335041, 8), // 231\n    (8392742123471896576, 8), // 232\n    (8686550888106661441, 8), // 233\n    (8989320386052055296, 8), // 234\n    (9301283852250390625, 8), // 235\n    (9622679558836781056, 8), // 236\n    (9953750901796946721, 8), // 237\n    (10294746488738365696, 8), // 238\n    (10645920227784266881, 8), // 239\n    (11007531417600000000, 8), // 240\n    (11379844838561358721, 8), // 241\n    (11763130845074473216, 8), // 242\n    (12157665459056928801, 8), // 243\n    (12563730464589807616, 8), // 244\n    (12981613503750390625, 8), // 245\n    (13411608173635297536, 8), // 246\n    (13854014124583882561, 8), // 247\n    (14309137159611744256, 8), // 248\n    (14777289335064248001, 8), // 249\n    (15258789062500000000, 8), // 250\n    (15753961211814252001, 8), // 251\n    (16263137215612256256, 8), // 252\n    (16786655174842630561, 8), // 253\n    (17324859965700833536, 8), // 254\n    (17878103347812890625, 8), // 255\n    (0, 0), // 256\n];\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","fuzz","target","x86_64-unknown-linux-gnu","release","build","typenum-85e81dd0a8c9dcba","out","consts.rs"],"content":"\n/**\nType aliases for many constants.\n\nThis file is generated by typenum's build script.\n\nFor unsigned integers, the format is `U` followed by the number. We define aliases for\n\n- Numbers 0 through 1024\n- Powers of 2 below `u64::MAX`\n- Powers of 10 below `u64::MAX`\n\nThese alias definitions look like this:\n\n```rust\nuse typenum::{B0, B1, UInt, UTerm};\n\n# #[allow(dead_code)]\ntype U6 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e;\n```\n\nFor positive signed integers, the format is `P` followed by the number and for negative\nsigned integers it is `N` followed by the number. For the signed integer zero, we use\n`Z0`. We define aliases for\n\n- Numbers -1024 through 1024\n- Powers of 2 between `i64::MIN` and `i64::MAX`\n- Powers of 10 between `i64::MIN` and `i64::MAX`\n\nThese alias definitions look like this:\n\n```rust\nuse typenum::{B0, B1, UInt, UTerm, PInt, NInt};\n\n# #[allow(dead_code)]\ntype P6 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n# #[allow(dead_code)]\ntype N6 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n```\n\n# Example\n```rust\n# #[allow(unused_imports)]\nuse typenum::{U0, U1, U2, U3, U4, U5, U6};\n# #[allow(unused_imports)]\nuse typenum::{N3, N2, N1, Z0, P1, P2, P3};\n# #[allow(unused_imports)]\nuse typenum::{U774, N17, N10000, P1024, P4096};\n```\n\nWe also define the aliases `False` and `True` for `B0` and `B1`, respectively.\n*/\n#[allow(missing_docs)]\npub mod consts {\n    use crate::uint::{UInt, UTerm};\n    use crate::int::{PInt, NInt};\n\n    pub use crate::bit::{B0, B1};\n    pub use crate::int::Z0;\n\n    pub type True = B1;\n    pub type False = B0;\n    pub type U0 = UTerm;\n    pub type U1 = UInt\u003cUTerm, B1\u003e;\n    pub type P1 = PInt\u003cU1\u003e; pub type N1 = NInt\u003cU1\u003e;\n    pub type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    pub type P2 = PInt\u003cU2\u003e; pub type N2 = NInt\u003cU2\u003e;\n    pub type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    pub type P3 = PInt\u003cU3\u003e; pub type N3 = NInt\u003cU3\u003e;\n    pub type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    pub type P4 = PInt\u003cU4\u003e; pub type N4 = NInt\u003cU4\u003e;\n    pub type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    pub type P5 = PInt\u003cU5\u003e; pub type N5 = NInt\u003cU5\u003e;\n    pub type U6 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e;\n    pub type P6 = PInt\u003cU6\u003e; pub type N6 = NInt\u003cU6\u003e;\n    pub type U7 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e;\n    pub type P7 = PInt\u003cU7\u003e; pub type N7 = NInt\u003cU7\u003e;\n    pub type U8 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P8 = PInt\u003cU8\u003e; pub type N8 = NInt\u003cU8\u003e;\n    pub type U9 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P9 = PInt\u003cU9\u003e; pub type N9 = NInt\u003cU9\u003e;\n    pub type U10 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P10 = PInt\u003cU10\u003e; pub type N10 = NInt\u003cU10\u003e;\n    pub type U11 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P11 = PInt\u003cU11\u003e; pub type N11 = NInt\u003cU11\u003e;\n    pub type U12 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P12 = PInt\u003cU12\u003e; pub type N12 = NInt\u003cU12\u003e;\n    pub type U13 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P13 = PInt\u003cU13\u003e; pub type N13 = NInt\u003cU13\u003e;\n    pub type U14 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P14 = PInt\u003cU14\u003e; pub type N14 = NInt\u003cU14\u003e;\n    pub type U15 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P15 = PInt\u003cU15\u003e; pub type N15 = NInt\u003cU15\u003e;\n    pub type U16 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P16 = PInt\u003cU16\u003e; pub type N16 = NInt\u003cU16\u003e;\n    pub type U17 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P17 = PInt\u003cU17\u003e; pub type N17 = NInt\u003cU17\u003e;\n    pub type U18 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P18 = PInt\u003cU18\u003e; pub type N18 = NInt\u003cU18\u003e;\n    pub type U19 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P19 = PInt\u003cU19\u003e; pub type N19 = NInt\u003cU19\u003e;\n    pub type U20 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P20 = PInt\u003cU20\u003e; pub type N20 = NInt\u003cU20\u003e;\n    pub type U21 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P21 = PInt\u003cU21\u003e; pub type N21 = NInt\u003cU21\u003e;\n    pub type U22 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P22 = PInt\u003cU22\u003e; pub type N22 = NInt\u003cU22\u003e;\n    pub type U23 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P23 = PInt\u003cU23\u003e; pub type N23 = NInt\u003cU23\u003e;\n    pub type U24 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P24 = PInt\u003cU24\u003e; pub type N24 = NInt\u003cU24\u003e;\n    pub type U25 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P25 = PInt\u003cU25\u003e; pub type N25 = NInt\u003cU25\u003e;\n    pub type U26 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P26 = PInt\u003cU26\u003e; pub type N26 = NInt\u003cU26\u003e;\n    pub type U27 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P27 = PInt\u003cU27\u003e; pub type N27 = NInt\u003cU27\u003e;\n    pub type U28 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P28 = PInt\u003cU28\u003e; pub type N28 = NInt\u003cU28\u003e;\n    pub type U29 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P29 = PInt\u003cU29\u003e; pub type N29 = NInt\u003cU29\u003e;\n    pub type U30 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P30 = PInt\u003cU30\u003e; pub type N30 = NInt\u003cU30\u003e;\n    pub type U31 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P31 = PInt\u003cU31\u003e; pub type N31 = NInt\u003cU31\u003e;\n    pub type U32 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P32 = PInt\u003cU32\u003e; pub type N32 = NInt\u003cU32\u003e;\n    pub type U33 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P33 = PInt\u003cU33\u003e; pub type N33 = NInt\u003cU33\u003e;\n    pub type U34 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P34 = PInt\u003cU34\u003e; pub type N34 = NInt\u003cU34\u003e;\n    pub type U35 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P35 = PInt\u003cU35\u003e; pub type N35 = NInt\u003cU35\u003e;\n    pub type U36 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P36 = PInt\u003cU36\u003e; pub type N36 = NInt\u003cU36\u003e;\n    pub type U37 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P37 = PInt\u003cU37\u003e; pub type N37 = NInt\u003cU37\u003e;\n    pub type U38 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P38 = PInt\u003cU38\u003e; pub type N38 = NInt\u003cU38\u003e;\n    pub type U39 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P39 = PInt\u003cU39\u003e; pub type N39 = NInt\u003cU39\u003e;\n    pub type U40 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P40 = PInt\u003cU40\u003e; pub type N40 = NInt\u003cU40\u003e;\n    pub type U41 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P41 = PInt\u003cU41\u003e; pub type N41 = NInt\u003cU41\u003e;\n    pub type U42 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P42 = PInt\u003cU42\u003e; pub type N42 = NInt\u003cU42\u003e;\n    pub type U43 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P43 = PInt\u003cU43\u003e; pub type N43 = NInt\u003cU43\u003e;\n    pub type U44 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P44 = PInt\u003cU44\u003e; pub type N44 = NInt\u003cU44\u003e;\n    pub type U45 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P45 = PInt\u003cU45\u003e; pub type N45 = NInt\u003cU45\u003e;\n    pub type U46 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P46 = PInt\u003cU46\u003e; pub type N46 = NInt\u003cU46\u003e;\n    pub type U47 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P47 = PInt\u003cU47\u003e; pub type N47 = NInt\u003cU47\u003e;\n    pub type U48 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P48 = PInt\u003cU48\u003e; pub type N48 = NInt\u003cU48\u003e;\n    pub type U49 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P49 = PInt\u003cU49\u003e; pub type N49 = NInt\u003cU49\u003e;\n    pub type U50 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P50 = PInt\u003cU50\u003e; pub type N50 = NInt\u003cU50\u003e;\n    pub type U51 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P51 = PInt\u003cU51\u003e; pub type N51 = NInt\u003cU51\u003e;\n    pub type U52 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P52 = PInt\u003cU52\u003e; pub type N52 = NInt\u003cU52\u003e;\n    pub type U53 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P53 = PInt\u003cU53\u003e; pub type N53 = NInt\u003cU53\u003e;\n    pub type U54 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P54 = PInt\u003cU54\u003e; pub type N54 = NInt\u003cU54\u003e;\n    pub type U55 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P55 = PInt\u003cU55\u003e; pub type N55 = NInt\u003cU55\u003e;\n    pub type U56 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P56 = PInt\u003cU56\u003e; pub type N56 = NInt\u003cU56\u003e;\n    pub type U57 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P57 = PInt\u003cU57\u003e; pub type N57 = NInt\u003cU57\u003e;\n    pub type U58 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P58 = PInt\u003cU58\u003e; pub type N58 = NInt\u003cU58\u003e;\n    pub type U59 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P59 = PInt\u003cU59\u003e; pub type N59 = NInt\u003cU59\u003e;\n    pub type U60 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P60 = PInt\u003cU60\u003e; pub type N60 = NInt\u003cU60\u003e;\n    pub type U61 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P61 = PInt\u003cU61\u003e; pub type N61 = NInt\u003cU61\u003e;\n    pub type U62 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P62 = PInt\u003cU62\u003e; pub type N62 = NInt\u003cU62\u003e;\n    pub type U63 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P63 = PInt\u003cU63\u003e; pub type N63 = NInt\u003cU63\u003e;\n    pub type U64 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P64 = PInt\u003cU64\u003e; pub type N64 = NInt\u003cU64\u003e;\n    pub type U65 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P65 = PInt\u003cU65\u003e; pub type N65 = NInt\u003cU65\u003e;\n    pub type U66 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P66 = PInt\u003cU66\u003e; pub type N66 = NInt\u003cU66\u003e;\n    pub type U67 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P67 = PInt\u003cU67\u003e; pub type N67 = NInt\u003cU67\u003e;\n    pub type U68 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P68 = PInt\u003cU68\u003e; pub type N68 = NInt\u003cU68\u003e;\n    pub type U69 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P69 = PInt\u003cU69\u003e; pub type N69 = NInt\u003cU69\u003e;\n    pub type U70 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P70 = PInt\u003cU70\u003e; pub type N70 = NInt\u003cU70\u003e;\n    pub type U71 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P71 = PInt\u003cU71\u003e; pub type N71 = NInt\u003cU71\u003e;\n    pub type U72 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P72 = PInt\u003cU72\u003e; pub type N72 = NInt\u003cU72\u003e;\n    pub type U73 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P73 = PInt\u003cU73\u003e; pub type N73 = NInt\u003cU73\u003e;\n    pub type U74 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P74 = PInt\u003cU74\u003e; pub type N74 = NInt\u003cU74\u003e;\n    pub type U75 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P75 = PInt\u003cU75\u003e; pub type N75 = NInt\u003cU75\u003e;\n    pub type U76 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P76 = PInt\u003cU76\u003e; pub type N76 = NInt\u003cU76\u003e;\n    pub type U77 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P77 = PInt\u003cU77\u003e; pub type N77 = NInt\u003cU77\u003e;\n    pub type U78 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P78 = PInt\u003cU78\u003e; pub type N78 = NInt\u003cU78\u003e;\n    pub type U79 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P79 = PInt\u003cU79\u003e; pub type N79 = NInt\u003cU79\u003e;\n    pub type U80 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P80 = PInt\u003cU80\u003e; pub type N80 = NInt\u003cU80\u003e;\n    pub type U81 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P81 = PInt\u003cU81\u003e; pub type N81 = NInt\u003cU81\u003e;\n    pub type U82 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P82 = PInt\u003cU82\u003e; pub type N82 = NInt\u003cU82\u003e;\n    pub type U83 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P83 = PInt\u003cU83\u003e; pub type N83 = NInt\u003cU83\u003e;\n    pub type U84 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P84 = PInt\u003cU84\u003e; pub type N84 = NInt\u003cU84\u003e;\n    pub type U85 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P85 = PInt\u003cU85\u003e; pub type N85 = NInt\u003cU85\u003e;\n    pub type U86 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P86 = PInt\u003cU86\u003e; pub type N86 = NInt\u003cU86\u003e;\n    pub type U87 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P87 = PInt\u003cU87\u003e; pub type N87 = NInt\u003cU87\u003e;\n    pub type U88 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P88 = PInt\u003cU88\u003e; pub type N88 = NInt\u003cU88\u003e;\n    pub type U89 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P89 = PInt\u003cU89\u003e; pub type N89 = NInt\u003cU89\u003e;\n    pub type U90 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P90 = PInt\u003cU90\u003e; pub type N90 = NInt\u003cU90\u003e;\n    pub type U91 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P91 = PInt\u003cU91\u003e; pub type N91 = NInt\u003cU91\u003e;\n    pub type U92 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P92 = PInt\u003cU92\u003e; pub type N92 = NInt\u003cU92\u003e;\n    pub type U93 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P93 = PInt\u003cU93\u003e; pub type N93 = NInt\u003cU93\u003e;\n    pub type U94 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P94 = PInt\u003cU94\u003e; pub type N94 = NInt\u003cU94\u003e;\n    pub type U95 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P95 = PInt\u003cU95\u003e; pub type N95 = NInt\u003cU95\u003e;\n    pub type U96 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P96 = PInt\u003cU96\u003e; pub type N96 = NInt\u003cU96\u003e;\n    pub type U97 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P97 = PInt\u003cU97\u003e; pub type N97 = NInt\u003cU97\u003e;\n    pub type U98 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P98 = PInt\u003cU98\u003e; pub type N98 = NInt\u003cU98\u003e;\n    pub type U99 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P99 = PInt\u003cU99\u003e; pub type N99 = NInt\u003cU99\u003e;\n    pub type U100 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P100 = PInt\u003cU100\u003e; pub type N100 = NInt\u003cU100\u003e;\n    pub type U101 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P101 = PInt\u003cU101\u003e; pub type N101 = NInt\u003cU101\u003e;\n    pub type U102 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P102 = PInt\u003cU102\u003e; pub type N102 = NInt\u003cU102\u003e;\n    pub type U103 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P103 = PInt\u003cU103\u003e; pub type N103 = NInt\u003cU103\u003e;\n    pub type U104 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P104 = PInt\u003cU104\u003e; pub type N104 = NInt\u003cU104\u003e;\n    pub type U105 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P105 = PInt\u003cU105\u003e; pub type N105 = NInt\u003cU105\u003e;\n    pub type U106 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P106 = PInt\u003cU106\u003e; pub type N106 = NInt\u003cU106\u003e;\n    pub type U107 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P107 = PInt\u003cU107\u003e; pub type N107 = NInt\u003cU107\u003e;\n    pub type U108 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P108 = PInt\u003cU108\u003e; pub type N108 = NInt\u003cU108\u003e;\n    pub type U109 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P109 = PInt\u003cU109\u003e; pub type N109 = NInt\u003cU109\u003e;\n    pub type U110 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P110 = PInt\u003cU110\u003e; pub type N110 = NInt\u003cU110\u003e;\n    pub type U111 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P111 = PInt\u003cU111\u003e; pub type N111 = NInt\u003cU111\u003e;\n    pub type U112 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P112 = PInt\u003cU112\u003e; pub type N112 = NInt\u003cU112\u003e;\n    pub type U113 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P113 = PInt\u003cU113\u003e; pub type N113 = NInt\u003cU113\u003e;\n    pub type U114 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P114 = PInt\u003cU114\u003e; pub type N114 = NInt\u003cU114\u003e;\n    pub type U115 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P115 = PInt\u003cU115\u003e; pub type N115 = NInt\u003cU115\u003e;\n    pub type U116 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P116 = PInt\u003cU116\u003e; pub type N116 = NInt\u003cU116\u003e;\n    pub type U117 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P117 = PInt\u003cU117\u003e; pub type N117 = NInt\u003cU117\u003e;\n    pub type U118 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P118 = PInt\u003cU118\u003e; pub type N118 = NInt\u003cU118\u003e;\n    pub type U119 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P119 = PInt\u003cU119\u003e; pub type N119 = NInt\u003cU119\u003e;\n    pub type U120 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P120 = PInt\u003cU120\u003e; pub type N120 = NInt\u003cU120\u003e;\n    pub type U121 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P121 = PInt\u003cU121\u003e; pub type N121 = NInt\u003cU121\u003e;\n    pub type U122 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P122 = PInt\u003cU122\u003e; pub type N122 = NInt\u003cU122\u003e;\n    pub type U123 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P123 = PInt\u003cU123\u003e; pub type N123 = NInt\u003cU123\u003e;\n    pub type U124 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P124 = PInt\u003cU124\u003e; pub type N124 = NInt\u003cU124\u003e;\n    pub type U125 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P125 = PInt\u003cU125\u003e; pub type N125 = NInt\u003cU125\u003e;\n    pub type U126 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P126 = PInt\u003cU126\u003e; pub type N126 = NInt\u003cU126\u003e;\n    pub type U127 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P127 = PInt\u003cU127\u003e; pub type N127 = NInt\u003cU127\u003e;\n    pub type U128 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P128 = PInt\u003cU128\u003e; pub type N128 = NInt\u003cU128\u003e;\n    pub type U129 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P129 = PInt\u003cU129\u003e; pub type N129 = NInt\u003cU129\u003e;\n    pub type U130 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P130 = PInt\u003cU130\u003e; pub type N130 = NInt\u003cU130\u003e;\n    pub type U131 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P131 = PInt\u003cU131\u003e; pub type N131 = NInt\u003cU131\u003e;\n    pub type U132 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P132 = PInt\u003cU132\u003e; pub type N132 = NInt\u003cU132\u003e;\n    pub type U133 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P133 = PInt\u003cU133\u003e; pub type N133 = NInt\u003cU133\u003e;\n    pub type U134 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P134 = PInt\u003cU134\u003e; pub type N134 = NInt\u003cU134\u003e;\n    pub type U135 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P135 = PInt\u003cU135\u003e; pub type N135 = NInt\u003cU135\u003e;\n    pub type U136 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P136 = PInt\u003cU136\u003e; pub type N136 = NInt\u003cU136\u003e;\n    pub type U137 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P137 = PInt\u003cU137\u003e; pub type N137 = NInt\u003cU137\u003e;\n    pub type U138 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P138 = PInt\u003cU138\u003e; pub type N138 = NInt\u003cU138\u003e;\n    pub type U139 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P139 = PInt\u003cU139\u003e; pub type N139 = NInt\u003cU139\u003e;\n    pub type U140 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P140 = PInt\u003cU140\u003e; pub type N140 = NInt\u003cU140\u003e;\n    pub type U141 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P141 = PInt\u003cU141\u003e; pub type N141 = NInt\u003cU141\u003e;\n    pub type U142 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P142 = PInt\u003cU142\u003e; pub type N142 = NInt\u003cU142\u003e;\n    pub type U143 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P143 = PInt\u003cU143\u003e; pub type N143 = NInt\u003cU143\u003e;\n    pub type U144 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P144 = PInt\u003cU144\u003e; pub type N144 = NInt\u003cU144\u003e;\n    pub type U145 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P145 = PInt\u003cU145\u003e; pub type N145 = NInt\u003cU145\u003e;\n    pub type U146 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P146 = PInt\u003cU146\u003e; pub type N146 = NInt\u003cU146\u003e;\n    pub type U147 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P147 = PInt\u003cU147\u003e; pub type N147 = NInt\u003cU147\u003e;\n    pub type U148 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P148 = PInt\u003cU148\u003e; pub type N148 = NInt\u003cU148\u003e;\n    pub type U149 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P149 = PInt\u003cU149\u003e; pub type N149 = NInt\u003cU149\u003e;\n    pub type U150 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P150 = PInt\u003cU150\u003e; pub type N150 = NInt\u003cU150\u003e;\n    pub type U151 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P151 = PInt\u003cU151\u003e; pub type N151 = NInt\u003cU151\u003e;\n    pub type U152 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P152 = PInt\u003cU152\u003e; pub type N152 = NInt\u003cU152\u003e;\n    pub type U153 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P153 = PInt\u003cU153\u003e; pub type N153 = NInt\u003cU153\u003e;\n    pub type U154 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P154 = PInt\u003cU154\u003e; pub type N154 = NInt\u003cU154\u003e;\n    pub type U155 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P155 = PInt\u003cU155\u003e; pub type N155 = NInt\u003cU155\u003e;\n    pub type U156 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P156 = PInt\u003cU156\u003e; pub type N156 = NInt\u003cU156\u003e;\n    pub type U157 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P157 = PInt\u003cU157\u003e; pub type N157 = NInt\u003cU157\u003e;\n    pub type U158 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P158 = PInt\u003cU158\u003e; pub type N158 = NInt\u003cU158\u003e;\n    pub type U159 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P159 = PInt\u003cU159\u003e; pub type N159 = NInt\u003cU159\u003e;\n    pub type U160 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P160 = PInt\u003cU160\u003e; pub type N160 = NInt\u003cU160\u003e;\n    pub type U161 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P161 = PInt\u003cU161\u003e; pub type N161 = NInt\u003cU161\u003e;\n    pub type U162 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P162 = PInt\u003cU162\u003e; pub type N162 = NInt\u003cU162\u003e;\n    pub type U163 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P163 = PInt\u003cU163\u003e; pub type N163 = NInt\u003cU163\u003e;\n    pub type U164 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P164 = PInt\u003cU164\u003e; pub type N164 = NInt\u003cU164\u003e;\n    pub type U165 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P165 = PInt\u003cU165\u003e; pub type N165 = NInt\u003cU165\u003e;\n    pub type U166 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P166 = PInt\u003cU166\u003e; pub type N166 = NInt\u003cU166\u003e;\n    pub type U167 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P167 = PInt\u003cU167\u003e; pub type N167 = NInt\u003cU167\u003e;\n    pub type U168 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P168 = PInt\u003cU168\u003e; pub type N168 = NInt\u003cU168\u003e;\n    pub type U169 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P169 = PInt\u003cU169\u003e; pub type N169 = NInt\u003cU169\u003e;\n    pub type U170 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P170 = PInt\u003cU170\u003e; pub type N170 = NInt\u003cU170\u003e;\n    pub type U171 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P171 = PInt\u003cU171\u003e; pub type N171 = NInt\u003cU171\u003e;\n    pub type U172 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P172 = PInt\u003cU172\u003e; pub type N172 = NInt\u003cU172\u003e;\n    pub type U173 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P173 = PInt\u003cU173\u003e; pub type N173 = NInt\u003cU173\u003e;\n    pub type U174 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P174 = PInt\u003cU174\u003e; pub type N174 = NInt\u003cU174\u003e;\n    pub type U175 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P175 = PInt\u003cU175\u003e; pub type N175 = NInt\u003cU175\u003e;\n    pub type U176 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P176 = PInt\u003cU176\u003e; pub type N176 = NInt\u003cU176\u003e;\n    pub type U177 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P177 = PInt\u003cU177\u003e; pub type N177 = NInt\u003cU177\u003e;\n    pub type U178 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P178 = PInt\u003cU178\u003e; pub type N178 = NInt\u003cU178\u003e;\n    pub type U179 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P179 = PInt\u003cU179\u003e; pub type N179 = NInt\u003cU179\u003e;\n    pub type U180 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P180 = PInt\u003cU180\u003e; pub type N180 = NInt\u003cU180\u003e;\n    pub type U181 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P181 = PInt\u003cU181\u003e; pub type N181 = NInt\u003cU181\u003e;\n    pub type U182 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P182 = PInt\u003cU182\u003e; pub type N182 = NInt\u003cU182\u003e;\n    pub type U183 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P183 = PInt\u003cU183\u003e; pub type N183 = NInt\u003cU183\u003e;\n    pub type U184 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P184 = PInt\u003cU184\u003e; pub type N184 = NInt\u003cU184\u003e;\n    pub type U185 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P185 = PInt\u003cU185\u003e; pub type N185 = NInt\u003cU185\u003e;\n    pub type U186 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P186 = PInt\u003cU186\u003e; pub type N186 = NInt\u003cU186\u003e;\n    pub type U187 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P187 = PInt\u003cU187\u003e; pub type N187 = NInt\u003cU187\u003e;\n    pub type U188 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P188 = PInt\u003cU188\u003e; pub type N188 = NInt\u003cU188\u003e;\n    pub type U189 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P189 = PInt\u003cU189\u003e; pub type N189 = NInt\u003cU189\u003e;\n    pub type U190 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P190 = PInt\u003cU190\u003e; pub type N190 = NInt\u003cU190\u003e;\n    pub type U191 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P191 = PInt\u003cU191\u003e; pub type N191 = NInt\u003cU191\u003e;\n    pub type U192 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P192 = PInt\u003cU192\u003e; pub type N192 = NInt\u003cU192\u003e;\n    pub type U193 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P193 = PInt\u003cU193\u003e; pub type N193 = NInt\u003cU193\u003e;\n    pub type U194 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P194 = PInt\u003cU194\u003e; pub type N194 = NInt\u003cU194\u003e;\n    pub type U195 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P195 = PInt\u003cU195\u003e; pub type N195 = NInt\u003cU195\u003e;\n    pub type U196 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P196 = PInt\u003cU196\u003e; pub type N196 = NInt\u003cU196\u003e;\n    pub type U197 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P197 = PInt\u003cU197\u003e; pub type N197 = NInt\u003cU197\u003e;\n    pub type U198 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P198 = PInt\u003cU198\u003e; pub type N198 = NInt\u003cU198\u003e;\n    pub type U199 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P199 = PInt\u003cU199\u003e; pub type N199 = NInt\u003cU199\u003e;\n    pub type U200 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P200 = PInt\u003cU200\u003e; pub type N200 = NInt\u003cU200\u003e;\n    pub type U201 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P201 = PInt\u003cU201\u003e; pub type N201 = NInt\u003cU201\u003e;\n    pub type U202 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P202 = PInt\u003cU202\u003e; pub type N202 = NInt\u003cU202\u003e;\n    pub type U203 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P203 = PInt\u003cU203\u003e; pub type N203 = NInt\u003cU203\u003e;\n    pub type U204 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P204 = PInt\u003cU204\u003e; pub type N204 = NInt\u003cU204\u003e;\n    pub type U205 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P205 = PInt\u003cU205\u003e; pub type N205 = NInt\u003cU205\u003e;\n    pub type U206 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P206 = PInt\u003cU206\u003e; pub type N206 = NInt\u003cU206\u003e;\n    pub type U207 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P207 = PInt\u003cU207\u003e; pub type N207 = NInt\u003cU207\u003e;\n    pub type U208 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P208 = PInt\u003cU208\u003e; pub type N208 = NInt\u003cU208\u003e;\n    pub type U209 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P209 = PInt\u003cU209\u003e; pub type N209 = NInt\u003cU209\u003e;\n    pub type U210 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P210 = PInt\u003cU210\u003e; pub type N210 = NInt\u003cU210\u003e;\n    pub type U211 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P211 = PInt\u003cU211\u003e; pub type N211 = NInt\u003cU211\u003e;\n    pub type U212 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P212 = PInt\u003cU212\u003e; pub type N212 = NInt\u003cU212\u003e;\n    pub type U213 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P213 = PInt\u003cU213\u003e; pub type N213 = NInt\u003cU213\u003e;\n    pub type U214 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P214 = PInt\u003cU214\u003e; pub type N214 = NInt\u003cU214\u003e;\n    pub type U215 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P215 = PInt\u003cU215\u003e; pub type N215 = NInt\u003cU215\u003e;\n    pub type U216 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P216 = PInt\u003cU216\u003e; pub type N216 = NInt\u003cU216\u003e;\n    pub type U217 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P217 = PInt\u003cU217\u003e; pub type N217 = NInt\u003cU217\u003e;\n    pub type U218 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P218 = PInt\u003cU218\u003e; pub type N218 = NInt\u003cU218\u003e;\n    pub type U219 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P219 = PInt\u003cU219\u003e; pub type N219 = NInt\u003cU219\u003e;\n    pub type U220 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P220 = PInt\u003cU220\u003e; pub type N220 = NInt\u003cU220\u003e;\n    pub type U221 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P221 = PInt\u003cU221\u003e; pub type N221 = NInt\u003cU221\u003e;\n    pub type U222 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P222 = PInt\u003cU222\u003e; pub type N222 = NInt\u003cU222\u003e;\n    pub type U223 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P223 = PInt\u003cU223\u003e; pub type N223 = NInt\u003cU223\u003e;\n    pub type U224 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P224 = PInt\u003cU224\u003e; pub type N224 = NInt\u003cU224\u003e;\n    pub type U225 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P225 = PInt\u003cU225\u003e; pub type N225 = NInt\u003cU225\u003e;\n    pub type U226 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P226 = PInt\u003cU226\u003e; pub type N226 = NInt\u003cU226\u003e;\n    pub type U227 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P227 = PInt\u003cU227\u003e; pub type N227 = NInt\u003cU227\u003e;\n    pub type U228 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P228 = PInt\u003cU228\u003e; pub type N228 = NInt\u003cU228\u003e;\n    pub type U229 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P229 = PInt\u003cU229\u003e; pub type N229 = NInt\u003cU229\u003e;\n    pub type U230 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P230 = PInt\u003cU230\u003e; pub type N230 = NInt\u003cU230\u003e;\n    pub type U231 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P231 = PInt\u003cU231\u003e; pub type N231 = NInt\u003cU231\u003e;\n    pub type U232 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P232 = PInt\u003cU232\u003e; pub type N232 = NInt\u003cU232\u003e;\n    pub type U233 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P233 = PInt\u003cU233\u003e; pub type N233 = NInt\u003cU233\u003e;\n    pub type U234 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P234 = PInt\u003cU234\u003e; pub type N234 = NInt\u003cU234\u003e;\n    pub type U235 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P235 = PInt\u003cU235\u003e; pub type N235 = NInt\u003cU235\u003e;\n    pub type U236 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P236 = PInt\u003cU236\u003e; pub type N236 = NInt\u003cU236\u003e;\n    pub type U237 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P237 = PInt\u003cU237\u003e; pub type N237 = NInt\u003cU237\u003e;\n    pub type U238 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P238 = PInt\u003cU238\u003e; pub type N238 = NInt\u003cU238\u003e;\n    pub type U239 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P239 = PInt\u003cU239\u003e; pub type N239 = NInt\u003cU239\u003e;\n    pub type U240 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P240 = PInt\u003cU240\u003e; pub type N240 = NInt\u003cU240\u003e;\n    pub type U241 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P241 = PInt\u003cU241\u003e; pub type N241 = NInt\u003cU241\u003e;\n    pub type U242 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P242 = PInt\u003cU242\u003e; pub type N242 = NInt\u003cU242\u003e;\n    pub type U243 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P243 = PInt\u003cU243\u003e; pub type N243 = NInt\u003cU243\u003e;\n    pub type U244 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P244 = PInt\u003cU244\u003e; pub type N244 = NInt\u003cU244\u003e;\n    pub type U245 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P245 = PInt\u003cU245\u003e; pub type N245 = NInt\u003cU245\u003e;\n    pub type U246 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P246 = PInt\u003cU246\u003e; pub type N246 = NInt\u003cU246\u003e;\n    pub type U247 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P247 = PInt\u003cU247\u003e; pub type N247 = NInt\u003cU247\u003e;\n    pub type U248 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P248 = PInt\u003cU248\u003e; pub type N248 = NInt\u003cU248\u003e;\n    pub type U249 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P249 = PInt\u003cU249\u003e; pub type N249 = NInt\u003cU249\u003e;\n    pub type U250 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P250 = PInt\u003cU250\u003e; pub type N250 = NInt\u003cU250\u003e;\n    pub type U251 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P251 = PInt\u003cU251\u003e; pub type N251 = NInt\u003cU251\u003e;\n    pub type U252 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P252 = PInt\u003cU252\u003e; pub type N252 = NInt\u003cU252\u003e;\n    pub type U253 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P253 = PInt\u003cU253\u003e; pub type N253 = NInt\u003cU253\u003e;\n    pub type U254 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P254 = PInt\u003cU254\u003e; pub type N254 = NInt\u003cU254\u003e;\n    pub type U255 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P255 = PInt\u003cU255\u003e; pub type N255 = NInt\u003cU255\u003e;\n    pub type U256 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P256 = PInt\u003cU256\u003e; pub type N256 = NInt\u003cU256\u003e;\n    pub type U257 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P257 = PInt\u003cU257\u003e; pub type N257 = NInt\u003cU257\u003e;\n    pub type U258 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P258 = PInt\u003cU258\u003e; pub type N258 = NInt\u003cU258\u003e;\n    pub type U259 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P259 = PInt\u003cU259\u003e; pub type N259 = NInt\u003cU259\u003e;\n    pub type U260 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P260 = PInt\u003cU260\u003e; pub type N260 = NInt\u003cU260\u003e;\n    pub type U261 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P261 = PInt\u003cU261\u003e; pub type N261 = NInt\u003cU261\u003e;\n    pub type U262 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P262 = PInt\u003cU262\u003e; pub type N262 = NInt\u003cU262\u003e;\n    pub type U263 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P263 = PInt\u003cU263\u003e; pub type N263 = NInt\u003cU263\u003e;\n    pub type U264 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P264 = PInt\u003cU264\u003e; pub type N264 = NInt\u003cU264\u003e;\n    pub type U265 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P265 = PInt\u003cU265\u003e; pub type N265 = NInt\u003cU265\u003e;\n    pub type U266 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P266 = PInt\u003cU266\u003e; pub type N266 = NInt\u003cU266\u003e;\n    pub type U267 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P267 = PInt\u003cU267\u003e; pub type N267 = NInt\u003cU267\u003e;\n    pub type U268 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P268 = PInt\u003cU268\u003e; pub type N268 = NInt\u003cU268\u003e;\n    pub type U269 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P269 = PInt\u003cU269\u003e; pub type N269 = NInt\u003cU269\u003e;\n    pub type U270 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P270 = PInt\u003cU270\u003e; pub type N270 = NInt\u003cU270\u003e;\n    pub type U271 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P271 = PInt\u003cU271\u003e; pub type N271 = NInt\u003cU271\u003e;\n    pub type U272 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P272 = PInt\u003cU272\u003e; pub type N272 = NInt\u003cU272\u003e;\n    pub type U273 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P273 = PInt\u003cU273\u003e; pub type N273 = NInt\u003cU273\u003e;\n    pub type U274 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P274 = PInt\u003cU274\u003e; pub type N274 = NInt\u003cU274\u003e;\n    pub type U275 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P275 = PInt\u003cU275\u003e; pub type N275 = NInt\u003cU275\u003e;\n    pub type U276 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P276 = PInt\u003cU276\u003e; pub type N276 = NInt\u003cU276\u003e;\n    pub type U277 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P277 = PInt\u003cU277\u003e; pub type N277 = NInt\u003cU277\u003e;\n    pub type U278 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P278 = PInt\u003cU278\u003e; pub type N278 = NInt\u003cU278\u003e;\n    pub type U279 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P279 = PInt\u003cU279\u003e; pub type N279 = NInt\u003cU279\u003e;\n    pub type U280 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P280 = PInt\u003cU280\u003e; pub type N280 = NInt\u003cU280\u003e;\n    pub type U281 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P281 = PInt\u003cU281\u003e; pub type N281 = NInt\u003cU281\u003e;\n    pub type U282 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P282 = PInt\u003cU282\u003e; pub type N282 = NInt\u003cU282\u003e;\n    pub type U283 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P283 = PInt\u003cU283\u003e; pub type N283 = NInt\u003cU283\u003e;\n    pub type U284 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P284 = PInt\u003cU284\u003e; pub type N284 = NInt\u003cU284\u003e;\n    pub type U285 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P285 = PInt\u003cU285\u003e; pub type N285 = NInt\u003cU285\u003e;\n    pub type U286 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P286 = PInt\u003cU286\u003e; pub type N286 = NInt\u003cU286\u003e;\n    pub type U287 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P287 = PInt\u003cU287\u003e; pub type N287 = NInt\u003cU287\u003e;\n    pub type U288 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P288 = PInt\u003cU288\u003e; pub type N288 = NInt\u003cU288\u003e;\n    pub type U289 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P289 = PInt\u003cU289\u003e; pub type N289 = NInt\u003cU289\u003e;\n    pub type U290 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P290 = PInt\u003cU290\u003e; pub type N290 = NInt\u003cU290\u003e;\n    pub type U291 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P291 = PInt\u003cU291\u003e; pub type N291 = NInt\u003cU291\u003e;\n    pub type U292 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P292 = PInt\u003cU292\u003e; pub type N292 = NInt\u003cU292\u003e;\n    pub type U293 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P293 = PInt\u003cU293\u003e; pub type N293 = NInt\u003cU293\u003e;\n    pub type U294 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P294 = PInt\u003cU294\u003e; pub type N294 = NInt\u003cU294\u003e;\n    pub type U295 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P295 = PInt\u003cU295\u003e; pub type N295 = NInt\u003cU295\u003e;\n    pub type U296 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P296 = PInt\u003cU296\u003e; pub type N296 = NInt\u003cU296\u003e;\n    pub type U297 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P297 = PInt\u003cU297\u003e; pub type N297 = NInt\u003cU297\u003e;\n    pub type U298 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P298 = PInt\u003cU298\u003e; pub type N298 = NInt\u003cU298\u003e;\n    pub type U299 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P299 = PInt\u003cU299\u003e; pub type N299 = NInt\u003cU299\u003e;\n    pub type U300 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P300 = PInt\u003cU300\u003e; pub type N300 = NInt\u003cU300\u003e;\n    pub type U301 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P301 = PInt\u003cU301\u003e; pub type N301 = NInt\u003cU301\u003e;\n    pub type U302 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P302 = PInt\u003cU302\u003e; pub type N302 = NInt\u003cU302\u003e;\n    pub type U303 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P303 = PInt\u003cU303\u003e; pub type N303 = NInt\u003cU303\u003e;\n    pub type U304 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P304 = PInt\u003cU304\u003e; pub type N304 = NInt\u003cU304\u003e;\n    pub type U305 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P305 = PInt\u003cU305\u003e; pub type N305 = NInt\u003cU305\u003e;\n    pub type U306 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P306 = PInt\u003cU306\u003e; pub type N306 = NInt\u003cU306\u003e;\n    pub type U307 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P307 = PInt\u003cU307\u003e; pub type N307 = NInt\u003cU307\u003e;\n    pub type U308 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P308 = PInt\u003cU308\u003e; pub type N308 = NInt\u003cU308\u003e;\n    pub type U309 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P309 = PInt\u003cU309\u003e; pub type N309 = NInt\u003cU309\u003e;\n    pub type U310 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P310 = PInt\u003cU310\u003e; pub type N310 = NInt\u003cU310\u003e;\n    pub type U311 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P311 = PInt\u003cU311\u003e; pub type N311 = NInt\u003cU311\u003e;\n    pub type U312 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P312 = PInt\u003cU312\u003e; pub type N312 = NInt\u003cU312\u003e;\n    pub type U313 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P313 = PInt\u003cU313\u003e; pub type N313 = NInt\u003cU313\u003e;\n    pub type U314 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P314 = PInt\u003cU314\u003e; pub type N314 = NInt\u003cU314\u003e;\n    pub type U315 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P315 = PInt\u003cU315\u003e; pub type N315 = NInt\u003cU315\u003e;\n    pub type U316 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P316 = PInt\u003cU316\u003e; pub type N316 = NInt\u003cU316\u003e;\n    pub type U317 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P317 = PInt\u003cU317\u003e; pub type N317 = NInt\u003cU317\u003e;\n    pub type U318 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P318 = PInt\u003cU318\u003e; pub type N318 = NInt\u003cU318\u003e;\n    pub type U319 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P319 = PInt\u003cU319\u003e; pub type N319 = NInt\u003cU319\u003e;\n    pub type U320 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P320 = PInt\u003cU320\u003e; pub type N320 = NInt\u003cU320\u003e;\n    pub type U321 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P321 = PInt\u003cU321\u003e; pub type N321 = NInt\u003cU321\u003e;\n    pub type U322 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P322 = PInt\u003cU322\u003e; pub type N322 = NInt\u003cU322\u003e;\n    pub type U323 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P323 = PInt\u003cU323\u003e; pub type N323 = NInt\u003cU323\u003e;\n    pub type U324 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P324 = PInt\u003cU324\u003e; pub type N324 = NInt\u003cU324\u003e;\n    pub type U325 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P325 = PInt\u003cU325\u003e; pub type N325 = NInt\u003cU325\u003e;\n    pub type U326 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P326 = PInt\u003cU326\u003e; pub type N326 = NInt\u003cU326\u003e;\n    pub type U327 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P327 = PInt\u003cU327\u003e; pub type N327 = NInt\u003cU327\u003e;\n    pub type U328 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P328 = PInt\u003cU328\u003e; pub type N328 = NInt\u003cU328\u003e;\n    pub type U329 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P329 = PInt\u003cU329\u003e; pub type N329 = NInt\u003cU329\u003e;\n    pub type U330 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P330 = PInt\u003cU330\u003e; pub type N330 = NInt\u003cU330\u003e;\n    pub type U331 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P331 = PInt\u003cU331\u003e; pub type N331 = NInt\u003cU331\u003e;\n    pub type U332 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P332 = PInt\u003cU332\u003e; pub type N332 = NInt\u003cU332\u003e;\n    pub type U333 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P333 = PInt\u003cU333\u003e; pub type N333 = NInt\u003cU333\u003e;\n    pub type U334 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P334 = PInt\u003cU334\u003e; pub type N334 = NInt\u003cU334\u003e;\n    pub type U335 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P335 = PInt\u003cU335\u003e; pub type N335 = NInt\u003cU335\u003e;\n    pub type U336 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P336 = PInt\u003cU336\u003e; pub type N336 = NInt\u003cU336\u003e;\n    pub type U337 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P337 = PInt\u003cU337\u003e; pub type N337 = NInt\u003cU337\u003e;\n    pub type U338 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P338 = PInt\u003cU338\u003e; pub type N338 = NInt\u003cU338\u003e;\n    pub type U339 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P339 = PInt\u003cU339\u003e; pub type N339 = NInt\u003cU339\u003e;\n    pub type U340 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P340 = PInt\u003cU340\u003e; pub type N340 = NInt\u003cU340\u003e;\n    pub type U341 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P341 = PInt\u003cU341\u003e; pub type N341 = NInt\u003cU341\u003e;\n    pub type U342 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P342 = PInt\u003cU342\u003e; pub type N342 = NInt\u003cU342\u003e;\n    pub type U343 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P343 = PInt\u003cU343\u003e; pub type N343 = NInt\u003cU343\u003e;\n    pub type U344 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P344 = PInt\u003cU344\u003e; pub type N344 = NInt\u003cU344\u003e;\n    pub type U345 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P345 = PInt\u003cU345\u003e; pub type N345 = NInt\u003cU345\u003e;\n    pub type U346 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P346 = PInt\u003cU346\u003e; pub type N346 = NInt\u003cU346\u003e;\n    pub type U347 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P347 = PInt\u003cU347\u003e; pub type N347 = NInt\u003cU347\u003e;\n    pub type U348 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P348 = PInt\u003cU348\u003e; pub type N348 = NInt\u003cU348\u003e;\n    pub type U349 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P349 = PInt\u003cU349\u003e; pub type N349 = NInt\u003cU349\u003e;\n    pub type U350 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P350 = PInt\u003cU350\u003e; pub type N350 = NInt\u003cU350\u003e;\n    pub type U351 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P351 = PInt\u003cU351\u003e; pub type N351 = NInt\u003cU351\u003e;\n    pub type U352 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P352 = PInt\u003cU352\u003e; pub type N352 = NInt\u003cU352\u003e;\n    pub type U353 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P353 = PInt\u003cU353\u003e; pub type N353 = NInt\u003cU353\u003e;\n    pub type U354 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P354 = PInt\u003cU354\u003e; pub type N354 = NInt\u003cU354\u003e;\n    pub type U355 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P355 = PInt\u003cU355\u003e; pub type N355 = NInt\u003cU355\u003e;\n    pub type U356 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P356 = PInt\u003cU356\u003e; pub type N356 = NInt\u003cU356\u003e;\n    pub type U357 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P357 = PInt\u003cU357\u003e; pub type N357 = NInt\u003cU357\u003e;\n    pub type U358 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P358 = PInt\u003cU358\u003e; pub type N358 = NInt\u003cU358\u003e;\n    pub type U359 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P359 = PInt\u003cU359\u003e; pub type N359 = NInt\u003cU359\u003e;\n    pub type U360 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P360 = PInt\u003cU360\u003e; pub type N360 = NInt\u003cU360\u003e;\n    pub type U361 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P361 = PInt\u003cU361\u003e; pub type N361 = NInt\u003cU361\u003e;\n    pub type U362 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P362 = PInt\u003cU362\u003e; pub type N362 = NInt\u003cU362\u003e;\n    pub type U363 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P363 = PInt\u003cU363\u003e; pub type N363 = NInt\u003cU363\u003e;\n    pub type U364 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P364 = PInt\u003cU364\u003e; pub type N364 = NInt\u003cU364\u003e;\n    pub type U365 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P365 = PInt\u003cU365\u003e; pub type N365 = NInt\u003cU365\u003e;\n    pub type U366 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P366 = PInt\u003cU366\u003e; pub type N366 = NInt\u003cU366\u003e;\n    pub type U367 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P367 = PInt\u003cU367\u003e; pub type N367 = NInt\u003cU367\u003e;\n    pub type U368 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P368 = PInt\u003cU368\u003e; pub type N368 = NInt\u003cU368\u003e;\n    pub type U369 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P369 = PInt\u003cU369\u003e; pub type N369 = NInt\u003cU369\u003e;\n    pub type U370 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P370 = PInt\u003cU370\u003e; pub type N370 = NInt\u003cU370\u003e;\n    pub type U371 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P371 = PInt\u003cU371\u003e; pub type N371 = NInt\u003cU371\u003e;\n    pub type U372 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P372 = PInt\u003cU372\u003e; pub type N372 = NInt\u003cU372\u003e;\n    pub type U373 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P373 = PInt\u003cU373\u003e; pub type N373 = NInt\u003cU373\u003e;\n    pub type U374 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P374 = PInt\u003cU374\u003e; pub type N374 = NInt\u003cU374\u003e;\n    pub type U375 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P375 = PInt\u003cU375\u003e; pub type N375 = NInt\u003cU375\u003e;\n    pub type U376 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P376 = PInt\u003cU376\u003e; pub type N376 = NInt\u003cU376\u003e;\n    pub type U377 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P377 = PInt\u003cU377\u003e; pub type N377 = NInt\u003cU377\u003e;\n    pub type U378 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P378 = PInt\u003cU378\u003e; pub type N378 = NInt\u003cU378\u003e;\n    pub type U379 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P379 = PInt\u003cU379\u003e; pub type N379 = NInt\u003cU379\u003e;\n    pub type U380 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P380 = PInt\u003cU380\u003e; pub type N380 = NInt\u003cU380\u003e;\n    pub type U381 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P381 = PInt\u003cU381\u003e; pub type N381 = NInt\u003cU381\u003e;\n    pub type U382 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P382 = PInt\u003cU382\u003e; pub type N382 = NInt\u003cU382\u003e;\n    pub type U383 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P383 = PInt\u003cU383\u003e; pub type N383 = NInt\u003cU383\u003e;\n    pub type U384 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P384 = PInt\u003cU384\u003e; pub type N384 = NInt\u003cU384\u003e;\n    pub type U385 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P385 = PInt\u003cU385\u003e; pub type N385 = NInt\u003cU385\u003e;\n    pub type U386 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P386 = PInt\u003cU386\u003e; pub type N386 = NInt\u003cU386\u003e;\n    pub type U387 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P387 = PInt\u003cU387\u003e; pub type N387 = NInt\u003cU387\u003e;\n    pub type U388 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P388 = PInt\u003cU388\u003e; pub type N388 = NInt\u003cU388\u003e;\n    pub type U389 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P389 = PInt\u003cU389\u003e; pub type N389 = NInt\u003cU389\u003e;\n    pub type U390 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P390 = PInt\u003cU390\u003e; pub type N390 = NInt\u003cU390\u003e;\n    pub type U391 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P391 = PInt\u003cU391\u003e; pub type N391 = NInt\u003cU391\u003e;\n    pub type U392 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P392 = PInt\u003cU392\u003e; pub type N392 = NInt\u003cU392\u003e;\n    pub type U393 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P393 = PInt\u003cU393\u003e; pub type N393 = NInt\u003cU393\u003e;\n    pub type U394 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P394 = PInt\u003cU394\u003e; pub type N394 = NInt\u003cU394\u003e;\n    pub type U395 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P395 = PInt\u003cU395\u003e; pub type N395 = NInt\u003cU395\u003e;\n    pub type U396 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P396 = PInt\u003cU396\u003e; pub type N396 = NInt\u003cU396\u003e;\n    pub type U397 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P397 = PInt\u003cU397\u003e; pub type N397 = NInt\u003cU397\u003e;\n    pub type U398 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P398 = PInt\u003cU398\u003e; pub type N398 = NInt\u003cU398\u003e;\n    pub type U399 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P399 = PInt\u003cU399\u003e; pub type N399 = NInt\u003cU399\u003e;\n    pub type U400 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P400 = PInt\u003cU400\u003e; pub type N400 = NInt\u003cU400\u003e;\n    pub type U401 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P401 = PInt\u003cU401\u003e; pub type N401 = NInt\u003cU401\u003e;\n    pub type U402 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P402 = PInt\u003cU402\u003e; pub type N402 = NInt\u003cU402\u003e;\n    pub type U403 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P403 = PInt\u003cU403\u003e; pub type N403 = NInt\u003cU403\u003e;\n    pub type U404 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P404 = PInt\u003cU404\u003e; pub type N404 = NInt\u003cU404\u003e;\n    pub type U405 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P405 = PInt\u003cU405\u003e; pub type N405 = NInt\u003cU405\u003e;\n    pub type U406 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P406 = PInt\u003cU406\u003e; pub type N406 = NInt\u003cU406\u003e;\n    pub type U407 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P407 = PInt\u003cU407\u003e; pub type N407 = NInt\u003cU407\u003e;\n    pub type U408 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P408 = PInt\u003cU408\u003e; pub type N408 = NInt\u003cU408\u003e;\n    pub type U409 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P409 = PInt\u003cU409\u003e; pub type N409 = NInt\u003cU409\u003e;\n    pub type U410 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P410 = PInt\u003cU410\u003e; pub type N410 = NInt\u003cU410\u003e;\n    pub type U411 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P411 = PInt\u003cU411\u003e; pub type N411 = NInt\u003cU411\u003e;\n    pub type U412 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P412 = PInt\u003cU412\u003e; pub type N412 = NInt\u003cU412\u003e;\n    pub type U413 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P413 = PInt\u003cU413\u003e; pub type N413 = NInt\u003cU413\u003e;\n    pub type U414 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P414 = PInt\u003cU414\u003e; pub type N414 = NInt\u003cU414\u003e;\n    pub type U415 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P415 = PInt\u003cU415\u003e; pub type N415 = NInt\u003cU415\u003e;\n    pub type U416 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P416 = PInt\u003cU416\u003e; pub type N416 = NInt\u003cU416\u003e;\n    pub type U417 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P417 = PInt\u003cU417\u003e; pub type N417 = NInt\u003cU417\u003e;\n    pub type U418 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P418 = PInt\u003cU418\u003e; pub type N418 = NInt\u003cU418\u003e;\n    pub type U419 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P419 = PInt\u003cU419\u003e; pub type N419 = NInt\u003cU419\u003e;\n    pub type U420 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P420 = PInt\u003cU420\u003e; pub type N420 = NInt\u003cU420\u003e;\n    pub type U421 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P421 = PInt\u003cU421\u003e; pub type N421 = NInt\u003cU421\u003e;\n    pub type U422 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P422 = PInt\u003cU422\u003e; pub type N422 = NInt\u003cU422\u003e;\n    pub type U423 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P423 = PInt\u003cU423\u003e; pub type N423 = NInt\u003cU423\u003e;\n    pub type U424 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P424 = PInt\u003cU424\u003e; pub type N424 = NInt\u003cU424\u003e;\n    pub type U425 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P425 = PInt\u003cU425\u003e; pub type N425 = NInt\u003cU425\u003e;\n    pub type U426 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P426 = PInt\u003cU426\u003e; pub type N426 = NInt\u003cU426\u003e;\n    pub type U427 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P427 = PInt\u003cU427\u003e; pub type N427 = NInt\u003cU427\u003e;\n    pub type U428 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P428 = PInt\u003cU428\u003e; pub type N428 = NInt\u003cU428\u003e;\n    pub type U429 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P429 = PInt\u003cU429\u003e; pub type N429 = NInt\u003cU429\u003e;\n    pub type U430 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P430 = PInt\u003cU430\u003e; pub type N430 = NInt\u003cU430\u003e;\n    pub type U431 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P431 = PInt\u003cU431\u003e; pub type N431 = NInt\u003cU431\u003e;\n    pub type U432 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P432 = PInt\u003cU432\u003e; pub type N432 = NInt\u003cU432\u003e;\n    pub type U433 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P433 = PInt\u003cU433\u003e; pub type N433 = NInt\u003cU433\u003e;\n    pub type U434 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P434 = PInt\u003cU434\u003e; pub type N434 = NInt\u003cU434\u003e;\n    pub type U435 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P435 = PInt\u003cU435\u003e; pub type N435 = NInt\u003cU435\u003e;\n    pub type U436 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P436 = PInt\u003cU436\u003e; pub type N436 = NInt\u003cU436\u003e;\n    pub type U437 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P437 = PInt\u003cU437\u003e; pub type N437 = NInt\u003cU437\u003e;\n    pub type U438 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P438 = PInt\u003cU438\u003e; pub type N438 = NInt\u003cU438\u003e;\n    pub type U439 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P439 = PInt\u003cU439\u003e; pub type N439 = NInt\u003cU439\u003e;\n    pub type U440 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P440 = PInt\u003cU440\u003e; pub type N440 = NInt\u003cU440\u003e;\n    pub type U441 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P441 = PInt\u003cU441\u003e; pub type N441 = NInt\u003cU441\u003e;\n    pub type U442 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P442 = PInt\u003cU442\u003e; pub type N442 = NInt\u003cU442\u003e;\n    pub type U443 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P443 = PInt\u003cU443\u003e; pub type N443 = NInt\u003cU443\u003e;\n    pub type U444 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P444 = PInt\u003cU444\u003e; pub type N444 = NInt\u003cU444\u003e;\n    pub type U445 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P445 = PInt\u003cU445\u003e; pub type N445 = NInt\u003cU445\u003e;\n    pub type U446 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P446 = PInt\u003cU446\u003e; pub type N446 = NInt\u003cU446\u003e;\n    pub type U447 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P447 = PInt\u003cU447\u003e; pub type N447 = NInt\u003cU447\u003e;\n    pub type U448 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P448 = PInt\u003cU448\u003e; pub type N448 = NInt\u003cU448\u003e;\n    pub type U449 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P449 = PInt\u003cU449\u003e; pub type N449 = NInt\u003cU449\u003e;\n    pub type U450 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P450 = PInt\u003cU450\u003e; pub type N450 = NInt\u003cU450\u003e;\n    pub type U451 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P451 = PInt\u003cU451\u003e; pub type N451 = NInt\u003cU451\u003e;\n    pub type U452 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P452 = PInt\u003cU452\u003e; pub type N452 = NInt\u003cU452\u003e;\n    pub type U453 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P453 = PInt\u003cU453\u003e; pub type N453 = NInt\u003cU453\u003e;\n    pub type U454 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P454 = PInt\u003cU454\u003e; pub type N454 = NInt\u003cU454\u003e;\n    pub type U455 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P455 = PInt\u003cU455\u003e; pub type N455 = NInt\u003cU455\u003e;\n    pub type U456 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P456 = PInt\u003cU456\u003e; pub type N456 = NInt\u003cU456\u003e;\n    pub type U457 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P457 = PInt\u003cU457\u003e; pub type N457 = NInt\u003cU457\u003e;\n    pub type U458 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P458 = PInt\u003cU458\u003e; pub type N458 = NInt\u003cU458\u003e;\n    pub type U459 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P459 = PInt\u003cU459\u003e; pub type N459 = NInt\u003cU459\u003e;\n    pub type U460 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P460 = PInt\u003cU460\u003e; pub type N460 = NInt\u003cU460\u003e;\n    pub type U461 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P461 = PInt\u003cU461\u003e; pub type N461 = NInt\u003cU461\u003e;\n    pub type U462 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P462 = PInt\u003cU462\u003e; pub type N462 = NInt\u003cU462\u003e;\n    pub type U463 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P463 = PInt\u003cU463\u003e; pub type N463 = NInt\u003cU463\u003e;\n    pub type U464 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P464 = PInt\u003cU464\u003e; pub type N464 = NInt\u003cU464\u003e;\n    pub type U465 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P465 = PInt\u003cU465\u003e; pub type N465 = NInt\u003cU465\u003e;\n    pub type U466 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P466 = PInt\u003cU466\u003e; pub type N466 = NInt\u003cU466\u003e;\n    pub type U467 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P467 = PInt\u003cU467\u003e; pub type N467 = NInt\u003cU467\u003e;\n    pub type U468 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P468 = PInt\u003cU468\u003e; pub type N468 = NInt\u003cU468\u003e;\n    pub type U469 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P469 = PInt\u003cU469\u003e; pub type N469 = NInt\u003cU469\u003e;\n    pub type U470 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P470 = PInt\u003cU470\u003e; pub type N470 = NInt\u003cU470\u003e;\n    pub type U471 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P471 = PInt\u003cU471\u003e; pub type N471 = NInt\u003cU471\u003e;\n    pub type U472 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P472 = PInt\u003cU472\u003e; pub type N472 = NInt\u003cU472\u003e;\n    pub type U473 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P473 = PInt\u003cU473\u003e; pub type N473 = NInt\u003cU473\u003e;\n    pub type U474 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P474 = PInt\u003cU474\u003e; pub type N474 = NInt\u003cU474\u003e;\n    pub type U475 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P475 = PInt\u003cU475\u003e; pub type N475 = NInt\u003cU475\u003e;\n    pub type U476 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P476 = PInt\u003cU476\u003e; pub type N476 = NInt\u003cU476\u003e;\n    pub type U477 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P477 = PInt\u003cU477\u003e; pub type N477 = NInt\u003cU477\u003e;\n    pub type U478 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P478 = PInt\u003cU478\u003e; pub type N478 = NInt\u003cU478\u003e;\n    pub type U479 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P479 = PInt\u003cU479\u003e; pub type N479 = NInt\u003cU479\u003e;\n    pub type U480 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P480 = PInt\u003cU480\u003e; pub type N480 = NInt\u003cU480\u003e;\n    pub type U481 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P481 = PInt\u003cU481\u003e; pub type N481 = NInt\u003cU481\u003e;\n    pub type U482 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P482 = PInt\u003cU482\u003e; pub type N482 = NInt\u003cU482\u003e;\n    pub type U483 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P483 = PInt\u003cU483\u003e; pub type N483 = NInt\u003cU483\u003e;\n    pub type U484 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P484 = PInt\u003cU484\u003e; pub type N484 = NInt\u003cU484\u003e;\n    pub type U485 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P485 = PInt\u003cU485\u003e; pub type N485 = NInt\u003cU485\u003e;\n    pub type U486 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P486 = PInt\u003cU486\u003e; pub type N486 = NInt\u003cU486\u003e;\n    pub type U487 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P487 = PInt\u003cU487\u003e; pub type N487 = NInt\u003cU487\u003e;\n    pub type U488 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P488 = PInt\u003cU488\u003e; pub type N488 = NInt\u003cU488\u003e;\n    pub type U489 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P489 = PInt\u003cU489\u003e; pub type N489 = NInt\u003cU489\u003e;\n    pub type U490 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P490 = PInt\u003cU490\u003e; pub type N490 = NInt\u003cU490\u003e;\n    pub type U491 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P491 = PInt\u003cU491\u003e; pub type N491 = NInt\u003cU491\u003e;\n    pub type U492 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P492 = PInt\u003cU492\u003e; pub type N492 = NInt\u003cU492\u003e;\n    pub type U493 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P493 = PInt\u003cU493\u003e; pub type N493 = NInt\u003cU493\u003e;\n    pub type U494 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P494 = PInt\u003cU494\u003e; pub type N494 = NInt\u003cU494\u003e;\n    pub type U495 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P495 = PInt\u003cU495\u003e; pub type N495 = NInt\u003cU495\u003e;\n    pub type U496 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P496 = PInt\u003cU496\u003e; pub type N496 = NInt\u003cU496\u003e;\n    pub type U497 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P497 = PInt\u003cU497\u003e; pub type N497 = NInt\u003cU497\u003e;\n    pub type U498 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P498 = PInt\u003cU498\u003e; pub type N498 = NInt\u003cU498\u003e;\n    pub type U499 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P499 = PInt\u003cU499\u003e; pub type N499 = NInt\u003cU499\u003e;\n    pub type U500 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P500 = PInt\u003cU500\u003e; pub type N500 = NInt\u003cU500\u003e;\n    pub type U501 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P501 = PInt\u003cU501\u003e; pub type N501 = NInt\u003cU501\u003e;\n    pub type U502 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P502 = PInt\u003cU502\u003e; pub type N502 = NInt\u003cU502\u003e;\n    pub type U503 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P503 = PInt\u003cU503\u003e; pub type N503 = NInt\u003cU503\u003e;\n    pub type U504 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P504 = PInt\u003cU504\u003e; pub type N504 = NInt\u003cU504\u003e;\n    pub type U505 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P505 = PInt\u003cU505\u003e; pub type N505 = NInt\u003cU505\u003e;\n    pub type U506 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P506 = PInt\u003cU506\u003e; pub type N506 = NInt\u003cU506\u003e;\n    pub type U507 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P507 = PInt\u003cU507\u003e; pub type N507 = NInt\u003cU507\u003e;\n    pub type U508 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P508 = PInt\u003cU508\u003e; pub type N508 = NInt\u003cU508\u003e;\n    pub type U509 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P509 = PInt\u003cU509\u003e; pub type N509 = NInt\u003cU509\u003e;\n    pub type U510 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P510 = PInt\u003cU510\u003e; pub type N510 = NInt\u003cU510\u003e;\n    pub type U511 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P511 = PInt\u003cU511\u003e; pub type N511 = NInt\u003cU511\u003e;\n    pub type U512 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P512 = PInt\u003cU512\u003e; pub type N512 = NInt\u003cU512\u003e;\n    pub type U513 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P513 = PInt\u003cU513\u003e; pub type N513 = NInt\u003cU513\u003e;\n    pub type U514 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P514 = PInt\u003cU514\u003e; pub type N514 = NInt\u003cU514\u003e;\n    pub type U515 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P515 = PInt\u003cU515\u003e; pub type N515 = NInt\u003cU515\u003e;\n    pub type U516 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P516 = PInt\u003cU516\u003e; pub type N516 = NInt\u003cU516\u003e;\n    pub type U517 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P517 = PInt\u003cU517\u003e; pub type N517 = NInt\u003cU517\u003e;\n    pub type U518 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P518 = PInt\u003cU518\u003e; pub type N518 = NInt\u003cU518\u003e;\n    pub type U519 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P519 = PInt\u003cU519\u003e; pub type N519 = NInt\u003cU519\u003e;\n    pub type U520 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P520 = PInt\u003cU520\u003e; pub type N520 = NInt\u003cU520\u003e;\n    pub type U521 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P521 = PInt\u003cU521\u003e; pub type N521 = NInt\u003cU521\u003e;\n    pub type U522 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P522 = PInt\u003cU522\u003e; pub type N522 = NInt\u003cU522\u003e;\n    pub type U523 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P523 = PInt\u003cU523\u003e; pub type N523 = NInt\u003cU523\u003e;\n    pub type U524 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P524 = PInt\u003cU524\u003e; pub type N524 = NInt\u003cU524\u003e;\n    pub type U525 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P525 = PInt\u003cU525\u003e; pub type N525 = NInt\u003cU525\u003e;\n    pub type U526 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P526 = PInt\u003cU526\u003e; pub type N526 = NInt\u003cU526\u003e;\n    pub type U527 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P527 = PInt\u003cU527\u003e; pub type N527 = NInt\u003cU527\u003e;\n    pub type U528 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P528 = PInt\u003cU528\u003e; pub type N528 = NInt\u003cU528\u003e;\n    pub type U529 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P529 = PInt\u003cU529\u003e; pub type N529 = NInt\u003cU529\u003e;\n    pub type U530 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P530 = PInt\u003cU530\u003e; pub type N530 = NInt\u003cU530\u003e;\n    pub type U531 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P531 = PInt\u003cU531\u003e; pub type N531 = NInt\u003cU531\u003e;\n    pub type U532 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P532 = PInt\u003cU532\u003e; pub type N532 = NInt\u003cU532\u003e;\n    pub type U533 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P533 = PInt\u003cU533\u003e; pub type N533 = NInt\u003cU533\u003e;\n    pub type U534 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P534 = PInt\u003cU534\u003e; pub type N534 = NInt\u003cU534\u003e;\n    pub type U535 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P535 = PInt\u003cU535\u003e; pub type N535 = NInt\u003cU535\u003e;\n    pub type U536 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P536 = PInt\u003cU536\u003e; pub type N536 = NInt\u003cU536\u003e;\n    pub type U537 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P537 = PInt\u003cU537\u003e; pub type N537 = NInt\u003cU537\u003e;\n    pub type U538 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P538 = PInt\u003cU538\u003e; pub type N538 = NInt\u003cU538\u003e;\n    pub type U539 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P539 = PInt\u003cU539\u003e; pub type N539 = NInt\u003cU539\u003e;\n    pub type U540 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P540 = PInt\u003cU540\u003e; pub type N540 = NInt\u003cU540\u003e;\n    pub type U541 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P541 = PInt\u003cU541\u003e; pub type N541 = NInt\u003cU541\u003e;\n    pub type U542 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P542 = PInt\u003cU542\u003e; pub type N542 = NInt\u003cU542\u003e;\n    pub type U543 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P543 = PInt\u003cU543\u003e; pub type N543 = NInt\u003cU543\u003e;\n    pub type U544 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P544 = PInt\u003cU544\u003e; pub type N544 = NInt\u003cU544\u003e;\n    pub type U545 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P545 = PInt\u003cU545\u003e; pub type N545 = NInt\u003cU545\u003e;\n    pub type U546 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P546 = PInt\u003cU546\u003e; pub type N546 = NInt\u003cU546\u003e;\n    pub type U547 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P547 = PInt\u003cU547\u003e; pub type N547 = NInt\u003cU547\u003e;\n    pub type U548 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P548 = PInt\u003cU548\u003e; pub type N548 = NInt\u003cU548\u003e;\n    pub type U549 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P549 = PInt\u003cU549\u003e; pub type N549 = NInt\u003cU549\u003e;\n    pub type U550 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P550 = PInt\u003cU550\u003e; pub type N550 = NInt\u003cU550\u003e;\n    pub type U551 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P551 = PInt\u003cU551\u003e; pub type N551 = NInt\u003cU551\u003e;\n    pub type U552 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P552 = PInt\u003cU552\u003e; pub type N552 = NInt\u003cU552\u003e;\n    pub type U553 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P553 = PInt\u003cU553\u003e; pub type N553 = NInt\u003cU553\u003e;\n    pub type U554 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P554 = PInt\u003cU554\u003e; pub type N554 = NInt\u003cU554\u003e;\n    pub type U555 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P555 = PInt\u003cU555\u003e; pub type N555 = NInt\u003cU555\u003e;\n    pub type U556 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P556 = PInt\u003cU556\u003e; pub type N556 = NInt\u003cU556\u003e;\n    pub type U557 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P557 = PInt\u003cU557\u003e; pub type N557 = NInt\u003cU557\u003e;\n    pub type U558 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P558 = PInt\u003cU558\u003e; pub type N558 = NInt\u003cU558\u003e;\n    pub type U559 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P559 = PInt\u003cU559\u003e; pub type N559 = NInt\u003cU559\u003e;\n    pub type U560 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P560 = PInt\u003cU560\u003e; pub type N560 = NInt\u003cU560\u003e;\n    pub type U561 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P561 = PInt\u003cU561\u003e; pub type N561 = NInt\u003cU561\u003e;\n    pub type U562 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P562 = PInt\u003cU562\u003e; pub type N562 = NInt\u003cU562\u003e;\n    pub type U563 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P563 = PInt\u003cU563\u003e; pub type N563 = NInt\u003cU563\u003e;\n    pub type U564 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P564 = PInt\u003cU564\u003e; pub type N564 = NInt\u003cU564\u003e;\n    pub type U565 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P565 = PInt\u003cU565\u003e; pub type N565 = NInt\u003cU565\u003e;\n    pub type U566 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P566 = PInt\u003cU566\u003e; pub type N566 = NInt\u003cU566\u003e;\n    pub type U567 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P567 = PInt\u003cU567\u003e; pub type N567 = NInt\u003cU567\u003e;\n    pub type U568 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P568 = PInt\u003cU568\u003e; pub type N568 = NInt\u003cU568\u003e;\n    pub type U569 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P569 = PInt\u003cU569\u003e; pub type N569 = NInt\u003cU569\u003e;\n    pub type U570 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P570 = PInt\u003cU570\u003e; pub type N570 = NInt\u003cU570\u003e;\n    pub type U571 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P571 = PInt\u003cU571\u003e; pub type N571 = NInt\u003cU571\u003e;\n    pub type U572 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P572 = PInt\u003cU572\u003e; pub type N572 = NInt\u003cU572\u003e;\n    pub type U573 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P573 = PInt\u003cU573\u003e; pub type N573 = NInt\u003cU573\u003e;\n    pub type U574 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P574 = PInt\u003cU574\u003e; pub type N574 = NInt\u003cU574\u003e;\n    pub type U575 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P575 = PInt\u003cU575\u003e; pub type N575 = NInt\u003cU575\u003e;\n    pub type U576 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P576 = PInt\u003cU576\u003e; pub type N576 = NInt\u003cU576\u003e;\n    pub type U577 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P577 = PInt\u003cU577\u003e; pub type N577 = NInt\u003cU577\u003e;\n    pub type U578 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P578 = PInt\u003cU578\u003e; pub type N578 = NInt\u003cU578\u003e;\n    pub type U579 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P579 = PInt\u003cU579\u003e; pub type N579 = NInt\u003cU579\u003e;\n    pub type U580 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P580 = PInt\u003cU580\u003e; pub type N580 = NInt\u003cU580\u003e;\n    pub type U581 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P581 = PInt\u003cU581\u003e; pub type N581 = NInt\u003cU581\u003e;\n    pub type U582 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P582 = PInt\u003cU582\u003e; pub type N582 = NInt\u003cU582\u003e;\n    pub type U583 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P583 = PInt\u003cU583\u003e; pub type N583 = NInt\u003cU583\u003e;\n    pub type U584 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P584 = PInt\u003cU584\u003e; pub type N584 = NInt\u003cU584\u003e;\n    pub type U585 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P585 = PInt\u003cU585\u003e; pub type N585 = NInt\u003cU585\u003e;\n    pub type U586 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P586 = PInt\u003cU586\u003e; pub type N586 = NInt\u003cU586\u003e;\n    pub type U587 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P587 = PInt\u003cU587\u003e; pub type N587 = NInt\u003cU587\u003e;\n    pub type U588 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P588 = PInt\u003cU588\u003e; pub type N588 = NInt\u003cU588\u003e;\n    pub type U589 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P589 = PInt\u003cU589\u003e; pub type N589 = NInt\u003cU589\u003e;\n    pub type U590 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P590 = PInt\u003cU590\u003e; pub type N590 = NInt\u003cU590\u003e;\n    pub type U591 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P591 = PInt\u003cU591\u003e; pub type N591 = NInt\u003cU591\u003e;\n    pub type U592 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P592 = PInt\u003cU592\u003e; pub type N592 = NInt\u003cU592\u003e;\n    pub type U593 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P593 = PInt\u003cU593\u003e; pub type N593 = NInt\u003cU593\u003e;\n    pub type U594 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P594 = PInt\u003cU594\u003e; pub type N594 = NInt\u003cU594\u003e;\n    pub type U595 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P595 = PInt\u003cU595\u003e; pub type N595 = NInt\u003cU595\u003e;\n    pub type U596 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P596 = PInt\u003cU596\u003e; pub type N596 = NInt\u003cU596\u003e;\n    pub type U597 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P597 = PInt\u003cU597\u003e; pub type N597 = NInt\u003cU597\u003e;\n    pub type U598 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P598 = PInt\u003cU598\u003e; pub type N598 = NInt\u003cU598\u003e;\n    pub type U599 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P599 = PInt\u003cU599\u003e; pub type N599 = NInt\u003cU599\u003e;\n    pub type U600 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P600 = PInt\u003cU600\u003e; pub type N600 = NInt\u003cU600\u003e;\n    pub type U601 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P601 = PInt\u003cU601\u003e; pub type N601 = NInt\u003cU601\u003e;\n    pub type U602 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P602 = PInt\u003cU602\u003e; pub type N602 = NInt\u003cU602\u003e;\n    pub type U603 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P603 = PInt\u003cU603\u003e; pub type N603 = NInt\u003cU603\u003e;\n    pub type U604 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P604 = PInt\u003cU604\u003e; pub type N604 = NInt\u003cU604\u003e;\n    pub type U605 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P605 = PInt\u003cU605\u003e; pub type N605 = NInt\u003cU605\u003e;\n    pub type U606 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P606 = PInt\u003cU606\u003e; pub type N606 = NInt\u003cU606\u003e;\n    pub type U607 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P607 = PInt\u003cU607\u003e; pub type N607 = NInt\u003cU607\u003e;\n    pub type U608 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P608 = PInt\u003cU608\u003e; pub type N608 = NInt\u003cU608\u003e;\n    pub type U609 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P609 = PInt\u003cU609\u003e; pub type N609 = NInt\u003cU609\u003e;\n    pub type U610 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P610 = PInt\u003cU610\u003e; pub type N610 = NInt\u003cU610\u003e;\n    pub type U611 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P611 = PInt\u003cU611\u003e; pub type N611 = NInt\u003cU611\u003e;\n    pub type U612 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P612 = PInt\u003cU612\u003e; pub type N612 = NInt\u003cU612\u003e;\n    pub type U613 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P613 = PInt\u003cU613\u003e; pub type N613 = NInt\u003cU613\u003e;\n    pub type U614 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P614 = PInt\u003cU614\u003e; pub type N614 = NInt\u003cU614\u003e;\n    pub type U615 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P615 = PInt\u003cU615\u003e; pub type N615 = NInt\u003cU615\u003e;\n    pub type U616 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P616 = PInt\u003cU616\u003e; pub type N616 = NInt\u003cU616\u003e;\n    pub type U617 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P617 = PInt\u003cU617\u003e; pub type N617 = NInt\u003cU617\u003e;\n    pub type U618 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P618 = PInt\u003cU618\u003e; pub type N618 = NInt\u003cU618\u003e;\n    pub type U619 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P619 = PInt\u003cU619\u003e; pub type N619 = NInt\u003cU619\u003e;\n    pub type U620 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P620 = PInt\u003cU620\u003e; pub type N620 = NInt\u003cU620\u003e;\n    pub type U621 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P621 = PInt\u003cU621\u003e; pub type N621 = NInt\u003cU621\u003e;\n    pub type U622 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P622 = PInt\u003cU622\u003e; pub type N622 = NInt\u003cU622\u003e;\n    pub type U623 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P623 = PInt\u003cU623\u003e; pub type N623 = NInt\u003cU623\u003e;\n    pub type U624 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P624 = PInt\u003cU624\u003e; pub type N624 = NInt\u003cU624\u003e;\n    pub type U625 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P625 = PInt\u003cU625\u003e; pub type N625 = NInt\u003cU625\u003e;\n    pub type U626 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P626 = PInt\u003cU626\u003e; pub type N626 = NInt\u003cU626\u003e;\n    pub type U627 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P627 = PInt\u003cU627\u003e; pub type N627 = NInt\u003cU627\u003e;\n    pub type U628 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P628 = PInt\u003cU628\u003e; pub type N628 = NInt\u003cU628\u003e;\n    pub type U629 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P629 = PInt\u003cU629\u003e; pub type N629 = NInt\u003cU629\u003e;\n    pub type U630 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P630 = PInt\u003cU630\u003e; pub type N630 = NInt\u003cU630\u003e;\n    pub type U631 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P631 = PInt\u003cU631\u003e; pub type N631 = NInt\u003cU631\u003e;\n    pub type U632 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P632 = PInt\u003cU632\u003e; pub type N632 = NInt\u003cU632\u003e;\n    pub type U633 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P633 = PInt\u003cU633\u003e; pub type N633 = NInt\u003cU633\u003e;\n    pub type U634 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P634 = PInt\u003cU634\u003e; pub type N634 = NInt\u003cU634\u003e;\n    pub type U635 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P635 = PInt\u003cU635\u003e; pub type N635 = NInt\u003cU635\u003e;\n    pub type U636 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P636 = PInt\u003cU636\u003e; pub type N636 = NInt\u003cU636\u003e;\n    pub type U637 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P637 = PInt\u003cU637\u003e; pub type N637 = NInt\u003cU637\u003e;\n    pub type U638 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P638 = PInt\u003cU638\u003e; pub type N638 = NInt\u003cU638\u003e;\n    pub type U639 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P639 = PInt\u003cU639\u003e; pub type N639 = NInt\u003cU639\u003e;\n    pub type U640 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P640 = PInt\u003cU640\u003e; pub type N640 = NInt\u003cU640\u003e;\n    pub type U641 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P641 = PInt\u003cU641\u003e; pub type N641 = NInt\u003cU641\u003e;\n    pub type U642 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P642 = PInt\u003cU642\u003e; pub type N642 = NInt\u003cU642\u003e;\n    pub type U643 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P643 = PInt\u003cU643\u003e; pub type N643 = NInt\u003cU643\u003e;\n    pub type U644 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P644 = PInt\u003cU644\u003e; pub type N644 = NInt\u003cU644\u003e;\n    pub type U645 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P645 = PInt\u003cU645\u003e; pub type N645 = NInt\u003cU645\u003e;\n    pub type U646 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P646 = PInt\u003cU646\u003e; pub type N646 = NInt\u003cU646\u003e;\n    pub type U647 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P647 = PInt\u003cU647\u003e; pub type N647 = NInt\u003cU647\u003e;\n    pub type U648 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P648 = PInt\u003cU648\u003e; pub type N648 = NInt\u003cU648\u003e;\n    pub type U649 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P649 = PInt\u003cU649\u003e; pub type N649 = NInt\u003cU649\u003e;\n    pub type U650 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P650 = PInt\u003cU650\u003e; pub type N650 = NInt\u003cU650\u003e;\n    pub type U651 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P651 = PInt\u003cU651\u003e; pub type N651 = NInt\u003cU651\u003e;\n    pub type U652 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P652 = PInt\u003cU652\u003e; pub type N652 = NInt\u003cU652\u003e;\n    pub type U653 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P653 = PInt\u003cU653\u003e; pub type N653 = NInt\u003cU653\u003e;\n    pub type U654 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P654 = PInt\u003cU654\u003e; pub type N654 = NInt\u003cU654\u003e;\n    pub type U655 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P655 = PInt\u003cU655\u003e; pub type N655 = NInt\u003cU655\u003e;\n    pub type U656 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P656 = PInt\u003cU656\u003e; pub type N656 = NInt\u003cU656\u003e;\n    pub type U657 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P657 = PInt\u003cU657\u003e; pub type N657 = NInt\u003cU657\u003e;\n    pub type U658 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P658 = PInt\u003cU658\u003e; pub type N658 = NInt\u003cU658\u003e;\n    pub type U659 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P659 = PInt\u003cU659\u003e; pub type N659 = NInt\u003cU659\u003e;\n    pub type U660 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P660 = PInt\u003cU660\u003e; pub type N660 = NInt\u003cU660\u003e;\n    pub type U661 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P661 = PInt\u003cU661\u003e; pub type N661 = NInt\u003cU661\u003e;\n    pub type U662 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P662 = PInt\u003cU662\u003e; pub type N662 = NInt\u003cU662\u003e;\n    pub type U663 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P663 = PInt\u003cU663\u003e; pub type N663 = NInt\u003cU663\u003e;\n    pub type U664 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P664 = PInt\u003cU664\u003e; pub type N664 = NInt\u003cU664\u003e;\n    pub type U665 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P665 = PInt\u003cU665\u003e; pub type N665 = NInt\u003cU665\u003e;\n    pub type U666 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P666 = PInt\u003cU666\u003e; pub type N666 = NInt\u003cU666\u003e;\n    pub type U667 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P667 = PInt\u003cU667\u003e; pub type N667 = NInt\u003cU667\u003e;\n    pub type U668 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P668 = PInt\u003cU668\u003e; pub type N668 = NInt\u003cU668\u003e;\n    pub type U669 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P669 = PInt\u003cU669\u003e; pub type N669 = NInt\u003cU669\u003e;\n    pub type U670 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P670 = PInt\u003cU670\u003e; pub type N670 = NInt\u003cU670\u003e;\n    pub type U671 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P671 = PInt\u003cU671\u003e; pub type N671 = NInt\u003cU671\u003e;\n    pub type U672 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P672 = PInt\u003cU672\u003e; pub type N672 = NInt\u003cU672\u003e;\n    pub type U673 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P673 = PInt\u003cU673\u003e; pub type N673 = NInt\u003cU673\u003e;\n    pub type U674 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P674 = PInt\u003cU674\u003e; pub type N674 = NInt\u003cU674\u003e;\n    pub type U675 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P675 = PInt\u003cU675\u003e; pub type N675 = NInt\u003cU675\u003e;\n    pub type U676 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P676 = PInt\u003cU676\u003e; pub type N676 = NInt\u003cU676\u003e;\n    pub type U677 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P677 = PInt\u003cU677\u003e; pub type N677 = NInt\u003cU677\u003e;\n    pub type U678 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P678 = PInt\u003cU678\u003e; pub type N678 = NInt\u003cU678\u003e;\n    pub type U679 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P679 = PInt\u003cU679\u003e; pub type N679 = NInt\u003cU679\u003e;\n    pub type U680 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P680 = PInt\u003cU680\u003e; pub type N680 = NInt\u003cU680\u003e;\n    pub type U681 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P681 = PInt\u003cU681\u003e; pub type N681 = NInt\u003cU681\u003e;\n    pub type U682 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P682 = PInt\u003cU682\u003e; pub type N682 = NInt\u003cU682\u003e;\n    pub type U683 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P683 = PInt\u003cU683\u003e; pub type N683 = NInt\u003cU683\u003e;\n    pub type U684 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P684 = PInt\u003cU684\u003e; pub type N684 = NInt\u003cU684\u003e;\n    pub type U685 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P685 = PInt\u003cU685\u003e; pub type N685 = NInt\u003cU685\u003e;\n    pub type U686 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P686 = PInt\u003cU686\u003e; pub type N686 = NInt\u003cU686\u003e;\n    pub type U687 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P687 = PInt\u003cU687\u003e; pub type N687 = NInt\u003cU687\u003e;\n    pub type U688 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P688 = PInt\u003cU688\u003e; pub type N688 = NInt\u003cU688\u003e;\n    pub type U689 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P689 = PInt\u003cU689\u003e; pub type N689 = NInt\u003cU689\u003e;\n    pub type U690 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P690 = PInt\u003cU690\u003e; pub type N690 = NInt\u003cU690\u003e;\n    pub type U691 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P691 = PInt\u003cU691\u003e; pub type N691 = NInt\u003cU691\u003e;\n    pub type U692 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P692 = PInt\u003cU692\u003e; pub type N692 = NInt\u003cU692\u003e;\n    pub type U693 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P693 = PInt\u003cU693\u003e; pub type N693 = NInt\u003cU693\u003e;\n    pub type U694 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P694 = PInt\u003cU694\u003e; pub type N694 = NInt\u003cU694\u003e;\n    pub type U695 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P695 = PInt\u003cU695\u003e; pub type N695 = NInt\u003cU695\u003e;\n    pub type U696 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P696 = PInt\u003cU696\u003e; pub type N696 = NInt\u003cU696\u003e;\n    pub type U697 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P697 = PInt\u003cU697\u003e; pub type N697 = NInt\u003cU697\u003e;\n    pub type U698 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P698 = PInt\u003cU698\u003e; pub type N698 = NInt\u003cU698\u003e;\n    pub type U699 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P699 = PInt\u003cU699\u003e; pub type N699 = NInt\u003cU699\u003e;\n    pub type U700 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P700 = PInt\u003cU700\u003e; pub type N700 = NInt\u003cU700\u003e;\n    pub type U701 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P701 = PInt\u003cU701\u003e; pub type N701 = NInt\u003cU701\u003e;\n    pub type U702 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P702 = PInt\u003cU702\u003e; pub type N702 = NInt\u003cU702\u003e;\n    pub type U703 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P703 = PInt\u003cU703\u003e; pub type N703 = NInt\u003cU703\u003e;\n    pub type U704 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P704 = PInt\u003cU704\u003e; pub type N704 = NInt\u003cU704\u003e;\n    pub type U705 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P705 = PInt\u003cU705\u003e; pub type N705 = NInt\u003cU705\u003e;\n    pub type U706 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P706 = PInt\u003cU706\u003e; pub type N706 = NInt\u003cU706\u003e;\n    pub type U707 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P707 = PInt\u003cU707\u003e; pub type N707 = NInt\u003cU707\u003e;\n    pub type U708 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P708 = PInt\u003cU708\u003e; pub type N708 = NInt\u003cU708\u003e;\n    pub type U709 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P709 = PInt\u003cU709\u003e; pub type N709 = NInt\u003cU709\u003e;\n    pub type U710 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P710 = PInt\u003cU710\u003e; pub type N710 = NInt\u003cU710\u003e;\n    pub type U711 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P711 = PInt\u003cU711\u003e; pub type N711 = NInt\u003cU711\u003e;\n    pub type U712 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P712 = PInt\u003cU712\u003e; pub type N712 = NInt\u003cU712\u003e;\n    pub type U713 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P713 = PInt\u003cU713\u003e; pub type N713 = NInt\u003cU713\u003e;\n    pub type U714 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P714 = PInt\u003cU714\u003e; pub type N714 = NInt\u003cU714\u003e;\n    pub type U715 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P715 = PInt\u003cU715\u003e; pub type N715 = NInt\u003cU715\u003e;\n    pub type U716 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P716 = PInt\u003cU716\u003e; pub type N716 = NInt\u003cU716\u003e;\n    pub type U717 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P717 = PInt\u003cU717\u003e; pub type N717 = NInt\u003cU717\u003e;\n    pub type U718 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P718 = PInt\u003cU718\u003e; pub type N718 = NInt\u003cU718\u003e;\n    pub type U719 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P719 = PInt\u003cU719\u003e; pub type N719 = NInt\u003cU719\u003e;\n    pub type U720 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P720 = PInt\u003cU720\u003e; pub type N720 = NInt\u003cU720\u003e;\n    pub type U721 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P721 = PInt\u003cU721\u003e; pub type N721 = NInt\u003cU721\u003e;\n    pub type U722 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P722 = PInt\u003cU722\u003e; pub type N722 = NInt\u003cU722\u003e;\n    pub type U723 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P723 = PInt\u003cU723\u003e; pub type N723 = NInt\u003cU723\u003e;\n    pub type U724 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P724 = PInt\u003cU724\u003e; pub type N724 = NInt\u003cU724\u003e;\n    pub type U725 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P725 = PInt\u003cU725\u003e; pub type N725 = NInt\u003cU725\u003e;\n    pub type U726 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P726 = PInt\u003cU726\u003e; pub type N726 = NInt\u003cU726\u003e;\n    pub type U727 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P727 = PInt\u003cU727\u003e; pub type N727 = NInt\u003cU727\u003e;\n    pub type U728 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P728 = PInt\u003cU728\u003e; pub type N728 = NInt\u003cU728\u003e;\n    pub type U729 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P729 = PInt\u003cU729\u003e; pub type N729 = NInt\u003cU729\u003e;\n    pub type U730 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P730 = PInt\u003cU730\u003e; pub type N730 = NInt\u003cU730\u003e;\n    pub type U731 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P731 = PInt\u003cU731\u003e; pub type N731 = NInt\u003cU731\u003e;\n    pub type U732 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P732 = PInt\u003cU732\u003e; pub type N732 = NInt\u003cU732\u003e;\n    pub type U733 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P733 = PInt\u003cU733\u003e; pub type N733 = NInt\u003cU733\u003e;\n    pub type U734 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P734 = PInt\u003cU734\u003e; pub type N734 = NInt\u003cU734\u003e;\n    pub type U735 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P735 = PInt\u003cU735\u003e; pub type N735 = NInt\u003cU735\u003e;\n    pub type U736 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P736 = PInt\u003cU736\u003e; pub type N736 = NInt\u003cU736\u003e;\n    pub type U737 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P737 = PInt\u003cU737\u003e; pub type N737 = NInt\u003cU737\u003e;\n    pub type U738 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P738 = PInt\u003cU738\u003e; pub type N738 = NInt\u003cU738\u003e;\n    pub type U739 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P739 = PInt\u003cU739\u003e; pub type N739 = NInt\u003cU739\u003e;\n    pub type U740 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P740 = PInt\u003cU740\u003e; pub type N740 = NInt\u003cU740\u003e;\n    pub type U741 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P741 = PInt\u003cU741\u003e; pub type N741 = NInt\u003cU741\u003e;\n    pub type U742 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P742 = PInt\u003cU742\u003e; pub type N742 = NInt\u003cU742\u003e;\n    pub type U743 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P743 = PInt\u003cU743\u003e; pub type N743 = NInt\u003cU743\u003e;\n    pub type U744 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P744 = PInt\u003cU744\u003e; pub type N744 = NInt\u003cU744\u003e;\n    pub type U745 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P745 = PInt\u003cU745\u003e; pub type N745 = NInt\u003cU745\u003e;\n    pub type U746 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P746 = PInt\u003cU746\u003e; pub type N746 = NInt\u003cU746\u003e;\n    pub type U747 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P747 = PInt\u003cU747\u003e; pub type N747 = NInt\u003cU747\u003e;\n    pub type U748 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P748 = PInt\u003cU748\u003e; pub type N748 = NInt\u003cU748\u003e;\n    pub type U749 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P749 = PInt\u003cU749\u003e; pub type N749 = NInt\u003cU749\u003e;\n    pub type U750 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P750 = PInt\u003cU750\u003e; pub type N750 = NInt\u003cU750\u003e;\n    pub type U751 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P751 = PInt\u003cU751\u003e; pub type N751 = NInt\u003cU751\u003e;\n    pub type U752 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P752 = PInt\u003cU752\u003e; pub type N752 = NInt\u003cU752\u003e;\n    pub type U753 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P753 = PInt\u003cU753\u003e; pub type N753 = NInt\u003cU753\u003e;\n    pub type U754 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P754 = PInt\u003cU754\u003e; pub type N754 = NInt\u003cU754\u003e;\n    pub type U755 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P755 = PInt\u003cU755\u003e; pub type N755 = NInt\u003cU755\u003e;\n    pub type U756 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P756 = PInt\u003cU756\u003e; pub type N756 = NInt\u003cU756\u003e;\n    pub type U757 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P757 = PInt\u003cU757\u003e; pub type N757 = NInt\u003cU757\u003e;\n    pub type U758 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P758 = PInt\u003cU758\u003e; pub type N758 = NInt\u003cU758\u003e;\n    pub type U759 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P759 = PInt\u003cU759\u003e; pub type N759 = NInt\u003cU759\u003e;\n    pub type U760 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P760 = PInt\u003cU760\u003e; pub type N760 = NInt\u003cU760\u003e;\n    pub type U761 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P761 = PInt\u003cU761\u003e; pub type N761 = NInt\u003cU761\u003e;\n    pub type U762 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P762 = PInt\u003cU762\u003e; pub type N762 = NInt\u003cU762\u003e;\n    pub type U763 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P763 = PInt\u003cU763\u003e; pub type N763 = NInt\u003cU763\u003e;\n    pub type U764 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P764 = PInt\u003cU764\u003e; pub type N764 = NInt\u003cU764\u003e;\n    pub type U765 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P765 = PInt\u003cU765\u003e; pub type N765 = NInt\u003cU765\u003e;\n    pub type U766 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P766 = PInt\u003cU766\u003e; pub type N766 = NInt\u003cU766\u003e;\n    pub type U767 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P767 = PInt\u003cU767\u003e; pub type N767 = NInt\u003cU767\u003e;\n    pub type U768 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P768 = PInt\u003cU768\u003e; pub type N768 = NInt\u003cU768\u003e;\n    pub type U769 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P769 = PInt\u003cU769\u003e; pub type N769 = NInt\u003cU769\u003e;\n    pub type U770 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P770 = PInt\u003cU770\u003e; pub type N770 = NInt\u003cU770\u003e;\n    pub type U771 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P771 = PInt\u003cU771\u003e; pub type N771 = NInt\u003cU771\u003e;\n    pub type U772 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P772 = PInt\u003cU772\u003e; pub type N772 = NInt\u003cU772\u003e;\n    pub type U773 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P773 = PInt\u003cU773\u003e; pub type N773 = NInt\u003cU773\u003e;\n    pub type U774 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P774 = PInt\u003cU774\u003e; pub type N774 = NInt\u003cU774\u003e;\n    pub type U775 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P775 = PInt\u003cU775\u003e; pub type N775 = NInt\u003cU775\u003e;\n    pub type U776 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P776 = PInt\u003cU776\u003e; pub type N776 = NInt\u003cU776\u003e;\n    pub type U777 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P777 = PInt\u003cU777\u003e; pub type N777 = NInt\u003cU777\u003e;\n    pub type U778 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P778 = PInt\u003cU778\u003e; pub type N778 = NInt\u003cU778\u003e;\n    pub type U779 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P779 = PInt\u003cU779\u003e; pub type N779 = NInt\u003cU779\u003e;\n    pub type U780 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P780 = PInt\u003cU780\u003e; pub type N780 = NInt\u003cU780\u003e;\n    pub type U781 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P781 = PInt\u003cU781\u003e; pub type N781 = NInt\u003cU781\u003e;\n    pub type U782 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P782 = PInt\u003cU782\u003e; pub type N782 = NInt\u003cU782\u003e;\n    pub type U783 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P783 = PInt\u003cU783\u003e; pub type N783 = NInt\u003cU783\u003e;\n    pub type U784 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P784 = PInt\u003cU784\u003e; pub type N784 = NInt\u003cU784\u003e;\n    pub type U785 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P785 = PInt\u003cU785\u003e; pub type N785 = NInt\u003cU785\u003e;\n    pub type U786 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P786 = PInt\u003cU786\u003e; pub type N786 = NInt\u003cU786\u003e;\n    pub type U787 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P787 = PInt\u003cU787\u003e; pub type N787 = NInt\u003cU787\u003e;\n    pub type U788 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P788 = PInt\u003cU788\u003e; pub type N788 = NInt\u003cU788\u003e;\n    pub type U789 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P789 = PInt\u003cU789\u003e; pub type N789 = NInt\u003cU789\u003e;\n    pub type U790 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P790 = PInt\u003cU790\u003e; pub type N790 = NInt\u003cU790\u003e;\n    pub type U791 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P791 = PInt\u003cU791\u003e; pub type N791 = NInt\u003cU791\u003e;\n    pub type U792 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P792 = PInt\u003cU792\u003e; pub type N792 = NInt\u003cU792\u003e;\n    pub type U793 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P793 = PInt\u003cU793\u003e; pub type N793 = NInt\u003cU793\u003e;\n    pub type U794 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P794 = PInt\u003cU794\u003e; pub type N794 = NInt\u003cU794\u003e;\n    pub type U795 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P795 = PInt\u003cU795\u003e; pub type N795 = NInt\u003cU795\u003e;\n    pub type U796 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P796 = PInt\u003cU796\u003e; pub type N796 = NInt\u003cU796\u003e;\n    pub type U797 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P797 = PInt\u003cU797\u003e; pub type N797 = NInt\u003cU797\u003e;\n    pub type U798 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P798 = PInt\u003cU798\u003e; pub type N798 = NInt\u003cU798\u003e;\n    pub type U799 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P799 = PInt\u003cU799\u003e; pub type N799 = NInt\u003cU799\u003e;\n    pub type U800 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P800 = PInt\u003cU800\u003e; pub type N800 = NInt\u003cU800\u003e;\n    pub type U801 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P801 = PInt\u003cU801\u003e; pub type N801 = NInt\u003cU801\u003e;\n    pub type U802 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P802 = PInt\u003cU802\u003e; pub type N802 = NInt\u003cU802\u003e;\n    pub type U803 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P803 = PInt\u003cU803\u003e; pub type N803 = NInt\u003cU803\u003e;\n    pub type U804 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P804 = PInt\u003cU804\u003e; pub type N804 = NInt\u003cU804\u003e;\n    pub type U805 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P805 = PInt\u003cU805\u003e; pub type N805 = NInt\u003cU805\u003e;\n    pub type U806 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P806 = PInt\u003cU806\u003e; pub type N806 = NInt\u003cU806\u003e;\n    pub type U807 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P807 = PInt\u003cU807\u003e; pub type N807 = NInt\u003cU807\u003e;\n    pub type U808 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P808 = PInt\u003cU808\u003e; pub type N808 = NInt\u003cU808\u003e;\n    pub type U809 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P809 = PInt\u003cU809\u003e; pub type N809 = NInt\u003cU809\u003e;\n    pub type U810 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P810 = PInt\u003cU810\u003e; pub type N810 = NInt\u003cU810\u003e;\n    pub type U811 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P811 = PInt\u003cU811\u003e; pub type N811 = NInt\u003cU811\u003e;\n    pub type U812 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P812 = PInt\u003cU812\u003e; pub type N812 = NInt\u003cU812\u003e;\n    pub type U813 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P813 = PInt\u003cU813\u003e; pub type N813 = NInt\u003cU813\u003e;\n    pub type U814 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P814 = PInt\u003cU814\u003e; pub type N814 = NInt\u003cU814\u003e;\n    pub type U815 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P815 = PInt\u003cU815\u003e; pub type N815 = NInt\u003cU815\u003e;\n    pub type U816 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P816 = PInt\u003cU816\u003e; pub type N816 = NInt\u003cU816\u003e;\n    pub type U817 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P817 = PInt\u003cU817\u003e; pub type N817 = NInt\u003cU817\u003e;\n    pub type U818 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P818 = PInt\u003cU818\u003e; pub type N818 = NInt\u003cU818\u003e;\n    pub type U819 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P819 = PInt\u003cU819\u003e; pub type N819 = NInt\u003cU819\u003e;\n    pub type U820 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P820 = PInt\u003cU820\u003e; pub type N820 = NInt\u003cU820\u003e;\n    pub type U821 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P821 = PInt\u003cU821\u003e; pub type N821 = NInt\u003cU821\u003e;\n    pub type U822 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P822 = PInt\u003cU822\u003e; pub type N822 = NInt\u003cU822\u003e;\n    pub type U823 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P823 = PInt\u003cU823\u003e; pub type N823 = NInt\u003cU823\u003e;\n    pub type U824 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P824 = PInt\u003cU824\u003e; pub type N824 = NInt\u003cU824\u003e;\n    pub type U825 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P825 = PInt\u003cU825\u003e; pub type N825 = NInt\u003cU825\u003e;\n    pub type U826 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P826 = PInt\u003cU826\u003e; pub type N826 = NInt\u003cU826\u003e;\n    pub type U827 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P827 = PInt\u003cU827\u003e; pub type N827 = NInt\u003cU827\u003e;\n    pub type U828 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P828 = PInt\u003cU828\u003e; pub type N828 = NInt\u003cU828\u003e;\n    pub type U829 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P829 = PInt\u003cU829\u003e; pub type N829 = NInt\u003cU829\u003e;\n    pub type U830 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P830 = PInt\u003cU830\u003e; pub type N830 = NInt\u003cU830\u003e;\n    pub type U831 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P831 = PInt\u003cU831\u003e; pub type N831 = NInt\u003cU831\u003e;\n    pub type U832 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P832 = PInt\u003cU832\u003e; pub type N832 = NInt\u003cU832\u003e;\n    pub type U833 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P833 = PInt\u003cU833\u003e; pub type N833 = NInt\u003cU833\u003e;\n    pub type U834 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P834 = PInt\u003cU834\u003e; pub type N834 = NInt\u003cU834\u003e;\n    pub type U835 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P835 = PInt\u003cU835\u003e; pub type N835 = NInt\u003cU835\u003e;\n    pub type U836 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P836 = PInt\u003cU836\u003e; pub type N836 = NInt\u003cU836\u003e;\n    pub type U837 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P837 = PInt\u003cU837\u003e; pub type N837 = NInt\u003cU837\u003e;\n    pub type U838 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P838 = PInt\u003cU838\u003e; pub type N838 = NInt\u003cU838\u003e;\n    pub type U839 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P839 = PInt\u003cU839\u003e; pub type N839 = NInt\u003cU839\u003e;\n    pub type U840 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P840 = PInt\u003cU840\u003e; pub type N840 = NInt\u003cU840\u003e;\n    pub type U841 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P841 = PInt\u003cU841\u003e; pub type N841 = NInt\u003cU841\u003e;\n    pub type U842 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P842 = PInt\u003cU842\u003e; pub type N842 = NInt\u003cU842\u003e;\n    pub type U843 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P843 = PInt\u003cU843\u003e; pub type N843 = NInt\u003cU843\u003e;\n    pub type U844 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P844 = PInt\u003cU844\u003e; pub type N844 = NInt\u003cU844\u003e;\n    pub type U845 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P845 = PInt\u003cU845\u003e; pub type N845 = NInt\u003cU845\u003e;\n    pub type U846 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P846 = PInt\u003cU846\u003e; pub type N846 = NInt\u003cU846\u003e;\n    pub type U847 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P847 = PInt\u003cU847\u003e; pub type N847 = NInt\u003cU847\u003e;\n    pub type U848 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P848 = PInt\u003cU848\u003e; pub type N848 = NInt\u003cU848\u003e;\n    pub type U849 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P849 = PInt\u003cU849\u003e; pub type N849 = NInt\u003cU849\u003e;\n    pub type U850 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P850 = PInt\u003cU850\u003e; pub type N850 = NInt\u003cU850\u003e;\n    pub type U851 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P851 = PInt\u003cU851\u003e; pub type N851 = NInt\u003cU851\u003e;\n    pub type U852 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P852 = PInt\u003cU852\u003e; pub type N852 = NInt\u003cU852\u003e;\n    pub type U853 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P853 = PInt\u003cU853\u003e; pub type N853 = NInt\u003cU853\u003e;\n    pub type U854 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P854 = PInt\u003cU854\u003e; pub type N854 = NInt\u003cU854\u003e;\n    pub type U855 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P855 = PInt\u003cU855\u003e; pub type N855 = NInt\u003cU855\u003e;\n    pub type U856 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P856 = PInt\u003cU856\u003e; pub type N856 = NInt\u003cU856\u003e;\n    pub type U857 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P857 = PInt\u003cU857\u003e; pub type N857 = NInt\u003cU857\u003e;\n    pub type U858 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P858 = PInt\u003cU858\u003e; pub type N858 = NInt\u003cU858\u003e;\n    pub type U859 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P859 = PInt\u003cU859\u003e; pub type N859 = NInt\u003cU859\u003e;\n    pub type U860 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P860 = PInt\u003cU860\u003e; pub type N860 = NInt\u003cU860\u003e;\n    pub type U861 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P861 = PInt\u003cU861\u003e; pub type N861 = NInt\u003cU861\u003e;\n    pub type U862 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P862 = PInt\u003cU862\u003e; pub type N862 = NInt\u003cU862\u003e;\n    pub type U863 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P863 = PInt\u003cU863\u003e; pub type N863 = NInt\u003cU863\u003e;\n    pub type U864 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P864 = PInt\u003cU864\u003e; pub type N864 = NInt\u003cU864\u003e;\n    pub type U865 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P865 = PInt\u003cU865\u003e; pub type N865 = NInt\u003cU865\u003e;\n    pub type U866 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P866 = PInt\u003cU866\u003e; pub type N866 = NInt\u003cU866\u003e;\n    pub type U867 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P867 = PInt\u003cU867\u003e; pub type N867 = NInt\u003cU867\u003e;\n    pub type U868 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P868 = PInt\u003cU868\u003e; pub type N868 = NInt\u003cU868\u003e;\n    pub type U869 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P869 = PInt\u003cU869\u003e; pub type N869 = NInt\u003cU869\u003e;\n    pub type U870 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P870 = PInt\u003cU870\u003e; pub type N870 = NInt\u003cU870\u003e;\n    pub type U871 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P871 = PInt\u003cU871\u003e; pub type N871 = NInt\u003cU871\u003e;\n    pub type U872 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P872 = PInt\u003cU872\u003e; pub type N872 = NInt\u003cU872\u003e;\n    pub type U873 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P873 = PInt\u003cU873\u003e; pub type N873 = NInt\u003cU873\u003e;\n    pub type U874 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P874 = PInt\u003cU874\u003e; pub type N874 = NInt\u003cU874\u003e;\n    pub type U875 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P875 = PInt\u003cU875\u003e; pub type N875 = NInt\u003cU875\u003e;\n    pub type U876 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P876 = PInt\u003cU876\u003e; pub type N876 = NInt\u003cU876\u003e;\n    pub type U877 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P877 = PInt\u003cU877\u003e; pub type N877 = NInt\u003cU877\u003e;\n    pub type U878 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P878 = PInt\u003cU878\u003e; pub type N878 = NInt\u003cU878\u003e;\n    pub type U879 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P879 = PInt\u003cU879\u003e; pub type N879 = NInt\u003cU879\u003e;\n    pub type U880 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P880 = PInt\u003cU880\u003e; pub type N880 = NInt\u003cU880\u003e;\n    pub type U881 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P881 = PInt\u003cU881\u003e; pub type N881 = NInt\u003cU881\u003e;\n    pub type U882 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P882 = PInt\u003cU882\u003e; pub type N882 = NInt\u003cU882\u003e;\n    pub type U883 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P883 = PInt\u003cU883\u003e; pub type N883 = NInt\u003cU883\u003e;\n    pub type U884 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P884 = PInt\u003cU884\u003e; pub type N884 = NInt\u003cU884\u003e;\n    pub type U885 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P885 = PInt\u003cU885\u003e; pub type N885 = NInt\u003cU885\u003e;\n    pub type U886 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P886 = PInt\u003cU886\u003e; pub type N886 = NInt\u003cU886\u003e;\n    pub type U887 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P887 = PInt\u003cU887\u003e; pub type N887 = NInt\u003cU887\u003e;\n    pub type U888 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P888 = PInt\u003cU888\u003e; pub type N888 = NInt\u003cU888\u003e;\n    pub type U889 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P889 = PInt\u003cU889\u003e; pub type N889 = NInt\u003cU889\u003e;\n    pub type U890 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P890 = PInt\u003cU890\u003e; pub type N890 = NInt\u003cU890\u003e;\n    pub type U891 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P891 = PInt\u003cU891\u003e; pub type N891 = NInt\u003cU891\u003e;\n    pub type U892 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P892 = PInt\u003cU892\u003e; pub type N892 = NInt\u003cU892\u003e;\n    pub type U893 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P893 = PInt\u003cU893\u003e; pub type N893 = NInt\u003cU893\u003e;\n    pub type U894 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P894 = PInt\u003cU894\u003e; pub type N894 = NInt\u003cU894\u003e;\n    pub type U895 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P895 = PInt\u003cU895\u003e; pub type N895 = NInt\u003cU895\u003e;\n    pub type U896 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P896 = PInt\u003cU896\u003e; pub type N896 = NInt\u003cU896\u003e;\n    pub type U897 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P897 = PInt\u003cU897\u003e; pub type N897 = NInt\u003cU897\u003e;\n    pub type U898 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P898 = PInt\u003cU898\u003e; pub type N898 = NInt\u003cU898\u003e;\n    pub type U899 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P899 = PInt\u003cU899\u003e; pub type N899 = NInt\u003cU899\u003e;\n    pub type U900 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P900 = PInt\u003cU900\u003e; pub type N900 = NInt\u003cU900\u003e;\n    pub type U901 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P901 = PInt\u003cU901\u003e; pub type N901 = NInt\u003cU901\u003e;\n    pub type U902 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P902 = PInt\u003cU902\u003e; pub type N902 = NInt\u003cU902\u003e;\n    pub type U903 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P903 = PInt\u003cU903\u003e; pub type N903 = NInt\u003cU903\u003e;\n    pub type U904 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P904 = PInt\u003cU904\u003e; pub type N904 = NInt\u003cU904\u003e;\n    pub type U905 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P905 = PInt\u003cU905\u003e; pub type N905 = NInt\u003cU905\u003e;\n    pub type U906 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P906 = PInt\u003cU906\u003e; pub type N906 = NInt\u003cU906\u003e;\n    pub type U907 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P907 = PInt\u003cU907\u003e; pub type N907 = NInt\u003cU907\u003e;\n    pub type U908 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P908 = PInt\u003cU908\u003e; pub type N908 = NInt\u003cU908\u003e;\n    pub type U909 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P909 = PInt\u003cU909\u003e; pub type N909 = NInt\u003cU909\u003e;\n    pub type U910 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P910 = PInt\u003cU910\u003e; pub type N910 = NInt\u003cU910\u003e;\n    pub type U911 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P911 = PInt\u003cU911\u003e; pub type N911 = NInt\u003cU911\u003e;\n    pub type U912 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P912 = PInt\u003cU912\u003e; pub type N912 = NInt\u003cU912\u003e;\n    pub type U913 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P913 = PInt\u003cU913\u003e; pub type N913 = NInt\u003cU913\u003e;\n    pub type U914 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P914 = PInt\u003cU914\u003e; pub type N914 = NInt\u003cU914\u003e;\n    pub type U915 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P915 = PInt\u003cU915\u003e; pub type N915 = NInt\u003cU915\u003e;\n    pub type U916 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P916 = PInt\u003cU916\u003e; pub type N916 = NInt\u003cU916\u003e;\n    pub type U917 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P917 = PInt\u003cU917\u003e; pub type N917 = NInt\u003cU917\u003e;\n    pub type U918 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P918 = PInt\u003cU918\u003e; pub type N918 = NInt\u003cU918\u003e;\n    pub type U919 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P919 = PInt\u003cU919\u003e; pub type N919 = NInt\u003cU919\u003e;\n    pub type U920 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P920 = PInt\u003cU920\u003e; pub type N920 = NInt\u003cU920\u003e;\n    pub type U921 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P921 = PInt\u003cU921\u003e; pub type N921 = NInt\u003cU921\u003e;\n    pub type U922 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P922 = PInt\u003cU922\u003e; pub type N922 = NInt\u003cU922\u003e;\n    pub type U923 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P923 = PInt\u003cU923\u003e; pub type N923 = NInt\u003cU923\u003e;\n    pub type U924 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P924 = PInt\u003cU924\u003e; pub type N924 = NInt\u003cU924\u003e;\n    pub type U925 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P925 = PInt\u003cU925\u003e; pub type N925 = NInt\u003cU925\u003e;\n    pub type U926 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P926 = PInt\u003cU926\u003e; pub type N926 = NInt\u003cU926\u003e;\n    pub type U927 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P927 = PInt\u003cU927\u003e; pub type N927 = NInt\u003cU927\u003e;\n    pub type U928 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P928 = PInt\u003cU928\u003e; pub type N928 = NInt\u003cU928\u003e;\n    pub type U929 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P929 = PInt\u003cU929\u003e; pub type N929 = NInt\u003cU929\u003e;\n    pub type U930 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P930 = PInt\u003cU930\u003e; pub type N930 = NInt\u003cU930\u003e;\n    pub type U931 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P931 = PInt\u003cU931\u003e; pub type N931 = NInt\u003cU931\u003e;\n    pub type U932 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P932 = PInt\u003cU932\u003e; pub type N932 = NInt\u003cU932\u003e;\n    pub type U933 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P933 = PInt\u003cU933\u003e; pub type N933 = NInt\u003cU933\u003e;\n    pub type U934 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P934 = PInt\u003cU934\u003e; pub type N934 = NInt\u003cU934\u003e;\n    pub type U935 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P935 = PInt\u003cU935\u003e; pub type N935 = NInt\u003cU935\u003e;\n    pub type U936 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P936 = PInt\u003cU936\u003e; pub type N936 = NInt\u003cU936\u003e;\n    pub type U937 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P937 = PInt\u003cU937\u003e; pub type N937 = NInt\u003cU937\u003e;\n    pub type U938 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P938 = PInt\u003cU938\u003e; pub type N938 = NInt\u003cU938\u003e;\n    pub type U939 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P939 = PInt\u003cU939\u003e; pub type N939 = NInt\u003cU939\u003e;\n    pub type U940 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P940 = PInt\u003cU940\u003e; pub type N940 = NInt\u003cU940\u003e;\n    pub type U941 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P941 = PInt\u003cU941\u003e; pub type N941 = NInt\u003cU941\u003e;\n    pub type U942 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P942 = PInt\u003cU942\u003e; pub type N942 = NInt\u003cU942\u003e;\n    pub type U943 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P943 = PInt\u003cU943\u003e; pub type N943 = NInt\u003cU943\u003e;\n    pub type U944 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P944 = PInt\u003cU944\u003e; pub type N944 = NInt\u003cU944\u003e;\n    pub type U945 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P945 = PInt\u003cU945\u003e; pub type N945 = NInt\u003cU945\u003e;\n    pub type U946 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P946 = PInt\u003cU946\u003e; pub type N946 = NInt\u003cU946\u003e;\n    pub type U947 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P947 = PInt\u003cU947\u003e; pub type N947 = NInt\u003cU947\u003e;\n    pub type U948 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P948 = PInt\u003cU948\u003e; pub type N948 = NInt\u003cU948\u003e;\n    pub type U949 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P949 = PInt\u003cU949\u003e; pub type N949 = NInt\u003cU949\u003e;\n    pub type U950 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P950 = PInt\u003cU950\u003e; pub type N950 = NInt\u003cU950\u003e;\n    pub type U951 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P951 = PInt\u003cU951\u003e; pub type N951 = NInt\u003cU951\u003e;\n    pub type U952 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P952 = PInt\u003cU952\u003e; pub type N952 = NInt\u003cU952\u003e;\n    pub type U953 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P953 = PInt\u003cU953\u003e; pub type N953 = NInt\u003cU953\u003e;\n    pub type U954 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P954 = PInt\u003cU954\u003e; pub type N954 = NInt\u003cU954\u003e;\n    pub type U955 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P955 = PInt\u003cU955\u003e; pub type N955 = NInt\u003cU955\u003e;\n    pub type U956 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P956 = PInt\u003cU956\u003e; pub type N956 = NInt\u003cU956\u003e;\n    pub type U957 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P957 = PInt\u003cU957\u003e; pub type N957 = NInt\u003cU957\u003e;\n    pub type U958 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P958 = PInt\u003cU958\u003e; pub type N958 = NInt\u003cU958\u003e;\n    pub type U959 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P959 = PInt\u003cU959\u003e; pub type N959 = NInt\u003cU959\u003e;\n    pub type U960 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P960 = PInt\u003cU960\u003e; pub type N960 = NInt\u003cU960\u003e;\n    pub type U961 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P961 = PInt\u003cU961\u003e; pub type N961 = NInt\u003cU961\u003e;\n    pub type U962 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P962 = PInt\u003cU962\u003e; pub type N962 = NInt\u003cU962\u003e;\n    pub type U963 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P963 = PInt\u003cU963\u003e; pub type N963 = NInt\u003cU963\u003e;\n    pub type U964 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P964 = PInt\u003cU964\u003e; pub type N964 = NInt\u003cU964\u003e;\n    pub type U965 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P965 = PInt\u003cU965\u003e; pub type N965 = NInt\u003cU965\u003e;\n    pub type U966 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P966 = PInt\u003cU966\u003e; pub type N966 = NInt\u003cU966\u003e;\n    pub type U967 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P967 = PInt\u003cU967\u003e; pub type N967 = NInt\u003cU967\u003e;\n    pub type U968 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P968 = PInt\u003cU968\u003e; pub type N968 = NInt\u003cU968\u003e;\n    pub type U969 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P969 = PInt\u003cU969\u003e; pub type N969 = NInt\u003cU969\u003e;\n    pub type U970 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P970 = PInt\u003cU970\u003e; pub type N970 = NInt\u003cU970\u003e;\n    pub type U971 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P971 = PInt\u003cU971\u003e; pub type N971 = NInt\u003cU971\u003e;\n    pub type U972 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P972 = PInt\u003cU972\u003e; pub type N972 = NInt\u003cU972\u003e;\n    pub type U973 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P973 = PInt\u003cU973\u003e; pub type N973 = NInt\u003cU973\u003e;\n    pub type U974 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P974 = PInt\u003cU974\u003e; pub type N974 = NInt\u003cU974\u003e;\n    pub type U975 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P975 = PInt\u003cU975\u003e; pub type N975 = NInt\u003cU975\u003e;\n    pub type U976 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P976 = PInt\u003cU976\u003e; pub type N976 = NInt\u003cU976\u003e;\n    pub type U977 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P977 = PInt\u003cU977\u003e; pub type N977 = NInt\u003cU977\u003e;\n    pub type U978 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P978 = PInt\u003cU978\u003e; pub type N978 = NInt\u003cU978\u003e;\n    pub type U979 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P979 = PInt\u003cU979\u003e; pub type N979 = NInt\u003cU979\u003e;\n    pub type U980 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P980 = PInt\u003cU980\u003e; pub type N980 = NInt\u003cU980\u003e;\n    pub type U981 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P981 = PInt\u003cU981\u003e; pub type N981 = NInt\u003cU981\u003e;\n    pub type U982 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P982 = PInt\u003cU982\u003e; pub type N982 = NInt\u003cU982\u003e;\n    pub type U983 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P983 = PInt\u003cU983\u003e; pub type N983 = NInt\u003cU983\u003e;\n    pub type U984 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P984 = PInt\u003cU984\u003e; pub type N984 = NInt\u003cU984\u003e;\n    pub type U985 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P985 = PInt\u003cU985\u003e; pub type N985 = NInt\u003cU985\u003e;\n    pub type U986 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P986 = PInt\u003cU986\u003e; pub type N986 = NInt\u003cU986\u003e;\n    pub type U987 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P987 = PInt\u003cU987\u003e; pub type N987 = NInt\u003cU987\u003e;\n    pub type U988 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P988 = PInt\u003cU988\u003e; pub type N988 = NInt\u003cU988\u003e;\n    pub type U989 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P989 = PInt\u003cU989\u003e; pub type N989 = NInt\u003cU989\u003e;\n    pub type U990 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P990 = PInt\u003cU990\u003e; pub type N990 = NInt\u003cU990\u003e;\n    pub type U991 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P991 = PInt\u003cU991\u003e; pub type N991 = NInt\u003cU991\u003e;\n    pub type U992 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P992 = PInt\u003cU992\u003e; pub type N992 = NInt\u003cU992\u003e;\n    pub type U993 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P993 = PInt\u003cU993\u003e; pub type N993 = NInt\u003cU993\u003e;\n    pub type U994 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P994 = PInt\u003cU994\u003e; pub type N994 = NInt\u003cU994\u003e;\n    pub type U995 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P995 = PInt\u003cU995\u003e; pub type N995 = NInt\u003cU995\u003e;\n    pub type U996 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P996 = PInt\u003cU996\u003e; pub type N996 = NInt\u003cU996\u003e;\n    pub type U997 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P997 = PInt\u003cU997\u003e; pub type N997 = NInt\u003cU997\u003e;\n    pub type U998 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P998 = PInt\u003cU998\u003e; pub type N998 = NInt\u003cU998\u003e;\n    pub type U999 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P999 = PInt\u003cU999\u003e; pub type N999 = NInt\u003cU999\u003e;\n    pub type U1000 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P1000 = PInt\u003cU1000\u003e; pub type N1000 = NInt\u003cU1000\u003e;\n    pub type U1001 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P1001 = PInt\u003cU1001\u003e; pub type N1001 = NInt\u003cU1001\u003e;\n    pub type U1002 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P1002 = PInt\u003cU1002\u003e; pub type N1002 = NInt\u003cU1002\u003e;\n    pub type U1003 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P1003 = PInt\u003cU1003\u003e; pub type N1003 = NInt\u003cU1003\u003e;\n    pub type U1004 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P1004 = PInt\u003cU1004\u003e; pub type N1004 = NInt\u003cU1004\u003e;\n    pub type U1005 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P1005 = PInt\u003cU1005\u003e; pub type N1005 = NInt\u003cU1005\u003e;\n    pub type U1006 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P1006 = PInt\u003cU1006\u003e; pub type N1006 = NInt\u003cU1006\u003e;\n    pub type U1007 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P1007 = PInt\u003cU1007\u003e; pub type N1007 = NInt\u003cU1007\u003e;\n    pub type U1008 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P1008 = PInt\u003cU1008\u003e; pub type N1008 = NInt\u003cU1008\u003e;\n    pub type U1009 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P1009 = PInt\u003cU1009\u003e; pub type N1009 = NInt\u003cU1009\u003e;\n    pub type U1010 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P1010 = PInt\u003cU1010\u003e; pub type N1010 = NInt\u003cU1010\u003e;\n    pub type U1011 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P1011 = PInt\u003cU1011\u003e; pub type N1011 = NInt\u003cU1011\u003e;\n    pub type U1012 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P1012 = PInt\u003cU1012\u003e; pub type N1012 = NInt\u003cU1012\u003e;\n    pub type U1013 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P1013 = PInt\u003cU1013\u003e; pub type N1013 = NInt\u003cU1013\u003e;\n    pub type U1014 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P1014 = PInt\u003cU1014\u003e; pub type N1014 = NInt\u003cU1014\u003e;\n    pub type U1015 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P1015 = PInt\u003cU1015\u003e; pub type N1015 = NInt\u003cU1015\u003e;\n    pub type U1016 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P1016 = PInt\u003cU1016\u003e; pub type N1016 = NInt\u003cU1016\u003e;\n    pub type U1017 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P1017 = PInt\u003cU1017\u003e; pub type N1017 = NInt\u003cU1017\u003e;\n    pub type U1018 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P1018 = PInt\u003cU1018\u003e; pub type N1018 = NInt\u003cU1018\u003e;\n    pub type U1019 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P1019 = PInt\u003cU1019\u003e; pub type N1019 = NInt\u003cU1019\u003e;\n    pub type U1020 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P1020 = PInt\u003cU1020\u003e; pub type N1020 = NInt\u003cU1020\u003e;\n    pub type U1021 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P1021 = PInt\u003cU1021\u003e; pub type N1021 = NInt\u003cU1021\u003e;\n    pub type U1022 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P1022 = PInt\u003cU1022\u003e; pub type N1022 = NInt\u003cU1022\u003e;\n    pub type U1023 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P1023 = PInt\u003cU1023\u003e; pub type N1023 = NInt\u003cU1023\u003e;\n    pub type U1024 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P1024 = PInt\u003cU1024\u003e; pub type N1024 = NInt\u003cU1024\u003e;\n    pub type U2048 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P2048 = PInt\u003cU2048\u003e; pub type N2048 = NInt\u003cU2048\u003e;\n    pub type U4096 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P4096 = PInt\u003cU4096\u003e; pub type N4096 = NInt\u003cU4096\u003e;\n    pub type U8192 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P8192 = PInt\u003cU8192\u003e; pub type N8192 = NInt\u003cU8192\u003e;\n    pub type U16384 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P16384 = PInt\u003cU16384\u003e; pub type N16384 = NInt\u003cU16384\u003e;\n    pub type U32768 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P32768 = PInt\u003cU32768\u003e; pub type N32768 = NInt\u003cU32768\u003e;\n    pub type U65536 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P65536 = PInt\u003cU65536\u003e; pub type N65536 = NInt\u003cU65536\u003e;\n    pub type U131072 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P131072 = PInt\u003cU131072\u003e; pub type N131072 = NInt\u003cU131072\u003e;\n    pub type U262144 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P262144 = PInt\u003cU262144\u003e; pub type N262144 = NInt\u003cU262144\u003e;\n    pub type U524288 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P524288 = PInt\u003cU524288\u003e; pub type N524288 = NInt\u003cU524288\u003e;\n    pub type U1048576 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P1048576 = PInt\u003cU1048576\u003e; pub type N1048576 = NInt\u003cU1048576\u003e;\n    pub type U2097152 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P2097152 = PInt\u003cU2097152\u003e; pub type N2097152 = NInt\u003cU2097152\u003e;\n    pub type U4194304 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P4194304 = PInt\u003cU4194304\u003e; pub type N4194304 = NInt\u003cU4194304\u003e;\n    pub type U8388608 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P8388608 = PInt\u003cU8388608\u003e; pub type N8388608 = NInt\u003cU8388608\u003e;\n    pub type U16777216 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P16777216 = PInt\u003cU16777216\u003e; pub type N16777216 = NInt\u003cU16777216\u003e;\n    pub type U33554432 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P33554432 = PInt\u003cU33554432\u003e; pub type N33554432 = NInt\u003cU33554432\u003e;\n    pub type U67108864 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P67108864 = PInt\u003cU67108864\u003e; pub type N67108864 = NInt\u003cU67108864\u003e;\n    pub type U134217728 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P134217728 = PInt\u003cU134217728\u003e; pub type N134217728 = NInt\u003cU134217728\u003e;\n    pub type U268435456 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P268435456 = PInt\u003cU268435456\u003e; pub type N268435456 = NInt\u003cU268435456\u003e;\n    pub type U536870912 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P536870912 = PInt\u003cU536870912\u003e; pub type N536870912 = NInt\u003cU536870912\u003e;\n    pub type U1073741824 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P1073741824 = PInt\u003cU1073741824\u003e; pub type N1073741824 = NInt\u003cU1073741824\u003e;\n    pub type U2147483648 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P2147483648 = PInt\u003cU2147483648\u003e; pub type N2147483648 = NInt\u003cU2147483648\u003e;\n    pub type U4294967296 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P4294967296 = PInt\u003cU4294967296\u003e; pub type N4294967296 = NInt\u003cU4294967296\u003e;\n    pub type U8589934592 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P8589934592 = PInt\u003cU8589934592\u003e; pub type N8589934592 = NInt\u003cU8589934592\u003e;\n    pub type U17179869184 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P17179869184 = PInt\u003cU17179869184\u003e; pub type N17179869184 = NInt\u003cU17179869184\u003e;\n    pub type U34359738368 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P34359738368 = PInt\u003cU34359738368\u003e; pub type N34359738368 = NInt\u003cU34359738368\u003e;\n    pub type U68719476736 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P68719476736 = PInt\u003cU68719476736\u003e; pub type N68719476736 = NInt\u003cU68719476736\u003e;\n    pub type U137438953472 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P137438953472 = PInt\u003cU137438953472\u003e; pub type N137438953472 = NInt\u003cU137438953472\u003e;\n    pub type U274877906944 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P274877906944 = PInt\u003cU274877906944\u003e; pub type N274877906944 = NInt\u003cU274877906944\u003e;\n    pub type U549755813888 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P549755813888 = PInt\u003cU549755813888\u003e; pub type N549755813888 = NInt\u003cU549755813888\u003e;\n    pub type U1099511627776 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P1099511627776 = PInt\u003cU1099511627776\u003e; pub type N1099511627776 = NInt\u003cU1099511627776\u003e;\n    pub type U2199023255552 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P2199023255552 = PInt\u003cU2199023255552\u003e; pub type N2199023255552 = NInt\u003cU2199023255552\u003e;\n    pub type U4398046511104 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P4398046511104 = PInt\u003cU4398046511104\u003e; pub type N4398046511104 = NInt\u003cU4398046511104\u003e;\n    pub type U8796093022208 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P8796093022208 = PInt\u003cU8796093022208\u003e; pub type N8796093022208 = NInt\u003cU8796093022208\u003e;\n    pub type U17592186044416 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P17592186044416 = PInt\u003cU17592186044416\u003e; pub type N17592186044416 = NInt\u003cU17592186044416\u003e;\n    pub type U35184372088832 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P35184372088832 = PInt\u003cU35184372088832\u003e; pub type N35184372088832 = NInt\u003cU35184372088832\u003e;\n    pub type U70368744177664 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P70368744177664 = PInt\u003cU70368744177664\u003e; pub type N70368744177664 = NInt\u003cU70368744177664\u003e;\n    pub type U140737488355328 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P140737488355328 = PInt\u003cU140737488355328\u003e; pub type N140737488355328 = NInt\u003cU140737488355328\u003e;\n    pub type U281474976710656 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P281474976710656 = PInt\u003cU281474976710656\u003e; pub type N281474976710656 = NInt\u003cU281474976710656\u003e;\n    pub type U562949953421312 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P562949953421312 = PInt\u003cU562949953421312\u003e; pub type N562949953421312 = NInt\u003cU562949953421312\u003e;\n    pub type U1125899906842624 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P1125899906842624 = PInt\u003cU1125899906842624\u003e; pub type N1125899906842624 = NInt\u003cU1125899906842624\u003e;\n    pub type U2251799813685248 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P2251799813685248 = PInt\u003cU2251799813685248\u003e; pub type N2251799813685248 = NInt\u003cU2251799813685248\u003e;\n    pub type U4503599627370496 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P4503599627370496 = PInt\u003cU4503599627370496\u003e; pub type N4503599627370496 = NInt\u003cU4503599627370496\u003e;\n    pub type U9007199254740992 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P9007199254740992 = PInt\u003cU9007199254740992\u003e; pub type N9007199254740992 = NInt\u003cU9007199254740992\u003e;\n    pub type U18014398509481984 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P18014398509481984 = PInt\u003cU18014398509481984\u003e; pub type N18014398509481984 = NInt\u003cU18014398509481984\u003e;\n    pub type U36028797018963968 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P36028797018963968 = PInt\u003cU36028797018963968\u003e; pub type N36028797018963968 = NInt\u003cU36028797018963968\u003e;\n    pub type U72057594037927936 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P72057594037927936 = PInt\u003cU72057594037927936\u003e; pub type N72057594037927936 = NInt\u003cU72057594037927936\u003e;\n    pub type U144115188075855872 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P144115188075855872 = PInt\u003cU144115188075855872\u003e; pub type N144115188075855872 = NInt\u003cU144115188075855872\u003e;\n    pub type U288230376151711744 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P288230376151711744 = PInt\u003cU288230376151711744\u003e; pub type N288230376151711744 = NInt\u003cU288230376151711744\u003e;\n    pub type U576460752303423488 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P576460752303423488 = PInt\u003cU576460752303423488\u003e; pub type N576460752303423488 = NInt\u003cU576460752303423488\u003e;\n    pub type U1152921504606846976 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P1152921504606846976 = PInt\u003cU1152921504606846976\u003e; pub type N1152921504606846976 = NInt\u003cU1152921504606846976\u003e;\n    pub type U2305843009213693952 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P2305843009213693952 = PInt\u003cU2305843009213693952\u003e; pub type N2305843009213693952 = NInt\u003cU2305843009213693952\u003e;\n    pub type U4611686018427387904 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P4611686018427387904 = PInt\u003cU4611686018427387904\u003e; pub type N4611686018427387904 = NInt\u003cU4611686018427387904\u003e;\n    pub type U9223372036854775808 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type U10000 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P10000 = PInt\u003cU10000\u003e; pub type N10000 = NInt\u003cU10000\u003e;\n    pub type U100000 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P100000 = PInt\u003cU100000\u003e; pub type N100000 = NInt\u003cU100000\u003e;\n    pub type U1000000 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P1000000 = PInt\u003cU1000000\u003e; pub type N1000000 = NInt\u003cU1000000\u003e;\n    pub type U10000000 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P10000000 = PInt\u003cU10000000\u003e; pub type N10000000 = NInt\u003cU10000000\u003e;\n    pub type U100000000 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P100000000 = PInt\u003cU100000000\u003e; pub type N100000000 = NInt\u003cU100000000\u003e;\n    pub type U1000000000 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P1000000000 = PInt\u003cU1000000000\u003e; pub type N1000000000 = NInt\u003cU1000000000\u003e;\n    pub type U10000000000 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P10000000000 = PInt\u003cU10000000000\u003e; pub type N10000000000 = NInt\u003cU10000000000\u003e;\n    pub type U100000000000 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P100000000000 = PInt\u003cU100000000000\u003e; pub type N100000000000 = NInt\u003cU100000000000\u003e;\n    pub type U1000000000000 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P1000000000000 = PInt\u003cU1000000000000\u003e; pub type N1000000000000 = NInt\u003cU1000000000000\u003e;\n    pub type U10000000000000 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P10000000000000 = PInt\u003cU10000000000000\u003e; pub type N10000000000000 = NInt\u003cU10000000000000\u003e;\n    pub type U100000000000000 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P100000000000000 = PInt\u003cU100000000000000\u003e; pub type N100000000000000 = NInt\u003cU100000000000000\u003e;\n    pub type U1000000000000000 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P1000000000000000 = PInt\u003cU1000000000000000\u003e; pub type N1000000000000000 = NInt\u003cU1000000000000000\u003e;\n    pub type U10000000000000000 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P10000000000000000 = PInt\u003cU10000000000000000\u003e; pub type N10000000000000000 = NInt\u003cU10000000000000000\u003e;\n    pub type U100000000000000000 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P100000000000000000 = PInt\u003cU100000000000000000\u003e; pub type N100000000000000000 = NInt\u003cU100000000000000000\u003e;\n    pub type U1000000000000000000 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P1000000000000000000 = PInt\u003cU1000000000000000000\u003e; pub type N1000000000000000000 = NInt\u003cU1000000000000000000\u003e;\n    pub type U10000000000000000000 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n}","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","fuzz","target","x86_64-unknown-linux-gnu","release","build","typenum-85e81dd0a8c9dcba","out","op.rs"],"content":"\n/**\nConvenient type operations.\n\nAny types representing values must be able to be expressed as `ident`s. That means they need to be\nin scope.\n\nFor example, `P5` is okay, but `typenum::P5` is not.\n\nYou may combine operators arbitrarily, although doing so excessively may require raising the\nrecursion limit.\n\n# Example\n```rust\n#![recursion_limit=\"128\"]\n#[macro_use] extern crate typenum;\nuse typenum::consts::*;\n\nfn main() {\n    assert_type!(\n        op!(min((P1 - P2) * (N3 + N7), P5 * (P3 + P4)) == P10)\n    );\n}\n```\nOperators are evaluated based on the operator precedence outlined\n[here](https://doc.rust-lang.org/reference.html#operator-precedence).\n\nThe full list of supported operators and functions is as follows:\n\n`*`, `/`, `%`, `+`, `-`, `\u003c\u003c`, `\u003e\u003e`, `\u0026`, `^`, `|`, `==`, `!=`, `\u003c=`, `\u003e=`, `\u003c`, `\u003e`, `cmp`, `sqr`, `sqrt`, `abs`, `cube`, `pow`, `min`, `max`, `log2`, `gcd`\n\nThey all expand to type aliases defined in the `operator_aliases` module. Here is an expanded list,\nincluding examples:\n\n---\nOperator `*`. Expands to `Prod`.\n\n```rust\n# #[macro_use] extern crate typenum;\n# use typenum::*;\n# fn main() {\nassert_type_eq!(op!(P2 * P3), P6);\n# }\n```\n\n---\nOperator `/`. Expands to `Quot`.\n\n```rust\n# #[macro_use] extern crate typenum;\n# use typenum::*;\n# fn main() {\nassert_type_eq!(op!(P6 / P2), P3);\n# }\n```\n\n---\nOperator `%`. Expands to `Mod`.\n\n```rust\n# #[macro_use] extern crate typenum;\n# use typenum::*;\n# fn main() {\nassert_type_eq!(op!(P5 % P3), P2);\n# }\n```\n\n---\nOperator `+`. Expands to `Sum`.\n\n```rust\n# #[macro_use] extern crate typenum;\n# use typenum::*;\n# fn main() {\nassert_type_eq!(op!(P2 + P3), P5);\n# }\n```\n\n---\nOperator `-`. Expands to `Diff`.\n\n```rust\n# #[macro_use] extern crate typenum;\n# use typenum::*;\n# fn main() {\nassert_type_eq!(op!(P2 - P3), N1);\n# }\n```\n\n---\nOperator `\u003c\u003c`. Expands to `Shleft`.\n\n```rust\n# #[macro_use] extern crate typenum;\n# use typenum::*;\n# fn main() {\nassert_type_eq!(op!(U1 \u003c\u003c U5), U32);\n# }\n```\n\n---\nOperator `\u003e\u003e`. Expands to `Shright`.\n\n```rust\n# #[macro_use] extern crate typenum;\n# use typenum::*;\n# fn main() {\nassert_type_eq!(op!(U32 \u003e\u003e U5), U1);\n# }\n```\n\n---\nOperator `\u0026`. Expands to `And`.\n\n```rust\n# #[macro_use] extern crate typenum;\n# use typenum::*;\n# fn main() {\nassert_type_eq!(op!(U5 \u0026 U3), U1);\n# }\n```\n\n---\nOperator `^`. Expands to `Xor`.\n\n```rust\n# #[macro_use] extern crate typenum;\n# use typenum::*;\n# fn main() {\nassert_type_eq!(op!(U5 ^ U3), U6);\n# }\n```\n\n---\nOperator `|`. Expands to `Or`.\n\n```rust\n# #[macro_use] extern crate typenum;\n# use typenum::*;\n# fn main() {\nassert_type_eq!(op!(U5 | U3), U7);\n# }\n```\n\n---\nOperator `==`. Expands to `Eq`.\n\n```rust\n# #[macro_use] extern crate typenum;\n# use typenum::*;\n# fn main() {\nassert_type_eq!(op!(P5 == P3 + P2), True);\n# }\n```\n\n---\nOperator `!=`. Expands to `NotEq`.\n\n```rust\n# #[macro_use] extern crate typenum;\n# use typenum::*;\n# fn main() {\nassert_type_eq!(op!(P5 != P3 + P2), False);\n# }\n```\n\n---\nOperator `\u003c=`. Expands to `LeEq`.\n\n```rust\n# #[macro_use] extern crate typenum;\n# use typenum::*;\n# fn main() {\nassert_type_eq!(op!(P6 \u003c= P3 + P2), False);\n# }\n```\n\n---\nOperator `\u003e=`. Expands to `GrEq`.\n\n```rust\n# #[macro_use] extern crate typenum;\n# use typenum::*;\n# fn main() {\nassert_type_eq!(op!(P6 \u003e= P3 + P2), True);\n# }\n```\n\n---\nOperator `\u003c`. Expands to `Le`.\n\n```rust\n# #[macro_use] extern crate typenum;\n# use typenum::*;\n# fn main() {\nassert_type_eq!(op!(P4 \u003c P3 + P2), True);\n# }\n```\n\n---\nOperator `\u003e`. Expands to `Gr`.\n\n```rust\n# #[macro_use] extern crate typenum;\n# use typenum::*;\n# fn main() {\nassert_type_eq!(op!(P5 \u003c P3 + P2), False);\n# }\n```\n\n---\nOperator `cmp`. Expands to `Compare`.\n\n```rust\n# #[macro_use] extern crate typenum;\n# use typenum::*;\n# fn main() {\nassert_type_eq!(op!(cmp(P2, P3)), Less);\n# }\n```\n\n---\nOperator `sqr`. Expands to `Square`.\n\n```rust\n# #[macro_use] extern crate typenum;\n# use typenum::*;\n# fn main() {\nassert_type_eq!(op!(sqr(P2)), P4);\n# }\n```\n\n---\nOperator `sqrt`. Expands to `Sqrt`.\n\n```rust\n# #[macro_use] extern crate typenum;\n# use typenum::*;\n# fn main() {\nassert_type_eq!(op!(sqrt(U9)), U3);\n# }\n```\n\n---\nOperator `abs`. Expands to `AbsVal`.\n\n```rust\n# #[macro_use] extern crate typenum;\n# use typenum::*;\n# fn main() {\nassert_type_eq!(op!(abs(N2)), P2);\n# }\n```\n\n---\nOperator `cube`. Expands to `Cube`.\n\n```rust\n# #[macro_use] extern crate typenum;\n# use typenum::*;\n# fn main() {\nassert_type_eq!(op!(cube(P2)), P8);\n# }\n```\n\n---\nOperator `pow`. Expands to `Exp`.\n\n```rust\n# #[macro_use] extern crate typenum;\n# use typenum::*;\n# fn main() {\nassert_type_eq!(op!(pow(P2, P3)), P8);\n# }\n```\n\n---\nOperator `min`. Expands to `Minimum`.\n\n```rust\n# #[macro_use] extern crate typenum;\n# use typenum::*;\n# fn main() {\nassert_type_eq!(op!(min(P2, P3)), P2);\n# }\n```\n\n---\nOperator `max`. Expands to `Maximum`.\n\n```rust\n# #[macro_use] extern crate typenum;\n# use typenum::*;\n# fn main() {\nassert_type_eq!(op!(max(P2, P3)), P3);\n# }\n```\n\n---\nOperator `log2`. Expands to `Log2`.\n\n```rust\n# #[macro_use] extern crate typenum;\n# use typenum::*;\n# fn main() {\nassert_type_eq!(op!(log2(U9)), U3);\n# }\n```\n\n---\nOperator `gcd`. Expands to `Gcf`.\n\n```rust\n# #[macro_use] extern crate typenum;\n# use typenum::*;\n# fn main() {\nassert_type_eq!(op!(gcd(U9, U21)), U3);\n# }\n```\n\n*/\n#[macro_export(local_inner_macros)]\nmacro_rules! op {\n    ($($tail:tt)*) =\u003e ( __op_internal__!($($tail)*) );\n}\n\n    #[doc(hidden)]\n    #[macro_export(local_inner_macros)]\n    macro_rules! __op_internal__ {\n\n(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: cmp $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[Compare, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)\n);\n(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: sqr $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[Square, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)\n);\n(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: sqrt $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[Sqrt, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)\n);\n(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: abs $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[AbsVal, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)\n);\n(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: cube $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[Cube, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)\n);\n(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: pow $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[Exp, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)\n);\n(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: min $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[Minimum, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)\n);\n(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: max $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[Maximum, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)\n);\n(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: log2 $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[Log2, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)\n);\n(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: gcd $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[Gcf, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)\n);\n(@stack[LParen, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: , $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[LParen, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)\n);\n(@stack[$stack_top:ident, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: , $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[$stack_top, $($queue,)*] @tail: , $($tail)*)\n);\n(@stack[Prod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: * $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Prod, $($queue,)*] @tail: * $($tail)*)\n);\n(@stack[Quot, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: * $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Quot, $($queue,)*] @tail: * $($tail)*)\n);\n(@stack[Mod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: * $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Mod, $($queue,)*] @tail: * $($tail)*)\n);\n(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: * $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[Prod, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)\n);\n(@stack[Prod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: / $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Prod, $($queue,)*] @tail: / $($tail)*)\n);\n(@stack[Quot, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: / $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Quot, $($queue,)*] @tail: / $($tail)*)\n);\n(@stack[Mod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: / $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Mod, $($queue,)*] @tail: / $($tail)*)\n);\n(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: / $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[Quot, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)\n);\n(@stack[Prod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: % $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Prod, $($queue,)*] @tail: % $($tail)*)\n);\n(@stack[Quot, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: % $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Quot, $($queue,)*] @tail: % $($tail)*)\n);\n(@stack[Mod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: % $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Mod, $($queue,)*] @tail: % $($tail)*)\n);\n(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: % $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[Mod, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)\n);\n(@stack[Prod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: + $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Prod, $($queue,)*] @tail: + $($tail)*)\n);\n(@stack[Quot, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: + $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Quot, $($queue,)*] @tail: + $($tail)*)\n);\n(@stack[Mod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: + $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Mod, $($queue,)*] @tail: + $($tail)*)\n);\n(@stack[Sum, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: + $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Sum, $($queue,)*] @tail: + $($tail)*)\n);\n(@stack[Diff, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: + $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Diff, $($queue,)*] @tail: + $($tail)*)\n);\n(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: + $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[Sum, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)\n);\n(@stack[Prod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: - $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Prod, $($queue,)*] @tail: - $($tail)*)\n);\n(@stack[Quot, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: - $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Quot, $($queue,)*] @tail: - $($tail)*)\n);\n(@stack[Mod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: - $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Mod, $($queue,)*] @tail: - $($tail)*)\n);\n(@stack[Sum, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: - $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Sum, $($queue,)*] @tail: - $($tail)*)\n);\n(@stack[Diff, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: - $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Diff, $($queue,)*] @tail: - $($tail)*)\n);\n(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: - $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[Diff, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)\n);\n(@stack[Prod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c\u003c $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Prod, $($queue,)*] @tail: \u003c\u003c $($tail)*)\n);\n(@stack[Quot, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c\u003c $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Quot, $($queue,)*] @tail: \u003c\u003c $($tail)*)\n);\n(@stack[Mod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c\u003c $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Mod, $($queue,)*] @tail: \u003c\u003c $($tail)*)\n);\n(@stack[Sum, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c\u003c $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Sum, $($queue,)*] @tail: \u003c\u003c $($tail)*)\n);\n(@stack[Diff, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c\u003c $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Diff, $($queue,)*] @tail: \u003c\u003c $($tail)*)\n);\n(@stack[Shleft, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c\u003c $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Shleft, $($queue,)*] @tail: \u003c\u003c $($tail)*)\n);\n(@stack[Shright, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c\u003c $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Shright, $($queue,)*] @tail: \u003c\u003c $($tail)*)\n);\n(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c\u003c $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[Shleft, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)\n);\n(@stack[Prod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e\u003e $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Prod, $($queue,)*] @tail: \u003e\u003e $($tail)*)\n);\n(@stack[Quot, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e\u003e $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Quot, $($queue,)*] @tail: \u003e\u003e $($tail)*)\n);\n(@stack[Mod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e\u003e $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Mod, $($queue,)*] @tail: \u003e\u003e $($tail)*)\n);\n(@stack[Sum, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e\u003e $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Sum, $($queue,)*] @tail: \u003e\u003e $($tail)*)\n);\n(@stack[Diff, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e\u003e $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Diff, $($queue,)*] @tail: \u003e\u003e $($tail)*)\n);\n(@stack[Shleft, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e\u003e $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Shleft, $($queue,)*] @tail: \u003e\u003e $($tail)*)\n);\n(@stack[Shright, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e\u003e $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Shright, $($queue,)*] @tail: \u003e\u003e $($tail)*)\n);\n(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e\u003e $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[Shright, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)\n);\n(@stack[Prod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u0026 $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Prod, $($queue,)*] @tail: \u0026 $($tail)*)\n);\n(@stack[Quot, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u0026 $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Quot, $($queue,)*] @tail: \u0026 $($tail)*)\n);\n(@stack[Mod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u0026 $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Mod, $($queue,)*] @tail: \u0026 $($tail)*)\n);\n(@stack[Sum, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u0026 $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Sum, $($queue,)*] @tail: \u0026 $($tail)*)\n);\n(@stack[Diff, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u0026 $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Diff, $($queue,)*] @tail: \u0026 $($tail)*)\n);\n(@stack[Shleft, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u0026 $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Shleft, $($queue,)*] @tail: \u0026 $($tail)*)\n);\n(@stack[Shright, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u0026 $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Shright, $($queue,)*] @tail: \u0026 $($tail)*)\n);\n(@stack[And, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u0026 $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[And, $($queue,)*] @tail: \u0026 $($tail)*)\n);\n(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u0026 $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[And, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)\n);\n(@stack[Prod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: ^ $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Prod, $($queue,)*] @tail: ^ $($tail)*)\n);\n(@stack[Quot, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: ^ $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Quot, $($queue,)*] @tail: ^ $($tail)*)\n);\n(@stack[Mod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: ^ $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Mod, $($queue,)*] @tail: ^ $($tail)*)\n);\n(@stack[Sum, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: ^ $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Sum, $($queue,)*] @tail: ^ $($tail)*)\n);\n(@stack[Diff, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: ^ $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Diff, $($queue,)*] @tail: ^ $($tail)*)\n);\n(@stack[Shleft, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: ^ $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Shleft, $($queue,)*] @tail: ^ $($tail)*)\n);\n(@stack[Shright, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: ^ $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Shright, $($queue,)*] @tail: ^ $($tail)*)\n);\n(@stack[And, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: ^ $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[And, $($queue,)*] @tail: ^ $($tail)*)\n);\n(@stack[Xor, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: ^ $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Xor, $($queue,)*] @tail: ^ $($tail)*)\n);\n(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: ^ $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[Xor, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)\n);\n(@stack[Prod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: | $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Prod, $($queue,)*] @tail: | $($tail)*)\n);\n(@stack[Quot, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: | $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Quot, $($queue,)*] @tail: | $($tail)*)\n);\n(@stack[Mod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: | $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Mod, $($queue,)*] @tail: | $($tail)*)\n);\n(@stack[Sum, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: | $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Sum, $($queue,)*] @tail: | $($tail)*)\n);\n(@stack[Diff, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: | $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Diff, $($queue,)*] @tail: | $($tail)*)\n);\n(@stack[Shleft, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: | $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Shleft, $($queue,)*] @tail: | $($tail)*)\n);\n(@stack[Shright, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: | $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Shright, $($queue,)*] @tail: | $($tail)*)\n);\n(@stack[And, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: | $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[And, $($queue,)*] @tail: | $($tail)*)\n);\n(@stack[Xor, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: | $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Xor, $($queue,)*] @tail: | $($tail)*)\n);\n(@stack[Or, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: | $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Or, $($queue,)*] @tail: | $($tail)*)\n);\n(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: | $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[Or, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)\n);\n(@stack[Prod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: == $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Prod, $($queue,)*] @tail: == $($tail)*)\n);\n(@stack[Quot, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: == $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Quot, $($queue,)*] @tail: == $($tail)*)\n);\n(@stack[Mod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: == $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Mod, $($queue,)*] @tail: == $($tail)*)\n);\n(@stack[Sum, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: == $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Sum, $($queue,)*] @tail: == $($tail)*)\n);\n(@stack[Diff, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: == $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Diff, $($queue,)*] @tail: == $($tail)*)\n);\n(@stack[Shleft, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: == $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Shleft, $($queue,)*] @tail: == $($tail)*)\n);\n(@stack[Shright, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: == $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Shright, $($queue,)*] @tail: == $($tail)*)\n);\n(@stack[And, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: == $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[And, $($queue,)*] @tail: == $($tail)*)\n);\n(@stack[Xor, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: == $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Xor, $($queue,)*] @tail: == $($tail)*)\n);\n(@stack[Or, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: == $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Or, $($queue,)*] @tail: == $($tail)*)\n);\n(@stack[Eq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: == $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Eq, $($queue,)*] @tail: == $($tail)*)\n);\n(@stack[NotEq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: == $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[NotEq, $($queue,)*] @tail: == $($tail)*)\n);\n(@stack[LeEq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: == $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[LeEq, $($queue,)*] @tail: == $($tail)*)\n);\n(@stack[GrEq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: == $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[GrEq, $($queue,)*] @tail: == $($tail)*)\n);\n(@stack[Le, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: == $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Le, $($queue,)*] @tail: == $($tail)*)\n);\n(@stack[Gr, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: == $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Gr, $($queue,)*] @tail: == $($tail)*)\n);\n(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: == $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[Eq, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)\n);\n(@stack[Prod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: != $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Prod, $($queue,)*] @tail: != $($tail)*)\n);\n(@stack[Quot, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: != $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Quot, $($queue,)*] @tail: != $($tail)*)\n);\n(@stack[Mod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: != $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Mod, $($queue,)*] @tail: != $($tail)*)\n);\n(@stack[Sum, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: != $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Sum, $($queue,)*] @tail: != $($tail)*)\n);\n(@stack[Diff, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: != $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Diff, $($queue,)*] @tail: != $($tail)*)\n);\n(@stack[Shleft, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: != $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Shleft, $($queue,)*] @tail: != $($tail)*)\n);\n(@stack[Shright, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: != $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Shright, $($queue,)*] @tail: != $($tail)*)\n);\n(@stack[And, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: != $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[And, $($queue,)*] @tail: != $($tail)*)\n);\n(@stack[Xor, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: != $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Xor, $($queue,)*] @tail: != $($tail)*)\n);\n(@stack[Or, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: != $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Or, $($queue,)*] @tail: != $($tail)*)\n);\n(@stack[Eq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: != $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Eq, $($queue,)*] @tail: != $($tail)*)\n);\n(@stack[NotEq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: != $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[NotEq, $($queue,)*] @tail: != $($tail)*)\n);\n(@stack[LeEq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: != $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[LeEq, $($queue,)*] @tail: != $($tail)*)\n);\n(@stack[GrEq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: != $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[GrEq, $($queue,)*] @tail: != $($tail)*)\n);\n(@stack[Le, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: != $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Le, $($queue,)*] @tail: != $($tail)*)\n);\n(@stack[Gr, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: != $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Gr, $($queue,)*] @tail: != $($tail)*)\n);\n(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: != $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[NotEq, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)\n);\n(@stack[Prod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Prod, $($queue,)*] @tail: \u003c= $($tail)*)\n);\n(@stack[Quot, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Quot, $($queue,)*] @tail: \u003c= $($tail)*)\n);\n(@stack[Mod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Mod, $($queue,)*] @tail: \u003c= $($tail)*)\n);\n(@stack[Sum, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Sum, $($queue,)*] @tail: \u003c= $($tail)*)\n);\n(@stack[Diff, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Diff, $($queue,)*] @tail: \u003c= $($tail)*)\n);\n(@stack[Shleft, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Shleft, $($queue,)*] @tail: \u003c= $($tail)*)\n);\n(@stack[Shright, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Shright, $($queue,)*] @tail: \u003c= $($tail)*)\n);\n(@stack[And, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[And, $($queue,)*] @tail: \u003c= $($tail)*)\n);\n(@stack[Xor, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Xor, $($queue,)*] @tail: \u003c= $($tail)*)\n);\n(@stack[Or, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Or, $($queue,)*] @tail: \u003c= $($tail)*)\n);\n(@stack[Eq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Eq, $($queue,)*] @tail: \u003c= $($tail)*)\n);\n(@stack[NotEq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[NotEq, $($queue,)*] @tail: \u003c= $($tail)*)\n);\n(@stack[LeEq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[LeEq, $($queue,)*] @tail: \u003c= $($tail)*)\n);\n(@stack[GrEq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[GrEq, $($queue,)*] @tail: \u003c= $($tail)*)\n);\n(@stack[Le, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Le, $($queue,)*] @tail: \u003c= $($tail)*)\n);\n(@stack[Gr, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Gr, $($queue,)*] @tail: \u003c= $($tail)*)\n);\n(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[LeEq, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)\n);\n(@stack[Prod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Prod, $($queue,)*] @tail: \u003e= $($tail)*)\n);\n(@stack[Quot, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Quot, $($queue,)*] @tail: \u003e= $($tail)*)\n);\n(@stack[Mod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Mod, $($queue,)*] @tail: \u003e= $($tail)*)\n);\n(@stack[Sum, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Sum, $($queue,)*] @tail: \u003e= $($tail)*)\n);\n(@stack[Diff, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Diff, $($queue,)*] @tail: \u003e= $($tail)*)\n);\n(@stack[Shleft, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Shleft, $($queue,)*] @tail: \u003e= $($tail)*)\n);\n(@stack[Shright, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Shright, $($queue,)*] @tail: \u003e= $($tail)*)\n);\n(@stack[And, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[And, $($queue,)*] @tail: \u003e= $($tail)*)\n);\n(@stack[Xor, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Xor, $($queue,)*] @tail: \u003e= $($tail)*)\n);\n(@stack[Or, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Or, $($queue,)*] @tail: \u003e= $($tail)*)\n);\n(@stack[Eq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Eq, $($queue,)*] @tail: \u003e= $($tail)*)\n);\n(@stack[NotEq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[NotEq, $($queue,)*] @tail: \u003e= $($tail)*)\n);\n(@stack[LeEq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[LeEq, $($queue,)*] @tail: \u003e= $($tail)*)\n);\n(@stack[GrEq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[GrEq, $($queue,)*] @tail: \u003e= $($tail)*)\n);\n(@stack[Le, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Le, $($queue,)*] @tail: \u003e= $($tail)*)\n);\n(@stack[Gr, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Gr, $($queue,)*] @tail: \u003e= $($tail)*)\n);\n(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[GrEq, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)\n);\n(@stack[Prod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Prod, $($queue,)*] @tail: \u003c $($tail)*)\n);\n(@stack[Quot, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Quot, $($queue,)*] @tail: \u003c $($tail)*)\n);\n(@stack[Mod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Mod, $($queue,)*] @tail: \u003c $($tail)*)\n);\n(@stack[Sum, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Sum, $($queue,)*] @tail: \u003c $($tail)*)\n);\n(@stack[Diff, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Diff, $($queue,)*] @tail: \u003c $($tail)*)\n);\n(@stack[Shleft, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Shleft, $($queue,)*] @tail: \u003c $($tail)*)\n);\n(@stack[Shright, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Shright, $($queue,)*] @tail: \u003c $($tail)*)\n);\n(@stack[And, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[And, $($queue,)*] @tail: \u003c $($tail)*)\n);\n(@stack[Xor, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Xor, $($queue,)*] @tail: \u003c $($tail)*)\n);\n(@stack[Or, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Or, $($queue,)*] @tail: \u003c $($tail)*)\n);\n(@stack[Eq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Eq, $($queue,)*] @tail: \u003c $($tail)*)\n);\n(@stack[NotEq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[NotEq, $($queue,)*] @tail: \u003c $($tail)*)\n);\n(@stack[LeEq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[LeEq, $($queue,)*] @tail: \u003c $($tail)*)\n);\n(@stack[GrEq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[GrEq, $($queue,)*] @tail: \u003c $($tail)*)\n);\n(@stack[Le, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Le, $($queue,)*] @tail: \u003c $($tail)*)\n);\n(@stack[Gr, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Gr, $($queue,)*] @tail: \u003c $($tail)*)\n);\n(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[Le, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)\n);\n(@stack[Prod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Prod, $($queue,)*] @tail: \u003e $($tail)*)\n);\n(@stack[Quot, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Quot, $($queue,)*] @tail: \u003e $($tail)*)\n);\n(@stack[Mod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Mod, $($queue,)*] @tail: \u003e $($tail)*)\n);\n(@stack[Sum, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Sum, $($queue,)*] @tail: \u003e $($tail)*)\n);\n(@stack[Diff, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Diff, $($queue,)*] @tail: \u003e $($tail)*)\n);\n(@stack[Shleft, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Shleft, $($queue,)*] @tail: \u003e $($tail)*)\n);\n(@stack[Shright, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Shright, $($queue,)*] @tail: \u003e $($tail)*)\n);\n(@stack[And, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[And, $($queue,)*] @tail: \u003e $($tail)*)\n);\n(@stack[Xor, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Xor, $($queue,)*] @tail: \u003e $($tail)*)\n);\n(@stack[Or, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Or, $($queue,)*] @tail: \u003e $($tail)*)\n);\n(@stack[Eq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Eq, $($queue,)*] @tail: \u003e $($tail)*)\n);\n(@stack[NotEq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[NotEq, $($queue,)*] @tail: \u003e $($tail)*)\n);\n(@stack[LeEq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[LeEq, $($queue,)*] @tail: \u003e $($tail)*)\n);\n(@stack[GrEq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[GrEq, $($queue,)*] @tail: \u003e $($tail)*)\n);\n(@stack[Le, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Le, $($queue,)*] @tail: \u003e $($tail)*)\n);\n(@stack[Gr, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Gr, $($queue,)*] @tail: \u003e $($tail)*)\n);\n(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[Gr, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)\n);\n(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: ( $($stuff:tt)* ) $($tail:tt)* )\n =\u003e (\n    __op_internal__!(@stack[LParen, $($stack,)*] @queue[$($queue,)*]\n                     @tail: $($stuff)* RParen $($tail)*)\n);\n(@stack[LParen, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: RParen $($tail:tt)*) =\u003e (\n    __op_internal__!(@rp3 @stack[$($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)\n);\n(@stack[$stack_top:ident, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: RParen $($tail:tt)*)\n =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[$stack_top, $($queue,)*] @tail: RParen $($tail)*)\n);\n(@rp3 @stack[Compare, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Compare, $($queue,)*] @tail: $($tail)*)\n);\n(@rp3 @stack[Square, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Square, $($queue,)*] @tail: $($tail)*)\n);\n(@rp3 @stack[Sqrt, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Sqrt, $($queue,)*] @tail: $($tail)*)\n);\n(@rp3 @stack[AbsVal, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[AbsVal, $($queue,)*] @tail: $($tail)*)\n);\n(@rp3 @stack[Cube, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Cube, $($queue,)*] @tail: $($tail)*)\n);\n(@rp3 @stack[Exp, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Exp, $($queue,)*] @tail: $($tail)*)\n);\n(@rp3 @stack[Minimum, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Minimum, $($queue,)*] @tail: $($tail)*)\n);\n(@rp3 @stack[Maximum, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Maximum, $($queue,)*] @tail: $($tail)*)\n);\n(@rp3 @stack[Log2, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Log2, $($queue,)*] @tail: $($tail)*)\n);\n(@rp3 @stack[Gcf, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Gcf, $($queue,)*] @tail: $($tail)*)\n);\n(@rp3 @stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)\n);\n(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: $num:ident $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[$num, $($queue,)*] @tail: $($tail)*)\n);\n(@stack[] @queue[$($queue:ident,)*] @tail: ) =\u003e (\n    __op_internal__!(@reverse[] @input: $($queue,)*)\n);\n(@stack[$stack_top:ident, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail:) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[$stack_top, $($queue,)*] @tail: )\n);\n(@reverse[$($revved:ident,)*] @input: $head:ident, $($tail:ident,)* ) =\u003e (\n    __op_internal__!(@reverse[$head, $($revved,)*] @input: $($tail,)*)\n);\n(@reverse[$($revved:ident,)*] @input: ) =\u003e (\n    __op_internal__!(@eval @stack[] @input[$($revved,)*])\n);\n(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[Prod, $($tail:ident,)*]) =\u003e (\n    __op_internal__!(@eval @stack[$crate::Prod\u003c$b, $a\u003e, $($stack,)*] @input[$($tail,)*])\n);\n(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[Quot, $($tail:ident,)*]) =\u003e (\n    __op_internal__!(@eval @stack[$crate::Quot\u003c$b, $a\u003e, $($stack,)*] @input[$($tail,)*])\n);\n(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[Mod, $($tail:ident,)*]) =\u003e (\n    __op_internal__!(@eval @stack[$crate::Mod\u003c$b, $a\u003e, $($stack,)*] @input[$($tail,)*])\n);\n(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[Sum, $($tail:ident,)*]) =\u003e (\n    __op_internal__!(@eval @stack[$crate::Sum\u003c$b, $a\u003e, $($stack,)*] @input[$($tail,)*])\n);\n(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[Diff, $($tail:ident,)*]) =\u003e (\n    __op_internal__!(@eval @stack[$crate::Diff\u003c$b, $a\u003e, $($stack,)*] @input[$($tail,)*])\n);\n(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[Shleft, $($tail:ident,)*]) =\u003e (\n    __op_internal__!(@eval @stack[$crate::Shleft\u003c$b, $a\u003e, $($stack,)*] @input[$($tail,)*])\n);\n(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[Shright, $($tail:ident,)*]) =\u003e (\n    __op_internal__!(@eval @stack[$crate::Shright\u003c$b, $a\u003e, $($stack,)*] @input[$($tail,)*])\n);\n(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[And, $($tail:ident,)*]) =\u003e (\n    __op_internal__!(@eval @stack[$crate::And\u003c$b, $a\u003e, $($stack,)*] @input[$($tail,)*])\n);\n(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[Xor, $($tail:ident,)*]) =\u003e (\n    __op_internal__!(@eval @stack[$crate::Xor\u003c$b, $a\u003e, $($stack,)*] @input[$($tail,)*])\n);\n(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[Or, $($tail:ident,)*]) =\u003e (\n    __op_internal__!(@eval @stack[$crate::Or\u003c$b, $a\u003e, $($stack,)*] @input[$($tail,)*])\n);\n(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[Eq, $($tail:ident,)*]) =\u003e (\n    __op_internal__!(@eval @stack[$crate::Eq\u003c$b, $a\u003e, $($stack,)*] @input[$($tail,)*])\n);\n(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[NotEq, $($tail:ident,)*]) =\u003e (\n    __op_internal__!(@eval @stack[$crate::NotEq\u003c$b, $a\u003e, $($stack,)*] @input[$($tail,)*])\n);\n(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[LeEq, $($tail:ident,)*]) =\u003e (\n    __op_internal__!(@eval @stack[$crate::LeEq\u003c$b, $a\u003e, $($stack,)*] @input[$($tail,)*])\n);\n(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[GrEq, $($tail:ident,)*]) =\u003e (\n    __op_internal__!(@eval @stack[$crate::GrEq\u003c$b, $a\u003e, $($stack,)*] @input[$($tail,)*])\n);\n(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[Le, $($tail:ident,)*]) =\u003e (\n    __op_internal__!(@eval @stack[$crate::Le\u003c$b, $a\u003e, $($stack,)*] @input[$($tail,)*])\n);\n(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[Gr, $($tail:ident,)*]) =\u003e (\n    __op_internal__!(@eval @stack[$crate::Gr\u003c$b, $a\u003e, $($stack,)*] @input[$($tail,)*])\n);\n(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[Compare, $($tail:ident,)*]) =\u003e (\n    __op_internal__!(@eval @stack[$crate::Compare\u003c$b, $a\u003e, $($stack,)*] @input[$($tail,)*])\n);\n(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[Exp, $($tail:ident,)*]) =\u003e (\n    __op_internal__!(@eval @stack[$crate::Exp\u003c$b, $a\u003e, $($stack,)*] @input[$($tail,)*])\n);\n(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[Minimum, $($tail:ident,)*]) =\u003e (\n    __op_internal__!(@eval @stack[$crate::Minimum\u003c$b, $a\u003e, $($stack,)*] @input[$($tail,)*])\n);\n(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[Maximum, $($tail:ident,)*]) =\u003e (\n    __op_internal__!(@eval @stack[$crate::Maximum\u003c$b, $a\u003e, $($stack,)*] @input[$($tail,)*])\n);\n(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[Gcf, $($tail:ident,)*]) =\u003e (\n    __op_internal__!(@eval @stack[$crate::Gcf\u003c$b, $a\u003e, $($stack,)*] @input[$($tail,)*])\n);\n(@eval @stack[$a:ty, $($stack:ty,)*] @input[Square, $($tail:ident,)*]) =\u003e (\n    __op_internal__!(@eval @stack[$crate::Square\u003c$a\u003e, $($stack,)*] @input[$($tail,)*])\n);\n(@eval @stack[$a:ty, $($stack:ty,)*] @input[Sqrt, $($tail:ident,)*]) =\u003e (\n    __op_internal__!(@eval @stack[$crate::Sqrt\u003c$a\u003e, $($stack,)*] @input[$($tail,)*])\n);\n(@eval @stack[$a:ty, $($stack:ty,)*] @input[AbsVal, $($tail:ident,)*]) =\u003e (\n    __op_internal__!(@eval @stack[$crate::AbsVal\u003c$a\u003e, $($stack,)*] @input[$($tail,)*])\n);\n(@eval @stack[$a:ty, $($stack:ty,)*] @input[Cube, $($tail:ident,)*]) =\u003e (\n    __op_internal__!(@eval @stack[$crate::Cube\u003c$a\u003e, $($stack,)*] @input[$($tail,)*])\n);\n(@eval @stack[$a:ty, $($stack:ty,)*] @input[Log2, $($tail:ident,)*]) =\u003e (\n    __op_internal__!(@eval @stack[$crate::Log2\u003c$a\u003e, $($stack,)*] @input[$($tail,)*])\n);\n(@eval @stack[$($stack:ty,)*] @input[$head:ident, $($tail:ident,)*]) =\u003e (\n    __op_internal__!(@eval @stack[$head, $($stack,)*] @input[$($tail,)*])\n);\n(@eval @stack[$stack:ty,] @input[]) =\u003e (\n    $stack\n);\n($($tail:tt)* ) =\u003e (\n    __op_internal__!(@stack[] @queue[] @tail: $($tail)*)\n);\n}","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","fuzz","target","x86_64-unknown-linux-gnu","release","build","typenum-85e81dd0a8c9dcba","out","tests.rs"],"content":"\nextern crate typenum;\n\nuse std::ops::*;\nuse std::cmp::Ordering;\nuse typenum::*;\n\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitAnd_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0BitAndU0 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitAndU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitOr_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0BitOrU0 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitOrU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitXor_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0BitXorU0 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitXorU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shl_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShlU0 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0ShlU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shr_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShrU0 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0ShrU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Add_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0AddU0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0AddU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Min_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MinU0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MinU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Max_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MaxU0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MaxU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Gcd_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0GcdU0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0GcdU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Sub_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0SubU0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0SubU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Mul_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MulU0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MulU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Pow_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0PowU0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0PowU0 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Cmp_0() {\n    type A = UTerm;\n    type B = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0CmpU0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU0CmpU0 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitAnd_1() {\n    type A = UTerm;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0BitAndU1 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitAndU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitOr_1() {\n    type A = UTerm;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0BitOrU1 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitOrU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitXor_1() {\n    type A = UTerm;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0BitXorU1 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitXorU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shl_1() {\n    type A = UTerm;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShlU1 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0ShlU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shr_1() {\n    type A = UTerm;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShrU1 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0ShrU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Add_1() {\n    type A = UTerm;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0AddU1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0AddU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Min_1() {\n    type A = UTerm;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MinU1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MinU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Max_1() {\n    type A = UTerm;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0MaxU1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MaxU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Gcd_1() {\n    type A = UTerm;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0GcdU1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0GcdU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Mul_1() {\n    type A = UTerm;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MulU1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MulU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Div_1() {\n    type A = UTerm;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0DivU1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0DivU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Rem_1() {\n    type A = UTerm;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0RemU1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0RemU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_PartialDiv_1() {\n    type A = UTerm;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0PartialDivU1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0PartialDivU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Pow_1() {\n    type A = UTerm;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0PowU1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0PowU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Cmp_1() {\n    type A = UTerm;\n    type B = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0CmpU1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU0CmpU1 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitAnd_2() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0BitAndU2 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitAndU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitOr_2() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0BitOrU2 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitOrU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitXor_2() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0BitXorU2 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitXorU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shl_2() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShlU2 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0ShlU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shr_2() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShrU2 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0ShrU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Add_2() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0AddU2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0AddU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Min_2() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MinU2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MinU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Max_2() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0MaxU2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MaxU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Gcd_2() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0GcdU2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0GcdU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Mul_2() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MulU2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MulU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Div_2() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0DivU2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0DivU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Rem_2() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0RemU2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0RemU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_PartialDiv_2() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0PartialDivU2 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0PartialDivU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Pow_2() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0PowU2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0PowU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Cmp_2() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0CmpU2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU0CmpU2 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitAnd_3() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0BitAndU3 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitAndU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitOr_3() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0BitOrU3 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitOrU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitXor_3() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0BitXorU3 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitXorU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shl_3() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShlU3 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0ShlU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shr_3() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShrU3 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0ShrU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Add_3() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0AddU3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0AddU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Min_3() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MinU3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MinU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Max_3() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0MaxU3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MaxU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Gcd_3() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0GcdU3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0GcdU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Mul_3() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MulU3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MulU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Div_3() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0DivU3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0DivU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Rem_3() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0RemU3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0RemU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_PartialDiv_3() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0PartialDivU3 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0PartialDivU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Pow_3() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0PowU3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0PowU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Cmp_3() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0CmpU3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU0CmpU3 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitAnd_4() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0BitAndU4 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitAndU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitOr_4() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0BitOrU4 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitOrU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitXor_4() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0BitXorU4 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitXorU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shl_4() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShlU4 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0ShlU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shr_4() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShrU4 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0ShrU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Add_4() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0AddU4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0AddU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Min_4() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MinU4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MinU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Max_4() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0MaxU4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MaxU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Gcd_4() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0GcdU4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0GcdU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Mul_4() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MulU4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MulU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Div_4() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0DivU4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0DivU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Rem_4() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0RemU4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0RemU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_PartialDiv_4() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0PartialDivU4 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0PartialDivU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Pow_4() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0PowU4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0PowU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Cmp_4() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0CmpU4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU0CmpU4 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitAnd_5() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0BitAndU5 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitAndU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitOr_5() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0BitOrU5 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitOrU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitXor_5() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0BitXorU5 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitXorU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shl_5() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShlU5 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0ShlU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shr_5() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShrU5 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0ShrU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Add_5() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0AddU5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0AddU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Min_5() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MinU5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MinU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Max_5() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0MaxU5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MaxU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Gcd_5() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0GcdU5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0GcdU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Mul_5() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MulU5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MulU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Div_5() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0DivU5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0DivU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Rem_5() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0RemU5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0RemU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_PartialDiv_5() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0PartialDivU5 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0PartialDivU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Pow_5() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0PowU5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0PowU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Cmp_5() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0CmpU5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU0CmpU5 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitAnd_0() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1BitAndU0 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitAndU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitOr_0() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UTerm;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1BitOrU0 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitOrU0 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitXor_0() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UTerm;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1BitXorU0 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitXorU0 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shl_0() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UTerm;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1ShlU0 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1ShlU0 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shr_0() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UTerm;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1ShrU0 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1ShrU0 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Add_0() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UTerm;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1AddU0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1AddU0 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Min_0() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1MinU0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MinU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Max_0() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UTerm;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MaxU0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MaxU0 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Gcd_0() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UTerm;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1GcdU0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1GcdU0 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Sub_0() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UTerm;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1SubU0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1SubU0 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Mul_0() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1MulU0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MulU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Pow_0() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UTerm;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1PowU0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1PowU0 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Cmp_0() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1CmpU0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU1CmpU0 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitAnd_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1BitAndU1 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitAndU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitOr_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1BitOrU1 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitOrU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitXor_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1BitXorU1 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitXorU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shl_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1ShlU1 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1ShlU1 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shr_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1ShrU1 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1ShrU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Add_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1AddU1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1AddU1 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Min_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MinU1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MinU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Max_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MaxU1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MaxU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Gcd_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1GcdU1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1GcdU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Sub_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1SubU1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1SubU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Mul_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MulU1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MulU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Div_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1DivU1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1DivU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Rem_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1RemU1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1RemU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_PartialDiv_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1PartialDivU1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1PartialDivU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Pow_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1PowU1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1PowU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Cmp_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1CmpU1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU1CmpU1 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitAnd_2() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1BitAndU2 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitAndU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitOr_2() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1BitOrU2 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitOrU2 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitXor_2() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1BitXorU2 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitXorU2 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shl_2() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1ShlU2 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1ShlU2 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shr_2() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1ShrU2 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1ShrU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Add_2() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1AddU2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1AddU2 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Min_2() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MinU2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MinU2 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Max_2() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MaxU2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MaxU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Gcd_2() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1GcdU2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1GcdU2 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Mul_2() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MulU2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MulU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Div_2() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1DivU2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1DivU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Rem_2() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1RemU2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1RemU2 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Pow_2() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1PowU2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1PowU2 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Cmp_2() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1CmpU2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU1CmpU2 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitAnd_3() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1BitAndU3 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitAndU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitOr_3() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1BitOrU3 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitOrU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitXor_3() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1BitXorU3 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitXorU3 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shl_3() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U8 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1ShlU3 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU8\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1ShlU3 as Unsigned\u003e::to_u64(), \u003cU8 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shr_3() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1ShrU3 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1ShrU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Add_3() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1AddU3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1AddU3 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Min_3() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MinU3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MinU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Max_3() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MaxU3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MaxU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Gcd_3() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1GcdU3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1GcdU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Mul_3() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MulU3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MulU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Div_3() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1DivU3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1DivU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Rem_3() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1RemU3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1RemU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Pow_3() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1PowU3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1PowU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Cmp_3() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1CmpU3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU1CmpU3 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitAnd_4() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1BitAndU4 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitAndU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitOr_4() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1BitOrU4 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitOrU4 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitXor_4() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1BitXorU4 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitXorU4 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shl_4() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U16 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1ShlU4 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU16\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1ShlU4 as Unsigned\u003e::to_u64(), \u003cU16 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shr_4() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1ShrU4 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1ShrU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Add_4() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1AddU4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1AddU4 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Min_4() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MinU4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MinU4 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Max_4() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MaxU4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MaxU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Gcd_4() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1GcdU4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1GcdU4 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Mul_4() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MulU4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MulU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Div_4() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1DivU4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1DivU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Rem_4() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1RemU4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1RemU4 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Pow_4() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1PowU4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1PowU4 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Cmp_4() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1CmpU4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU1CmpU4 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitAnd_5() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1BitAndU5 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitAndU5 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitOr_5() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1BitOrU5 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitOrU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitXor_5() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1BitXorU5 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitXorU5 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shl_5() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U32 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1ShlU5 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU32\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1ShlU5 as Unsigned\u003e::to_u64(), \u003cU32 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shr_5() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1ShrU5 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1ShrU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Add_5() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U6 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1AddU5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU6\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1AddU5 as Unsigned\u003e::to_u64(), \u003cU6 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Min_5() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MinU5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MinU5 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Max_5() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MaxU5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MaxU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Gcd_5() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1GcdU5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1GcdU5 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Mul_5() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MulU5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MulU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Div_5() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1DivU5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1DivU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Rem_5() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1RemU5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1RemU5 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Pow_5() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1PowU5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1PowU5 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Cmp_5() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1CmpU5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU1CmpU5 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitAnd_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2BitAndU0 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitAndU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitOr_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UTerm;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2BitOrU0 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitOrU0 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitXor_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UTerm;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2BitXorU0 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitXorU0 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shl_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UTerm;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2ShlU0 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2ShlU0 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shr_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UTerm;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2ShrU0 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2ShrU0 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Add_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UTerm;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2AddU0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2AddU0 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Min_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2MinU0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MinU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Max_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UTerm;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MaxU0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MaxU0 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Gcd_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UTerm;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2GcdU0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2GcdU0 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Sub_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UTerm;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2SubU0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2SubU0 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Mul_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2MulU0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MulU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Pow_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UTerm;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2PowU0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2PowU0 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Cmp_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2CmpU0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU2CmpU0 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitAnd_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2BitAndU1 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitAndU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitOr_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2BitOrU1 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitOrU1 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitXor_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2BitXorU1 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitXorU1 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shl_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2ShlU1 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2ShlU1 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shr_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2ShrU1 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2ShrU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Add_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2AddU1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2AddU1 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Min_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MinU1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MinU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Max_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MaxU1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MaxU1 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Gcd_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2GcdU1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2GcdU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Sub_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2SubU1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2SubU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Mul_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MulU1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MulU1 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Div_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2DivU1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2DivU1 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Rem_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2RemU1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2RemU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_PartialDiv_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2PartialDivU1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2PartialDivU1 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Pow_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2PowU1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2PowU1 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Cmp_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2CmpU1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU2CmpU1 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitAnd_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2BitAndU2 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitAndU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitOr_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2BitOrU2 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitOrU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitXor_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2BitXorU2 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitXorU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shl_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U8 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2ShlU2 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU8\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2ShlU2 as Unsigned\u003e::to_u64(), \u003cU8 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shr_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2ShrU2 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2ShrU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Add_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2AddU2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2AddU2 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Min_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MinU2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MinU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Max_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MaxU2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MaxU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Gcd_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2GcdU2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2GcdU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Sub_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2SubU2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2SubU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Mul_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MulU2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MulU2 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Div_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2DivU2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2DivU2 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Rem_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2RemU2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2RemU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_PartialDiv_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2PartialDivU2 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2PartialDivU2 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Pow_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2PowU2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2PowU2 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Cmp_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2CmpU2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU2CmpU2 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitAnd_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2BitAndU3 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitAndU3 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitOr_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2BitOrU3 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitOrU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitXor_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2BitXorU3 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitXorU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shl_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U16 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2ShlU3 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU16\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2ShlU3 as Unsigned\u003e::to_u64(), \u003cU16 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shr_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2ShrU3 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2ShrU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Add_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2AddU3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2AddU3 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Min_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MinU3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MinU3 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Max_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MaxU3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MaxU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Gcd_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2GcdU3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2GcdU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Mul_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U6 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MulU3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU6\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MulU3 as Unsigned\u003e::to_u64(), \u003cU6 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Div_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2DivU3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2DivU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Rem_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2RemU3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2RemU3 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Pow_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U8 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2PowU3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU8\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2PowU3 as Unsigned\u003e::to_u64(), \u003cU8 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Cmp_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2CmpU3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU2CmpU3 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitAnd_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2BitAndU4 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitAndU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitOr_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U6 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2BitOrU4 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU6\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitOrU4 as Unsigned\u003e::to_u64(), \u003cU6 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitXor_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U6 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2BitXorU4 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU6\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitXorU4 as Unsigned\u003e::to_u64(), \u003cU6 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shl_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U32 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2ShlU4 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU32\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2ShlU4 as Unsigned\u003e::to_u64(), \u003cU32 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shr_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2ShrU4 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2ShrU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Add_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U6 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2AddU4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU6\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2AddU4 as Unsigned\u003e::to_u64(), \u003cU6 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Min_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MinU4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MinU4 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Max_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MaxU4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MaxU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Gcd_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2GcdU4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2GcdU4 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Mul_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U8 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MulU4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU8\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MulU4 as Unsigned\u003e::to_u64(), \u003cU8 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Div_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2DivU4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2DivU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Rem_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2RemU4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2RemU4 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Pow_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U16 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2PowU4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU16\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2PowU4 as Unsigned\u003e::to_u64(), \u003cU16 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Cmp_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2CmpU4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU2CmpU4 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitAnd_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2BitAndU5 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitAndU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitOr_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U7 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2BitOrU5 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU7\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitOrU5 as Unsigned\u003e::to_u64(), \u003cU7 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitXor_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U7 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2BitXorU5 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU7\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitXorU5 as Unsigned\u003e::to_u64(), \u003cU7 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shl_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U64 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2ShlU5 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU64\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2ShlU5 as Unsigned\u003e::to_u64(), \u003cU64 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shr_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2ShrU5 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2ShrU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Add_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U7 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2AddU5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU7\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2AddU5 as Unsigned\u003e::to_u64(), \u003cU7 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Min_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MinU5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MinU5 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Max_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MaxU5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MaxU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Gcd_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2GcdU5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2GcdU5 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Mul_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U10 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MulU5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU10\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MulU5 as Unsigned\u003e::to_u64(), \u003cU10 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Div_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2DivU5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2DivU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Rem_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2RemU5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2RemU5 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Pow_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U32 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2PowU5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU32\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2PowU5 as Unsigned\u003e::to_u64(), \u003cU32 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Cmp_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2CmpU5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU2CmpU5 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitAnd_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3BitAndU0 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitAndU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitOr_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UTerm;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3BitOrU0 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitOrU0 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitXor_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UTerm;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3BitXorU0 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitXorU0 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shl_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UTerm;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3ShlU0 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3ShlU0 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shr_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UTerm;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3ShrU0 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3ShrU0 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Add_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UTerm;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3AddU0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3AddU0 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Min_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3MinU0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MinU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Max_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UTerm;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MaxU0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MaxU0 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Gcd_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UTerm;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3GcdU0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3GcdU0 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Sub_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UTerm;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3SubU0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3SubU0 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Mul_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3MulU0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MulU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Pow_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UTerm;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3PowU0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3PowU0 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Cmp_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3CmpU0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU3CmpU0 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitAnd_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3BitAndU1 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitAndU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitOr_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3BitOrU1 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitOrU1 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitXor_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3BitXorU1 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitXorU1 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shl_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U6 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3ShlU1 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU6\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3ShlU1 as Unsigned\u003e::to_u64(), \u003cU6 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shr_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3ShrU1 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3ShrU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Add_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3AddU1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3AddU1 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Min_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MinU1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MinU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Max_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MaxU1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MaxU1 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Gcd_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3GcdU1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3GcdU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Sub_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3SubU1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3SubU1 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Mul_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MulU1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MulU1 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Div_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3DivU1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3DivU1 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Rem_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3RemU1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3RemU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_PartialDiv_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3PartialDivU1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3PartialDivU1 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Pow_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3PowU1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3PowU1 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Cmp_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3CmpU1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU3CmpU1 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitAnd_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3BitAndU2 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitAndU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitOr_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3BitOrU2 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitOrU2 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitXor_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3BitXorU2 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitXorU2 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shl_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U12 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3ShlU2 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU12\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3ShlU2 as Unsigned\u003e::to_u64(), \u003cU12 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shr_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3ShrU2 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3ShrU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Add_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3AddU2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3AddU2 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Min_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MinU2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MinU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Max_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MaxU2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MaxU2 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Gcd_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3GcdU2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3GcdU2 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Sub_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3SubU2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3SubU2 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Mul_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U6 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MulU2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU6\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MulU2 as Unsigned\u003e::to_u64(), \u003cU6 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Div_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3DivU2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3DivU2 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Rem_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3RemU2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3RemU2 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Pow_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U9 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3PowU2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU9\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3PowU2 as Unsigned\u003e::to_u64(), \u003cU9 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Cmp_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3CmpU2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU3CmpU2 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitAnd_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3BitAndU3 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitAndU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitOr_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3BitOrU3 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitOrU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitXor_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3BitXorU3 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitXorU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shl_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U24 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3ShlU3 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU24\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3ShlU3 as Unsigned\u003e::to_u64(), \u003cU24 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shr_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3ShrU3 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3ShrU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Add_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U6 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3AddU3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU6\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3AddU3 as Unsigned\u003e::to_u64(), \u003cU6 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Min_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MinU3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MinU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Max_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MaxU3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MaxU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Gcd_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3GcdU3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3GcdU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Sub_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3SubU3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3SubU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Mul_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U9 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MulU3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU9\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MulU3 as Unsigned\u003e::to_u64(), \u003cU9 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Div_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3DivU3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3DivU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Rem_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3RemU3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3RemU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_PartialDiv_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3PartialDivU3 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3PartialDivU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Pow_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U27 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3PowU3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU27\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3PowU3 as Unsigned\u003e::to_u64(), \u003cU27 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Cmp_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3CmpU3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU3CmpU3 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitAnd_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3BitAndU4 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitAndU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitOr_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U7 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3BitOrU4 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU7\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitOrU4 as Unsigned\u003e::to_u64(), \u003cU7 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitXor_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U7 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3BitXorU4 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU7\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitXorU4 as Unsigned\u003e::to_u64(), \u003cU7 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shl_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U48 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3ShlU4 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU48\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3ShlU4 as Unsigned\u003e::to_u64(), \u003cU48 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shr_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3ShrU4 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3ShrU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Add_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U7 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3AddU4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU7\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3AddU4 as Unsigned\u003e::to_u64(), \u003cU7 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Min_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MinU4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MinU4 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Max_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MaxU4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MaxU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Gcd_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3GcdU4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3GcdU4 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Mul_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U12 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MulU4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU12\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MulU4 as Unsigned\u003e::to_u64(), \u003cU12 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Div_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3DivU4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3DivU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Rem_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3RemU4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3RemU4 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Pow_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U81 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3PowU4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU81\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3PowU4 as Unsigned\u003e::to_u64(), \u003cU81 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Cmp_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3CmpU4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU3CmpU4 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitAnd_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3BitAndU5 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitAndU5 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitOr_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U7 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3BitOrU5 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU7\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitOrU5 as Unsigned\u003e::to_u64(), \u003cU7 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitXor_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U6 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3BitXorU5 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU6\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitXorU5 as Unsigned\u003e::to_u64(), \u003cU6 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shl_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U96 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3ShlU5 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU96\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3ShlU5 as Unsigned\u003e::to_u64(), \u003cU96 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shr_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3ShrU5 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3ShrU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Add_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U8 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3AddU5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU8\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3AddU5 as Unsigned\u003e::to_u64(), \u003cU8 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Min_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MinU5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MinU5 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Max_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MaxU5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MaxU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Gcd_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3GcdU5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3GcdU5 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Mul_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U15 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MulU5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU15\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MulU5 as Unsigned\u003e::to_u64(), \u003cU15 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Div_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3DivU5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3DivU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Rem_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3RemU5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3RemU5 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Pow_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U243 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3PowU5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU243\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3PowU5 as Unsigned\u003e::to_u64(), \u003cU243 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Cmp_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3CmpU5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU3CmpU5 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitAnd_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4BitAndU0 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitAndU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitOr_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UTerm;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4BitOrU0 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitOrU0 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitXor_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UTerm;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4BitXorU0 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitXorU0 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shl_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UTerm;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4ShlU0 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4ShlU0 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shr_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UTerm;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4ShrU0 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4ShrU0 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Add_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UTerm;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4AddU0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4AddU0 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Min_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4MinU0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MinU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Max_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UTerm;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MaxU0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MaxU0 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Gcd_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UTerm;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4GcdU0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4GcdU0 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Sub_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UTerm;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4SubU0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4SubU0 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Mul_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4MulU0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MulU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Pow_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UTerm;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4PowU0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4PowU0 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Cmp_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4CmpU0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU4CmpU0 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitAnd_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4BitAndU1 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitAndU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitOr_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4BitOrU1 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitOrU1 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitXor_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4BitXorU1 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitXorU1 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shl_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U8 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4ShlU1 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU8\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4ShlU1 as Unsigned\u003e::to_u64(), \u003cU8 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shr_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4ShrU1 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4ShrU1 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Add_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4AddU1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4AddU1 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Min_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MinU1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MinU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Max_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MaxU1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MaxU1 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Gcd_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4GcdU1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4GcdU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Sub_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4SubU1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4SubU1 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Mul_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MulU1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MulU1 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Div_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4DivU1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4DivU1 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Rem_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4RemU1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4RemU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_PartialDiv_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4PartialDivU1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4PartialDivU1 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Pow_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4PowU1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4PowU1 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Cmp_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4CmpU1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU4CmpU1 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitAnd_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4BitAndU2 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitAndU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitOr_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U6 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4BitOrU2 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU6\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitOrU2 as Unsigned\u003e::to_u64(), \u003cU6 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitXor_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U6 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4BitXorU2 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU6\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitXorU2 as Unsigned\u003e::to_u64(), \u003cU6 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shl_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U16 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4ShlU2 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU16\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4ShlU2 as Unsigned\u003e::to_u64(), \u003cU16 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shr_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4ShrU2 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4ShrU2 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Add_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U6 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4AddU2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU6\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4AddU2 as Unsigned\u003e::to_u64(), \u003cU6 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Min_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MinU2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MinU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Max_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MaxU2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MaxU2 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Gcd_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4GcdU2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4GcdU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Sub_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4SubU2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4SubU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Mul_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U8 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MulU2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU8\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MulU2 as Unsigned\u003e::to_u64(), \u003cU8 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Div_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4DivU2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4DivU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Rem_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4RemU2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4RemU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_PartialDiv_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4PartialDivU2 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4PartialDivU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Pow_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U16 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4PowU2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU16\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4PowU2 as Unsigned\u003e::to_u64(), \u003cU16 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Cmp_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4CmpU2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU4CmpU2 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitAnd_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4BitAndU3 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitAndU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitOr_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U7 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4BitOrU3 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU7\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitOrU3 as Unsigned\u003e::to_u64(), \u003cU7 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitXor_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U7 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4BitXorU3 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU7\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitXorU3 as Unsigned\u003e::to_u64(), \u003cU7 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shl_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U32 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4ShlU3 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU32\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4ShlU3 as Unsigned\u003e::to_u64(), \u003cU32 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shr_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4ShrU3 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4ShrU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Add_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U7 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4AddU3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU7\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4AddU3 as Unsigned\u003e::to_u64(), \u003cU7 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Min_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MinU3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MinU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Max_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MaxU3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MaxU3 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Gcd_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4GcdU3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4GcdU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Sub_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4SubU3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4SubU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Mul_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U12 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MulU3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU12\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MulU3 as Unsigned\u003e::to_u64(), \u003cU12 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Div_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4DivU3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4DivU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Rem_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4RemU3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4RemU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Pow_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U64 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4PowU3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU64\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4PowU3 as Unsigned\u003e::to_u64(), \u003cU64 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Cmp_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4CmpU3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU4CmpU3 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitAnd_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4BitAndU4 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitAndU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitOr_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4BitOrU4 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitOrU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitXor_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4BitXorU4 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitXorU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shl_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U64 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4ShlU4 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU64\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4ShlU4 as Unsigned\u003e::to_u64(), \u003cU64 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shr_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4ShrU4 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4ShrU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Add_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U8 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4AddU4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU8\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4AddU4 as Unsigned\u003e::to_u64(), \u003cU8 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Min_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MinU4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MinU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Max_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MaxU4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MaxU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Gcd_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4GcdU4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4GcdU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Sub_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4SubU4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4SubU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Mul_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U16 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MulU4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU16\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MulU4 as Unsigned\u003e::to_u64(), \u003cU16 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Div_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4DivU4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4DivU4 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Rem_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4RemU4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4RemU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_PartialDiv_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4PartialDivU4 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4PartialDivU4 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Pow_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U256 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4PowU4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU256\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4PowU4 as Unsigned\u003e::to_u64(), \u003cU256 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Cmp_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4CmpU4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU4CmpU4 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitAnd_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4BitAndU5 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitAndU5 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitOr_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4BitOrU5 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitOrU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitXor_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4BitXorU5 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitXorU5 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shl_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U128 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4ShlU5 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU128\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4ShlU5 as Unsigned\u003e::to_u64(), \u003cU128 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shr_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4ShrU5 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4ShrU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Add_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U9 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4AddU5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU9\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4AddU5 as Unsigned\u003e::to_u64(), \u003cU9 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Min_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MinU5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MinU5 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Max_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MaxU5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MaxU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Gcd_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4GcdU5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4GcdU5 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Mul_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U20 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MulU5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU20\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MulU5 as Unsigned\u003e::to_u64(), \u003cU20 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Div_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4DivU5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4DivU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Rem_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4RemU5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4RemU5 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Pow_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U1024 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4PowU5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU1024\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4PowU5 as Unsigned\u003e::to_u64(), \u003cU1024 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Cmp_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4CmpU5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU4CmpU5 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitAnd_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5BitAndU0 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitAndU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitOr_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UTerm;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5BitOrU0 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitOrU0 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitXor_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UTerm;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5BitXorU0 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitXorU0 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shl_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UTerm;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5ShlU0 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5ShlU0 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shr_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UTerm;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5ShrU0 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5ShrU0 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Add_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UTerm;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5AddU0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5AddU0 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Min_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5MinU0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MinU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Max_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UTerm;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MaxU0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MaxU0 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Gcd_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UTerm;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5GcdU0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5GcdU0 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Sub_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UTerm;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5SubU0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5SubU0 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Mul_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5MulU0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MulU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Pow_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UTerm;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5PowU0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5PowU0 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Cmp_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5CmpU0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU5CmpU0 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitAnd_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5BitAndU1 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitAndU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitOr_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5BitOrU1 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitOrU1 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitXor_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5BitXorU1 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitXorU1 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shl_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U10 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5ShlU1 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU10\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5ShlU1 as Unsigned\u003e::to_u64(), \u003cU10 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shr_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5ShrU1 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5ShrU1 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Add_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U6 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5AddU1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU6\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5AddU1 as Unsigned\u003e::to_u64(), \u003cU6 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Min_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MinU1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MinU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Max_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MaxU1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MaxU1 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Gcd_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5GcdU1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5GcdU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Sub_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5SubU1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5SubU1 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Mul_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MulU1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MulU1 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Div_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5DivU1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5DivU1 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Rem_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5RemU1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5RemU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_PartialDiv_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5PartialDivU1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5PartialDivU1 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Pow_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5PowU1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5PowU1 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Cmp_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5CmpU1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU5CmpU1 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitAnd_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5BitAndU2 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitAndU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitOr_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U7 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5BitOrU2 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU7\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitOrU2 as Unsigned\u003e::to_u64(), \u003cU7 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitXor_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U7 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5BitXorU2 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU7\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitXorU2 as Unsigned\u003e::to_u64(), \u003cU7 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shl_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U20 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5ShlU2 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU20\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5ShlU2 as Unsigned\u003e::to_u64(), \u003cU20 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shr_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5ShrU2 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5ShrU2 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Add_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U7 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5AddU2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU7\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5AddU2 as Unsigned\u003e::to_u64(), \u003cU7 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Min_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MinU2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MinU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Max_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MaxU2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MaxU2 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Gcd_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5GcdU2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5GcdU2 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Sub_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5SubU2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5SubU2 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Mul_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U10 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MulU2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU10\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MulU2 as Unsigned\u003e::to_u64(), \u003cU10 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Div_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5DivU2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5DivU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Rem_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5RemU2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5RemU2 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Pow_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U25 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5PowU2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU25\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5PowU2 as Unsigned\u003e::to_u64(), \u003cU25 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Cmp_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5CmpU2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU5CmpU2 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitAnd_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5BitAndU3 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitAndU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitOr_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U7 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5BitOrU3 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU7\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitOrU3 as Unsigned\u003e::to_u64(), \u003cU7 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitXor_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U6 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5BitXorU3 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU6\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitXorU3 as Unsigned\u003e::to_u64(), \u003cU6 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shl_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U40 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5ShlU3 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU40\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5ShlU3 as Unsigned\u003e::to_u64(), \u003cU40 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shr_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5ShrU3 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5ShrU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Add_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U8 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5AddU3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU8\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5AddU3 as Unsigned\u003e::to_u64(), \u003cU8 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Min_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MinU3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MinU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Max_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MaxU3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MaxU3 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Gcd_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5GcdU3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5GcdU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Sub_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5SubU3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5SubU3 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Mul_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U15 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MulU3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU15\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MulU3 as Unsigned\u003e::to_u64(), \u003cU15 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Div_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5DivU3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5DivU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Rem_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5RemU3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5RemU3 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Pow_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U125 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5PowU3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU125\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5PowU3 as Unsigned\u003e::to_u64(), \u003cU125 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Cmp_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5CmpU3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU5CmpU3 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitAnd_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5BitAndU4 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitAndU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitOr_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5BitOrU4 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitOrU4 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitXor_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5BitXorU4 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitXorU4 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shl_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U80 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5ShlU4 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU80\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5ShlU4 as Unsigned\u003e::to_u64(), \u003cU80 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shr_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5ShrU4 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5ShrU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Add_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U9 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5AddU4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU9\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5AddU4 as Unsigned\u003e::to_u64(), \u003cU9 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Min_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MinU4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MinU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Max_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MaxU4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MaxU4 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Gcd_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5GcdU4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5GcdU4 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Sub_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5SubU4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5SubU4 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Mul_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U20 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MulU4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU20\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MulU4 as Unsigned\u003e::to_u64(), \u003cU20 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Div_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5DivU4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5DivU4 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Rem_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5RemU4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5RemU4 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Pow_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U625 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5PowU4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU625\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5PowU4 as Unsigned\u003e::to_u64(), \u003cU625 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Cmp_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5CmpU4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU5CmpU4 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitAnd_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5BitAndU5 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitAndU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitOr_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5BitOrU5 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitOrU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitXor_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5BitXorU5 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitXorU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shl_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U160 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5ShlU5 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU160\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5ShlU5 as Unsigned\u003e::to_u64(), \u003cU160 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shr_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5ShrU5 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5ShrU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Add_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U10 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5AddU5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU10\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5AddU5 as Unsigned\u003e::to_u64(), \u003cU10 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Min_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MinU5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MinU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Max_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MaxU5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MaxU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Gcd_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5GcdU5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5GcdU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Sub_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5SubU5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5SubU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Mul_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U25 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MulU5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU25\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MulU5 as Unsigned\u003e::to_u64(), \u003cU25 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Div_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5DivU5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5DivU5 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Rem_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5RemU5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5RemU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_PartialDiv_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5PartialDivU5 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5PartialDivU5 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Pow_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U3125 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5PowU5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU3125\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5PowU5 as Unsigned\u003e::to_u64(), \u003cU3125 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Cmp_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5CmpU5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU5CmpU5 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Add_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N10 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5AddN5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN10\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5AddN5 as Integer\u003e::to_i64(), \u003cN10 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Sub_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N5SubN5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5SubN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Mul_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P25 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MulN5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP25\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MulN5 as Integer\u003e::to_i64(), \u003cP25 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Min_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MinN5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MinN5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Max_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MaxN5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MaxN5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Gcd_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5GcdN5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5GcdN5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Div_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5DivN5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5DivN5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Rem_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N5RemN5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5RemN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_PartialDiv_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5PartialDivN5 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5PartialDivN5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Cmp_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5CmpN5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN5CmpN5 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Add_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N9 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5AddN4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN9\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5AddN4 as Integer\u003e::to_i64(), \u003cN9 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Sub_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5SubN4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5SubN4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Mul_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P20 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MulN4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP20\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MulN4 as Integer\u003e::to_i64(), \u003cP20 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Min_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MinN4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MinN4 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Max_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MaxN4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MaxN4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Gcd_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5GcdN4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5GcdN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Div_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5DivN4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5DivN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Rem_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5RemN4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5RemN4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Cmp_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5CmpN4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN5CmpN4 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Add_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N8 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5AddN3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN8\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5AddN3 as Integer\u003e::to_i64(), \u003cN8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Sub_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5SubN3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5SubN3 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Mul_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P15 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MulN3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP15\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MulN3 as Integer\u003e::to_i64(), \u003cP15 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Min_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MinN3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MinN3 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Max_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MaxN3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MaxN3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Gcd_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5GcdN3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5GcdN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Div_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5DivN3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5DivN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Rem_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5RemN3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5RemN3 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Cmp_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5CmpN3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN5CmpN3 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Add_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N7 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5AddN2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN7\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5AddN2 as Integer\u003e::to_i64(), \u003cN7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Sub_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5SubN2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5SubN2 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Mul_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P10 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MulN2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP10\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MulN2 as Integer\u003e::to_i64(), \u003cP10 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Min_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MinN2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MinN2 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Max_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MaxN2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MaxN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Gcd_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5GcdN2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5GcdN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Div_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5DivN2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5DivN2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Rem_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5RemN2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5RemN2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Cmp_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5CmpN2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN5CmpN2 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Add_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N6 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5AddN1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN6\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5AddN1 as Integer\u003e::to_i64(), \u003cN6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Sub_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5SubN1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5SubN1 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Mul_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MulN1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MulN1 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Min_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MinN1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MinN1 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Max_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MaxN1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MaxN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Gcd_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5GcdN1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5GcdN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Div_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5DivN1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5DivN1 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Rem_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N5RemN1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5RemN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_PartialDiv_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5PartialDivN1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5PartialDivN1 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Cmp_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5CmpN1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN5CmpN1 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Add__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5Add_0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5Add_0 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Sub__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5Sub_0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5Sub_0 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Mul__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N5Mul_0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5Mul_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Min__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5Min_0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5Min_0 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Max__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N5Max_0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5Max_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Gcd__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5Gcd_0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5Gcd_0 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Pow__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5Pow_0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5Pow_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Cmp__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N5Cmp_0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN5Cmp_0 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Add_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5AddP1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5AddP1 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Sub_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N6 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5SubP1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN6\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5SubP1 as Integer\u003e::to_i64(), \u003cN6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Mul_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MulP1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MulP1 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Min_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MinP1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MinP1 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Max_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MaxP1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MaxP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Gcd_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5GcdP1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5GcdP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Div_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5DivP1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5DivP1 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Rem_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N5RemP1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5RemP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_PartialDiv_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5PartialDivP1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5PartialDivP1 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Pow_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5PowP1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5PowP1 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Cmp_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5CmpP1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN5CmpP1 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Add_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5AddP2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5AddP2 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Sub_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N7 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5SubP2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN7\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5SubP2 as Integer\u003e::to_i64(), \u003cN7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Mul_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N10 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MulP2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN10\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MulP2 as Integer\u003e::to_i64(), \u003cN10 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Min_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MinP2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MinP2 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Max_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MaxP2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MaxP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Gcd_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5GcdP2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5GcdP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Div_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5DivP2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5DivP2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Rem_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5RemP2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5RemP2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Pow_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P25 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5PowP2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP25\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5PowP2 as Integer\u003e::to_i64(), \u003cP25 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Cmp_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5CmpP2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN5CmpP2 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Add_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5AddP3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5AddP3 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Sub_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N8 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5SubP3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN8\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5SubP3 as Integer\u003e::to_i64(), \u003cN8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Mul_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N15 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MulP3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN15\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MulP3 as Integer\u003e::to_i64(), \u003cN15 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Min_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MinP3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MinP3 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Max_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MaxP3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MaxP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Gcd_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5GcdP3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5GcdP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Div_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5DivP3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5DivP3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Rem_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5RemP3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5RemP3 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Pow_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N125 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5PowP3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN125\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5PowP3 as Integer\u003e::to_i64(), \u003cN125 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Cmp_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5CmpP3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN5CmpP3 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Add_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5AddP4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5AddP4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Sub_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N9 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5SubP4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN9\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5SubP4 as Integer\u003e::to_i64(), \u003cN9 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Mul_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N20 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MulP4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN20\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MulP4 as Integer\u003e::to_i64(), \u003cN20 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Min_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MinP4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MinP4 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Max_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MaxP4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MaxP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Gcd_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5GcdP4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5GcdP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Div_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5DivP4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5DivP4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Rem_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5RemP4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5RemP4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Pow_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P625 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5PowP4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP625\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5PowP4 as Integer\u003e::to_i64(), \u003cP625 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Cmp_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5CmpP4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN5CmpP4 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Add_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N5AddP5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5AddP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Sub_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N10 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5SubP5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN10\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5SubP5 as Integer\u003e::to_i64(), \u003cN10 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Mul_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N25 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MulP5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN25\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MulP5 as Integer\u003e::to_i64(), \u003cN25 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Min_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MinP5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MinP5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Max_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MaxP5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MaxP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Gcd_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5GcdP5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5GcdP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Div_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5DivP5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5DivP5 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Rem_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N5RemP5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5RemP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_PartialDiv_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5PartialDivP5 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5PartialDivP5 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Pow_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N3125 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5PowP5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN3125\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5PowP5 as Integer\u003e::to_i64(), \u003cN3125 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Cmp_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5CmpP5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN5CmpP5 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Add_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N9 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4AddN5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN9\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4AddN5 as Integer\u003e::to_i64(), \u003cN9 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Sub_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4SubN5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4SubN5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Mul_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P20 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MulN5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP20\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MulN5 as Integer\u003e::to_i64(), \u003cP20 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Min_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MinN5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MinN5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Max_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MaxN5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MaxN5 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Gcd_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4GcdN5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4GcdN5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Div_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4DivN5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4DivN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Rem_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4RemN5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4RemN5 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Cmp_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4CmpN5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN4CmpN5 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Add_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N8 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4AddN4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN8\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4AddN4 as Integer\u003e::to_i64(), \u003cN8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Sub_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4SubN4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4SubN4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Mul_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P16 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MulN4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP16\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MulN4 as Integer\u003e::to_i64(), \u003cP16 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Min_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MinN4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MinN4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Max_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MaxN4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MaxN4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Gcd_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4GcdN4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4GcdN4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Div_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4DivN4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4DivN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Rem_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4RemN4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4RemN4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_PartialDiv_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4PartialDivN4 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4PartialDivN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Cmp_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4CmpN4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN4CmpN4 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Add_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N7 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4AddN3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN7\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4AddN3 as Integer\u003e::to_i64(), \u003cN7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Sub_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4SubN3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4SubN3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Mul_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P12 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MulN3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP12\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MulN3 as Integer\u003e::to_i64(), \u003cP12 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Min_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MinN3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MinN3 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Max_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MaxN3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MaxN3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Gcd_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4GcdN3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4GcdN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Div_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4DivN3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4DivN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Rem_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4RemN3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4RemN3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Cmp_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4CmpN3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN4CmpN3 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Add_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N6 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4AddN2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN6\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4AddN2 as Integer\u003e::to_i64(), \u003cN6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Sub_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4SubN2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4SubN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Mul_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P8 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MulN2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP8\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MulN2 as Integer\u003e::to_i64(), \u003cP8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Min_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MinN2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MinN2 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Max_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MaxN2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MaxN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Gcd_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4GcdN2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4GcdN2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Div_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4DivN2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4DivN2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Rem_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4RemN2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4RemN2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_PartialDiv_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4PartialDivN2 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4PartialDivN2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Cmp_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4CmpN2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN4CmpN2 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Add_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4AddN1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4AddN1 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Sub_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4SubN1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4SubN1 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Mul_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MulN1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MulN1 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Min_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MinN1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MinN1 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Max_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MaxN1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MaxN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Gcd_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4GcdN1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4GcdN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Div_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4DivN1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4DivN1 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Rem_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4RemN1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4RemN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_PartialDiv_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4PartialDivN1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4PartialDivN1 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Cmp_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4CmpN1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN4CmpN1 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Add__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4Add_0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4Add_0 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Sub__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4Sub_0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4Sub_0 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Mul__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4Mul_0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4Mul_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Min__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4Min_0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4Min_0 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Max__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4Max_0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4Max_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Gcd__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4Gcd_0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4Gcd_0 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Pow__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4Pow_0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4Pow_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Cmp__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4Cmp_0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN4Cmp_0 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Add_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4AddP1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4AddP1 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Sub_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4SubP1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4SubP1 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Mul_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MulP1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MulP1 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Min_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MinP1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MinP1 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Max_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MaxP1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MaxP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Gcd_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4GcdP1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4GcdP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Div_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4DivP1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4DivP1 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Rem_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4RemP1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4RemP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_PartialDiv_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4PartialDivP1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4PartialDivP1 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Pow_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4PowP1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4PowP1 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Cmp_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4CmpP1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN4CmpP1 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Add_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4AddP2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4AddP2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Sub_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N6 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4SubP2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN6\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4SubP2 as Integer\u003e::to_i64(), \u003cN6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Mul_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N8 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MulP2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN8\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MulP2 as Integer\u003e::to_i64(), \u003cN8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Min_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MinP2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MinP2 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Max_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MaxP2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MaxP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Gcd_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4GcdP2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4GcdP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Div_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4DivP2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4DivP2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Rem_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4RemP2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4RemP2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_PartialDiv_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4PartialDivP2 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4PartialDivP2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Pow_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P16 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4PowP2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP16\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4PowP2 as Integer\u003e::to_i64(), \u003cP16 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Cmp_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4CmpP2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN4CmpP2 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Add_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4AddP3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4AddP3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Sub_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N7 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4SubP3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN7\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4SubP3 as Integer\u003e::to_i64(), \u003cN7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Mul_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N12 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MulP3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN12\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MulP3 as Integer\u003e::to_i64(), \u003cN12 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Min_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MinP3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MinP3 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Max_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MaxP3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MaxP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Gcd_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4GcdP3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4GcdP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Div_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4DivP3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4DivP3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Rem_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4RemP3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4RemP3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Pow_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N64 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4PowP3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN64\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4PowP3 as Integer\u003e::to_i64(), \u003cN64 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Cmp_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4CmpP3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN4CmpP3 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Add_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4AddP4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4AddP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Sub_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N8 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4SubP4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN8\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4SubP4 as Integer\u003e::to_i64(), \u003cN8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Mul_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N16 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MulP4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN16\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MulP4 as Integer\u003e::to_i64(), \u003cN16 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Min_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MinP4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MinP4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Max_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MaxP4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MaxP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Gcd_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4GcdP4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4GcdP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Div_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4DivP4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4DivP4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Rem_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4RemP4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4RemP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_PartialDiv_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4PartialDivP4 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4PartialDivP4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Pow_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P256 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4PowP4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP256\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4PowP4 as Integer\u003e::to_i64(), \u003cP256 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Cmp_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4CmpP4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN4CmpP4 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Add_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4AddP5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4AddP5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Sub_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N9 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4SubP5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN9\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4SubP5 as Integer\u003e::to_i64(), \u003cN9 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Mul_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N20 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MulP5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN20\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MulP5 as Integer\u003e::to_i64(), \u003cN20 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Min_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MinP5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MinP5 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Max_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MaxP5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MaxP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Gcd_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4GcdP5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4GcdP5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Div_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4DivP5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4DivP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Rem_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4RemP5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4RemP5 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Pow_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N1024 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4PowP5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN1024\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4PowP5 as Integer\u003e::to_i64(), \u003cN1024 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Cmp_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4CmpP5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN4CmpP5 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Add_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N8 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3AddN5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN8\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3AddN5 as Integer\u003e::to_i64(), \u003cN8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Sub_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3SubN5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3SubN5 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Mul_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P15 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MulN5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP15\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MulN5 as Integer\u003e::to_i64(), \u003cP15 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Min_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MinN5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MinN5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Max_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MaxN5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MaxN5 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Gcd_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3GcdN5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3GcdN5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Div_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3DivN5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3DivN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Rem_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3RemN5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3RemN5 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Cmp_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3CmpN5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN3CmpN5 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Add_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N7 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3AddN4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN7\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3AddN4 as Integer\u003e::to_i64(), \u003cN7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Sub_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3SubN4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3SubN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Mul_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P12 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MulN4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP12\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MulN4 as Integer\u003e::to_i64(), \u003cP12 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Min_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MinN4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MinN4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Max_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MaxN4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MaxN4 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Gcd_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3GcdN4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3GcdN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Div_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3DivN4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3DivN4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Rem_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3RemN4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3RemN4 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Cmp_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3CmpN4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN3CmpN4 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Add_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N6 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3AddN3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN6\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3AddN3 as Integer\u003e::to_i64(), \u003cN6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Sub_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3SubN3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3SubN3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Mul_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P9 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MulN3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP9\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MulN3 as Integer\u003e::to_i64(), \u003cP9 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Min_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MinN3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MinN3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Max_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MaxN3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MaxN3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Gcd_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3GcdN3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3GcdN3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Div_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3DivN3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3DivN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Rem_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3RemN3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3RemN3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_PartialDiv_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3PartialDivN3 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3PartialDivN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Cmp_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3CmpN3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN3CmpN3 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Add_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3AddN2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3AddN2 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Sub_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3SubN2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3SubN2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Mul_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P6 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MulN2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP6\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MulN2 as Integer\u003e::to_i64(), \u003cP6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Min_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MinN2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MinN2 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Max_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MaxN2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MaxN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Gcd_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3GcdN2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3GcdN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Div_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3DivN2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3DivN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Rem_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3RemN2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3RemN2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Cmp_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3CmpN2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN3CmpN2 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Add_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3AddN1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3AddN1 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Sub_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3SubN1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3SubN1 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Mul_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MulN1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MulN1 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Min_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MinN1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MinN1 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Max_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MaxN1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MaxN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Gcd_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3GcdN1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3GcdN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Div_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3DivN1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3DivN1 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Rem_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3RemN1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3RemN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_PartialDiv_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3PartialDivN1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3PartialDivN1 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Cmp_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3CmpN1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN3CmpN1 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Add__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3Add_0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3Add_0 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Sub__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3Sub_0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3Sub_0 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Mul__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3Mul_0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3Mul_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Min__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3Min_0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3Min_0 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Max__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3Max_0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3Max_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Gcd__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3Gcd_0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3Gcd_0 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Pow__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3Pow_0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3Pow_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Cmp__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3Cmp_0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN3Cmp_0 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Add_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3AddP1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3AddP1 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Sub_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3SubP1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3SubP1 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Mul_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MulP1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MulP1 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Min_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MinP1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MinP1 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Max_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MaxP1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MaxP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Gcd_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3GcdP1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3GcdP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Div_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3DivP1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3DivP1 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Rem_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3RemP1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3RemP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_PartialDiv_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3PartialDivP1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3PartialDivP1 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Pow_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3PowP1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3PowP1 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Cmp_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3CmpP1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN3CmpP1 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Add_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3AddP2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3AddP2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Sub_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3SubP2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3SubP2 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Mul_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N6 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MulP2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN6\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MulP2 as Integer\u003e::to_i64(), \u003cN6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Min_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MinP2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MinP2 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Max_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MaxP2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MaxP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Gcd_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3GcdP2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3GcdP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Div_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3DivP2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3DivP2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Rem_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3RemP2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3RemP2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Pow_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P9 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3PowP2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP9\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3PowP2 as Integer\u003e::to_i64(), \u003cP9 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Cmp_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3CmpP2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN3CmpP2 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Add_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3AddP3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3AddP3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Sub_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N6 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3SubP3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN6\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3SubP3 as Integer\u003e::to_i64(), \u003cN6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Mul_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N9 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MulP3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN9\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MulP3 as Integer\u003e::to_i64(), \u003cN9 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Min_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MinP3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MinP3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Max_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MaxP3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MaxP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Gcd_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3GcdP3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3GcdP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Div_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3DivP3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3DivP3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Rem_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3RemP3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3RemP3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_PartialDiv_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3PartialDivP3 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3PartialDivP3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Pow_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N27 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3PowP3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN27\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3PowP3 as Integer\u003e::to_i64(), \u003cN27 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Cmp_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3CmpP3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN3CmpP3 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Add_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3AddP4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3AddP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Sub_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N7 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3SubP4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN7\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3SubP4 as Integer\u003e::to_i64(), \u003cN7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Mul_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N12 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MulP4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN12\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MulP4 as Integer\u003e::to_i64(), \u003cN12 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Min_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MinP4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MinP4 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Max_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MaxP4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MaxP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Gcd_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3GcdP4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3GcdP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Div_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3DivP4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3DivP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Rem_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3RemP4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3RemP4 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Pow_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P81 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3PowP4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP81\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3PowP4 as Integer\u003e::to_i64(), \u003cP81 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Cmp_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3CmpP4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN3CmpP4 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Add_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3AddP5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3AddP5 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Sub_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N8 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3SubP5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN8\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3SubP5 as Integer\u003e::to_i64(), \u003cN8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Mul_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N15 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MulP5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN15\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MulP5 as Integer\u003e::to_i64(), \u003cN15 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Min_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MinP5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MinP5 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Max_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MaxP5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MaxP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Gcd_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3GcdP5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3GcdP5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Div_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3DivP5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3DivP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Rem_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3RemP5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3RemP5 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Pow_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N243 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3PowP5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN243\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3PowP5 as Integer\u003e::to_i64(), \u003cN243 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Cmp_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3CmpP5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN3CmpP5 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Add_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N7 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2AddN5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN7\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2AddN5 as Integer\u003e::to_i64(), \u003cN7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Sub_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2SubN5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2SubN5 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Mul_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P10 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MulN5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP10\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MulN5 as Integer\u003e::to_i64(), \u003cP10 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Min_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MinN5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MinN5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Max_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MaxN5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MaxN5 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Gcd_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2GcdN5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2GcdN5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Div_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2DivN5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2DivN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Rem_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2RemN5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2RemN5 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Cmp_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2CmpN5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN2CmpN5 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Add_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N6 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2AddN4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN6\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2AddN4 as Integer\u003e::to_i64(), \u003cN6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Sub_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2SubN4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2SubN4 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Mul_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P8 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MulN4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP8\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MulN4 as Integer\u003e::to_i64(), \u003cP8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Min_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MinN4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MinN4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Max_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MaxN4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MaxN4 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Gcd_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2GcdN4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2GcdN4 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Div_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2DivN4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2DivN4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Rem_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2RemN4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2RemN4 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Cmp_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2CmpN4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN2CmpN4 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Add_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2AddN3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2AddN3 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Sub_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2SubN3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2SubN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Mul_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P6 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MulN3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP6\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MulN3 as Integer\u003e::to_i64(), \u003cP6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Min_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MinN3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MinN3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Max_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MaxN3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MaxN3 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Gcd_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2GcdN3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2GcdN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Div_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2DivN3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2DivN3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Rem_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2RemN3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2RemN3 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Cmp_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2CmpN3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN2CmpN3 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Add_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2AddN2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2AddN2 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Sub_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2SubN2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2SubN2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Mul_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MulN2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MulN2 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Min_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MinN2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MinN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Max_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MaxN2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MaxN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Gcd_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2GcdN2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2GcdN2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Div_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2DivN2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2DivN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Rem_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2RemN2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2RemN2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_PartialDiv_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2PartialDivN2 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2PartialDivN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Cmp_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2CmpN2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN2CmpN2 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Add_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2AddN1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2AddN1 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Sub_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2SubN1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2SubN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Mul_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MulN1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MulN1 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Min_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MinN1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MinN1 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Max_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MaxN1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MaxN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Gcd_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2GcdN1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2GcdN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Div_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2DivN1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2DivN1 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Rem_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2RemN1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2RemN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_PartialDiv_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2PartialDivN1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2PartialDivN1 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Cmp_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2CmpN1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN2CmpN1 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Add__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2Add_0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2Add_0 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Sub__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2Sub_0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2Sub_0 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Mul__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2Mul_0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2Mul_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Min__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2Min_0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2Min_0 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Max__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2Max_0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2Max_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Gcd__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2Gcd_0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2Gcd_0 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Pow__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2Pow_0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2Pow_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Cmp__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2Cmp_0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN2Cmp_0 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Add_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2AddP1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2AddP1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Sub_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2SubP1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2SubP1 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Mul_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MulP1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MulP1 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Min_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MinP1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MinP1 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Max_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MaxP1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MaxP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Gcd_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2GcdP1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2GcdP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Div_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2DivP1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2DivP1 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Rem_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2RemP1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2RemP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_PartialDiv_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2PartialDivP1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2PartialDivP1 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Pow_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2PowP1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2PowP1 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Cmp_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2CmpP1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN2CmpP1 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Add_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2AddP2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2AddP2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Sub_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2SubP2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2SubP2 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Mul_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MulP2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MulP2 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Min_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MinP2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MinP2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Max_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MaxP2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MaxP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Gcd_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2GcdP2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2GcdP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Div_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2DivP2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2DivP2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Rem_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2RemP2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2RemP2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_PartialDiv_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2PartialDivP2 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2PartialDivP2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Pow_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2PowP2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2PowP2 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Cmp_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2CmpP2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN2CmpP2 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Add_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2AddP3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2AddP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Sub_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2SubP3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2SubP3 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Mul_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N6 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MulP3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN6\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MulP3 as Integer\u003e::to_i64(), \u003cN6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Min_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MinP3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MinP3 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Max_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MaxP3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MaxP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Gcd_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2GcdP3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2GcdP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Div_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2DivP3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2DivP3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Rem_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2RemP3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2RemP3 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Pow_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N8 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2PowP3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN8\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2PowP3 as Integer\u003e::to_i64(), \u003cN8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Cmp_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2CmpP3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN2CmpP3 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Add_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2AddP4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2AddP4 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Sub_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N6 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2SubP4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN6\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2SubP4 as Integer\u003e::to_i64(), \u003cN6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Mul_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N8 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MulP4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN8\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MulP4 as Integer\u003e::to_i64(), \u003cN8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Min_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MinP4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MinP4 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Max_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MaxP4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MaxP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Gcd_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2GcdP4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2GcdP4 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Div_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2DivP4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2DivP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Rem_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2RemP4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2RemP4 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Pow_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P16 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2PowP4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP16\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2PowP4 as Integer\u003e::to_i64(), \u003cP16 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Cmp_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2CmpP4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN2CmpP4 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Add_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2AddP5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2AddP5 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Sub_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N7 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2SubP5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN7\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2SubP5 as Integer\u003e::to_i64(), \u003cN7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Mul_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N10 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MulP5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN10\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MulP5 as Integer\u003e::to_i64(), \u003cN10 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Min_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MinP5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MinP5 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Max_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MaxP5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MaxP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Gcd_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2GcdP5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2GcdP5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Div_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2DivP5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2DivP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Rem_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2RemP5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2RemP5 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Pow_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N32 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2PowP5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN32\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2PowP5 as Integer\u003e::to_i64(), \u003cN32 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Cmp_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2CmpP5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN2CmpP5 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Add_N5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N6 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1AddN5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN6\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1AddN5 as Integer\u003e::to_i64(), \u003cN6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Sub_N5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1SubN5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1SubN5 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Mul_N5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MulN5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MulN5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Min_N5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MinN5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MinN5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Max_N5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MaxN5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MaxN5 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Gcd_N5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1GcdN5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1GcdN5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Div_N5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1DivN5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1DivN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Rem_N5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1RemN5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1RemN5 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Pow_N5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1PowN5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1PowN5 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Cmp_N5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1CmpN5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN1CmpN5 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Add_N4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1AddN4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1AddN4 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Sub_N4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1SubN4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1SubN4 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Mul_N4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MulN4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MulN4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Min_N4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MinN4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MinN4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Max_N4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MaxN4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MaxN4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Gcd_N4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1GcdN4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1GcdN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Div_N4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1DivN4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1DivN4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Rem_N4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1RemN4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1RemN4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Pow_N4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1PowN4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1PowN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Cmp_N4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1CmpN4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN1CmpN4 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Add_N3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1AddN3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1AddN3 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Sub_N3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1SubN3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1SubN3 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Mul_N3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MulN3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MulN3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Min_N3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MinN3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MinN3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Max_N3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MaxN3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MaxN3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Gcd_N3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1GcdN3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1GcdN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Div_N3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1DivN3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1DivN3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Rem_N3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1RemN3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1RemN3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Pow_N3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1PowN3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1PowN3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Cmp_N3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1CmpN3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN1CmpN3 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Add_N2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1AddN2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1AddN2 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Sub_N2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1SubN2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1SubN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Mul_N2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MulN2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MulN2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Min_N2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MinN2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MinN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Max_N2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MaxN2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MaxN2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Gcd_N2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1GcdN2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1GcdN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Div_N2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1DivN2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1DivN2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Rem_N2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1RemN2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1RemN2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Pow_N2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1PowN2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1PowN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Cmp_N2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1CmpN2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN1CmpN2 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Add_N1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1AddN1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1AddN1 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Sub_N1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1SubN1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1SubN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Mul_N1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MulN1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MulN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Min_N1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MinN1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MinN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Max_N1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MaxN1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MaxN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Gcd_N1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1GcdN1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1GcdN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Div_N1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1DivN1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1DivN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Rem_N1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1RemN1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1RemN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_PartialDiv_N1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1PartialDivN1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1PartialDivN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Pow_N1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1PowN1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1PowN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Cmp_N1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1CmpN1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN1CmpN1 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Add__0() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1Add_0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1Add_0 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Sub__0() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1Sub_0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1Sub_0 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Mul__0() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1Mul_0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1Mul_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Min__0() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1Min_0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1Min_0 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Max__0() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1Max_0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1Max_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Gcd__0() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1Gcd_0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1Gcd_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Pow__0() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1Pow_0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1Pow_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Cmp__0() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1Cmp_0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN1Cmp_0 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Add_P1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1AddP1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1AddP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Sub_P1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1SubP1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1SubP1 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Mul_P1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MulP1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MulP1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Min_P1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MinP1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MinP1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Max_P1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MaxP1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MaxP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Gcd_P1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1GcdP1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1GcdP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Div_P1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1DivP1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1DivP1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Rem_P1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1RemP1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1RemP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_PartialDiv_P1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1PartialDivP1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1PartialDivP1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Pow_P1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1PowP1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1PowP1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Cmp_P1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1CmpP1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN1CmpP1 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Add_P2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1AddP2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1AddP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Sub_P2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1SubP2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1SubP2 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Mul_P2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MulP2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MulP2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Min_P2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MinP2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MinP2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Max_P2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MaxP2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MaxP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Gcd_P2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1GcdP2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1GcdP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Div_P2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1DivP2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1DivP2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Rem_P2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1RemP2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1RemP2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Pow_P2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1PowP2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1PowP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Cmp_P2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1CmpP2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN1CmpP2 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Add_P3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1AddP3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1AddP3 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Sub_P3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1SubP3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1SubP3 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Mul_P3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MulP3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MulP3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Min_P3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MinP3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MinP3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Max_P3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MaxP3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MaxP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Gcd_P3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1GcdP3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1GcdP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Div_P3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1DivP3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1DivP3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Rem_P3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1RemP3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1RemP3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Pow_P3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1PowP3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1PowP3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Cmp_P3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1CmpP3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN1CmpP3 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Add_P4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1AddP4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1AddP4 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Sub_P4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1SubP4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1SubP4 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Mul_P4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MulP4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MulP4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Min_P4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MinP4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MinP4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Max_P4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MaxP4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MaxP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Gcd_P4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1GcdP4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1GcdP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Div_P4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1DivP4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1DivP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Rem_P4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1RemP4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1RemP4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Pow_P4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1PowP4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1PowP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Cmp_P4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1CmpP4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN1CmpP4 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Add_P5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1AddP5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1AddP5 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Sub_P5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N6 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1SubP5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN6\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1SubP5 as Integer\u003e::to_i64(), \u003cN6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Mul_P5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MulP5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MulP5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Min_P5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MinP5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MinP5 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Max_P5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MaxP5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MaxP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Gcd_P5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1GcdP5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1GcdP5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Div_P5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1DivP5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1DivP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Rem_P5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1RemP5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1RemP5 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Pow_P5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1PowP5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1PowP5 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Cmp_P5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1CmpP5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN1CmpP5 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Add_N5() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0AddN5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0AddN5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Sub_N5() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0SubN5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0SubN5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Mul_N5() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MulN5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MulN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Min_N5() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0MinN5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MinN5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Max_N5() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MaxN5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MaxN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Gcd_N5() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0GcdN5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0GcdN5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Div_N5() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0DivN5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0DivN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Rem_N5() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0RemN5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0RemN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_PartialDiv_N5() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PartialDivN5 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0PartialDivN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Cmp_N5() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0CmpN5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003c_0CmpN5 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Add_N4() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0AddN4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0AddN4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Sub_N4() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0SubN4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0SubN4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Mul_N4() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MulN4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MulN4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Min_N4() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0MinN4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MinN4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Max_N4() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MaxN4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MaxN4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Gcd_N4() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0GcdN4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0GcdN4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Div_N4() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0DivN4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0DivN4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Rem_N4() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0RemN4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0RemN4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_PartialDiv_N4() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PartialDivN4 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0PartialDivN4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Cmp_N4() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0CmpN4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003c_0CmpN4 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Add_N3() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0AddN3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0AddN3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Sub_N3() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0SubN3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0SubN3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Mul_N3() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MulN3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MulN3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Min_N3() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0MinN3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MinN3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Max_N3() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MaxN3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MaxN3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Gcd_N3() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0GcdN3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0GcdN3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Div_N3() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0DivN3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0DivN3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Rem_N3() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0RemN3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0RemN3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_PartialDiv_N3() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PartialDivN3 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0PartialDivN3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Cmp_N3() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0CmpN3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003c_0CmpN3 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Add_N2() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0AddN2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0AddN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Sub_N2() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0SubN2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0SubN2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Mul_N2() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MulN2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MulN2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Min_N2() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0MinN2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MinN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Max_N2() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MaxN2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MaxN2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Gcd_N2() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0GcdN2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0GcdN2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Div_N2() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0DivN2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0DivN2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Rem_N2() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0RemN2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0RemN2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_PartialDiv_N2() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PartialDivN2 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0PartialDivN2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Cmp_N2() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0CmpN2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003c_0CmpN2 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Add_N1() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0AddN1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0AddN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Sub_N1() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0SubN1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0SubN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Mul_N1() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MulN1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MulN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Min_N1() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0MinN1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MinN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Max_N1() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MaxN1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MaxN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Gcd_N1() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0GcdN1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0GcdN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Div_N1() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0DivN1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0DivN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Rem_N1() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0RemN1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0RemN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_PartialDiv_N1() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PartialDivN1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0PartialDivN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Cmp_N1() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0CmpN1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003c_0CmpN1 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Add__0() {\n    type A = Z0;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0Add_0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0Add_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Sub__0() {\n    type A = Z0;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0Sub_0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0Sub_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Mul__0() {\n    type A = Z0;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0Mul_0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0Mul_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Min__0() {\n    type A = Z0;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0Min_0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0Min_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Max__0() {\n    type A = Z0;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0Max_0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0Max_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Gcd__0() {\n    type A = Z0;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0Gcd_0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0Gcd_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Pow__0() {\n    type A = Z0;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0Pow_0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0Pow_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Cmp__0() {\n    type A = Z0;\n    type B = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0Cmp_0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003c_0Cmp_0 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Add_P1() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0AddP1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0AddP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Sub_P1() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0SubP1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0SubP1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Mul_P1() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MulP1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MulP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Min_P1() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MinP1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MinP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Max_P1() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0MaxP1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MaxP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Gcd_P1() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0GcdP1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0GcdP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Div_P1() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0DivP1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0DivP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Rem_P1() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0RemP1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0RemP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_PartialDiv_P1() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PartialDivP1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0PartialDivP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Pow_P1() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PowP1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0PowP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Cmp_P1() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0CmpP1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003c_0CmpP1 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Add_P2() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0AddP2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0AddP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Sub_P2() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0SubP2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0SubP2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Mul_P2() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MulP2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MulP2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Min_P2() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MinP2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MinP2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Max_P2() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0MaxP2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MaxP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Gcd_P2() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0GcdP2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0GcdP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Div_P2() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0DivP2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0DivP2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Rem_P2() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0RemP2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0RemP2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_PartialDiv_P2() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PartialDivP2 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0PartialDivP2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Pow_P2() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PowP2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0PowP2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Cmp_P2() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0CmpP2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003c_0CmpP2 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Add_P3() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0AddP3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0AddP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Sub_P3() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0SubP3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0SubP3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Mul_P3() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MulP3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MulP3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Min_P3() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MinP3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MinP3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Max_P3() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0MaxP3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MaxP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Gcd_P3() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0GcdP3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0GcdP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Div_P3() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0DivP3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0DivP3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Rem_P3() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0RemP3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0RemP3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_PartialDiv_P3() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PartialDivP3 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0PartialDivP3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Pow_P3() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PowP3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0PowP3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Cmp_P3() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0CmpP3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003c_0CmpP3 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Add_P4() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0AddP4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0AddP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Sub_P4() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0SubP4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0SubP4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Mul_P4() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MulP4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MulP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Min_P4() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MinP4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MinP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Max_P4() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0MaxP4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MaxP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Gcd_P4() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0GcdP4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0GcdP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Div_P4() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0DivP4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0DivP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Rem_P4() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0RemP4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0RemP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_PartialDiv_P4() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PartialDivP4 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0PartialDivP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Pow_P4() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PowP4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0PowP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Cmp_P4() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0CmpP4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003c_0CmpP4 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Add_P5() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0AddP5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0AddP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Sub_P5() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0SubP5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0SubP5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Mul_P5() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MulP5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MulP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Min_P5() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MinP5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MinP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Max_P5() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0MaxP5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MaxP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Gcd_P5() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0GcdP5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0GcdP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Div_P5() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0DivP5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0DivP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Rem_P5() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0RemP5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0RemP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_PartialDiv_P5() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PartialDivP5 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0PartialDivP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Pow_P5() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PowP5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0PowP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Cmp_P5() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0CmpP5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003c_0CmpP5 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Add_N5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1AddN5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1AddN5 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Sub_N5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P6 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1SubN5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP6\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1SubN5 as Integer\u003e::to_i64(), \u003cP6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Mul_N5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MulN5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MulN5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Min_N5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MinN5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MinN5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Max_N5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MaxN5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MaxN5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Gcd_N5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1GcdN5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1GcdN5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Div_N5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1DivN5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1DivN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Rem_N5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1RemN5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1RemN5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Pow_N5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1PowN5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1PowN5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Cmp_N5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1CmpN5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP1CmpN5 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Add_N4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1AddN4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1AddN4 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Sub_N4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1SubN4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1SubN4 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Mul_N4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MulN4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MulN4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Min_N4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MinN4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MinN4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Max_N4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MaxN4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MaxN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Gcd_N4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1GcdN4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1GcdN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Div_N4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1DivN4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1DivN4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Rem_N4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1RemN4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1RemN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Pow_N4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1PowN4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1PowN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Cmp_N4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1CmpN4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP1CmpN4 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Add_N3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1AddN3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1AddN3 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Sub_N3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1SubN3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1SubN3 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Mul_N3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MulN3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MulN3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Min_N3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MinN3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MinN3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Max_N3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MaxN3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MaxN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Gcd_N3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1GcdN3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1GcdN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Div_N3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1DivN3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1DivN3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Rem_N3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1RemN3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1RemN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Pow_N3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1PowN3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1PowN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Cmp_N3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1CmpN3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP1CmpN3 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Add_N2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1AddN2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1AddN2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Sub_N2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1SubN2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1SubN2 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Mul_N2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MulN2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MulN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Min_N2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MinN2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MinN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Max_N2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MaxN2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MaxN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Gcd_N2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1GcdN2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1GcdN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Div_N2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1DivN2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1DivN2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Rem_N2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1RemN2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1RemN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Pow_N2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1PowN2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1PowN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Cmp_N2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1CmpN2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP1CmpN2 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Add_N1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1AddN1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1AddN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Sub_N1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1SubN1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1SubN1 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Mul_N1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MulN1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MulN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Min_N1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MinN1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MinN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Max_N1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MaxN1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MaxN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Gcd_N1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1GcdN1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1GcdN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Div_N1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1DivN1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1DivN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Rem_N1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1RemN1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1RemN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_PartialDiv_N1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1PartialDivN1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1PartialDivN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Pow_N1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1PowN1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1PowN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Cmp_N1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1CmpN1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP1CmpN1 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Add__0() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1Add_0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1Add_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Sub__0() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1Sub_0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1Sub_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Mul__0() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1Mul_0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1Mul_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Min__0() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1Min_0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1Min_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Max__0() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1Max_0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1Max_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Gcd__0() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1Gcd_0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1Gcd_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Pow__0() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1Pow_0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1Pow_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Cmp__0() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1Cmp_0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP1Cmp_0 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Add_P1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1AddP1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1AddP1 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Sub_P1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1SubP1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1SubP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Mul_P1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MulP1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MulP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Min_P1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MinP1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MinP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Max_P1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MaxP1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MaxP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Gcd_P1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1GcdP1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1GcdP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Div_P1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1DivP1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1DivP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Rem_P1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1RemP1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1RemP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_PartialDiv_P1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1PartialDivP1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1PartialDivP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Pow_P1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1PowP1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1PowP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Cmp_P1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1CmpP1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP1CmpP1 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Add_P2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1AddP2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1AddP2 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Sub_P2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1SubP2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1SubP2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Mul_P2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MulP2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MulP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Min_P2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MinP2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MinP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Max_P2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MaxP2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MaxP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Gcd_P2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1GcdP2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1GcdP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Div_P2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1DivP2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1DivP2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Rem_P2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1RemP2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1RemP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Pow_P2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1PowP2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1PowP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Cmp_P2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1CmpP2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP1CmpP2 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Add_P3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1AddP3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1AddP3 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Sub_P3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1SubP3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1SubP3 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Mul_P3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MulP3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MulP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Min_P3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MinP3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MinP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Max_P3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MaxP3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MaxP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Gcd_P3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1GcdP3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1GcdP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Div_P3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1DivP3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1DivP3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Rem_P3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1RemP3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1RemP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Pow_P3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1PowP3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1PowP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Cmp_P3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1CmpP3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP1CmpP3 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Add_P4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1AddP4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1AddP4 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Sub_P4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1SubP4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1SubP4 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Mul_P4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MulP4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MulP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Min_P4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MinP4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MinP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Max_P4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MaxP4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MaxP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Gcd_P4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1GcdP4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1GcdP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Div_P4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1DivP4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1DivP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Rem_P4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1RemP4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1RemP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Pow_P4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1PowP4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1PowP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Cmp_P4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1CmpP4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP1CmpP4 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Add_P5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P6 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1AddP5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP6\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1AddP5 as Integer\u003e::to_i64(), \u003cP6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Sub_P5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1SubP5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1SubP5 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Mul_P5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MulP5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MulP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Min_P5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MinP5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MinP5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Max_P5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MaxP5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MaxP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Gcd_P5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1GcdP5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1GcdP5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Div_P5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1DivP5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1DivP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Rem_P5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1RemP5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1RemP5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Pow_P5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1PowP5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1PowP5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Cmp_P5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1CmpP5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP1CmpP5 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Add_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2AddN5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2AddN5 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Sub_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P7 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2SubN5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP7\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2SubN5 as Integer\u003e::to_i64(), \u003cP7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Mul_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N10 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MulN5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN10\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MulN5 as Integer\u003e::to_i64(), \u003cN10 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Min_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MinN5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MinN5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Max_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MaxN5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MaxN5 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Gcd_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2GcdN5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2GcdN5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Div_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2DivN5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2DivN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Rem_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2RemN5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2RemN5 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Cmp_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2CmpN5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP2CmpN5 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Add_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2AddN4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2AddN4 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Sub_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P6 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2SubN4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP6\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2SubN4 as Integer\u003e::to_i64(), \u003cP6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Mul_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N8 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MulN4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN8\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MulN4 as Integer\u003e::to_i64(), \u003cN8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Min_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MinN4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MinN4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Max_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MaxN4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MaxN4 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Gcd_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2GcdN4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2GcdN4 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Div_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2DivN4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2DivN4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Rem_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2RemN4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2RemN4 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Cmp_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2CmpN4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP2CmpN4 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Add_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2AddN3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2AddN3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Sub_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2SubN3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2SubN3 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Mul_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N6 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MulN3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN6\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MulN3 as Integer\u003e::to_i64(), \u003cN6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Min_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MinN3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MinN3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Max_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MaxN3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MaxN3 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Gcd_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2GcdN3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2GcdN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Div_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2DivN3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2DivN3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Rem_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2RemN3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2RemN3 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Cmp_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2CmpN3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP2CmpN3 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Add_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2AddN2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2AddN2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Sub_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2SubN2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2SubN2 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Mul_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MulN2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MulN2 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Min_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MinN2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MinN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Max_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MaxN2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MaxN2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Gcd_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2GcdN2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2GcdN2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Div_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2DivN2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2DivN2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Rem_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2RemN2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2RemN2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_PartialDiv_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2PartialDivN2 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2PartialDivN2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Cmp_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2CmpN2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP2CmpN2 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Add_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2AddN1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2AddN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Sub_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2SubN1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2SubN1 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Mul_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MulN1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MulN1 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Min_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MinN1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MinN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Max_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MaxN1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MaxN1 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Gcd_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2GcdN1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2GcdN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Div_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2DivN1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2DivN1 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Rem_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2RemN1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2RemN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_PartialDiv_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2PartialDivN1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2PartialDivN1 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Cmp_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2CmpN1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP2CmpN1 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Add__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2Add_0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2Add_0 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Sub__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2Sub_0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2Sub_0 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Mul__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2Mul_0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2Mul_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Min__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2Min_0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2Min_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Max__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2Max_0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2Max_0 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Gcd__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2Gcd_0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2Gcd_0 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Pow__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2Pow_0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2Pow_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Cmp__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2Cmp_0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP2Cmp_0 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Add_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2AddP1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2AddP1 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Sub_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2SubP1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2SubP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Mul_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MulP1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MulP1 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Min_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MinP1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MinP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Max_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MaxP1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MaxP1 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Gcd_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2GcdP1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2GcdP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Div_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2DivP1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2DivP1 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Rem_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2RemP1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2RemP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_PartialDiv_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2PartialDivP1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2PartialDivP1 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Pow_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2PowP1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2PowP1 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Cmp_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2CmpP1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP2CmpP1 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Add_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2AddP2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2AddP2 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Sub_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2SubP2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2SubP2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Mul_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MulP2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MulP2 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Min_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MinP2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MinP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Max_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MaxP2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MaxP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Gcd_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2GcdP2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2GcdP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Div_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2DivP2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2DivP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Rem_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2RemP2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2RemP2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_PartialDiv_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2PartialDivP2 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2PartialDivP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Pow_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2PowP2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2PowP2 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Cmp_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2CmpP2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP2CmpP2 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Add_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2AddP3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2AddP3 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Sub_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2SubP3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2SubP3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Mul_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P6 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MulP3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP6\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MulP3 as Integer\u003e::to_i64(), \u003cP6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Min_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MinP3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MinP3 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Max_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MaxP3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MaxP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Gcd_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2GcdP3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2GcdP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Div_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2DivP3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2DivP3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Rem_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2RemP3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2RemP3 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Pow_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P8 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2PowP3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP8\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2PowP3 as Integer\u003e::to_i64(), \u003cP8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Cmp_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2CmpP3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP2CmpP3 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Add_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P6 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2AddP4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP6\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2AddP4 as Integer\u003e::to_i64(), \u003cP6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Sub_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2SubP4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2SubP4 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Mul_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P8 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MulP4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP8\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MulP4 as Integer\u003e::to_i64(), \u003cP8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Min_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MinP4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MinP4 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Max_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MaxP4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MaxP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Gcd_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2GcdP4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2GcdP4 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Div_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2DivP4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2DivP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Rem_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2RemP4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2RemP4 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Pow_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P16 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2PowP4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP16\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2PowP4 as Integer\u003e::to_i64(), \u003cP16 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Cmp_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2CmpP4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP2CmpP4 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Add_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P7 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2AddP5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP7\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2AddP5 as Integer\u003e::to_i64(), \u003cP7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Sub_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2SubP5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2SubP5 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Mul_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P10 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MulP5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP10\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MulP5 as Integer\u003e::to_i64(), \u003cP10 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Min_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MinP5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MinP5 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Max_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MaxP5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MaxP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Gcd_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2GcdP5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2GcdP5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Div_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2DivP5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2DivP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Rem_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2RemP5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2RemP5 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Pow_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P32 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2PowP5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP32\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2PowP5 as Integer\u003e::to_i64(), \u003cP32 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Cmp_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2CmpP5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP2CmpP5 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Add_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3AddN5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3AddN5 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Sub_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P8 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3SubN5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP8\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3SubN5 as Integer\u003e::to_i64(), \u003cP8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Mul_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N15 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MulN5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN15\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MulN5 as Integer\u003e::to_i64(), \u003cN15 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Min_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MinN5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MinN5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Max_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MaxN5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MaxN5 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Gcd_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3GcdN5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3GcdN5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Div_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3DivN5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3DivN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Rem_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3RemN5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3RemN5 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Cmp_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3CmpN5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP3CmpN5 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Add_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3AddN4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3AddN4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Sub_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P7 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3SubN4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP7\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3SubN4 as Integer\u003e::to_i64(), \u003cP7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Mul_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N12 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MulN4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN12\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MulN4 as Integer\u003e::to_i64(), \u003cN12 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Min_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MinN4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MinN4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Max_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MaxN4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MaxN4 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Gcd_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3GcdN4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3GcdN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Div_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3DivN4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3DivN4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Rem_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3RemN4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3RemN4 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Cmp_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3CmpN4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP3CmpN4 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Add_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3AddN3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3AddN3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Sub_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P6 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3SubN3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP6\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3SubN3 as Integer\u003e::to_i64(), \u003cP6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Mul_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N9 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MulN3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN9\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MulN3 as Integer\u003e::to_i64(), \u003cN9 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Min_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MinN3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MinN3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Max_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MaxN3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MaxN3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Gcd_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3GcdN3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3GcdN3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Div_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3DivN3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3DivN3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Rem_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3RemN3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3RemN3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_PartialDiv_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3PartialDivN3 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3PartialDivN3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Cmp_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3CmpN3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP3CmpN3 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Add_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3AddN2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3AddN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Sub_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3SubN2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3SubN2 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Mul_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N6 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MulN2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN6\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MulN2 as Integer\u003e::to_i64(), \u003cN6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Min_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MinN2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MinN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Max_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MaxN2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MaxN2 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Gcd_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3GcdN2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3GcdN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Div_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3DivN2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3DivN2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Rem_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3RemN2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3RemN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Cmp_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3CmpN2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP3CmpN2 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Add_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3AddN1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3AddN1 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Sub_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3SubN1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3SubN1 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Mul_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MulN1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MulN1 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Min_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MinN1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MinN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Max_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MaxN1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MaxN1 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Gcd_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3GcdN1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3GcdN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Div_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3DivN1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3DivN1 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Rem_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3RemN1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3RemN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_PartialDiv_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3PartialDivN1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3PartialDivN1 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Cmp_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3CmpN1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP3CmpN1 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Add__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3Add_0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3Add_0 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Sub__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3Sub_0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3Sub_0 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Mul__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3Mul_0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3Mul_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Min__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3Min_0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3Min_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Max__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3Max_0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3Max_0 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Gcd__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3Gcd_0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3Gcd_0 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Pow__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3Pow_0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3Pow_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Cmp__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3Cmp_0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP3Cmp_0 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Add_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3AddP1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3AddP1 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Sub_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3SubP1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3SubP1 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Mul_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MulP1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MulP1 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Min_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MinP1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MinP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Max_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MaxP1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MaxP1 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Gcd_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3GcdP1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3GcdP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Div_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3DivP1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3DivP1 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Rem_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3RemP1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3RemP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_PartialDiv_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3PartialDivP1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3PartialDivP1 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Pow_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3PowP1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3PowP1 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Cmp_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3CmpP1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP3CmpP1 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Add_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3AddP2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3AddP2 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Sub_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3SubP2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3SubP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Mul_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P6 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MulP2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP6\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MulP2 as Integer\u003e::to_i64(), \u003cP6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Min_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MinP2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MinP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Max_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MaxP2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MaxP2 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Gcd_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3GcdP2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3GcdP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Div_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3DivP2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3DivP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Rem_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3RemP2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3RemP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Pow_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P9 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3PowP2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP9\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3PowP2 as Integer\u003e::to_i64(), \u003cP9 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Cmp_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3CmpP2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP3CmpP2 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Add_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P6 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3AddP3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP6\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3AddP3 as Integer\u003e::to_i64(), \u003cP6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Sub_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3SubP3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3SubP3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Mul_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P9 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MulP3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP9\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MulP3 as Integer\u003e::to_i64(), \u003cP9 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Min_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MinP3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MinP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Max_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MaxP3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MaxP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Gcd_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3GcdP3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3GcdP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Div_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3DivP3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3DivP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Rem_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3RemP3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3RemP3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_PartialDiv_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3PartialDivP3 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3PartialDivP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Pow_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P27 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3PowP3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP27\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3PowP3 as Integer\u003e::to_i64(), \u003cP27 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Cmp_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3CmpP3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP3CmpP3 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Add_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P7 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3AddP4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP7\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3AddP4 as Integer\u003e::to_i64(), \u003cP7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Sub_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3SubP4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3SubP4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Mul_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P12 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MulP4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP12\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MulP4 as Integer\u003e::to_i64(), \u003cP12 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Min_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MinP4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MinP4 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Max_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MaxP4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MaxP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Gcd_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3GcdP4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3GcdP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Div_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3DivP4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3DivP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Rem_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3RemP4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3RemP4 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Pow_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P81 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3PowP4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP81\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3PowP4 as Integer\u003e::to_i64(), \u003cP81 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Cmp_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3CmpP4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP3CmpP4 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Add_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P8 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3AddP5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP8\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3AddP5 as Integer\u003e::to_i64(), \u003cP8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Sub_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3SubP5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3SubP5 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Mul_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P15 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MulP5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP15\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MulP5 as Integer\u003e::to_i64(), \u003cP15 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Min_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MinP5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MinP5 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Max_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MaxP5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MaxP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Gcd_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3GcdP5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3GcdP5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Div_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3DivP5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3DivP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Rem_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3RemP5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3RemP5 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Pow_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P243 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3PowP5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP243\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3PowP5 as Integer\u003e::to_i64(), \u003cP243 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Cmp_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3CmpP5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP3CmpP5 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Add_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4AddN5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4AddN5 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Sub_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P9 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4SubN5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP9\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4SubN5 as Integer\u003e::to_i64(), \u003cP9 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Mul_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N20 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MulN5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN20\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MulN5 as Integer\u003e::to_i64(), \u003cN20 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Min_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MinN5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MinN5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Max_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MaxN5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MaxN5 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Gcd_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4GcdN5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4GcdN5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Div_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4DivN5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4DivN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Rem_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4RemN5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4RemN5 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Cmp_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4CmpN5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP4CmpN5 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Add_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4AddN4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4AddN4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Sub_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P8 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4SubN4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP8\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4SubN4 as Integer\u003e::to_i64(), \u003cP8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Mul_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N16 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MulN4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN16\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MulN4 as Integer\u003e::to_i64(), \u003cN16 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Min_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MinN4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MinN4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Max_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MaxN4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MaxN4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Gcd_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4GcdN4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4GcdN4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Div_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4DivN4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4DivN4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Rem_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4RemN4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4RemN4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_PartialDiv_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4PartialDivN4 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4PartialDivN4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Cmp_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4CmpN4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP4CmpN4 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Add_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4AddN3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4AddN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Sub_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P7 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4SubN3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP7\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4SubN3 as Integer\u003e::to_i64(), \u003cP7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Mul_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N12 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MulN3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN12\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MulN3 as Integer\u003e::to_i64(), \u003cN12 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Min_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MinN3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MinN3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Max_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MaxN3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MaxN3 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Gcd_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4GcdN3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4GcdN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Div_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4DivN3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4DivN3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Rem_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4RemN3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4RemN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Cmp_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4CmpN3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP4CmpN3 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Add_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4AddN2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4AddN2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Sub_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P6 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4SubN2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP6\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4SubN2 as Integer\u003e::to_i64(), \u003cP6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Mul_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N8 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MulN2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN8\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MulN2 as Integer\u003e::to_i64(), \u003cN8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Min_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MinN2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MinN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Max_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MaxN2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MaxN2 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Gcd_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4GcdN2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4GcdN2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Div_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4DivN2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4DivN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Rem_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4RemN2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4RemN2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_PartialDiv_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4PartialDivN2 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4PartialDivN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Cmp_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4CmpN2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP4CmpN2 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Add_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4AddN1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4AddN1 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Sub_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4SubN1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4SubN1 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Mul_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MulN1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MulN1 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Min_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MinN1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MinN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Max_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MaxN1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MaxN1 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Gcd_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4GcdN1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4GcdN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Div_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4DivN1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4DivN1 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Rem_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4RemN1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4RemN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_PartialDiv_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4PartialDivN1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4PartialDivN1 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Cmp_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4CmpN1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP4CmpN1 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Add__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4Add_0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4Add_0 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Sub__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4Sub_0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4Sub_0 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Mul__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4Mul_0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4Mul_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Min__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4Min_0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4Min_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Max__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4Max_0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4Max_0 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Gcd__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4Gcd_0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4Gcd_0 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Pow__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4Pow_0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4Pow_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Cmp__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4Cmp_0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP4Cmp_0 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Add_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4AddP1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4AddP1 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Sub_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4SubP1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4SubP1 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Mul_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MulP1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MulP1 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Min_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MinP1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MinP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Max_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MaxP1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MaxP1 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Gcd_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4GcdP1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4GcdP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Div_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4DivP1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4DivP1 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Rem_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4RemP1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4RemP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_PartialDiv_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4PartialDivP1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4PartialDivP1 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Pow_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4PowP1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4PowP1 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Cmp_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4CmpP1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP4CmpP1 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Add_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P6 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4AddP2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP6\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4AddP2 as Integer\u003e::to_i64(), \u003cP6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Sub_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4SubP2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4SubP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Mul_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P8 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MulP2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP8\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MulP2 as Integer\u003e::to_i64(), \u003cP8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Min_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MinP2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MinP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Max_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MaxP2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MaxP2 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Gcd_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4GcdP2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4GcdP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Div_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4DivP2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4DivP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Rem_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4RemP2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4RemP2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_PartialDiv_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4PartialDivP2 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4PartialDivP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Pow_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P16 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4PowP2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP16\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4PowP2 as Integer\u003e::to_i64(), \u003cP16 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Cmp_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4CmpP2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP4CmpP2 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Add_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P7 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4AddP3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP7\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4AddP3 as Integer\u003e::to_i64(), \u003cP7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Sub_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4SubP3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4SubP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Mul_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P12 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MulP3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP12\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MulP3 as Integer\u003e::to_i64(), \u003cP12 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Min_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MinP3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MinP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Max_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MaxP3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MaxP3 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Gcd_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4GcdP3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4GcdP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Div_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4DivP3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4DivP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Rem_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4RemP3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4RemP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Pow_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P64 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4PowP3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP64\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4PowP3 as Integer\u003e::to_i64(), \u003cP64 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Cmp_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4CmpP3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP4CmpP3 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Add_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P8 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4AddP4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP8\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4AddP4 as Integer\u003e::to_i64(), \u003cP8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Sub_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4SubP4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4SubP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Mul_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P16 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MulP4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP16\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MulP4 as Integer\u003e::to_i64(), \u003cP16 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Min_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MinP4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MinP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Max_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MaxP4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MaxP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Gcd_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4GcdP4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4GcdP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Div_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4DivP4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4DivP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Rem_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4RemP4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4RemP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_PartialDiv_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4PartialDivP4 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4PartialDivP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Pow_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P256 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4PowP4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP256\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4PowP4 as Integer\u003e::to_i64(), \u003cP256 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Cmp_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4CmpP4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP4CmpP4 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Add_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P9 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4AddP5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP9\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4AddP5 as Integer\u003e::to_i64(), \u003cP9 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Sub_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4SubP5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4SubP5 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Mul_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P20 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MulP5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP20\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MulP5 as Integer\u003e::to_i64(), \u003cP20 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Min_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MinP5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MinP5 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Max_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MaxP5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MaxP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Gcd_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4GcdP5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4GcdP5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Div_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4DivP5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4DivP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Rem_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4RemP5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4RemP5 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Pow_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1024 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4PowP5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1024\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4PowP5 as Integer\u003e::to_i64(), \u003cP1024 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Cmp_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4CmpP5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP4CmpP5 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Add_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P5AddN5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5AddN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Sub_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P10 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5SubN5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP10\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5SubN5 as Integer\u003e::to_i64(), \u003cP10 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Mul_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N25 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MulN5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN25\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MulN5 as Integer\u003e::to_i64(), \u003cN25 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Min_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MinN5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MinN5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Max_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MaxN5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MaxN5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Gcd_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5GcdN5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5GcdN5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Div_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5DivN5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5DivN5 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Rem_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P5RemN5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5RemN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_PartialDiv_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5PartialDivN5 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5PartialDivN5 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Cmp_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5CmpN5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP5CmpN5 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Add_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5AddN4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5AddN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Sub_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P9 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5SubN4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP9\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5SubN4 as Integer\u003e::to_i64(), \u003cP9 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Mul_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N20 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MulN4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN20\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MulN4 as Integer\u003e::to_i64(), \u003cN20 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Min_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MinN4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MinN4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Max_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MaxN4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MaxN4 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Gcd_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5GcdN4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5GcdN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Div_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5DivN4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5DivN4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Rem_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5RemN4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5RemN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Cmp_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5CmpN4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP5CmpN4 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Add_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5AddN3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5AddN3 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Sub_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P8 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5SubN3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP8\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5SubN3 as Integer\u003e::to_i64(), \u003cP8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Mul_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N15 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MulN3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN15\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MulN3 as Integer\u003e::to_i64(), \u003cN15 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Min_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MinN3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MinN3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Max_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MaxN3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MaxN3 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Gcd_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5GcdN3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5GcdN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Div_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5DivN3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5DivN3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Rem_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5RemN3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5RemN3 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Cmp_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5CmpN3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP5CmpN3 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Add_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5AddN2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5AddN2 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Sub_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P7 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5SubN2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP7\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5SubN2 as Integer\u003e::to_i64(), \u003cP7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Mul_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N10 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MulN2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN10\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MulN2 as Integer\u003e::to_i64(), \u003cN10 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Min_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MinN2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MinN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Max_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MaxN2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MaxN2 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Gcd_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5GcdN2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5GcdN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Div_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5DivN2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5DivN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Rem_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5RemN2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5RemN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Cmp_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5CmpN2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP5CmpN2 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Add_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5AddN1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5AddN1 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Sub_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P6 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5SubN1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP6\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5SubN1 as Integer\u003e::to_i64(), \u003cP6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Mul_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MulN1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MulN1 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Min_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MinN1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MinN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Max_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MaxN1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MaxN1 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Gcd_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5GcdN1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5GcdN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Div_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5DivN1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5DivN1 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Rem_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P5RemN1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5RemN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_PartialDiv_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5PartialDivN1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5PartialDivN1 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Cmp_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5CmpN1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP5CmpN1 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Add__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5Add_0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5Add_0 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Sub__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5Sub_0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5Sub_0 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Mul__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P5Mul_0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5Mul_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Min__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P5Min_0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5Min_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Max__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5Max_0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5Max_0 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Gcd__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5Gcd_0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5Gcd_0 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Pow__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5Pow_0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5Pow_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Cmp__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P5Cmp_0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP5Cmp_0 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Add_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P6 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5AddP1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP6\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5AddP1 as Integer\u003e::to_i64(), \u003cP6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Sub_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5SubP1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5SubP1 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Mul_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MulP1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MulP1 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Min_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MinP1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MinP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Max_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MaxP1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MaxP1 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Gcd_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5GcdP1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5GcdP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Div_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5DivP1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5DivP1 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Rem_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P5RemP1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5RemP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_PartialDiv_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5PartialDivP1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5PartialDivP1 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Pow_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5PowP1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5PowP1 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Cmp_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5CmpP1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP5CmpP1 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Add_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P7 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5AddP2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP7\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5AddP2 as Integer\u003e::to_i64(), \u003cP7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Sub_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5SubP2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5SubP2 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Mul_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P10 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MulP2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP10\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MulP2 as Integer\u003e::to_i64(), \u003cP10 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Min_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MinP2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MinP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Max_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MaxP2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MaxP2 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Gcd_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5GcdP2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5GcdP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Div_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5DivP2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5DivP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Rem_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5RemP2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5RemP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Pow_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P25 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5PowP2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP25\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5PowP2 as Integer\u003e::to_i64(), \u003cP25 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Cmp_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5CmpP2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP5CmpP2 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Add_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P8 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5AddP3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP8\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5AddP3 as Integer\u003e::to_i64(), \u003cP8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Sub_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5SubP3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5SubP3 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Mul_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P15 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MulP3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP15\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MulP3 as Integer\u003e::to_i64(), \u003cP15 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Min_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MinP3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MinP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Max_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MaxP3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MaxP3 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Gcd_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5GcdP3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5GcdP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Div_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5DivP3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5DivP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Rem_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5RemP3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5RemP3 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Pow_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P125 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5PowP3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP125\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5PowP3 as Integer\u003e::to_i64(), \u003cP125 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Cmp_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5CmpP3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP5CmpP3 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Add_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P9 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5AddP4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP9\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5AddP4 as Integer\u003e::to_i64(), \u003cP9 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Sub_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5SubP4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5SubP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Mul_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P20 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MulP4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP20\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MulP4 as Integer\u003e::to_i64(), \u003cP20 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Min_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MinP4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MinP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Max_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MaxP4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MaxP4 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Gcd_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5GcdP4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5GcdP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Div_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5DivP4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5DivP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Rem_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5RemP4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5RemP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Pow_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P625 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5PowP4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP625\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5PowP4 as Integer\u003e::to_i64(), \u003cP625 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Cmp_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5CmpP4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP5CmpP4 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Add_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P10 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5AddP5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP10\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5AddP5 as Integer\u003e::to_i64(), \u003cP10 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Sub_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P5SubP5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5SubP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Mul_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P25 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MulP5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP25\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MulP5 as Integer\u003e::to_i64(), \u003cP25 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Min_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MinP5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MinP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Max_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MaxP5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MaxP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Gcd_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5GcdP5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5GcdP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Div_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5DivP5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5DivP5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Rem_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P5RemP5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5RemP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_PartialDiv_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5PartialDivP5 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5PartialDivP5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Pow_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P3125 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5PowP5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP3125\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5PowP5 as Integer\u003e::to_i64(), \u003cP3125 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Cmp_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5CmpP5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP5CmpP5 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Neg() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type NegN5 = \u003c\u003cA as Neg\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n    assert_eq!(\u003cNegN5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Abs() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type AbsN5 = \u003c\u003cA as Abs\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n    assert_eq!(\u003cAbsN5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Neg() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type NegN4 = \u003c\u003cA as Neg\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n    assert_eq!(\u003cNegN4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Abs() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type AbsN4 = \u003c\u003cA as Abs\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n    assert_eq!(\u003cAbsN4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Neg() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type NegN3 = \u003c\u003cA as Neg\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n    assert_eq!(\u003cNegN3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Abs() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type AbsN3 = \u003c\u003cA as Abs\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n    assert_eq!(\u003cAbsN3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Neg() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type NegN2 = \u003c\u003cA as Neg\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n    assert_eq!(\u003cNegN2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Abs() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type AbsN2 = \u003c\u003cA as Abs\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n    assert_eq!(\u003cAbsN2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Neg() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type NegN1 = \u003c\u003cA as Neg\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n    assert_eq!(\u003cNegN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Abs() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type AbsN1 = \u003c\u003cA as Abs\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n    assert_eq!(\u003cAbsN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Neg() {\n    type A = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type Neg_0 = \u003c\u003cA as Neg\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n    assert_eq!(\u003cNeg_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Abs() {\n    type A = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type Abs_0 = \u003c\u003cA as Abs\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n    assert_eq!(\u003cAbs_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Neg() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type NegP1 = \u003c\u003cA as Neg\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n    assert_eq!(\u003cNegP1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Abs() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type AbsP1 = \u003c\u003cA as Abs\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n    assert_eq!(\u003cAbsP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Neg() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type NegP2 = \u003c\u003cA as Neg\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n    assert_eq!(\u003cNegP2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Abs() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type AbsP2 = \u003c\u003cA as Abs\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n    assert_eq!(\u003cAbsP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Neg() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type NegP3 = \u003c\u003cA as Neg\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n    assert_eq!(\u003cNegP3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Abs() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type AbsP3 = \u003c\u003cA as Abs\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n    assert_eq!(\u003cAbsP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Neg() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type NegP4 = \u003c\u003cA as Neg\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n    assert_eq!(\u003cNegP4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Abs() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type AbsP4 = \u003c\u003cA as Abs\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n    assert_eq!(\u003cAbsP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Neg() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type NegP5 = \u003c\u003cA as Neg\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n    assert_eq!(\u003cNegP5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Abs() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type AbsP5 = \u003c\u003cA as Abs\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n    assert_eq!(\u003cAbsP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","bin","coverage_report.rs"],"content":"//! This script runs `cargo tarpaulin` and opens the generated HTML report in the default browser.\r\n//! Used to regenerate the code-coverage report\r\n\r\nuse std::process::Command;\r\n\r\nfn run_command(cmd: \u0026str) {\r\n    let mut parts = cmd.split_whitespace().collect::\u003cVec\u003c_\u003e\u003e();\r\n    let cmd = parts.remove(0);\r\n\r\n    let mut child = Command::new(cmd)\r\n        .args(\u0026parts)\r\n        .spawn()\r\n        .expect(\"Failed to start command\");\r\n    let ecode = child.wait().expect(\"Failed to wait on command\");\r\n    assert!(ecode.success());\r\n}\r\n\r\nfn main() {\r\n    // run `cargo tarpaulin -ohtml`\r\n    // open `tarpaulin-report.html` in your browser\r\n    run_command(\"cargo tarpaulin -ohtml\");\r\n    run_command(\"open tarpaulin-report.html\");\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","bin","generate_docs","main.rs"],"content":"//! This is a simple binary that generates the documentation for the Lavendeux parser.\r\n//! Regenerates the contents of `documentation.md`, and `documentation.html`\r\nuse lavendeux_parser::Lavendeux;\r\nuse std::process::Command;\r\n\r\nfn run_command(cmd: \u0026str) {\r\n    let mut parts = cmd.split_whitespace().collect::\u003cVec\u003c_\u003e\u003e();\r\n    let cmd = parts.remove(0);\r\n\r\n    let mut child = Command::new(cmd)\r\n        .args(\u0026parts)\r\n        .spawn()\r\n        .expect(\"Failed to start command\");\r\n    let ecode = child.wait().expect(\"Failed to wait on command\");\r\n    assert!(ecode.success());\r\n}\r\n\r\nfn main() {\r\n    let parser = Lavendeux::new(Default::default());\r\n    let docs = parser.generate_documentation();\r\n    std::fs::write(\"documentation.md\", docs).expect(\"Failed to write documentation.md\");\r\n    run_command(\"rustdoc documentation.md --o ./ --html-before-content=src/bin/generate_docs/documentation_template.html\")\r\n}\r\n","traces":[{"line":6,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":7,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":8,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":10,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":11,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":12},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","documentation","markdown.rs"],"content":"use super::{operator_documentation, DocumentationFormatter, FunctionsByCategory};\r\n\r\n#[allow(dead_code)]\r\nenum MarkdownSnippet {\r\n    H1(String),\r\n    H2(String),\r\n    H3(String),\r\n    H4(String),\r\n\r\n    CodeBlock(String),\r\n    CodeInline(String),\r\n\r\n    Text(String),\r\n}\r\nimpl std::fmt::Display for MarkdownSnippet {\r\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\r\n        match self {\r\n            MarkdownSnippet::H1(s) =\u003e write!(f, \"# {}\", s.trim()),\r\n            MarkdownSnippet::H2(s) =\u003e write!(f, \"## {}\", s.trim()),\r\n            MarkdownSnippet::H3(s) =\u003e write!(f, \"### {}\", s.trim()),\r\n            MarkdownSnippet::H4(s) =\u003e write!(f, \"#### {}\", s.trim()),\r\n            MarkdownSnippet::CodeBlock(s) =\u003e write!(f, \"```lavendeux\\n{}\\n```\", s.trim()),\r\n            MarkdownSnippet::CodeInline(s) =\u003e write!(f, \"`{}`\", s.trim()),\r\n            MarkdownSnippet::Text(s) =\u003e write!(f, \"{}\", s),\r\n        }?;\r\n        writeln!(f)\r\n    }\r\n}\r\n\r\npub struct MarkdownFormatter;\r\nimpl DocumentationFormatter for MarkdownFormatter {\r\n    //\r\n    // Functions\r\n    //\r\n\r\n    fn format_function(\u0026self, state: \u0026crate::State, name: \u0026str) -\u003e Option\u003cString\u003e {\r\n        let function = state.get_function(name)?;\r\n        let mut pieces = Vec::new();\r\n\r\n        pieces.push(MarkdownSnippet::H3(function.name().to_string()));\r\n        pieces.push(MarkdownSnippet::CodeBlock(function.signature().to_string()));\r\n\r\n        if let Some(desc) = function.documentation().description() {\r\n            pieces.push(MarkdownSnippet::Text(desc.to_string()));\r\n        }\r\n        if let Some(ext_desc) = function.documentation().ext_description() {\r\n            for line in ext_desc.split('\\n') {\r\n                pieces.push(MarkdownSnippet::Text(line.to_string() + \"  \"));\r\n            }\r\n        }\r\n        if let Some(examples) = function.documentation().examples() {\r\n            let examples = examples.trim_start_matches(\"#skip\").trim();\r\n            if !examples.is_empty() {\r\n                pieces.push(MarkdownSnippet::Text(\"**Examples:**  \".to_string()));\r\n                pieces.push(MarkdownSnippet::CodeBlock(examples.to_string()));\r\n            }\r\n        }\r\n\r\n        Some(\r\n            pieces\r\n                .iter()\r\n                .map(|p| p.to_string())\r\n                .collect::\u003cVec\u003c_\u003e\u003e()\r\n                .join(\"\"),\r\n        )\r\n    }\r\n\r\n    fn format_function_category(\u0026self, state: \u0026crate::State, category: \u0026str) -\u003e Option\u003cString\u003e {\r\n        let functions = state.functions_by_category();\r\n        let key = functions\r\n            .keys()\r\n            .find(|k| k.to_lowercase() == category.to_lowercase())?;\r\n        let functions = functions.get(key)?;\r\n\r\n        let mut output = Vec::new();\r\n\r\n        for f in functions {\r\n            output.push(self.format_function(state, f.name())?);\r\n        }\r\n\r\n        Some(output.join(\"\\n------------\\n\"))\r\n    }\r\n\r\n    fn format_function_list(\u0026self, state: \u0026crate::State) -\u003e String {\r\n        let categories = state.functions_by_category();\r\n        let mut output = vec![];\r\n\r\n        let mut sorted_categories: Vec\u003c_\u003e = categories.keys().collect();\r\n        sorted_categories.sort();\r\n\r\n        for category in sorted_categories {\r\n            output.push(MarkdownSnippet::H2(category.to_string() + \" Functions\"));\r\n            output.push(MarkdownSnippet::Text(\r\n                self.format_function_category(state, category)\r\n                    .unwrap_or_default(),\r\n            ));\r\n        }\r\n\r\n        output\r\n            .iter()\r\n            .map(|p| p.to_string())\r\n            .collect::\u003cVec\u003c_\u003e\u003e()\r\n            .join(\"\")\r\n    }\r\n\r\n    //\r\n    // Section Loaders\r\n    //\r\n\r\n    fn format_operators(\u0026self) -\u003e String {\r\n        let mut output = vec![];\r\n        let mut operators = operator_documentation::all();\r\n        operators.sort_by(|a, b| a.name.cmp(b.name));\r\n\r\n        for operator in operators {\r\n            output.push(MarkdownSnippet::H2(operator.name.to_string()));\r\n\r\n            let symbols = operator.symbols.join(\", \");\r\n            output.push(MarkdownSnippet::Text(format!(\"`[{}]`  \", symbols)));\r\n\r\n            output.push(MarkdownSnippet::Text(operator.description.to_string()));\r\n\r\n            output.push(MarkdownSnippet::Text(\"**Examples:**  \".to_string()));\r\n            output.push(MarkdownSnippet::CodeBlock(operator.examples.to_string()));\r\n        }\r\n\r\n        output\r\n            .iter()\r\n            .map(|p| p.to_string())\r\n            .collect::\u003cVec\u003c_\u003e\u003e()\r\n            .join(\"\")\r\n    }\r\n\r\n    fn format_title(\u0026self, title: \u0026str) -\u003e String {\r\n        MarkdownSnippet::H1(title.to_string()).to_string()\r\n    }\r\n\r\n    fn format_subtitle(\u0026self, title: \u0026str) -\u003e String {\r\n        MarkdownSnippet::H2(title.to_string()).to_string()\r\n    }\r\n\r\n    fn format_subsubtitle(\u0026self, title: \u0026str) -\u003e String {\r\n        MarkdownSnippet::H3(title.to_string()).to_string()\r\n    }\r\n\r\n    fn format_text(\u0026self, text: \u0026str) -\u003e String {\r\n        MarkdownSnippet::Text(text.to_string()).to_string()\r\n    }\r\n}\r\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":1319},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":1319},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":40},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":129},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":286},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":860},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":1319},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":129},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":258},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":129},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":258},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":562},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":281},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":258},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":129},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":129},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":129},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":129},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":129},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":1055},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":100},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":270},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":37},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":85},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":141},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":225},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":225},"fn_name":null}],"covered":57,"coverable":64},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","documentation","mod.rs"],"content":"use crate::{functions::ParserFunction, State};\r\nuse std::collections::HashMap;\r\n\r\nmod plain;\r\npub use plain::PlaintextFormatter;\r\n\r\nmod markdown;\r\npub use markdown::MarkdownFormatter;\r\n\r\n#[macro_use]\r\nmod operator_documentation;\r\npub use operator_documentation::OperatorDocumentation;\r\n\r\nmod static_docs;\r\npub use static_docs::DocumentationTemplate;\r\n\r\npub trait FunctionsByCategory {\r\n    fn functions_by_category(\u0026self) -\u003e HashMap\u003cString, Vec\u003c\u0026dyn ParserFunction\u003e\u003e;\r\n}\r\n\r\nimpl FunctionsByCategory for State {\r\n    fn functions_by_category(\u0026self) -\u003e HashMap\u003cString, Vec\u003c\u0026dyn ParserFunction\u003e\u003e {\r\n        let mut categories: HashMap\u003cString, Vec\u003c\u0026dyn ParserFunction\u003e\u003e = HashMap::new();\r\n        for (_, function) in self.all_functions().iter() {\r\n            if function.name().starts_with(\"__\") {\r\n                // Skip hidden functions\r\n                continue;\r\n            }\r\n\r\n            if !categories.contains_key(function.documentation().category()) {\r\n                categories.insert(function.documentation().category().to_string(), Vec::new());\r\n            }\r\n            categories\r\n                .get_mut(function.documentation().category())\r\n                .unwrap()\r\n                .push(function.as_ref());\r\n        }\r\n\r\n        for (_, functions) in categories.iter_mut() {\r\n            functions.sort_by(|f1, f2| f1.name().cmp(f2.name()));\r\n        }\r\n        categories\r\n    }\r\n}\r\n\r\npub trait DocumentationFormatter {\r\n    /// A single function including extended descriptions and examples\r\n    fn format_function(\u0026self, state: \u0026State, name: \u0026str) -\u003e Option\u003cString\u003e;\r\n\r\n    /// A more focussed list of functions including extended descriptions\r\n    fn format_function_category(\u0026self, state: \u0026State, category: \u0026str) -\u003e Option\u003cString\u003e;\r\n\r\n    /// A general list of function signatures and short descriptions\r\n    fn format_function_list(\u0026self, state: \u0026State) -\u003e String;\r\n\r\n    //\r\n    // Section Documentation\r\n    //\r\n\r\n    fn format_operators(\u0026self) -\u003e String;\r\n\r\n    fn format_functions(\u0026self, state: \u0026State, search: Option\u003c\u0026str\u003e) -\u003e String {\r\n        if let Some(search) = search {\r\n            if let Some(s) = self.format_function(state, search) {\r\n                s\r\n            } else if let Some(s) = self.format_function_category(state, search) {\r\n                s\r\n            } else {\r\n                format!(\"No function or category found for '{}'\", search)\r\n            }\r\n        } else {\r\n            self.format_function_list(state)\r\n        }\r\n    }\r\n\r\n    //\r\n    // Global\r\n    //\r\n\r\n    fn format_title(\u0026self, title: \u0026str) -\u003e String;\r\n    fn format_subtitle(\u0026self, title: \u0026str) -\u003e String;\r\n    fn format_subsubtitle(\u0026self, title: \u0026str) -\u003e String;\r\n    fn format_text(\u0026self, text: \u0026str) -\u003e String;\r\n}\r\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":1820},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":1806},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":1974},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":168},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":1806},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":1806},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":1806},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":350},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":7747},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":19,"coverable":21},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","documentation","operator_documentation.rs"],"content":"use crate::pest::Rule;\r\npub struct OperatorDocumentation {\r\n    pub rules: \u0026'static [Rule],\r\n    pub name: \u0026'static str,\r\n    pub symbols: \u0026'static [\u0026'static str],\r\n\r\n    pub description: \u0026'static str,\r\n    pub examples: \u0026'static str,\r\n}\r\n\r\ninventory::collect!(OperatorDocumentation);\r\npub fn all() -\u003e Vec\u003c\u0026'static OperatorDocumentation\u003e {\r\n    let mut all: Vec\u003c_\u003e = inventory::iter::\u003cOperatorDocumentation\u003e\r\n        .into_iter()\r\n        .collect();\r\n    all.sort_by(|a, b| a.name.cmp(b.name));\r\n    all\r\n}\r\n\r\n/// Generates a documentation entry for an operator\r\nmacro_rules! document_operator {\r\n    (\r\n        name = $name:literal,\r\n        rules = [$($rule:ident),*],\r\n        symbols = [$($symbol:literal),*],\r\n        description = $description:literal,\r\n        examples = $examples:literal$(,)?\r\n    ) =\u003e {\r\n        inventory::submit! {\r\n            crate::documentation::OperatorDocumentation {\r\n                name: $name,\r\n                rules: \u0026[$(Rule::$rule),*],\r\n                symbols: \u0026[$($symbol),*],\r\n                description: indoc::indoc! { $description },\r\n                examples: indoc::indoc! { $examples }\r\n            }\r\n        }\r\n    };\r\n}\r\n\r\n#[cfg(test)]\r\nmod test {\r\n    use crate::{error::ErrorDetails, Error};\r\n\r\n    use super::*;\r\n\r\n    #[test]\r\n    fn test_all_rules_documented() {\r\n        let docs = all();\r\n        let mut errors = vec![];\r\n\r\n        for operator in docs {\r\n            let result = crate::Lavendeux::new(Default::default()).parse(operator.examples);\r\n            if let Err(e) = result {\r\n                errors.push(Error {\r\n                    details: ErrorDetails::Custom {\r\n                        msg: format!(\"{} Example Error\", operator.name),\r\n                    },\r\n                    source: Some(Box::new(e)),\r\n                    context: None,\r\n                });\r\n            }\r\n        }\r\n        for error in \u0026errors {\r\n            eprintln!(\"{}\\n\", error);\r\n        }\r\n\r\n        assert!(\r\n            errors.is_empty(),\r\n            \"{} errors found in operator documentation\",\r\n            errors.len()\r\n        );\r\n    }\r\n}\r\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":266},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":2},"fn_name":null}],"covered":4,"coverable":4},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","documentation","plain.rs"],"content":"use super::{DocumentationFormatter, FunctionsByCategory};\r\nuse crate::State;\r\n\r\npub struct PlaintextFormatter;\r\nimpl PlaintextFormatter {\r\n    fn draw_cool_box(title: \u0026str, lines: \u0026Vec\u003cString\u003e) -\u003e String {\r\n        let mut max_length = 0;\r\n        for line in lines.iter() {\r\n            if line.len() \u003e max_length {\r\n                max_length = line.len();\r\n            }\r\n        }\r\n        if title.len() \u003e max_length {\r\n            max_length = title.len();\r\n        }\r\n\r\n        // pad to max_length+1\r\n        let title = format!(\"{: \u003cwidth$}\", title, width = max_length + 1);\r\n\r\n        let mut output = format!(\"{}\\n\", \"\".repeat(max_length + 2));\r\n        output += \u0026format!(\" {}\\n\", title);\r\n        output += \u0026format!(\"{}\\n\", \"\".repeat(max_length + 2));\r\n        for line in lines {\r\n            output += \u0026format!(\" {: \u003cwidth$}\\n\", line, width = max_length + 1);\r\n        }\r\n        output += \u0026format!(\"{}\\n\", \"\".repeat(max_length + 2));\r\n\r\n        output\r\n    }\r\n}\r\nimpl DocumentationFormatter for PlaintextFormatter {\r\n    //\r\n    // Functions\r\n    //\r\n\r\n    fn format_function(\u0026self, state: \u0026State, name: \u0026str) -\u003e Option\u003cString\u003e {\r\n        let function = state.get_function(name)?;\r\n        let mut lines = Vec::new();\r\n        if let Some(desc) = function.documentation().description() {\r\n            lines.push(desc.to_string());\r\n        }\r\n        if let Some(ext_desc) = function.documentation().ext_description() {\r\n            for line in ext_desc.split('\\n') {\r\n                lines.push(line.to_string());\r\n            }\r\n        }\r\n        if let Some(examples) = function.documentation().examples() {\r\n            let examples = examples.trim_start_matches(\"#skip\").trim();\r\n            if !examples.is_empty() {\r\n                lines.push(\"Examples:\".to_string());\r\n                for line in examples.split('\\n') {\r\n                    lines.push(format!(\"  {}\", line));\r\n                }\r\n            }\r\n        }\r\n\r\n        Some(Self::draw_cool_box(\u0026function.signature(), \u0026lines))\r\n    }\r\n\r\n    fn format_function_category(\u0026self, state: \u0026State, category: \u0026str) -\u003e Option\u003cString\u003e {\r\n        let functions = state.functions_by_category();\r\n        let key = functions\r\n            .keys()\r\n            .find(|k| k.to_lowercase() == category.to_lowercase())?;\r\n        let functions = functions.get(key)?;\r\n\r\n        let mut output = Vec::new();\r\n\r\n        for f in functions {\r\n            let mut lines = Vec::new();\r\n            if let Some(desc) = f.documentation().description() {\r\n                lines.push(desc.to_string());\r\n            }\r\n            if let Some(ext_desc) = f.documentation().ext_description() {\r\n                for line in ext_desc.split('\\n') {\r\n                    lines.push(line.to_string());\r\n                }\r\n            }\r\n\r\n            if lines.is_empty() {\r\n                output.push(f.signature());\r\n            } else {\r\n                output.push(Self::draw_cool_box(\u0026f.signature(), \u0026lines));\r\n            }\r\n        }\r\n\r\n        Some(output.join(\"\\n\"))\r\n    }\r\n\r\n    fn format_function_list(\u0026self, state: \u0026State) -\u003e String {\r\n        let categories = state.functions_by_category();\r\n        let mut output = Vec::new();\r\n\r\n        let mut sorted_categories: Vec\u003c_\u003e = categories.keys().collect();\r\n        sorted_categories.sort();\r\n\r\n        for category in sorted_categories {\r\n            let functions = categories.get(category).unwrap();\r\n            let lines = functions\r\n                .iter()\r\n                .map(|f| match f.documentation().description() {\r\n                    Some(desc) =\u003e format!(\"{} : {}\", f.signature(), desc),\r\n                    None =\u003e f.signature(),\r\n                })\r\n                .collect();\r\n            output.push(Self::draw_cool_box(category, \u0026lines));\r\n        }\r\n\r\n        output.join(\"\\n\")\r\n    }\r\n\r\n    //\r\n    // Section Loaders\r\n    //\r\n\r\n    fn format_operators(\u0026self) -\u003e String {\r\n        todo!()\r\n    }\r\n\r\n    fn format_title(\u0026self, title: \u0026str) -\u003e String {\r\n        format!(\"{}\\n{}\", title, \"=\".repeat(title.len()))\r\n    }\r\n\r\n    fn format_subtitle(\u0026self, title: \u0026str) -\u003e String {\r\n        format!(\"{}\\n{}\", title, \"-\".repeat(title.len()))\r\n    }\r\n\r\n    fn format_subsubtitle(\u0026self, title: \u0026str) -\u003e String {\r\n        format!(\"{}\\n\\n\", title)\r\n    }\r\n\r\n    fn format_text(\u0026self, text: \u0026str) -\u003e String {\r\n        text.to_string()\r\n    }\r\n}\r\n","traces":[{"line":6,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":7,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":8,"address":[],"length":0,"stats":{"Line":141},"fn_name":null},{"line":9,"address":[],"length":0,"stats":{"Line":166},"fn_name":null},{"line":10,"address":[],"length":0,"stats":{"Line":50},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":373},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":116},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":47},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":46},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":156},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":38,"coverable":62},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","documentation","static_docs.rs"],"content":"use lazy_static::lazy_static;\r\nuse serde_json::{json, Value};\r\n\r\nuse super::DocumentationFormatter;\r\n\r\npub struct DocumentationTemplate(Box\u003cdyn DocumentationFormatter\u003e);\r\nimpl DocumentationTemplate {\r\n    const FUNCTION_TITLE: \u0026'static str = \"Functions\";\r\n    const OPERATOR_TITLE: \u0026'static str = \"Operators and Syntax\";\r\n\r\n    pub fn new(formatter: impl DocumentationFormatter + 'static) -\u003e Self {\r\n        Self(Box::new(formatter))\r\n    }\r\n\r\n    pub fn render_functions(\u0026self, state: \u0026crate::State, search: Option\u003c\u0026str\u003e) -\u003e String {\r\n        self.0.format_functions(state, search)\r\n    }\r\n\r\n    pub fn render_operators(\u0026self) -\u003e String {\r\n        self.0.format_operators()\r\n    }\r\n\r\n    pub fn render_values(\u0026self) -\u003e String {\r\n        let mut output = String::new();\r\n\r\n        let sections = VALUE_SECTION_DATA[\"contents\"].as_array().unwrap().iter();\r\n        for section in sections {\r\n            output += \u0026self.0.format_title(section[\"section\"].as_str().unwrap());\r\n            output += \u0026section[\"text\"]\r\n                .as_str()\r\n                .unwrap()\r\n                .split('\\n')\r\n                .map(|s| self.0.format_text(s.trim()))\r\n                .collect::\u003cString\u003e();\r\n        }\r\n\r\n        output\r\n    }\r\n\r\n    pub fn render(\u0026self, state: \u0026crate::State) -\u003e String {\r\n        let mut output = String::new();\r\n        output += \u0026self.render_values();\r\n        output += \"\\n\\n------------\\n\\n\";\r\n\r\n        output += \u0026self.0.format_title(Self::OPERATOR_TITLE);\r\n        output += \u0026self.render_operators();\r\n        output += \"\\n\\n------------\\n\\n\";\r\n\r\n        output += \u0026self.0.format_title(Self::FUNCTION_TITLE);\r\n        output += \u0026self.render_functions(state, None);\r\n\r\n        output\r\n    }\r\n}\r\n\r\nlazy_static! {\r\n    pub static ref VALUE_SECTION_DATA: Value = json!({\r\n        \"contents\": [\r\n            {\r\n                \"section\": \"Lavendeux Documentation\",\r\n                \"text\": \"\r\n                    Lavendish a language designed to manipulate values with concise, single-line expressions.\r\n                    It was created for use in Lavendeux (\u003chttps://rscarson.github.io/lavendeux/\u003e).\r\n\r\n                    Inputs are a series of expressions separated by a newline, or a `;`.\r\n                    Expressions can optionally end with an @decorator to format the output as a string\r\n\r\n                    Key features:\r\n                    - Functions ([reference](\u003c#function-assignment\u003e))\r\n                    - @Decorators ([reference](\u003c#decorator\u003e))\r\n                    - Seamless type conversion ([reference](\u003c#the-type-system\u003e))\r\n                \"\r\n            },\r\n\r\n            {\r\n                \"section\": \"The Type System\",\r\n                \"text\": \"\r\n                    All expressions in Lavendeux must return a value of a specific type.\r\n                    These types can be broadly categorized as `numeric`, `collection`, or `string`.\r\n\r\n                    The type of a given expression is calculated on a hierarchy, based on the 'specificity' of the types involved.\r\n                    The hierarchy is as follows (from lowest to highest priority):  \r\n                    - Bool\r\n                    - Int (in order, `u8, i8, u16, i16, u32, i32, u64, i64`)\r\n                    - Float\r\n                    - Fixed, then Currency\r\n                    - String\r\n                    - Array, then Object\r\n\r\n                    Note that range is not included, since it can only be compared to itself, or to arrays.\r\n\r\n                    So for example, if you add an int to a float, the result will be a float.\r\n                    Some types can also be grouped together, like `int` (see aboove), or `numeric` (which includes all numeric types), \r\n                    and `collection` (which includes range, string, array and object). 'any' is the implicit type that includes everything.\r\n\r\n                    The names of the types, for the most part, are self-explanatory, but here's a quick rundown:\r\n                    `bool` - A single-bit truth value\r\n                    `int` - A signed or unsigned integer of various sizes (`u8` to `i64`)\r\n                    `float` - A 64bit floating-point number\r\n                    `fixed` - A fixed-point decimal value\r\n                    `currency` - A fixed-point decimal value with a currency symbol and set precision\r\n                    `array` - An ordered collection of values, indexed by integers\r\n                    `object` - An unordered collection of key-value pairs\r\n                    `range` - An inclusive range of integers\r\n                    `string` - A sequence of characters\r\n                    `numeric` - The implicit type that includes all numeric types, and `bool`\r\n                    `collection` - The implicit type that includes all collection types\r\n                    `any` - The implicit type that includes everything\r\n\r\n                    --------\r\n\r\n                    ## bool\r\n                    The `bool` type is a single-bit truth value, and can be either `true` or `false`.\r\n                    In arithmetic operations, `true` is equivalent to `1`, and `false` is equivalent to `0`; operations are performed as if on a wrapping 1-bit integer.\r\n                    \r\n                    **Casting:**  \r\n                    It can be cast from any type; and truth is determined by equivalence to 0, or by emptiness, depending on the type.\r\n\r\n                    **Formatting:**  \r\n                    When cast to a string, it will be formatted as `true` or `false`.\r\n\r\n                    **Examples:**\r\n                    ```lavendeux\r\n                    1 as bool; // true\r\n                    [] as bool; // false\r\n                    ```\r\n\r\n                    ## int\r\n                    Covering the types from `u8` to `i64`, `int` is a signed or unsigned integer of various sizes.\r\n                    Integers can be written in decimal, binary, octal, or hexadecimal, with an optional suffix to specify the type.\r\n                    If no suffix is provided, the type defaults to i64.\r\n\r\n                    **Casting:**\r\n                    It can be cast from and to any type, and from any numeric type.\r\n\r\n                    **Formatting:**  \r\n                    When cast to a string, it will be formatted as a decimal number. For other formatting options, see [decorators](\u003c#decorators-functions\u003e).\r\n\r\n                    **Examples:**\r\n                    ```lavendeux\r\n                    0xFFu8; // 255\r\n                    0o77i16; // 63\r\n                    077; // 63\r\n                    0b1010_1010_1010_1010i32; // 43690\r\n                    38_000; // 38,000\r\n                    ```\r\n\r\n                    ## float\r\n                    A 64bit floating-point number, `float` can be written in decimal, or in scientific notation.\r\n\r\n                    **Casting:**\r\n                    It can be cast from and to any type, and from any numeric type.\r\n\r\n                    **Formatting:**  \r\n                    When cast to a string, it will be formatted as a decimal number. For other formatting options, see [decorators](\u003c#decorators-functions\u003e).\r\n\r\n                    **Examples:**\r\n                    ```lavendeux\r\n                    1.0; // 1.0\r\n                    .2; // 0.2\r\n                    3e+7; // 30,000,000\r\n                    ```\r\n\r\n                    ## fixed\r\n                    A fixed-point decimal value. Fixed literals are suffixed with `D`.\r\n\r\n                    Note that fixed-point exponentiation is not supported, and will result in an implicit cast to float.\r\n\r\n                    **Casting:**\r\n                    It can be cast from and to any type, and from any numeric type.\r\n\r\n                    **Formatting:**  \r\n                    When cast to a string, it will appear similar to int or float, depending on the decimal precision of the value.\r\n\r\n                    **Examples:**\r\n                    ```lavendeux\r\n                    1.22D; // 1.22\r\n                    4D; // 4\r\n                    ```\r\n\r\n                    ## currency\r\n                    A fixed-point decimal value with a currency symbol and set precision. Arithmetic operations will maintain the currency symbol only if both operands share the same one, and will use the larger precision.\r\n\r\n                    **Casting:**\r\n                    It can be cast from and to any type, and from any numeric type.\r\n\r\n                    **Formatting:**  \r\n                    When cast to a string, it will appear similar to fixed, but with the currency symbol.\r\n\r\n                    **Examples:**\r\n                    ```lavendeux\r\n                    $1.00 + 1; // $1.00\r\n                    $2.00 + 1.000; // 3.000\r\n                    3; // 3\r\n                    ```\r\n\r\n                    **Supported currency symbols:**\r\n\r\n                    ```text\r\n                    $ |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |\r\n                     |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |\r\n                     |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |\r\n                     |  | \r\n                    ```\r\n\r\n                    ## array\r\n                    An ordered collection of values, indexed by integers. Values can be a mix of types.\r\n\r\n                    **Casting:**\r\n                    It can be cast from any type; and will result in a single-value array - `A as array` is equivalent to `[A]`.\r\n                    When cast to any non-collection type, it will extract the single value, if the array has a length of 1 - `['a'] as int` would result in `a`.\r\n                    Casting a larger array to a non-collection type will result in an error.\r\n                    Casting array to object will result in an object with integer keys, and the values of the array.\r\n                    Casting range to array will result in an array of the range values (very large ranges may result in an error).\r\n\r\n                    **Formatting:**  \r\n                    When cast to a string, it will be formatted as a comma-separated list of values, enclosed in square brackets.\r\n\r\n                    **Examples:**\r\n                    ```lavendeux\r\n                    [1, 2, 3]; // [1, 2, 3]\r\n                    [1] as int; // 1\r\n                    [1, 2, 3] as object; // {0: 1, 1: 2, 2: 3}\r\n                    1..3 as array; // [1, 2, 3]\r\n                    ```\r\n\r\n                    ## object\r\n                    An unordered collection of key-value pairs, where keys are any non-collection type and values can be a mix of types.\r\n                    Unlike boolean comparison operators (see \u003c#boolean\u003e), key comparison is type-sensitive - `{1: 2} == {'1': 2}` would be false.\r\n\r\n                    **Casting:**\r\n                    It can be cast from any type; and will result in a single-value object - `A as object` is equivalent to `{0: A}`.\r\n                    This is the same as casting to array, then to object.\r\n                    When cast to any non-collection type, it will extract the single value, if the object has a length of 1 - `{0: 'a'} as int` would result in `a`.\r\n                    Casting a larger object to a non-collection type will result in an error.\r\n                    Casting object to array will result in an array of the object values.\r\n\r\n                    **Formatting:**  \r\n                    When cast to a string, it will be formatted as a comma-separated list of key-value pairs, enclosed in curly brackets.\r\n\r\n                    **Examples:**\r\n                    ```lavendeux\r\n                    {1: 2}; // {1: 2}\r\n                    {1: 2} as array; // [2]\r\n                    {1: 2} as int; // 2\r\n                    {1: 2} as string; // \\\"{1: 2}\\\"\r\n                    ```\r\n\r\n                    ## range\r\n                    An inclusive range of integers, with a start and end value. Start and end can be single characters, or any numeric type.\r\n                    \r\n                    **Casting:**\r\n                    Ranges cannot be cast from any type, and can only be cast to an array.\r\n\r\n                    **Formatting:**  \r\n                    When cast to a string, it will be formatted in the form `start..end`.\r\n\r\n                    **Examples:**\r\n                    ```lavendeux\r\n                    1..3 as array; // [1, 2, 3]\r\n                    'a'..'c' as array // ['a', 'b', 'c']\r\n                    ```\r\n\r\n                    ## string\r\n                    Any value can be cast to a string, to get a string representation of that value. It is encoding as a UTF-8 string.\r\n                    It is enclosed in single or double quotes, and supports the following supported escape sequences:\r\n                    - `\\\\\\'` Single-quote\r\n                    - `\\\\\\\"` Double-quote\r\n                    - `\\\\n` Newline\r\n                    - `\\\\r` Carriage-return\r\n                    - `\\\\t` Tab\r\n                    - `\\\\\\\\` Literal backslash\r\n\r\n                    **Casting:**\r\n                    It can be cast from any type, and cast to array or object.\r\n                    Casting to array will result in a character array, and casting to object will in a single-value object with the key `0i64`\r\n\r\n                    **Formatting:**  \r\n                    When cast to a string, it will be formatted as a string literal, without enclosing quotes.\r\n                    Inside a, array or object, it will be formatted as a string literal, with enclosing quotes.\r\n\r\n                    **Examples:**\r\n                    ```lavendeux\r\n                    \\\"test \\\\\\\"\\\"\r\n                    1 as string // \\\"1\\\"\r\n                    [1] as string // \\\"[1]\\\"\r\n                    {0: 1} as string // \\\"{0: 1}\\\"\r\n                    ```\r\n                \"\r\n            },\r\n        ]\r\n    });\r\n}\r\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":229},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":28,"coverable":28},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","error","error_details.rs"],"content":"use polyvalue::{Value, ValueType};\r\nuse thiserror::Error;\r\n\r\nuse super::SyntaxErrorCause;\r\n\r\nconst BUG_REPORT_URL : \u0026str = \"https://github.com/rscarson/lavendeux-parser/issues/new?assignees=\u0026labels=\u0026template=bug_report.md\u0026title=\";\r\n\r\n/// Inner error type for Lavendeux\r\n/// Gives more detailed information about the error\r\n/// And gets wrapped in the main Error type, along with metadata\r\n#[derive(Error, Debug)]\r\n#[rustfmt::skip]\r\npub enum ErrorDetails {\r\n    //\r\n    // Core\r\n    //\r\n\r\n    /// An error caused by a problem with the parser itself\r\n    #[error(\r\n        \"Internal parser issue: {msg}\\nPlease report this problem at {}\",\r\n        BUG_REPORT_URL\r\n    )]\r\n    Internal {\r\n        /// Message describing the error\r\n        msg: String,\r\n    },\r\n\r\n    /// An error caused by leaving a block empty\r\n    #[error(\"Block cannot be empty\")]\r\n    EmptyBlock,\r\n\r\n    /// An error caused by a problem with the syntax of the script\r\n    #[error(\"Syntax error; {cause}\")]\r\n    Syntax {\r\n        /// Cause of the syntax error\r\n        cause: SyntaxErrorCause\r\n    },\r\n\r\n    /// Error causing the parser thread to panic\r\n    #[error(\"Fatal error: {msg}\")]\r\n    Fatal {\r\n        /// Message describing the error\r\n        msg: String\r\n    },\r\n\r\n    /// A timeout error caused by a script taking too long to execute\r\n    #[error(\"Script execution timed out\")]\r\n    Timeout,\r\n\r\n    /// An error caused by a custom error message\r\n    #[error(\"{msg}\")]\r\n    Custom {\r\n        /// Message describing the error\r\n        msg: String,\r\n    },\r\n\r\n    /// An error used to return a value from a function early\r\n    #[error(\"Returned from the root scope\")]\r\n    Return {\r\n        /// Value being returned\r\n        value: Value,\r\n    },\r\n\r\n    /// An error used to skip a value from a loop\r\n    #[error(\"Skipped from outside a loop\")]\r\n    Skip,\r\n\r\n    /// An error used to skip a value from a loop\r\n    #[error(\"Break called from outside a loop\")]\r\n    Break,\r\n\r\n    ///////////////////////////////////////////////////////////////////////////\r\n    // Syntax Errors\r\n    // Deals with issues during Pest tree parsing\r\n    ///////////////////////////////////////////////////////////////////////////\r\n\r\n    /// An error caused by attempting to modify a read-only stdlib function\r\n    #[error(\"Could not alter system function {name}\")]\r\n    ReadOnlyFunction {\r\n        /// Name of the function being referred to\r\n        name: String,\r\n    },\r\n\r\n    /// An error caused by a problem with the syntax of the script\r\n    #[error(\"If statements are required return a value - use 'else' to select a default value\")]\r\n    NoElseBlock,\r\n    \r\n    /// An error caused by a problem with the syntax of the script\r\n    #[error(\"Did not specify a value for return\")]\r\n    UnterminatedReturn,\r\n\r\n    /// An error caused by using a decorator in the wrong place\r\n    #[error(\"@decorators must be at the end of a statement\")]\r\n    UnexpectedDecorator,\r\n\r\n    /// An error caused by using a postfix operator without an operand\r\n    #[error(\"Unterminated block comment: Expected '*/'\")]\r\n    UnterminatedComment,\r\n\r\n    /// An error caused by a missing bracket\r\n    #[error(\"Unclosed bracket: Expected ']'\")]\r\n    UnterminatedArray,\r\n\r\n    /// An error caused by a missing brace\r\n    #[error(\"Unclosed brace: Expected '}}'\")]\r\n    UnterminatedObject,\r\n\r\n    /// An error caused by a missing brace\r\n    #[error(\"Unclosed parentheses: Expected '('\")]\r\n    UnterminatedParen,\r\n\r\n    /// An error caused by ending a script on a backslash\r\n    #[error(\"Missing linebreak after '\\\\'\")]\r\n    UnterminatedLinebreak,\r\n\r\n    /// An error caused by a missing quote\r\n    #[error(\"Expected ' or \\\"\")]\r\n    UnterminatedLiteral,\r\n\r\n    /// Cause by a missing default case in a switch statement\r\n    #[error(\"Match expression is not exhaustive. Add a default case '_' to match all values\")]\r\n    NonExhaustiveSwitch,\r\n\r\n    /// Caused by a default case eclipsing other cases in a switch statement\r\n    #[error(\"All cases after the default case '_' are unreachable\")]\r\n    UnreachableSwitchCase,\r\n\r\n    /// Caused by a type mismatch in a switch statement\r\n    #[error(\"{case} is not valid for this switch statement. Expected a {expected_type}\")]\r\n    SwitchCaseTypeMismatch {\r\n        /// Case that caused the issue\r\n        case: Value,\r\n\r\n        /// Type that was expected\r\n        expected_type: ValueType,\r\n    },\r\n\r\n    ///////////////////////////////////////////////////////////////////////////\r\n    // Value Errors\r\n    // Mostly deals with variables, and value objects\r\n    ///////////////////////////////////////////////////////////////////////////\r\n    \r\n    /// Caused by assignments to constants\r\n    #[error(\"Cannot assign to a constant value\")]\r\n    ConstantValue,\r\n\r\n    /// An error caused by a mismatch in types for a range\r\n    #[error(\"Invalid combination of types for range. Use a pair of either integers, or characters\")]\r\n    RangeTypeMismatch,\r\n\r\n    /// An error caused by invalid range values\r\n    #[error(\"{start}..{end} is not a valid range: use integers or single-byte strings\")]\r\n    InvalidRange {\r\n        /// Start value\r\n        start: String,\r\n\r\n        /// End value\r\n        end: String,\r\n    },\r\n\r\n    /// An error caused by invalid range values\r\n    #[error(\"{start}..{end} is not a valid range: start \u003e end\")]\r\n    RangeStartGT {\r\n        /// Start value\r\n        start: String,\r\n\r\n        /// End value\r\n        end: String,\r\n    },\r\n\r\n    /// An error caused by a value being out of range\r\n    #[error(\"Arithmetic overflow\")]\r\n    Overflow,\r\n\r\n    /// Caused by a mismatch in the number of values in a destructuring assignment\r\n    #[error(\"Expected {expected_length} values, found {actual_length}\")]\r\n    DestructuringAssignment {\r\n        /// Number of values expected\r\n        expected_length: usize,\r\n\r\n        /// Number of values found\r\n        actual_length: usize,\r\n    },\r\n\r\n    /// An error caused by a value not being able to be parsed\r\n    #[error(\"Input could not be parsed as {expected_format}\")]\r\n    ValueFormat {\r\n        /// Format that was expected\r\n        expected_format: String,\r\n    },\r\n\r\n    /// An error caused by a value being out of range\r\n    #[error(\"{input} was out of range\")]\r\n    Range {\r\n        /// Input that was out of range\r\n        input: String,\r\n    },\r\n\r\n    /// An error caused by a missing variable\r\n    #[error(\"Undefined variable {name}. You can assign a value with {name} = ...\")]\r\n    VariableName {\r\n        /// Name of the variable being referred to\r\n        name: String,\r\n    },\r\n\r\n    /// An error caused by an attempt to access an element of an empty array\r\n    #[error(\"Array empty\")]\r\n    ArrayEmpty,\r\n\r\n    ///////////////////////////////////////////////////////////////////////////\r\n    // Function Errors\r\n    // Deals with issues during builtin, user, or extension function calls\r\n    ///////////////////////////////////////////////////////////////////////////\r\n\r\n    /// An error caused by a decorator specifying the wrong number of arguments\r\n    #[error(\"Decorator @{name} must accept a single argument\")]\r\n    DecoratorSignatureArgs {\r\n        /// Name of the decorator being referred to\r\n        name: String,\r\n    },\r\n\r\n    /// An error caused by a decorator specifying a return type\r\n    #[error(\"@{name} does not need to specify a return type; decorators always return a string\")]\r\n    DecoratorSignatureReturn {\r\n        /// Name of the decorator being referred to\r\n        name: String,\r\n    },\r\n\r\n    /// An error caused by a function call\r\n    #[error(\"Error in `{name}()`\")]\r\n    FunctionCall {\r\n        /// Name of the source function\r\n        name: String\r\n    },\r\n\r\n    /// An error caused by a function calling itself too many times\r\n    #[error(\"Recursive function went too deep\")]\r\n    StackOverflow,\r\n    \r\n    /// An error caused by calling a function with the wrong type of argument\r\n    #[error(\"Expected {expected_type} value for argument {arg} of `{signature}`\")]\r\n    FunctionArgumentType {\r\n        /// Argument number causing the issue (1-based)\r\n        arg: usize,\r\n\r\n        /// Type that was requested\r\n        expected_type: ValueType,\r\n        \r\n        /// Signature of the function called\r\n        signature: String,\r\n\r\n    },\r\n\r\n    /// An error caused by calling a function that does not exist\r\n    #[error(\"Undefined function {name}. You can define a function with {name}(a, b, c) = ...\")]\r\n    FunctionName {\r\n        /// Name of the function being referred to\r\n        name: String,\r\n    },\r\n\r\n    /// An error caused by calling a function using the wrong number of arguments\r\n    #[error(\r\n        \"Expected {} arguments for `{signature}`\",\r\n        if min == max {format!(\"{}\", min)} else {format!(\"{}-{}\", min, max)}\r\n    )]\r\n    FunctionArguments {\r\n        /// Smallest number of arguments accepted by the function\r\n        min: usize,\r\n        \r\n        /// Largest number of arguments accepted by the function\r\n        max: usize, \r\n        \r\n        \r\n        /// Signature of the function called\r\n        signature: String,\r\n        \r\n    },\r\n\r\n    /// An error caused by calling a decorator that does not exist\r\n    #[error(\"No decorator named {name}\")]\r\n    DecoratorName {\r\n        /// Name of the decorator being referred to\r\n        name: String,\r\n    },\r\n    \r\n    /// An error caused by attempting to use an API without registering it\r\n    #[error(\"API {name} was not found. Add it with api_register(\\\"{name}\\\", base_url, [optional api key])\")]\r\n    UnknownApi {\r\n        /// Name of the API being referred to\r\n        name: String,\r\n    },\r\n\r\n    //\r\n    // 3rd Party\r\n    //\r\n    \r\n    /// Error dealing with polyvalue issues\r\n    #[error(\"{0}\")]\r\n    Value(#[from] polyvalue::Error),\r\n\r\n    /// Error dealing with filesystem issues\r\n    #[error(\"{0}\")]\r\n    Io(#[from] std::io::Error),\r\n\r\n    /// Error dealing with network issues from the reqwest crate\r\n    #[error(\"{0}\")]\r\n    Network(#[from] reqwest::Error),\r\n\r\n    /// Error dealing with int parsing issues\r\n    #[error(\"{0}\")]\r\n    ParseIntError(#[from] std::num::ParseIntError),\r\n\r\n    /// Error dealing with utf8 issues\r\n    #[error(\"{0}\")]\r\n    FromUtf8Error(#[from] std::string::FromUtf8Error),\r\n\r\n    /// Error dealing with json issues\r\n    #[error(\"{0}\")]\r\n    SerdeJsonError(#[from] serde_json::Error),\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","error","macros.rs"],"content":"/// Matches an error to the type of ErrorDetails it contains\r\n/// # Arguments\r\n/// * `err` - The error to match\r\n/// * `pat` - The pattern to match against\r\n///\r\n/// # Example\r\n/// ```rust\r\n/// # use lavendeux_parser::error::Error;\r\n/// # use lavendeux_parser::error::ErrorDetails;\r\n/// # use lavendeux_parser::error_matches;\r\n///\r\n/// let err = Error {\r\n///     details: ErrorDetails::ArrayEmpty,\r\n///     context: None,\r\n///     source: None,\r\n/// };\r\n/// assert!(error_matches!(err, ArrayEmpty));\r\n/// ```\r\n#[macro_export]\r\nmacro_rules! error_matches {\r\n    ($err:expr, $pat:ident) =\u003e {\r\n        matches!(($err).details, $crate::error::ErrorDetails::$pat { .. })\r\n    };\r\n}\r\n\r\n/// Returns an Err(Error), optionally with a context and/or source\r\n/// Example:\r\n/// ```rust\r\n/// # use lavendeux_parser::error::Error;\r\n/// # use lavendeux_parser::oops;\r\n/// # use lavendeux_parser::Token;\r\n/// # fn example() -\u003e Result\u003c(), Error\u003e {\r\n/// # let token = Token::dummy();\r\n/// # let parent_error = Error::from(lavendeux_parser::error::ErrorDetails::ArrayEmpty);\r\n/// return oops!(FunctionName { name: \"foo\".to_string() }, token);\r\n/// return oops!(FunctionName { name: \"foo\".to_string() }, token = token, src = parent_error);\r\n/// # Ok(())\r\n/// # }\r\n/// ```\r\n#[macro_export]\r\nmacro_rules! oops {\r\n    ($variant:ident $({ $($n:ident$(:$v:expr)?),+ })?, token = $context:expr, src = $src:expr) =\u003e {\r\n        Err($crate::error::Error {\r\n            details: $crate::error::ErrorDetails::$variant $({ $($n $(: $v)?),+ })?,\r\n            context: Some($context.into_owned()),\r\n            source: Some(Box::new($src)),\r\n        })\r\n    };\r\n    ($variant:ident $({ $($n:ident$(:$v:expr)?),+ })?, $context:expr) =\u003e {\r\n        Err($crate::error::Error {\r\n            details: $crate::error::ErrorDetails::$variant $({ $($n $(: $v)?),+ })?,\r\n            context: Some($context.into_owned()),\r\n            source: None,\r\n        })\r\n    };\r\n    ($variant:ident $({ $($n:ident$(:$v:expr)?),+ })?, src = $src:expr) =\u003e {\r\n        Err($crate::error::Error {\r\n            details: $crate::error::ErrorDetails::$variant $({ $($n $(: $v)?),+ })?,\r\n            context: None,\r\n            source: Some(Box::new($src)),\r\n        })\r\n    };\r\n    ($variant:ident $({ $($n:ident$(:$v:expr)?),+ })?) =\u003e {\r\n        Err($crate::error::Error {\r\n            details: $crate::error::ErrorDetails::$variant $({ $($n $(: $v)?),+ })?,\r\n            context: None,\r\n            source: None,\r\n        })\r\n    };\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","error","mod.rs"],"content":"//! Error handling module.\r\n//! Defines the Error/ErrorDetails types, and associated traits and macros.\r\nuse crate::Token;\r\n\r\n#[macro_use]\r\nmod macros;\r\n\r\nmod error_details;\r\npub use error_details::ErrorDetails;\r\n\r\nmod traits;\r\npub use traits::*;\r\n\r\n/// Error type for the Lavendeux parser\r\n/// Can have optional context [Token], and parent error\r\n#[derive(Debug)]\r\npub struct Error {\r\n    /// details: The specific error that occurred - see [ErrorDetails]\r\n    pub details: ErrorDetails,\r\n\r\n    /// context: The [Token] that caused the error, or was being parsed when the error occurred\r\n    pub context: Option\u003cToken\u003c'static\u003e\u003e,\r\n\r\n    /// source: A parent error, if one exists - errors during a function call, for example\r\n    pub source: Option\u003cBox\u003cError\u003e\u003e,\r\n}\r\n\r\nimpl\u003c'i\u003e Error {\r\n    /// Add context to this error, in the form a [Token]\r\n    pub fn with_context(self, context: Token\u003c'i\u003e) -\u003e Self {\r\n        Error {\r\n            context: Some(context.into_owned()),\r\n            ..self\r\n        }\r\n    }\r\n\r\n    /// Link the parent error to this error\r\n    pub fn with_source(self, source: Error) -\u003e Self {\r\n        Error {\r\n            source: Some(Box::new(source)),\r\n            ..self\r\n        }\r\n    }\r\n\r\n    /// Remove context from this error\r\n    pub fn without_context(self) -\u003e Self {\r\n        Error {\r\n            context: None,\r\n            ..self\r\n        }\r\n    }\r\n\r\n    /// Offset the line-numbers in this and all parent errors\r\n    /// Useful for when a script is included in another script\r\n    /// Or for function calls\r\n    pub fn offset_linecount(mut self, offset: usize) -\u003e Self {\r\n        let mut new_context = self.context.clone();\r\n        if let Some(context) = \u0026mut new_context {\r\n            context.line += offset;\r\n        }\r\n\r\n        let mut new_source = std::mem::take(\u0026mut self.source);\r\n        if let Some(source) = new_source {\r\n            new_source = Some(Box::new(source.offset_linecount(offset)));\r\n        }\r\n\r\n        Error {\r\n            context: new_context,\r\n            source: new_source,\r\n            ..self\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003cT\u003e From\u003cT\u003e for Error\r\nwhere\r\n    T: std::convert::Into\u003cErrorDetails\u003e,\r\n{\r\n    fn from(details: T) -\u003e Self {\r\n        Error {\r\n            details: details.into(),\r\n            context: None,\r\n            source: None,\r\n        }\r\n    }\r\n}\r\n\r\nimpl std::error::Error for Error {}\r\nimpl std::fmt::Display for Error {\r\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter) -\u003e std::fmt::Result {\r\n        let token_part = if let Some(context) = \u0026self.context {\r\n            format!(\"{context}\\n= \")\r\n        } else {\r\n            \"\".to_string()\r\n        };\r\n\r\n        let source_part = if let Some(source) = \u0026self.source {\r\n            format!(\"\\n{}\", source)\r\n        } else {\r\n            \"\".to_string()\r\n        };\r\n\r\n        write!(f, \"{}{}{}\", token_part, self.details, source_part)\r\n    }\r\n}\r\n","traces":[{"line":30,"address":[],"length":0,"stats":{"Line":739},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":739},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":7,"coverable":19},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","error","traits.rs"],"content":"use std::{borrow::Cow, collections::HashSet};\r\n\r\nuse pest::error::ErrorVariant;\r\n\r\nuse crate::{error::ErrorDetails, pest::Rule, Error, Token};\r\n\r\n/// Describe the cause of a syntax error.\r\n#[derive(Debug, Clone, PartialEq, Eq, Hash)]\r\npub struct SyntaxErrorCause {\r\n    /// Tokens that could have followed the input\r\n    pub expected: Vec\u003cRuleCategory\u003e,\r\n\r\n    /// Tokens that were found instead\r\n    pub unexpected: Vec\u003cRuleCategory\u003e,\r\n}\r\nimpl std::fmt::Display for SyntaxErrorCause {\r\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\r\n        if !self.unexpected.is_empty() {\r\n            // Unexpected token\r\n            write!(f, \"Unexpected {}\", RuleCategory::fmt(\u0026self.unexpected))\r\n        } else if self.expected.len() == 1 {\r\n            // Expected a single token\r\n            write!(f, \"Expected {}\", self.expected[0])\r\n        } else if !self.expected.is_empty() {\r\n            // Expected multiple tokens\r\n            write!(f, \"Expected one of: {}\", RuleCategory::fmt(\u0026self.expected))\r\n        } else {\r\n            // No tokens expected\r\n            write!(f, \"Unexpected token\")\r\n        }\r\n    }\r\n}\r\n\r\n/// Wraps a syntax error into an Error.\r\npub trait WrapSyntaxError\u003cT, R\u003e {\r\n    /// Turns a pest error into an Error.\r\n    fn wrap_syntax_error(self, input: \u0026str) -\u003e Result\u003cT, Error\u003e;\r\n}\r\nimpl\u003cT\u003e WrapSyntaxError\u003cT, Rule\u003e for Result\u003cT, pest::error::Error\u003cRule\u003e\u003e {\r\n    fn wrap_syntax_error(self, input: \u0026str) -\u003e Result\u003cT, Error\u003e {\r\n        match self {\r\n            Ok(v) =\u003e Ok(v),\r\n            Err(e) =\u003e {\r\n                let span = match e.location {\r\n                    pest::error::InputLocation::Pos(pos) =\u003e pos..(input.len()),\r\n                    pest::error::InputLocation::Span(span) =\u003e span.0..span.1,\r\n                };\r\n                let span = \u0026input[span];\r\n\r\n                let line = match e.line_col {\r\n                    pest::error::LineColLocation::Pos((line, _)) =\u003e line,\r\n                    pest::error::LineColLocation::Span((line, _), _) =\u003e line,\r\n                };\r\n\r\n                let token = crate::Token {\r\n                    line,\r\n                    rule: crate::Rule::SCRIPT,\r\n                    input: Cow::Borrowed(span.split('\\n').next().unwrap_or_default()),\r\n                }\r\n                .into_owned();\r\n\r\n                match e.variant {\r\n                    ErrorVariant::ParsingError {\r\n                        positives,\r\n                        negatives,\r\n                    } =\u003e {\r\n                        let cause = SyntaxErrorCause {\r\n                            expected: RuleCategory::collect(\u0026positives),\r\n                            unexpected: RuleCategory::collect(\u0026negatives),\r\n                        };\r\n                        oops!(Syntax { cause }, token)\r\n                    }\r\n\r\n                    ErrorVariant::CustomError { message } if message.contains(\"call limit\") =\u003e {\r\n                        oops!(StackOverflow, token)\r\n                    }\r\n\r\n                    _ =\u003e oops!(\r\n                        Syntax {\r\n                            cause: SyntaxErrorCause {\r\n                                expected: vec![],\r\n                                unexpected: vec![]\r\n                            }\r\n                        },\r\n                        token\r\n                    ),\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/// Wrap a 3rd party error into an Error.\r\npub trait WrapExternalError\u003c'i, T\u003e {\r\n    /// Adds a context [Token]\r\n    fn with_context(self, context: \u0026Token\u003c'i\u003e) -\u003e Result\u003cT, Error\u003e;\r\n\r\n    /// Adds a source [Error]\r\n    fn with_source(self, source: Error) -\u003e Result\u003cT, Error\u003e;\r\n\r\n    /// Wraps the error without context or a source\r\n    fn without_context(self) -\u003e Result\u003cT, Error\u003e;\r\n}\r\n\r\nimpl\u003c'i, T, E\u003e WrapExternalError\u003c'i, T\u003e for Result\u003cT, E\u003e\r\nwhere\r\n    E: Into\u003cError\u003e,\r\n{\r\n    fn with_context(self, context: \u0026Token\u003c'i\u003e) -\u003e Result\u003cT, Error\u003e {\r\n        match self {\r\n            Ok(v) =\u003e Ok(v),\r\n            Err(e) =\u003e Err(e.into().with_context(context.clone())),\r\n        }\r\n    }\r\n\r\n    fn with_source(self, source: Error) -\u003e Result\u003cT, Error\u003e {\r\n        match self {\r\n            Ok(v) =\u003e Ok(v),\r\n            Err(e) =\u003e Err(e.into().with_source(source)),\r\n        }\r\n    }\r\n\r\n    fn without_context(self) -\u003e Result\u003cT, Error\u003e {\r\n        match self {\r\n            Ok(v) =\u003e Ok(v),\r\n            Err(e) =\u003e Err(e.into().without_context()),\r\n        }\r\n    }\r\n}\r\n\r\n/// Wrap an `Option\u003cT\u003e` into a `Result\u003cT, Error\u003e`\r\npub trait WrapOption\u003c'i, T\u003e {\r\n    /// Turns an `Option\u003cT\u003e` into a `Result\u003cT, Error\u003e`\r\n    fn or_error(self, error: ErrorDetails) -\u003e Result\u003cT, Error\u003e;\r\n}\r\nimpl\u003c'i, T\u003e WrapOption\u003c'i, T\u003e for Option\u003cT\u003e {\r\n    fn or_error(self, error: ErrorDetails) -\u003e Result\u003cT, Error\u003e {\r\n        match self {\r\n            Some(v) =\u003e Ok(v),\r\n            None =\u003e Err(Error {\r\n                details: error,\r\n                context: None,\r\n                source: None,\r\n            }),\r\n        }\r\n    }\r\n}\r\n\r\n/// Describes the category of a rule.\r\n/// Used for error messages.\r\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\r\n#[allow(missing_docs)]\r\npub enum RuleCategory {\r\n    Block,\r\n    FunctionAssignment,\r\n    Expression,\r\n    Literal,\r\n    Identifier,\r\n    Operator,\r\n    Array,\r\n    Object,\r\n    Symbol(\u0026'static str),\r\n\r\n    IntSizeSuffix,\r\n    CurrencySymbol,\r\n\r\n    Hidden,\r\n}\r\n\r\nimpl RuleCategory {\r\n    /// Collects all rule categories from a list of rules.\r\n    pub fn collect(rules: \u0026[Rule]) -\u003e Vec\u003cSelf\u003e {\r\n        let set = rules\r\n            .iter()\r\n            .map(|r| RuleCategory::from(*r))\r\n            .filter(|e| e != \u0026RuleCategory::Hidden)\r\n            .collect::\u003cHashSet\u003c_\u003e\u003e();\r\n        set.into_iter().collect()\r\n    }\r\n\r\n    /// Formats a set of rule categories into a string.\r\n    pub fn fmt(cats: \u0026[Self]) -\u003e String {\r\n        let mut cats = cats.iter().map(|c| c.to_string()).collect::\u003cVec\u003c_\u003e\u003e();\r\n        cats.sort();\r\n        cats.join(\", \")\r\n    }\r\n}\r\n\r\nimpl std::fmt::Display for RuleCategory {\r\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\r\n        match self {\r\n            Self::Block =\u003e write!(f, \"block\"),\r\n            Self::FunctionAssignment =\u003e write!(f, \"function assignment\"),\r\n            Self::Expression =\u003e write!(f, \"expression\"),\r\n            Self::Literal =\u003e write!(f, \"value\"),\r\n            Self::Identifier =\u003e write!(f, \"identifier\"),\r\n            Self::Operator =\u003e write!(f, \"operator\"),\r\n            Self::Array =\u003e write!(f, \"array\"),\r\n            Self::Object =\u003e write!(f, \"object\"),\r\n            Self::Symbol(s) =\u003e write!(f, \"`{}`\", s),\r\n\r\n            Self::IntSizeSuffix =\u003e write!(f, \"integer suffix\"),\r\n            Self::CurrencySymbol =\u003e write!(f, \"currency symbol\"),\r\n\r\n            Self::Hidden =\u003e write!(f, \"\"),\r\n        }\r\n    }\r\n}\r\n\r\nimpl From\u003cRule\u003e for RuleCategory {\r\n    fn from(rule: Rule) -\u003e Self {\r\n        match rule {\r\n            Rule::BLOCK =\u003e Self::Block,\r\n\r\n            Rule::FUNCTION_ASSIGNMENT_STATEMENT =\u003e Self::FunctionAssignment,\r\n\r\n            Rule::SKIP_KEYWORD\r\n            | Rule::BREAK_KEYWORD\r\n            | Rule::RETURN_EXPRESSION\r\n            | Rule::SWITCH_EXPRESSION\r\n            | Rule::FOR_LOOP_EXPRESSION\r\n            | Rule::IF_EXPRESSION\r\n            | Rule::EXPR =\u003e Self::Expression,\r\n\r\n            Rule::symbol_questionmark =\u003e Self::Symbol(\"?\"),\r\n            Rule::symbol_colon =\u003e Self::Symbol(\":\"),\r\n            Rule::symbol_comma =\u003e Self::Symbol(\",\"),\r\n\r\n            Rule::symbol_opencurly =\u003e Self::Symbol(\"{\"),\r\n            Rule::symbol_closecurly =\u003e Self::Symbol(\"}\"),\r\n            Rule::array_symbol_opensquare =\u003e Self::Symbol(\"[\"),\r\n            Rule::symbol_opensquare =\u003e Self::Symbol(\"[\"),\r\n            Rule::symbol_closesquare =\u003e Self::Symbol(\"]\"),\r\n            Rule::symbol_arrow =\u003e Self::Symbol(\"=\u003e\"),\r\n            Rule::symbol_at =\u003e Self::Symbol(\"@\"),\r\n            Rule::symbol_eq =\u003e Self::Symbol(\"=\"),\r\n            Rule::EOL =\u003e Self::Symbol(\"EOL\"),\r\n\r\n            Rule::POSTFIX_EMPTYINDEX\r\n            | Rule::del_keyword\r\n            | Rule::POSTFIX_DECORATE\r\n            | Rule::POSTFIX_INDEX\r\n            | Rule::POSTFIX_CALL\r\n            | Rule::PREFIX_DEL\r\n            | Rule::PREFIX_BOOL_NOT\r\n            | Rule::PREFIX_BIT_NOT\r\n            | Rule::PREFIX_NEG\r\n            | Rule::PREFIX_INC\r\n            | Rule::PREFIX_DEC\r\n            | Rule::POSTFIX_INC\r\n            | Rule::POSTFIX_DEC\r\n            | Rule::OP_ASSIGN_ADD\r\n            | Rule::OP_ASSIGN_SUB\r\n            | Rule::OP_ASSIGN_POW\r\n            | Rule::OP_ASSIGN_MUL\r\n            | Rule::OP_ASSIGN_DIV\r\n            | Rule::OP_ASSIGN_MOD\r\n            | Rule::OP_BASSIGN_AND\r\n            | Rule::OP_BASSIGN_OR\r\n            | Rule::OP_ASSIGN_OR\r\n            | Rule::OP_ASSIGN_AND\r\n            | Rule::OP_ASSIGN_XOR\r\n            | Rule::OP_ASSIGN_SL\r\n            | Rule::OP_ASSIGN_SR\r\n            | Rule::OP_ASSIGN\r\n            | Rule::OP_BOOL_OR\r\n            | Rule::OP_BOOL_AND\r\n            | Rule::OP_BOOL_EQ\r\n            | Rule::OP_BOOL_NE\r\n            | Rule::OP_BOOL_LE\r\n            | Rule::OP_BOOL_GE\r\n            | Rule::OP_BOOL_LT\r\n            | Rule::OP_BOOL_GT\r\n            | Rule::OP_BIT_OR\r\n            | Rule::OP_BIT_XOR\r\n            | Rule::OP_BIT_AND\r\n            | Rule::OP_BIT_SL\r\n            | Rule::OP_BIT_SR\r\n            | Rule::OP_ADD\r\n            | Rule::OP_SUB\r\n            | Rule::OP_MUL\r\n            | Rule::OP_DIV\r\n            | Rule::OP_MOD\r\n            | Rule::OP_POW\r\n            | Rule::match_infix_op\r\n            | Rule::OP_MATCH_CONTAINS\r\n            | Rule::OP_MATCH_MATCHES\r\n            | Rule::OP_MATCH_IS\r\n            | Rule::OP_MATCH_STARTSWITH\r\n            | Rule::OP_MATCH_ENDSWITH\r\n            | Rule::OP_RANGE\r\n            | Rule::OP_CAST\r\n            | Rule::OP_TERNARY\r\n            | Rule::bool_infix_op\r\n            | Rule::bitwise_infix_op\r\n            | Rule::arithmetic_infix_op\r\n            | Rule::assignment_infix_op\r\n            | Rule::prefix_op\r\n            | Rule::prefix_arith\r\n            | Rule::postfix_arith\r\n            | Rule::KEYWORD_EXPRESSION\r\n            | Rule::postfix_operation\r\n            | Rule::postfixcall_args\r\n            | Rule::POSTFIX_NORMALMODE\r\n            | Rule::POSTFIX_OBJECTMODE\r\n            | Rule::infix_op =\u003e Self::Operator,\r\n\r\n            Rule::ARRAY_TERM =\u003e Self::Array,\r\n            Rule::OBJECT_TERM =\u003e Self::Object,\r\n\r\n            Rule::TERM\r\n            | Rule::ATOMIC_VALUE\r\n            | Rule::dec_literal\r\n            | Rule::hex_literal\r\n            | Rule::bin_literal\r\n            | Rule::oct_literal\r\n            | Rule::fixed_literal\r\n            | Rule::currency_literal\r\n            | Rule::sci_literal\r\n            | Rule::float_literal\r\n            | Rule::const_literal\r\n            | Rule::int_literal\r\n            | Rule::bool_literal\r\n            | Rule::string_literal\r\n            | Rule::regex_literal =\u003e Self::Literal,\r\n\r\n            Rule::identifier =\u003e Self::Identifier,\r\n\r\n            Rule::int_sep\r\n            | Rule::sized_literal_suffix\r\n            | Rule::intsize_u8\r\n            | Rule::intsize_i8\r\n            | Rule::intsize_u16\r\n            | Rule::intsize_i16\r\n            | Rule::intsize_u32\r\n            | Rule::intsize_i32\r\n            | Rule::intsize_u64\r\n            | Rule::intsize_i64 =\u003e Self::IntSizeSuffix,\r\n\r\n            Rule::currency_suffix | Rule::currency_symbol =\u003e Self::CurrencySymbol,\r\n\r\n            Rule::object_keyvalue_pair\r\n            | Rule::block_line\r\n            | Rule::for_conditional\r\n            | Rule::switch_case\r\n            | Rule::if_block\r\n            | Rule::function_typespec\r\n            | Rule::function_argument\r\n            | Rule::function_name\r\n            | Rule::SCRIPT\r\n            | Rule::reserved_words\r\n            | Rule::ERROR\r\n            | Rule::UNTERMINATED_BLOCK_COMMENT\r\n            | Rule::UNTERMINATED_STRING_LITERAL\r\n            | Rule::UNCLOSED_BRACKET\r\n            | Rule::UNCLOSED_BRACE\r\n            | Rule::UNCLOSED_PAREN\r\n            | Rule::MISSING_LINEBREAK\r\n            | Rule::EOI\r\n            | Rule::LINE\r\n            | Rule::INLINE_COMMENT\r\n            | Rule::BLOCK_COMMENT\r\n            | Rule::COMMENT\r\n            | Rule::WHITESPACE\r\n            | Rule::STATEMENT =\u003e Self::Hidden,\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":210},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":210},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":201},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":4699},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":4699},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":3960},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":739},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":121},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":121},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":116},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":460},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":460},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":442},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":442},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":372},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":281,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":318,"address":[],"length":0,"stats":{"Line":16},"fn_name":null}],"covered":46,"coverable":83},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","functions","compiler_cache.rs"],"content":"use crate::{pest, Error, Node};\r\nuse once_cell::sync::OnceCell;\r\nuse std::cell::RefCell;\r\nuse std::collections::hash_map::Entry;\r\nuse std::collections::HashMap;\r\nuse std::rc::Rc;\r\n\r\n// A cache of pre-compiled user function bodies\r\nthread_local! {\r\n    static USER_FUNCTION_CACHE: OnceCell\u003cRefCell\u003cHashMap\u003cString, Rc\u003cNode\u003e\u003e\u003e\u003e = OnceCell::new();\r\n}\r\n\r\npub fn cached_fn_compile(src: \u0026'i str, line_offset: usize) -\u003e Result\u003cRc\u003cNode\u003c'i\u003e\u003e, Error\u003e {\r\n    USER_FUNCTION_CACHE.with(|once_lock| {\r\n        let rt_mut = once_lock.get_or_init(|| RefCell::new(HashMap::new()));\r\n        let mut cache = rt_mut.borrow_mut();\r\n\r\n        match cache.entry(src.to_string()) {\r\n            Entry::Occupied(o) =\u003e Ok(o.get().clone()),\r\n            Entry::Vacant(v) =\u003e {\r\n                let mut node = pest::parse_input(src, pest::Rule::EXPR)?;\r\n                node.token_offsetline(line_offset);\r\n                Ok(v.insert(Rc::new(node)).clone())\r\n            }\r\n        }\r\n    })\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","functions","documentation.rs"],"content":"/// Documentation for a function\r\npub trait FunctionDocumentation: core::fmt::Debug {\r\n    /// Clone the documentation\r\n    fn clone_self(\u0026self) -\u003e Box\u003cdyn FunctionDocumentation\u003e;\r\n\r\n    /// The category of the function\r\n    fn category(\u0026self) -\u003e \u0026str;\r\n\r\n    /// Set the category of the function\r\n    fn set_category(\u0026mut self, category: \u0026str);\r\n\r\n    /// The description of the function\r\n    fn description(\u0026self) -\u003e Option\u003c\u0026str\u003e;\r\n\r\n    /// Set the description of the function\r\n    fn set_description(\u0026mut self, description: Option\u003c\u0026str\u003e);\r\n\r\n    /// The extended description of the function\r\n    fn ext_description(\u0026self) -\u003e Option\u003c\u0026str\u003e;\r\n\r\n    /// Set the extended description of the function\r\n    fn set_ext_description(\u0026mut self, ext_description: Option\u003c\u0026str\u003e);\r\n\r\n    /// The examples of the function\r\n    fn examples(\u0026self) -\u003e Option\u003c\u0026str\u003e;\r\n\r\n    /// Set the examples of the function\r\n    fn set_examples(\u0026mut self, examples: Option\u003c\u0026str\u003e);\r\n}\r\n\r\n/// Documentation for a function\r\n#[derive(Debug, Clone, Copy)]\r\npub struct StaticFunctionDocumentation {\r\n    /// The category of the function\r\n    pub category: \u0026'static str,\r\n\r\n    /// The description of the function\r\n    pub description: Option\u003c\u0026'static str\u003e,\r\n\r\n    /// The extended description of the function\r\n    pub ext_description: Option\u003c\u0026'static str\u003e,\r\n\r\n    /// The examples for the function\r\n    pub examples: Option\u003c\u0026'static str\u003e,\r\n}\r\nimpl FunctionDocumentation for StaticFunctionDocumentation {\r\n    fn clone_self(\u0026self) -\u003e Box\u003cdyn FunctionDocumentation\u003e {\r\n        Box::new(*self)\r\n    }\r\n\r\n    fn category(\u0026self) -\u003e \u0026str {\r\n        self.category\r\n    }\r\n    fn description(\u0026self) -\u003e Option\u003c\u0026str\u003e {\r\n        self.description\r\n    }\r\n    fn ext_description(\u0026self) -\u003e Option\u003c\u0026str\u003e {\r\n        self.ext_description\r\n    }\r\n    fn examples(\u0026self) -\u003e Option\u003c\u0026str\u003e {\r\n        self.examples\r\n    }\r\n\r\n    fn set_category(\u0026mut self, _: \u0026str) {}\r\n    fn set_description(\u0026mut self, _: Option\u003c\u0026str\u003e) {}\r\n    fn set_ext_description(\u0026mut self, _: Option\u003c\u0026str\u003e) {}\r\n    fn set_examples(\u0026mut self, _: Option\u003c\u0026str\u003e) {}\r\n}\r\n\r\n/// Documentation for a function\r\n#[derive(Debug, Clone)]\r\npub struct UserFunctionDocumentation {\r\n    /// The category of the function\r\n    pub category: String,\r\n\r\n    /// The description of the function\r\n    pub description: Option\u003cString\u003e,\r\n\r\n    /// The extended description of the function\r\n    pub ext_description: Option\u003cString\u003e,\r\n\r\n    /// The examples for the function\r\n    pub examples: Option\u003cString\u003e,\r\n}\r\nimpl FunctionDocumentation for UserFunctionDocumentation {\r\n    fn clone_self(\u0026self) -\u003e Box\u003cdyn FunctionDocumentation\u003e {\r\n        Box::new(self.clone())\r\n    }\r\n\r\n    fn category(\u0026self) -\u003e \u0026str {\r\n        \u0026self.category\r\n    }\r\n    fn set_category(\u0026mut self, category: \u0026str) {\r\n        self.category = category.to_string();\r\n    }\r\n\r\n    fn description(\u0026self) -\u003e Option\u003c\u0026str\u003e {\r\n        self.description.as_deref()\r\n    }\r\n    fn set_description(\u0026mut self, description: Option\u003c\u0026str\u003e) {\r\n        self.description = description.map(|s| s.to_string());\r\n    }\r\n\r\n    fn ext_description(\u0026self) -\u003e Option\u003c\u0026str\u003e {\r\n        self.ext_description.as_deref()\r\n    }\r\n    fn set_ext_description(\u0026mut self, ext_description: Option\u003c\u0026str\u003e) {\r\n        self.ext_description = ext_description.map(|s| s.to_string());\r\n    }\r\n\r\n    fn examples(\u0026self) -\u003e Option\u003c\u0026str\u003e {\r\n        self.examples.as_deref()\r\n    }\r\n    fn set_examples(\u0026mut self, examples: Option\u003c\u0026str\u003e) {\r\n        self.examples = examples.map(|s| s.to_string());\r\n    }\r\n}\r\n","traces":[{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":3780},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":3780},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":153},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":153},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":153},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":153},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":259},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":259},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":3},"fn_name":null}],"covered":22,"coverable":32},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","functions","macros.rs"],"content":"/// This macro defines a standard function and registers it with the standard library of functions.\r\n/// The standard function is a function that takes multiple arguments and returns a value.\r\n///\r\n/// # Usage\r\n/// ```rust\r\n/// use lavendeux_parser::{define_stdfunction, required_arg};\r\n/// define_stdfunction!(\r\n///     add { a: Standard::Numeric, b: Standard::Numeric },\r\n///     returns = Numeric,\r\n///     docs = {\r\n///         category: \"Math\",\r\n///         description: \"Addition\",\r\n///         ext_description: \"Adds two numbers together.\",\r\n///         examples: \"\r\n///             assert_eq(\r\n///                 add(2, 3),\r\n///                 5\r\n///             )\r\n///         \"\r\n///     },\r\n///     handler = (state, reference) {\r\n///         let a = required_arg!(state::a).as_a::\u003ci64\u003e()?;\r\n///         let b = required_arg!(state::b).as_a::\u003ci64\u003e()?;\r\n///         Ok((a + b).into())\r\n///     }\r\n/// );\r\n/// ```\r\n///\r\n/// # Arguments\r\n/// - `$name:ident`: The name of the function.\r\n/// - `$aname:ident : $meta:ident::$atype:ident`: The arguments of the function, where `$aname` is the argument name, `$meta` is how to process the argument (Standard, Optional or Plural), and `$atype` is the argument value type (See [polyvalue::ValueType]).\r\n/// - `returns = $return:ident`: The return value type of the function. See [polyvalue::ValueType].\r\n/// - `docs = { ... }`: The documentation for the function, including the category name, description, extended description, and examples.\r\n/// - `handler = $handler:expr`: The handler function that implements the logic of the function.\r\n#[macro_export]\r\nmacro_rules! define_stdfunction {\r\n    (\r\n        $name:ident { $($aname:ident : $meta:ident::$atype:ident),* },\r\n        returns = $return:ident,\r\n        docs = {\r\n            category: $category:literal,\r\n            description: $description:expr,\r\n            ext_description: $ext_description:literal,\r\n            examples: $examples:literal$(,)?\r\n        },\r\n        handler = ($hndstate:ident, $hndref:ident) $handler:block$(,)?\r\n    ) =\u003e {\r\n        paste::paste! {\r\n            #[allow(non_camel_case_types)]\r\n            #[derive(Debug, Copy, Clone)]\r\n            pub struct [\u003c_stdlibfn_$name\u003e];\r\n            impl [\u003c_stdlibfn_$name\u003e] {\r\n                const NAME: \u0026'static str = stringify!($name);\r\n\r\n                const DOCS: $crate::functions::StaticFunctionDocumentation = $crate::functions::StaticFunctionDocumentation {\r\n                    category: $category,\r\n                    description: Some($description),\r\n                    ext_description: Some(indoc::indoc! { $ext_description }),\r\n                    examples: Some(indoc::indoc! { $examples })\r\n                };\r\n                const ARGUMENTS: \u0026'static [(\u0026'static str, $crate::functions::FunctionArgument)] = \u0026[$(\r\n                    (stringify!($aname), $crate::functions::FunctionArgument {\r\n                        expected_type: $crate::polyvalue::ValueType::$atype,\r\n                        meta: $crate::functions::FunctionArgumentType::$meta\r\n                    })\r\n                ),*];\r\n\r\n                pub fn new() -\u003e Self {\r\n                    Self\r\n                }\r\n            }\r\n\r\n            impl $crate::functions::ParserFunction for [\u003c_stdlibfn_$name\u003e] {\r\n                fn name(\u0026self) -\u003e \u0026str {\r\n                    Self::NAME\r\n                }\r\n\r\n                fn is_readonly(\u0026self) -\u003e bool {\r\n                    true\r\n                }\r\n\r\n                fn documentation(\u0026self) -\u003e \u0026dyn $crate::functions::FunctionDocumentation {\r\n                    \u0026Self::DOCS\r\n                }\r\n\r\n                fn documentation_mut(\u0026mut self) -\u003e \u0026mut dyn $crate::functions::FunctionDocumentation {\r\n                    unimplemented!()\r\n                }\r\n\r\n                fn return_type(\u0026self) -\u003e $crate::polyvalue::ValueType {\r\n                    $crate::polyvalue::ValueType::$return\r\n                }\r\n\r\n                fn expected_arguments(\u0026self) -\u003e Vec\u003c(std::borrow::Cow\u003c'static, str\u003e, $crate::functions::FunctionArgument)\u003e {\r\n                    Self::ARGUMENTS\r\n                        .iter()\r\n                        .copied()\r\n                        .map(|(name, arg)| (std::borrow::Cow::Borrowed(name), arg))\r\n                        .collect()\r\n                }\r\n\r\n                fn clone_self(\u0026self) -\u003e Box\u003cdyn $crate::functions::ParserFunction\u003e {\r\n                    Box::new(Self::new())\r\n                }\r\n\r\n                fn call(\u0026self, $hndstate: \u0026mut $crate::State, $hndref: Option\u003c\u0026$crate::AssignmentTarget\u003e) -\u003e Result\u003c$crate::polyvalue::Value, $crate::Error\u003e $handler\r\n            }\r\n\r\n            inventory::submit! {\r\n                \u0026[\u003c_stdlibfn_$name\u003e] as \u0026'static dyn $crate::functions::ParserFunction\r\n            }\r\n        }\r\n    };\r\n}\r\n\r\n/// Defines a decorator function and registers it with the standard library of functions.\r\n/// The decorator function is a function that takes a single argument and returns a string.\r\n///\r\n/// # Usage\r\n/// ```rust\r\n/// use lavendeux_parser::{define_stddecorator};\r\n/// define_stddecorator!(\r\n///     upper { input: String },\r\n///     docs = {\r\n///         description: \"Uppercase\",\r\n///         ext_description: \"Converts the input string to uppercase.\",\r\n///         examples: \"\r\n///             assert_eq(\r\n///                 'hello' @upper,\r\n///                 'HELLO'\r\n///             )\r\n///         \"\r\n///     },\r\n///     handler = (input) {\r\n///         Ok(input.as_a::\u003cString\u003e()?.to_uppercase())\r\n///     }\r\n/// );\r\n/// ```\r\n///\r\n/// # Arguments\r\n/// - `$name:ident`: The name of the function.\r\n/// - `$aname:ident : $atype:ident`: The argument of the function, where `$aname` is the argument name and `$atype` is the argument value type (See [polyvalue::ValueType]).\r\n/// - `docs = { ... }`: The documentation for the function, including the category name, description, extended description, and examples.\r\n/// - `handler = $handler:expr`: The handler function that implements the logic of the function.\r\n#[macro_export]\r\nmacro_rules! define_stddecorator {\r\n    (\r\n        $name:ident { $aname:ident : $atype:ident },\r\n        docs = {\r\n            description: $description:expr,\r\n            ext_description: $ext_description:literal,\r\n            examples: $examples:literal$(,)?\r\n        },\r\n        handler = ($hndval:ident) $handler:block$(,)?\r\n    ) =\u003e {\r\n        paste::paste! {\r\n            #[allow(non_camel_case_types)]\r\n            #[derive(Debug, Copy, Clone)]\r\n            pub struct [\u003c_stdlibfn_dec_$name\u003e];\r\n            impl [\u003c_stdlibfn_dec_$name\u003e] {\r\n                const NAME: \u0026'static str = concat!(\"@\", stringify!($name));\r\n\r\n                const DOCS: $crate::functions::StaticFunctionDocumentation = $crate::functions::StaticFunctionDocumentation {\r\n                    category: \"Decorators\",\r\n                    description: Some($description),\r\n                    ext_description: Some(indoc::indoc! { $ext_description }),\r\n                    examples: Some(indoc::indoc! { $examples })\r\n                };\r\n                const ARGUMENTS: \u0026'static [(\u0026'static str, $crate::functions::FunctionArgument)] = \u0026[\r\n                    (stringify!($aname), $crate::functions::FunctionArgument {\r\n                        expected_type: $crate::polyvalue::ValueType::$atype,\r\n                        meta: $crate::functions::FunctionArgumentType::Standard\r\n                    })\r\n                ];\r\n\r\n                pub fn new() -\u003e Self {\r\n                    Self\r\n                }\r\n            }\r\n\r\n            impl $crate::functions::ParserFunction for [\u003c_stdlibfn_dec_$name\u003e] {\r\n                fn name(\u0026self) -\u003e \u0026str {\r\n                    Self::NAME\r\n                }\r\n\r\n                fn is_readonly(\u0026self) -\u003e bool {\r\n                    true\r\n                }\r\n\r\n                fn documentation(\u0026self) -\u003e \u0026 dyn $crate::functions::FunctionDocumentation {\r\n                    \u0026Self::DOCS\r\n                }\r\n\r\n                fn documentation_mut(\u0026mut self) -\u003e \u0026mut dyn $crate::functions::FunctionDocumentation {\r\n                    unimplemented!()\r\n                }\r\n\r\n                fn return_type(\u0026self) -\u003e $crate::polyvalue::ValueType {\r\n                    $crate::polyvalue::ValueType::String\r\n                }\r\n\r\n                fn expected_arguments(\u0026self) -\u003e Vec\u003c(std::borrow::Cow\u003c'static, str\u003e, $crate::functions::FunctionArgument)\u003e {\r\n                    Self::ARGUMENTS\r\n                        .iter()\r\n                        .copied()\r\n                        .map(|(name, arg)| (std::borrow::Cow::Borrowed(name), arg))\r\n                        .collect()\r\n                }\r\n\r\n                fn clone_self(\u0026self) -\u003e Box\u003cdyn $crate::functions::ParserFunction\u003e {\r\n                    Box::new(Self::new())\r\n                }\r\n\r\n                fn call(\u0026self, state: \u0026mut $crate::State, _: Option\u003c\u0026$crate::AssignmentTarget\u003e) -\u003e Result\u003c$crate::polyvalue::Value, $crate::Error\u003e {\r\n                    let $hndval = $crate::required_arg!(state::$aname);\r\n                    let value: Result\u003cString, $crate::Error\u003e = $handler;\r\n                    Ok(value?.into())\r\n                }\r\n            }\r\n\r\n            inventory::submit! {\r\n                \u0026[\u003c_stdlibfn_dec_$name\u003e] as \u0026'static dyn $crate::functions::ParserFunction\r\n            }\r\n        }\r\n    };\r\n}\r\n\r\n/// Extracts a required argument from the state and returns it. If the argument is not found, it returns an error.\r\n/// Use it like `required_arg!(state::name)`.\r\n#[macro_export]\r\nmacro_rules! required_arg {\r\n    ($state:ident :: $name:ident) =\u003e {\r\n        match $state.get_variable(stringify!($name)).cloned() {\r\n            Some(v) =\u003e v,\r\n            None =\u003e {\r\n                return $crate::oops!(Internal {\r\n                    msg: format!(\"Missing required argument: {}\", stringify!($name))\r\n                })\r\n            }\r\n        }\r\n    };\r\n}\r\n\r\n/// Extracts an optional argument from the state and returns it. If the argument is not found, it returns `None`.\r\n/// Use it like `optional_arg!(state::name)`.\r\n#[macro_export]\r\nmacro_rules! optional_arg {\r\n    ($state:ident :: $name:ident) =\u003e {\r\n        $state.get_variable(stringify!($name)).cloned()\r\n    };\r\n}\r\n","traces":[{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":6569},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":6569},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":19938},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":19938},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":3691},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":3691},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":489},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":489},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":845},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":845},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":845},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":845},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":1690},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":845},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":6569},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":6569},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":1162},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":1162},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":4832},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":4832},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":654},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":654},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":64},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":64},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":64},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":64},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":128},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":64},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":1162},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":1162},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":44},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":44},"fn_name":null}],"covered":36,"coverable":46},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","functions","mod.rs"],"content":"mod std_function;\r\nmod user_function;\r\n\r\n#[macro_use]\r\nmod macros;\r\n\r\nmod documentation;\r\npub use documentation::*;\r\n\r\npub use std_function::{FunctionArgument, FunctionArgumentType, ParserFunction};\r\npub use user_function::UserDefinedFunction;\r\n\r\n/// The standard library of functions\r\n/// Loaded by the state by default\r\npub mod stdlib;\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","functions","std_function.rs"],"content":"use std::borrow::Cow;\r\n\r\nuse crate::{syntax_tree::AssignmentTarget, Error, State};\r\nuse polyvalue::{Value, ValueType};\r\n\r\nuse super::FunctionDocumentation;\r\n\r\n/// A function argument type\r\n#[derive(Debug, Copy, Clone)]\r\npub enum FunctionArgumentType {\r\n    /// Normal argument\r\n    Standard,\r\n    /// 0-or-more of\r\n    Plural,\r\n    /// 0-or-1 of\r\n    Optional,\r\n}\r\n\r\n/// A function argument\r\n#[derive(Debug, Copy, Clone)]\r\npub struct FunctionArgument {\r\n    /// Type condition to enforce\r\n    pub expected_type: ValueType,\r\n\r\n    /// How to parse the argument\r\n    pub meta: FunctionArgumentType,\r\n}\r\n\r\nimpl FunctionArgument {\r\n    /// Returns true if the argument can be skipped on type errors or missing values\r\n    pub fn is_optional(\u0026self) -\u003e bool {\r\n        !matches!(self.meta, FunctionArgumentType::Standard)\r\n    }\r\n\r\n    /// Returns true if the argument should consume 0 or more args until a non-matching type is found\r\n    pub fn is_plural(\u0026self) -\u003e bool {\r\n        matches!(self.meta, FunctionArgumentType::Plural)\r\n    }\r\n}\r\n\r\npub trait ManageArguments {\r\n    fn arg_count_span(\u0026self) -\u003e (usize, usize);\r\n    fn map_arguments(\r\n        \u0026self,\r\n        values: \u0026[Value],\r\n        state: \u0026mut State,\r\n        function_signature: String,\r\n    ) -\u003e Result\u003c(), Error\u003e;\r\n}\r\nimpl ManageArguments for Vec\u003c(Cow\u003c'_, str\u003e, FunctionArgument)\u003e {\r\n    fn arg_count_span(\u0026self) -\u003e (usize, usize) {\r\n        let (mut min, mut max) = (0, 0);\r\n        for (_, arg) in self.iter() {\r\n            if !arg.is_optional() {\r\n                min += 1;\r\n            }\r\n            max += 1;\r\n        }\r\n        (min, max)\r\n    }\r\n\r\n    fn map_arguments(\r\n        \u0026self,\r\n        values: \u0026[Value],\r\n        state: \u0026mut State,\r\n        function_signature: String,\r\n    ) -\u003e Result\u003c(), Error\u003e {\r\n        let mut values = values.iter().peekable();\r\n\r\n        for (i, (name, arg)) in self.iter().enumerate() {\r\n            let next = values.next();\r\n            if next.is_none() \u0026\u0026 !arg.is_optional() {\r\n                let span = self.arg_count_span();\r\n                return oops!(FunctionArguments {\r\n                    min: span.0,\r\n                    max: span.1,\r\n                    signature: function_signature\r\n                });\r\n            } else if next.is_none() {\r\n                continue;\r\n            }\r\n\r\n            let next = next.unwrap().clone().as_type(arg.expected_type);\r\n            if next.is_err() {\r\n                if arg.is_optional() {\r\n                    continue;\r\n                } else {\r\n                    return oops!(FunctionArgumentType {\r\n                        arg: i + 1,\r\n                        expected_type: arg.expected_type,\r\n                        signature: function_signature\r\n                    });\r\n                }\r\n            }\r\n            let next = next.unwrap();\r\n\r\n            if arg.is_plural() {\r\n                let mut matches = Vec::new();\r\n                matches.push(next);\r\n                while let Some(next) = values.peek() {\r\n                    if next.is_a(arg.expected_type) {\r\n                        matches.push(values.next().unwrap().clone());\r\n                    } else {\r\n                        break;\r\n                    }\r\n                }\r\n                state.set_variable(name, Value::array(matches));\r\n            } else {\r\n                state.set_variable(name, next);\r\n            }\r\n        }\r\n\r\n        if values.next().is_some() {\r\n            let span = self.arg_count_span();\r\n            return oops!(FunctionArguments {\r\n                min: span.0,\r\n                max: span.1,\r\n                signature: function_signature\r\n            });\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n}\r\n\r\n/// Object trait used for parser functions\r\npub trait ParserFunction\r\nwhere\r\n    Self: Send + Sync + std::fmt::Debug,\r\n{\r\n    /// Name of the function\r\n    fn name(\u0026self) -\u003e \u0026str;\r\n\r\n    /// Return type of the function\r\n    fn return_type(\u0026self) -\u003e ValueType;\r\n\r\n    /// Expected arguments for the function\r\n    fn expected_arguments(\u0026self) -\u003e Vec\u003c(Cow\u003c'static, str\u003e, FunctionArgument)\u003e;\r\n\r\n    /// Clones the function\r\n    fn clone_self(\u0026self) -\u003e Box\u003cdyn ParserFunction\u003e;\r\n\r\n    /// Identifies system functions that should not be overridden by user functions\r\n    fn is_readonly(\u0026self) -\u003e bool {\r\n        false\r\n    }\r\n\r\n    /// Documentation for the function\r\n    fn documentation(\u0026self) -\u003e \u0026dyn FunctionDocumentation;\r\n\r\n    /// Mutable version of documentation\r\n    fn documentation_mut(\u0026mut self) -\u003e \u0026mut dyn FunctionDocumentation;\r\n\r\n    /// Call the function's handler - use exec instead to map arguments first\r\n    fn call(\u0026self, state: \u0026mut State, reference: Option\u003c\u0026AssignmentTarget\u003e)\r\n        -\u003e Result\u003cValue, Error\u003e;\r\n\r\n    /// Loads the arguments into the state\r\n    fn load_arguments(\u0026self, values: \u0026[Value], state: \u0026mut State) -\u003e Result\u003c(), Error\u003e {\r\n        match self\r\n            .expected_arguments()\r\n            .map_arguments(values, state, self.signature())\r\n        {\r\n            Ok(_) =\u003e Ok(()),\r\n            Err(e) =\u003e {\r\n                state.scope_out();\r\n                Err(e)\r\n            }\r\n        }\r\n    }\r\n\r\n    /// Returns the function signature\r\n    fn signature(\u0026self) -\u003e String {\r\n        format!(\r\n            \"{}({}) -\u003e {}\",\r\n            self.name(),\r\n            self.expected_arguments()\r\n                .iter()\r\n                .map(|(name, arg)| {\r\n                    let type_name = if arg.expected_type == ValueType::Any {\r\n                        \"\".to_string()\r\n                    } else {\r\n                        format!(\":{}\", arg.expected_type)\r\n                    };\r\n                    (if arg.is_optional() {\r\n                        format!(\"[{}{}]\", name, type_name)\r\n                    } else {\r\n                        format!(\"{}{}\", name, type_name)\r\n                    } + if arg.is_plural() { \", ...\" } else { \"\" })\r\n                })\r\n                .collect::\u003cVec\u003cString\u003e\u003e()\r\n                .join(\", \"),\r\n            self.return_type(),\r\n        )\r\n    }\r\n\r\n    /// Executes the function with the given values\r\n    /// Values are checked mapped into the state into a new scope\r\n    /// arg1_references is used to add a pass-by-reference flag to the first argument\r\n    fn exec(\r\n        \u0026self,\r\n        values: \u0026[Value],\r\n        state: \u0026mut State,\r\n        reference: Option\u003c\u0026AssignmentTarget\u003e,\r\n    ) -\u003e Result\u003cValue, Error\u003e {\r\n        state.scope_into()?;\r\n        state.lock_scope();\r\n        self.load_arguments(values, state)?;\r\n\r\n        let result = self.call(state, reference);\r\n        state.scope_out();\r\n\r\n        result\r\n    }\r\n}\r\n","traces":[{"line":31,"address":[],"length":0,"stats":{"Line":832},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":859},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":1438},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":2876},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":383},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":383},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":1001},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":618},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":623},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":618},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":613},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":613},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":612},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":612},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":612},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":383},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":383},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":383},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":383},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":383},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":383},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":383},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":545},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":545},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":545},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":545},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":545},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":1371},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":1652},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":409},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":417},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":805},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":1652},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":545},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":545},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":545},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":383},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":383},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":383},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":383},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":383},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":383},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":383},"fn_name":null}],"covered":49,"coverable":81},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","functions","stdlib","bitwise.rs"],"content":"use crate::define_stdfunction;\r\nuse polyvalue::{\r\n    operations::{BitwiseOperation, BitwiseOperationExt},\r\n    types::I64,\r\n    InnerValue,\r\n};\r\n\r\nmacro_rules! define_standard_bitwise_fn {\r\n    ($operation:ident, $examples:literal, $bitwise_op:ident) =\u003e {\r\n        define_stdfunction!(\r\n            $operation {\r\n                left: Standard::Int,\r\n                right: Standard::Int\r\n            },\r\n            returns = Int,\r\n            docs = {\r\n                category: \"Bitwise\",\r\n                description: concat!(\"Performs a bitwise \", stringify!($operation), \" operation on two integers\"),\r\n                ext_description: \"\r\n                    Floats and Fixed-point numbers will be truncated to integers before the operation is performed.\r\n                \",\r\n                examples: $examples,\r\n            },\r\n            handler = (state, _reference) {\r\n                let left = required_arg!(state::left);\r\n                let right = required_arg!(state::right);\r\n                Ok(left.bitwise_op(right, BitwiseOperation::$bitwise_op)?)\r\n            },\r\n        );\r\n    };\r\n}\r\n\r\ndefine_standard_bitwise_fn!(xor, \"assert_eq(0b1010, xor(0b1100, 0b0110))\", Xor);\r\ndefine_standard_bitwise_fn!(and, \"assert_eq(0b0100, and(0b1100, 0b0110))\", And);\r\ndefine_standard_bitwise_fn!(or, \"assert_eq(0b1110, or(0b1100, 0b0110))\", Or);\r\n\r\ndefine_stdfunction!(\r\n    not {\r\n        value: Standard::Int\r\n    },\r\n    returns = Int,\r\n    docs = {\r\n        category: \"Bitwise\",\r\n        description: \"Performs a bitwise NOT operation on an integer\",\r\n        ext_description: \"\r\n            Floats and Fixed-point numbers will be truncated to integers before the operation is performed.\r\n        \",\r\n        examples: \"\r\n            assert_eq(0b1111_1111u8, not(0b0000_0000u8))\r\n        \",\r\n    },\r\n    handler = (state, _reference) {\r\n        let value = required_arg!(state::value);\r\n        Ok(value.bitwise_not()?)\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    llshift {\r\n        value: Standard::Int,\r\n        shift: Standard::Int\r\n    },\r\n    returns = Int,\r\n    docs = {\r\n        category: \"Bitwise\",\r\n        description: \"Performs a logical bitwise left shift operation on an integer\",\r\n        ext_description: \"\r\n            Floats and Fixed-point numbers will be truncated to integers before the operation is performed.\r\n            Will always ignore the sign bit.\r\n        \",\r\n        examples: \"\r\n            assert_eq(\r\n                0b1000_0010i8,\r\n                llshift(0b0100_0001i8, 1)\r\n            )\r\n        \",\r\n    },\r\n    handler = (state, _reference) {\r\n        let value = required_arg!(state::value);\r\n        let shift = required_arg!(state::shift).as_a::\u003ci32\u003e()?;\r\n\r\n        Ok(match value.inner() {\r\n            InnerValue::U8(v) =\u003e v.logical_lshift(shift)?.into(),\r\n            InnerValue::U16(v) =\u003e v.logical_lshift(shift)?.into(),\r\n            InnerValue::U32(v) =\u003e v.logical_lshift(shift)?.into(),\r\n            InnerValue::U64(v) =\u003e v.logical_lshift(shift)?.into(),\r\n            InnerValue::I8(v) =\u003e v.logical_lshift(shift)?.into(),\r\n            InnerValue::I16(v) =\u003e v.logical_lshift(shift)?.into(),\r\n            InnerValue::I32(v) =\u003e v.logical_lshift(shift)?.into(),\r\n            _ =\u003e {\r\n                let v = value.as_a::\u003cI64\u003e()?;\r\n                v.logical_lshift(shift)?.into()\r\n            }\r\n        })\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    lrshift {\r\n        value: Standard::Int,\r\n        shift: Standard::Int\r\n    },\r\n    returns = Int,\r\n    docs = {\r\n        category: \"Bitwise\",\r\n        description: \"Performs a logical bitwise right shift operation on an integer\",\r\n        ext_description: \"\r\n            Floats and Fixed-point numbers will be truncated to integers before the operation is performed.\r\n            Will always ignore the sign bit.\r\n        \",\r\n        examples: \"\r\n            assert_eq(\r\n                0b0100_0000i8,\r\n                lrshift(0b1000_0001i8, 1)\r\n            )\r\n        \",\r\n    },\r\n    handler = (state, _reference) {\r\n        let value = required_arg!(state::value);\r\n        let shift = required_arg!(state::shift).as_a::\u003ci32\u003e()?;\r\n\r\n        Ok(match value.inner() {\r\n            InnerValue::U8(v) =\u003e v.logical_rshift(shift)?.into(),\r\n            InnerValue::U16(v) =\u003e v.logical_rshift(shift)?.into(),\r\n            InnerValue::U32(v) =\u003e v.logical_rshift(shift)?.into(),\r\n            InnerValue::U64(v) =\u003e v.logical_rshift(shift)?.into(),\r\n            InnerValue::I8(v) =\u003e v.logical_rshift(shift)?.into(),\r\n            InnerValue::I16(v) =\u003e v.logical_rshift(shift)?.into(),\r\n            InnerValue::I32(v) =\u003e v.logical_rshift(shift)?.into(),\r\n            _ =\u003e {\r\n                let v = value.as_a::\u003cI64\u003e()?;\r\n                v.logical_rshift(shift)?.into()\r\n            }\r\n        })\r\n    },\r\n);\r\n","traces":[{"line":24,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":6},"fn_name":null}],"covered":85,"coverable":85},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","functions","stdlib","collections.rs"],"content":"use crate::{\r\n    define_stdfunction,\r\n    error::{ErrorDetails, WrapExternalError},\r\n};\r\nuse polyvalue::{\r\n    operations::{IndexingMutationExt, IndexingOperationExt},\r\n    types::{Array, Object},\r\n    Value, ValueType,\r\n};\r\n\r\n/**********************************************\r\n *\r\n * Array Metadata Functions\r\n *\r\n *********************************************/\r\n\r\ndefine_stdfunction!(\r\n    len { input: Standard::Any },\r\n    returns = Int,\r\n    docs = {\r\n        category: \"Collections\",\r\n        description: \"Returns the length of the given array or object\",\r\n        ext_description: \"\r\n            For arrays and objects, this function returns the number of elements in the array or object.\r\n            For strings, it returns the number of characters.\r\n            For all other types it will return 1\r\n        \",\r\n        examples: \"\r\n            assert_eq(len('test'),       4);\r\n            assert_eq(len([1, 2, 3]),    3);\r\n            assert_eq(len({'a': 1, 'b': 2}), 2);\r\n            assert_eq(len(38),           1);\r\n        \",\r\n    },\r\n    handler = (state, _reference) {\r\n        let input = required_arg!(state::input);\r\n        Ok(Value::i64(input.len() as i64))\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    is_empty { input: Standard::Any },\r\n    returns = Bool,\r\n    docs = {\r\n    category: \"Collections\",\r\n    description: \"Returns true if the given array or object is empty\",\r\n    ext_description: \"\r\n        For arrays and objects, this function returns true if the array or object has no elements.\r\n        For strings, it returns true if the string is empty.\r\n        For all other types it will return false\r\n    \",\r\n    examples: \"\r\n        assert_eq(is_empty([]),     true);\r\n        assert_eq(is_empty({}),     true);\r\n        assert_eq(is_empty('test'), false);\r\n        assert_eq(is_empty(38),     false);\r\n        \",\r\n    },\r\n    handler = (state, _reference) {\r\n        let input = required_arg!(state::input);\r\n        Ok(Value::bool(input.len() == 0))\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    first { input: Standard::Array },\r\n    returns = Any,\r\n    docs = {\r\n        category: \"Collections\",\r\n        description: \"Returns the first element of the given array\",\r\n        ext_description: \"\r\n            Coerces its argument to an array and returns the first element.\r\n            If the resulting array is empty, an error is returned.\r\n        \",\r\n        examples: \"\r\n            assert_eq(first([1, 2, 3]), 1);\r\n            assert_eq(first(3),         3); // equivalent to first([3])\r\n            \r\n            would_err('first([])'); // Array is empty, so an error is returned\r\n        \",\r\n    },\r\n    handler = (state, _reference) {\r\n        let input = required_arg!(state::input).as_a::\u003cArray\u003e()?;\r\n        input.first().cloned().ok_or(ErrorDetails::ArrayEmpty).without_context()\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    last { input: Standard::Array },\r\n    returns = Any,\r\n    docs = {\r\n        category: \"Collections\",\r\n        description: \"Returns the last element of the given array\",\r\n        ext_description: \"\r\n            Coerces its argument to an array and returns the last element.\r\n            If the resulting array is empty, an error is returned.\r\n        \",\r\n        examples: \"\r\n            assert_eq(last([1, 2, 3]), 3);\r\n            assert_eq(last(3),         3); // equivalent to last([3])\r\n\r\n            would_err('last([])'); // Array is empty, so an error is returned\r\n        \",\r\n    },\r\n    handler = (state, _reference) {\r\n        let input = required_arg!(state::input).as_a::\u003cArray\u003e()?;\r\n        input.last().cloned().ok_or(ErrorDetails::ArrayEmpty).without_context()\r\n    },\r\n);\r\n\r\n/**********************************************\r\n *\r\n * Array Manipulation Functions\r\n *\r\n *********************************************/\r\n\r\ndefine_stdfunction!(\r\n    pop { input: Standard::Array },\r\n    returns = Any,\r\n    docs = {\r\n        category: \"Collections\",\r\n        description: \"Removes and returns the last element of the given array\",\r\n        ext_description: \"\r\n            Removes the last element from the given array and returns it.\r\n            If the array is empty, an error is returned.\r\n            If the input is a reference to an array in a variable, the variable is updated.\r\n        \",\r\n        examples: \"\r\n            assert_eq(pop([1, 2, 3]), 3);\r\n            would_err('pop([]') // Array is empty, so an error is returned\r\n            \r\n            a = [1];\r\n            assert_eq(pop(a), 1);\r\n            assert_eq(a, []);\r\n        \",\r\n    },\r\n    handler = (state, reference) {\r\n        let input = required_arg!(state::input);\r\n        let input_type = input.own_type();\r\n        let mut input = input.as_a::\u003cArray\u003e()?.clone();\r\n        let value = input.pop().ok_or(ErrorDetails::ArrayEmpty).without_context()?;\r\n\r\n        // Update the array if it references a variable containing an array\r\n        if let Some(reference) = reference {\r\n            if input_type == ValueType::Array {\r\n                reference.update_value_in_parent(state, input.clone().into())?;\r\n            }\r\n        };\r\n\r\n        Ok(value)\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    push { input: Standard::Collection, value: Standard::Any },\r\n    returns = Array,\r\n    docs = {\r\n        category: \"Collections\",\r\n        description: \"Appends the given value to the end of the given collection, and returns the result\",\r\n        ext_description: \"\r\n            Appends the given value to the end of the given collection.\r\n            If the input is a reference to a collection in a variable, the variable is updated.\r\n        \",\r\n        examples: \"\r\n        assert_eq(push([1, 2], 3), [1, 2, 3]);\r\n        assert_eq(push([], 3), [3]);\r\n        \r\n        a = [1];\r\n        assert_eq(push(a, 2), [1, 2]);\r\n        assert_eq(a, [1, 2]);\r\n    \",\r\n    },\r\n    handler = (state, reference) {\r\n        let input = required_arg!(state::input);\r\n        let input_type = input.own_type();\r\n        let value = required_arg!(state::value);\r\n\r\n        match input_type {\r\n            ValueType::Array =\u003e {\r\n                let mut input = input.as_a::\u003cArray\u003e()?;\r\n                input.push(value.clone());\r\n\r\n                // Update the array if it references a variable containing an array\r\n                if let Some(reference) = reference {\r\n                    if let Some(target) = reference.get_target_mut_in_parent(state)? {\r\n                        *target = input.clone().into();\r\n                    }\r\n                };\r\n\r\n                Ok(input.into())\r\n            }\r\n\r\n            ValueType::String =\u003e {\r\n                let mut input = input.as_a::\u003cString\u003e()?;\r\n                input.push_str(\u0026value.to_string());\r\n\r\n                // Update the array if it references a variable containing an array\r\n                if let Some(reference) = reference {\r\n                    reference.update_value_in_parent(state, input.clone().into())?;\r\n                };\r\n\r\n                Ok(input.into())\r\n            }\r\n\r\n            _ =\u003e oops!(Custom {\r\n                msg: format!(\"cannot push to `{input_type}`\")\r\n            })\r\n        }\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    enqueue { input: Standard::Array, value: Standard::Any },\r\n    returns = Array,\r\n    docs = {\r\n        category: \"Collections\",\r\n        description: \"Appends the given value to the start of the given array, and returns the result\",\r\n        ext_description: \"\r\n            Appends the given value to the start of the given array.\r\n            If the input is a reference to an array in a variable, the variable is updated.\r\n            This function is less performant than `push` for large arrays, as it requires shifting all elements by one position.\r\n        \",\r\n        examples: \"\r\n            assert_eq(enqueue([1, 2], 3), [3, 1, 2])\r\n            assert_eq(enqueue([], 3), [3])\r\n            \r\n            a = [1]\r\n            assert_eq(enqueue(a, 2), [2, 1])\r\n            assert_eq(a, [2, 1])\r\n        \",\r\n    },\r\n    handler = (state, reference) {\r\n        let input = required_arg!(state::input);\r\n        let input_type = input.own_type();\r\n        let mut input = input.as_a::\u003cArray\u003e()?.clone();\r\n        let value = required_arg!(state::value).clone();\r\n\r\n        input.insert(0, value);\r\n\r\n        // Update the array if it references a variable containing an array\r\n        if let Some(reference) = reference {\r\n            if input_type == ValueType::Array {\r\n                reference.update_value_in_parent(state, input.clone().into())?;\r\n            }\r\n        };\r\n\r\n        Ok(input.into())\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    dequeue { input: Standard::Array },\r\n    returns = Array,\r\n    docs = {\r\n        category: \"Collections\",\r\n        description: \"Removes and returns the first element of the given array\",\r\n        ext_description: \"\r\n            Removes the first element from the given array and returns it.\r\n            If the array is empty, an error is returned.\r\n            If the input is a reference to an array in a variable, the variable is updated.\r\n            This function is less performant than `pop` for large arrays, as it requires shifting all elements by one position.\r\n        \",\r\n        examples: \"\r\n            assert_eq(dequeue([1, 2, 3]), 1);\r\n            would_err('dequeue([]') // Array is empty, so an error is returned\r\n            \r\n            a = [1, 2];\r\n            assert_eq(dequeue(a), 1);\r\n            assert_eq(a, [2]);\r\n        \",\r\n    },\r\n    handler = (state, reference) {\r\n        let input = required_arg!(state::input);\r\n        let input_type = input.own_type();\r\n        let mut input = input.as_a::\u003cArray\u003e()?.clone();\r\n        let value = input.remove(0).ok_or(ErrorDetails::ArrayEmpty).without_context()?;\r\n\r\n        // Update the array if it references a variable containing an array\r\n        if let Some(reference) = reference {\r\n            if input_type == ValueType::Array {\r\n                reference.update_value_in_parent(state, input.clone().into())?;\r\n            }\r\n        };\r\n\r\n        Ok(value)\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    insert {\r\n        input: Standard::Array,\r\n        index: Standard::Int,\r\n        value: Standard::Any\r\n    },\r\n    returns = Array,\r\n    docs = {\r\n        category: \"Collections\",\r\n        description: \"Inserts the given value at the given index in the given array, and returns the result\",\r\n        ext_description: \"\r\n            Inserts the given value at the given index in the given array.\r\n            If the input is a reference to an array in a variable, the variable is updated.\r\n            If the index is out of bounds, an error is returned.\r\n        \",\r\n        examples: \"\r\n            assert_eq(insert([1, 2, 3], 1, 4), [1, 4, 2, 3]);\r\n            assert_eq(insert([1, 2, 3], 3, 4), [1, 2, 3, 4]);\r\n            assert_eq(insert([1, 2, 3], 0, 4), [4, 1, 2, 3]);\r\n\r\n            would_err('insert([1, 2, 3], 4, 4)') // Index out of bounds\r\n            \r\n            a = [1, 2, 3];\r\n            assert_eq(insert(a, 1, 4), [1, 4, 2, 3]);\r\n            assert_eq(a, [1, 4, 2, 3]);\r\n        \",\r\n    },\r\n    handler = (state, reference) {\r\n        let input = required_arg!(state::input);\r\n        let input_type = input.own_type();\r\n        let mut input = input.as_a::\u003cArray\u003e()?.clone();\r\n\r\n        let index = required_arg!(state::index);\r\n        let value = required_arg!(state::value);\r\n\r\n        input.insert_at(\u0026index, value.clone())?;\r\n\r\n        // Update the array if it references a variable containing an array\r\n        if let Some(reference) = reference {\r\n            if input_type == ValueType::Array {\r\n                reference.update_value_in_parent(state, input.clone().into())?;\r\n            }\r\n        };\r\n\r\n        Ok(input.into())\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    remove {\r\n        input: Standard::Array,\r\n        index: Standard::Int\r\n    },\r\n    returns = Array,\r\n    docs = {\r\n        category: \"Collections\",\r\n        description: \"Removes the element at the given index in the given array, and returns value\",\r\n        ext_description: \"\r\n            Removes the element at the given index in the given array.\r\n            If the input is a reference to an array in a variable, the variable is updated.\r\n            If the index is out of bounds, an error is returned.\r\n        \",\r\n        examples: \"\r\n            assert_eq(remove([1, 2, 3], 1), 2);\r\n            assert_eq(remove([1, 2, 3], 2), 3);\r\n            assert_eq(remove([1, 2, 3], 0), 1);\r\n\r\n            would_err('remove([1, 2, 3], 3)') // Index out of bounds\r\n            \r\n            a = [1, 2, 3];\r\n            assert_eq(remove(a, 1), 2);\r\n            assert_eq(a, [1, 3]);\r\n        \",\r\n    },\r\n    handler = (state, reference) {\r\n        let input = required_arg!(state::input);\r\n        let input_type = input.own_type();\r\n        let mut input = input.as_a::\u003cArray\u003e()?.clone();\r\n\r\n        let index = required_arg!(state::index);\r\n\r\n        let removed = input.delete_index(\u0026index)?;\r\n\r\n        // Update the array if it references a variable containing an array\r\n        if let Some(reference) = reference {\r\n            if input_type == ValueType::Array {\r\n                reference.update_value_in_parent(state, input.clone().into())?;\r\n            }\r\n        };\r\n\r\n        Ok(removed)\r\n    },\r\n);\r\n\r\n/**********************************************\r\n *\r\n * Object Manipulation Functions\r\n *\r\n *********************************************/\r\n\r\ndefine_stdfunction!(\r\n    keys { input: Standard::Object },\r\n    returns = Array,\r\n    docs = {\r\n        category: \"Collections\",\r\n        description: \"Returns an array of the keys of the given object\",\r\n        ext_description: \"\r\n            Returns an array of the keys of the given object.\r\n            The order of the keys is not guaranteed.\r\n        \",\r\n        examples: \"\r\n            assert_eq(\r\n                keys({'a': 1, 'b': 2}).sort(),\r\n                ['a', 'b']\r\n            );\r\n            assert_eq(keys({}), []);\r\n        \",\r\n    },\r\n    handler = (state, _reference) {\r\n        let input = required_arg!(state::input).as_a::\u003cObject\u003e()?;\r\n        Ok(Value::from(\r\n            input.keys().iter().cloned().cloned().collect::\u003cVec\u003c_\u003e\u003e()\r\n        ))\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    values { input: Standard::Object },\r\n    returns = Array,\r\n    docs = {\r\n        category: \"Collections\",\r\n        description: \"Returns an array of the values of the given object\",\r\n        ext_description: \"\r\n            Returns an array of the values of the given object.\r\n            The order of the values is not guaranteed.\r\n        \",\r\n        examples: \"\r\n            assert_eq(\r\n                values({'a': 1, 'b': 2}).sort(), \r\n                [1, 2]\r\n            );\r\n            assert_eq(values({}), []);\r\n        \",\r\n    },\r\n    handler = (state, _reference) {\r\n        let input = required_arg!(state::input).as_a::\u003cObject\u003e()?;\r\n        Ok(Value::from(\r\n            input.values().iter().cloned().cloned().collect::\u003cVec\u003c_\u003e\u003e()\r\n        ))\r\n    },\r\n);\r\n\r\n/**********************************************\r\n *\r\n * Array Query Functions\r\n *\r\n *********************************************/\r\n\r\ndefine_stdfunction!(\r\n    all { input: Standard::Array },\r\n    returns = Bool,\r\n    docs = {\r\n        category: \"Collections\",\r\n        description: \"Returns true if all elements of the given array are truthy\",\r\n        ext_description: \"\r\n            Returns true if all elements of the given array evaluate to true.\r\n            If the array is empty, true is returned.\r\n        \",\r\n        examples: \"\r\n            assert_eq(all([true, true, true]), true);\r\n            assert_eq(all([0, 1, 2]), false);\r\n            assert_eq(all([]), true);\r\n        \",\r\n    },\r\n    handler = (state, _reference) {\r\n        let input = required_arg!(state::input).as_a::\u003cArray\u003e()?;\r\n        Ok(Value::bool(input.iter().all(|v| v.is_truthy())))\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    any { input: Standard::Array },\r\n    returns = Bool,\r\n    docs = {\r\n        category: \"Collections\",\r\n        description: \"Returns true if any element of the given array is truthy\",\r\n        ext_description: \"\r\n            Returns true if any element of the given array evaluates to true.\r\n            If the array is empty, false is returned.\r\n        \",\r\n        examples: \"\r\n            assert_eq(any([true, true, true]), true);\r\n            assert_eq(any([0, 1, 2]), true);\r\n            assert_eq(any([]), false);\r\n        \",\r\n    },\r\n    handler = (state, _reference) {\r\n        let input = required_arg!(state::input).as_a::\u003cArray\u003e()?;\r\n        Ok(Value::bool(input.iter().any(|v| v.is_truthy())))\r\n    },\r\n);\r\n\r\n/**********************************************\r\n *\r\n * Array Combinators\r\n *\r\n *********************************************/\r\n\r\n// sort, reverse\r\n\r\ndefine_stdfunction!(\r\n    split {\r\n        input: Standard::Array,\r\n        index: Standard::Int\r\n    },\r\n    returns = Array,\r\n    docs = {\r\n        category: \"Collections\",\r\n        description: \"Splits the given array at the given index, and returns the two resulting arrays\",\r\n        ext_description: \"\r\n            If the index is out of bounds, an error is returned.\r\n            Returns start-to-index (excluding index) and index-to-end (including index) arrays.\r\n        \",\r\n        examples: \"\r\n            assert_eq(split([1, 2, 3, 4], 2), [[1, 2], [3, 4]]);\r\n            assert_eq(split([1, 2, 3, 4], 0), [[], [1, 2, 3, 4]]);\r\n            assert_eq(split([1, 2, 3, 4], 4), [[1, 2, 3, 4], []]);\r\n\r\n            would_err('split([1, 2, 3, 4], 5)') // Index out of bounds\r\n        \",\r\n    },\r\n    handler = (state, _reference) {\r\n        let input = required_arg!(state::input).as_a::\u003cArray\u003e()?.clone();\r\n        let index = required_arg!(state::index).as_a::\u003ci64\u003e()?;\r\n\r\n        let left = Value::range(0i64 ..= (index - 1i64));\r\n        let left = input.get_indices(\u0026left)?;\r\n\r\n        let right = Value::range(index ..= (input.len() as i64 - 1));\r\n        let right = input.get_indices(\u0026right)?;\r\n\r\n        Ok(Value::from(vec![left, right]))\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    merge {\r\n        left: Standard::Array,\r\n        right: Standard::Array\r\n    },\r\n    returns = Array,\r\n    docs = {\r\n        category: \"Collections\",\r\n        description: \"Merges the two given arrays into a single array, and returns the result\",\r\n        ext_description: \"\r\n            The two input arrays are concatenated into a single new array.\r\n            The input arrays are not updated.\r\n        \",\r\n        examples: \"\r\n            assert_eq(merge([1, 2], [3, 4]), [1, 2, 3, 4]);\r\n            assert_eq(merge([], [3, 4]), [3, 4]);\r\n            assert_eq(merge([1, 2], []), [1, 2]);\r\n        \",\r\n    },\r\n    handler = (state, _reference) {\r\n        let left = required_arg!(state::left).as_a::\u003cArray\u003e()?.clone();\r\n        let right = required_arg!(state::right).as_a::\u003cArray\u003e()?.clone();\r\n        Ok(Value::from(left.iter().chain(right.iter()).cloned().collect::\u003cVec\u003c_\u003e\u003e()))\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    extend {\r\n        left: Standard::Array,\r\n        right: Standard::Array\r\n    },\r\n    returns = Array,\r\n    docs = {\r\n        category: \"Collections\",\r\n        description: \"Appends the elements of the second array to the first array, and returns the result\",\r\n        ext_description: \"\r\n            The elements of the second array are appended to the first array.\r\n            The first array is updated.\r\n        \",\r\n        examples: \"\r\n            assert_eq(extend([1, 2], [3, 4]), [1, 2, 3, 4]);\r\n            assert_eq(extend([], [3, 4]), [3, 4]);\r\n            assert_eq(extend([1, 2], []), [1, 2]);\r\n\r\n            a = [1, 2];\r\n            extend(a, [3, 4])\r\n            assert_eq(a, [1, 2, 3, 4]);\r\n        \",\r\n    },\r\n    handler = (state, reference) {\r\n        let left = required_arg!(state::left);\r\n        let input_type = left.own_type();\r\n        let mut left = left.as_a::\u003cArray\u003e()?.clone();\r\n        let right = required_arg!(state::right).as_a::\u003cArray\u003e()?.clone();\r\n\r\n        left.extend(right.iter().cloned());\r\n\r\n        // Update the array if it references a variable containing an array\r\n        if let Some(reference) = reference {\r\n            if input_type == ValueType::Array {\r\n                reference.update_value_in_parent(state, left.clone().into())?;\r\n            }\r\n        };\r\n\r\n        Ok(left.into())\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    chunks {\r\n        input: Standard::Array,\r\n        size: Standard::Int\r\n    },\r\n    returns = Array,\r\n    docs = {\r\n        category: \"Collections\",\r\n        description: \"Splits the given array into chunks of the given size, and returns the resulting array of arrays\",\r\n        ext_description: \"\r\n            Splits the given array into chunks of the given size.\r\n            The last chunk may be smaller than the given size.\r\n        \",\r\n        examples: \"\r\n            assert_eq(chunks([1, 2, 3, 4, 5], 2), [[1, 2], [3, 4], [5]]);\r\n            assert_eq(chunks([1, 2, 3, 4, 5], 3), [[1, 2, 3], [4, 5]]);\r\n            assert_eq(chunks([1, 2, 3, 4, 5], 5), [[1, 2, 3, 4, 5]]);\r\n        \",\r\n    },\r\n    handler = (state, _reference) {\r\n        let input = required_arg!(state::input).as_a::\u003cArray\u003e()?.clone();\r\n        let size = required_arg!(state::size).as_a::\u003ci64\u003e()?;\r\n\r\n        let result = input.chunks(size as usize).map(|c| Value::from(c.to_vec())).collect::\u003cVec\u003c_\u003e\u003e();\r\n        Ok(Value::from(result))\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    flatten { input: Standard::Array },\r\n    returns = Array,\r\n    docs = {\r\n        category: \"Collections\",\r\n        description: \"Flattens the given array of arrays into a single array, and returns the result\",\r\n        ext_description: \"\r\n            Flattens the given array of arrays into a single array.\r\n            The input array is not updated.\r\n        \",\r\n        examples: \"\r\n            assert_eq(flatten([[1, 2], [3, 4]]), [1, 2, 3, 4]);\r\n            assert_eq(flatten([[1, 2], []]), [1, 2]);\r\n            assert_eq(flatten([[], []]), []);\r\n        \",\r\n    },\r\n    handler = (state, _reference) {\r\n        let input = required_arg!(state::input).as_a::\u003cArray\u003e()?.clone();\r\n        let result = input.iter().flat_map(|v| v.clone().as_a::\u003cArray\u003e().unwrap().iter().cloned().collect::\u003cVec\u003c_\u003e\u003e()).collect::\u003cVec\u003c_\u003e\u003e();\r\n        Ok(Value::from(result))\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    zip {\r\n        left: Standard::Array,\r\n        right: Standard::Array\r\n    },\r\n    returns = Array,\r\n    docs = {\r\n        category: \"Collections\",\r\n        description: \"Zips the two given arrays into an array of pairs, and returns the result\",\r\n        ext_description: \"\r\n            Zips the two given arrays into an array of pairs.\r\n            If the input arrays are of different lengths, the resulting array will have the length of the shortest input array.\r\n        \",\r\n        examples: \"\r\n            assert_eq(zip([1, 2, 3], [4, 5, 6]), [[1, 4], [2, 5], [3, 6]]);\r\n            assert_eq(zip([1, 2], [4, 5, 6]), [[1, 4], [2, 5]]);\r\n            assert_eq(zip([1, 2, 3], [4, 5]), [[1, 4], [2, 5]]);\r\n        \",\r\n    },\r\n    handler = (state, _reference) {\r\n        let left = required_arg!(state::left).as_a::\u003cArray\u003e()?.clone();\r\n        let right = required_arg!(state::right).as_a::\u003cArray\u003e()?.clone();\r\n\r\n        let result = left.iter().zip(right.iter()).map(|(l, r)| Value::from(vec![l.clone(), r.clone()])).collect::\u003cVec\u003c_\u003e\u003e();\r\n        Ok(Value::from(result))\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    zop {\r\n        left: Standard::Array,\r\n        right: Standard::Array\r\n    },\r\n    returns = Array,\r\n    docs = {\r\n        category: \"Collections\",\r\n        description: \"Zips the two given arrays into an array of pairs, and converts in to an object\",\r\n        ext_description: \"\r\n            Zips the two given arrays into an array of pairs, then converts the result to object\r\n            If the input arrays are of different lengths, the result will have the length of the shortest input array.\r\n            Will fail if any resulting keys would be invalid (collections cannot be used as object keys)\r\n        \",\r\n        examples: \"\r\n            assert_eq(zop(['a', 'b', 'c'], [1, 2, 3]), {'a': 1, 'b': 2, 'c': 3});\r\n        \",\r\n    },\r\n    handler = (state, _reference) {\r\n        let left = required_arg!(state::left).as_a::\u003cArray\u003e()?.clone();\r\n        let right = required_arg!(state::right).as_a::\u003cArray\u003e()?.clone();\r\n\r\n        let result = left.iter().zip(right.iter()).map(|(l, r)| (l.clone(), r.clone())).collect::\u003cVec\u003c(_,_)\u003e\u003e();\r\n        let result = Object::try_from(result)?;\r\n        Ok(Value::from(result))\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    sort { input: Standard::Array },\r\n    returns = Array,\r\n    docs = {\r\n        category: \"Collections\",\r\n        description: \"Sorts the given array, and returns the result\",\r\n        ext_description: \"\r\n            The resulting array is sorted in ascending order by value.\r\n            The original array is not updated.\r\n        \",\r\n        examples: \"\r\n            assert_eq(sort([3, 1, 2]), [1, 2, 3]);\r\n            assert_eq(sort(['c', 'a', 'b']), ['a', 'b', 'c']);\r\n        \",\r\n    },\r\n    handler = (state, _reference) {\r\n        let input = required_arg!(state::input).as_a::\u003cArray\u003e()?.clone();\r\n        let mut result = input.clone();\r\n        result.sort();\r\n        Ok(result.into())\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    reverse { input: Standard::Array },\r\n    returns = Array,\r\n    docs = {\r\n        category: \"Collections\",\r\n        description: \"Reverses the given array, and returns the result\",\r\n        ext_description: \"\r\n            The resulting array is the reverse of the input array.\r\n            The original array is not updated.\r\n        \",\r\n        examples: \"\r\n            assert_eq(reverse([1, 2, 3]), [3, 2, 1]);\r\n            assert_eq(reverse(['a', 'b', 'c']), ['c', 'b', 'a']);\r\n        \",\r\n    },\r\n    handler = (state, _reference) {\r\n        let input = required_arg!(state::input).as_a::\u003cArray\u003e()?.clone();\r\n        let mut result = input.clone();\r\n        result.reverse();\r\n        Ok(result.into())\r\n    },\r\n);\r\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":31},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":31},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":31},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":34},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":31},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":281,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":282,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":46},"fn_name":null},{"line":298,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":46},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":46},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":307,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":37},"fn_name":null},{"line":313,"address":[],"length":0,"stats":{"Line":40},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":318,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":322,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":323,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":326,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":328,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":329,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":330,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":331,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":333,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":334,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":336,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":338,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":339,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":340,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":341,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":344,"address":[],"length":0,"stats":{"Line":34},"fn_name":null},{"line":345,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":346,"address":[],"length":0,"stats":{"Line":34},"fn_name":null},{"line":348,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":34},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":354,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":359,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":369,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":370,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":371,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":372,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":373,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":374,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":375,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":376,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":377,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":379,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":380,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":381,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":382,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":384,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":385,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":387,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":388,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":389,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":390,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":395,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":396,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":397,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":398,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":399,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":400,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":401,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":402,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":403,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":404,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":405,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":406,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":407,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":408,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":410,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":411,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":413,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":414,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":415,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":416,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":427,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":428,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":429,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":430,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":431,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":432,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":433,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":434,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":435,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":436,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":437,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":438,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":439,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":440,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":441,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":443,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":444,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":445,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":449,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":450,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":451,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":452,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":453,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":454,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":455,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":456,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":457,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":458,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":459,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":460,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":461,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":462,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":463,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":465,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":466,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":467,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":479,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":480,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":481,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":482,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":484,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":485,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":486,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":487,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":488,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":489,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":490,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":491,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":492,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":493,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":494,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":495,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":497,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":498,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":500,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":501,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":502,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":504,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":505,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":507,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":508,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":510,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":514,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":515,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":516,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":517,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":519,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":520,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":521,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":522,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":523,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":524,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":525,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":526,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":527,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":528,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":529,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":530,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":531,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":533,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":534,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":535,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":536,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":540,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":541,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":542,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":543,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":545,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":546,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":547,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":548,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":549,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":550,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":551,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":552,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":553,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":554,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":555,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":556,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":558,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":559,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":560,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":561,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":563,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":564,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":565,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":566,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":567,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":569,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":572,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":573,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":574,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":578,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":582,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":583,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":584,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":585,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":587,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":588,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":589,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":590,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":591,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":592,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":593,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":594,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":595,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":596,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":597,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":598,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":599,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":601,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":602,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":603,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":605,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":606,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":610,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":611,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":612,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":613,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":614,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":615,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":616,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":617,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":618,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":619,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":620,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":621,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":622,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":623,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":624,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":626,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":627,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":628,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":629,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":633,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":634,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":635,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":636,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":638,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":639,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":640,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":641,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":642,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":643,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":644,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":645,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":646,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":647,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":648,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":649,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":650,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":652,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":653,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":654,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":656,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":657,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":661,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":662,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":663,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":664,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":666,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":667,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":668,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":669,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":670,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":671,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":672,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":673,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":674,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":675,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":676,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":677,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":679,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":680,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":681,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":683,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":684,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":685,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":689,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":690,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":691,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":692,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":693,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":694,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":695,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":696,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":697,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":698,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":699,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":700,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":701,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":702,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":704,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":705,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":706,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":707,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":708,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":712,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":713,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":714,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":715,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":716,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":717,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":718,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":719,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":720,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":721,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":722,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":723,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":724,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":725,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":727,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":728,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":729,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":730,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":731,"address":[],"length":0,"stats":{"Line":6},"fn_name":null}],"covered":528,"coverable":528},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","functions","stdlib","decorators_currency.rs"],"content":"use crate::define_stddecorator;\r\nuse polyvalue::types::{CurrencyInner, Fixed};\r\n\r\ndefine_stddecorator!(\r\n    usd { input: Numeric },\r\n    docs = {\r\n        description: \"Interprets a number as a USD amount\",\r\n        ext_description: \"Includes a dollar sign and two decimal places.\",\r\n        examples: \"\r\n            assert_eq(\r\n                100 @usd,\r\n                '$100.00'\r\n            )\r\n        \"\r\n    },\r\n    handler = (input) {\r\n        let input = input.as_a::\u003cFixed\u003e()?;\r\n        Ok(CurrencyInner::as_dollars(input).to_string())\r\n    }\r\n);\r\n\r\ndefine_stddecorator!(\r\n    eur { input: Numeric },\r\n    docs = {\r\n        description: \"Interprets a number as a Euro amount\",\r\n        ext_description: \"Includes a euro sign and two decimal places.\",\r\n        examples: \"\r\n            assert_eq(\r\n                100 @eur,\r\n                '100.00'\r\n            )\r\n        \"\r\n    },\r\n    handler = (input) {\r\n        let input = input.as_a::\u003cFixed\u003e()?;\r\n        Ok(CurrencyInner::as_euros(input).to_string())\r\n    }\r\n);\r\n\r\ndefine_stddecorator!(\r\n    cad { input: Numeric },\r\n    docs = {\r\n        description: \"Interprets a number as a CAD amount\",\r\n        ext_description: \"Includes a dollar sign and two decimal places.\",\r\n        examples: \"\r\n            assert_eq(\r\n                100 @cad,\r\n                '$100.00'\r\n            )\r\n        \"\r\n    },\r\n    handler = (input) {\r\n        let input = input.as_a::\u003cFixed\u003e()?;\r\n        Ok(CurrencyInner::as_dollars(input).to_string())\r\n    }\r\n);\r\n\r\ndefine_stddecorator!(\r\n    aud { input: Numeric },\r\n    docs = {\r\n        description: \"Interprets a number as a AUD amount\",\r\n        ext_description: \"Includes a dollar sign and two decimal places.\",\r\n        examples: \"\r\n            assert_eq(\r\n                100 @aud,\r\n                '$100.00'\r\n            )\r\n        \"\r\n    },\r\n    handler = (input) {\r\n        let input = input.as_a::\u003cFixed\u003e()?;\r\n        Ok(CurrencyInner::as_dollars(input).to_string())\r\n    }\r\n);\r\n\r\ndefine_stddecorator!(\r\n    gbp { input: Numeric },\r\n    docs = {\r\n        description: \"Interprets a number as a GBP amount\",\r\n        ext_description: \"Includes a pound sign and two decimal places.\",\r\n        examples: \"\r\n            assert_eq(\r\n                100 @gbp,\r\n                '100.00'\r\n            )\r\n        \"\r\n    },\r\n    handler = (input) {\r\n        let input = input.as_a::\u003cFixed\u003e()?;\r\n        Ok(CurrencyInner::as_pounds(input).to_string())\r\n    }\r\n);\r\n\r\ndefine_stddecorator!(\r\n    jpy { input: Numeric },\r\n    docs = {\r\n        description: \"Interprets a number as a JPY amount\",\r\n        ext_description: \"Includes a yen sign and no decimal places.\",\r\n        examples: \"\r\n            assert_eq(\r\n                100 @jpy,\r\n                '100'\r\n            )\r\n        \"\r\n    },\r\n    handler = (input) {\r\n        let input = input.as_a::\u003cFixed\u003e()?;\r\n        Ok(CurrencyInner::as_yen(input).to_string())\r\n    }\r\n);\r\n\r\ndefine_stddecorator!(\r\n    cny { input: Numeric },\r\n    docs = {\r\n        description: \"Interprets a number as a CNY amount\",\r\n        ext_description: \"Includes a yuan sign and two decimal places.\",\r\n        examples: \"\r\n            assert_eq(\r\n                100 @cny,\r\n                '100.00'\r\n            )\r\n        \"\r\n    },\r\n    handler = (input) {\r\n        let input = input.as_a::\u003cFixed\u003e()?;\r\n        Ok(CurrencyInner::as_yuan(input).to_string())\r\n    }\r\n);\r\n\r\ndefine_stddecorator!(\r\n    inr { input: Numeric },\r\n    docs = {\r\n        description: \"Interprets a number as a INR amount\",\r\n        ext_description: \"Includes a rupee sign and two decimal places.\",\r\n        examples: \"\r\n            assert_eq(\r\n                100 @inr,\r\n                '100.00'\r\n            )\r\n        \"\r\n    },\r\n    handler = (input) {\r\n        let input = input.as_a::\u003cFixed\u003e()?;\r\n        Ok(CurrencyInner::as_rupees(input).to_string())\r\n    }\r\n);\r\n\r\ndefine_stddecorator!(\r\n    rub { input: Numeric },\r\n    docs = {\r\n        description: \"Interprets a number as a RUB amount\",\r\n        ext_description: \"Includes a ruble sign and two decimal places.\",\r\n        examples: \"\r\n            assert_eq(\r\n                100 @rub,\r\n                '100.00'\r\n            )\r\n        \"\r\n    },\r\n    handler = (input) {\r\n        let input = input.as_a::\u003cFixed\u003e()?;\r\n        Ok(CurrencyInner::as_rubles(input).to_string())\r\n    }\r\n);\r\n","traces":[{"line":4,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":5,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":6,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":7,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":8,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":9,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":10,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":11,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":3},"fn_name":null}],"covered":117,"coverable":117},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","functions","stdlib","decorators_numeric.rs"],"content":"use crate::define_stddecorator;\r\nuse polyvalue::{operations::ArithmeticOperationExt, types::I64, ValueTrait};\r\n\r\ndefine_stddecorator!(\r\n    roman { input: Numeric },\r\n    docs = {\r\n        description: \"Interprets an integer as a roman numeral\",\r\n        ext_description: \"Like the roman system before it; this function only supports numbers up to 3999.\",\r\n        examples: \"\r\n            assert_eq(\r\n                123 @roman,\r\n                'CXXIII'\r\n            )\r\n        \"\r\n    },\r\n    handler = (input) {\r\n        let mut input = input.as_a::\u003ci64\u003e()?;\r\n        if input \u003e 3999 {\r\n            return oops!(Overflow);\r\n        }\r\n\r\n        let roman_numerals = vec![\r\n            (1000, \"M\"),\r\n            (900, \"CM\"),\r\n            (500, \"D\"),\r\n            (400, \"CD\"),\r\n            (100, \"C\"),\r\n            (90, \"XC\"),\r\n            (50, \"L\"),\r\n            (40, \"XL\"),\r\n            (10, \"X\"),\r\n            (9, \"IX\"),\r\n            (5, \"V\"),\r\n            (4, \"IV\"),\r\n            (1, \"I\"),\r\n        ];\r\n        let mut roman_numeral = String::new();\r\n        for (n, r) in roman_numerals {\r\n            while input \u003e= n {\r\n                roman_numeral.push_str(r);\r\n                input -= n;\r\n            }\r\n        }\r\n        Ok(roman_numeral)\r\n    }\r\n);\r\n\r\ndefine_stddecorator!(\r\n    ord { input: Numeric },\r\n    docs = {\r\n        description: \"Interprets an integer as an ordinal number\",\r\n        ext_description: \"This function will append the appropriate suffix to the input number.\",\r\n        examples: \"\r\n            assert_eq(\r\n                123 @ord,\r\n                '123rd'\r\n            )\r\n        \"\r\n    },\r\n    handler = (input) {\r\n        let input = input.as_a::\u003ci64\u003e()?;\r\n        let ordinal = match input % 10 {\r\n            1 =\u003e format!(\"{}st\", input),\r\n            2 =\u003e format!(\"{}nd\", input),\r\n            3 =\u003e format!(\"{}rd\", input),\r\n            _ =\u003e format!(\"{}th\", input),\r\n        };\r\n        Ok(ordinal)\r\n    }\r\n);\r\n\r\ndefine_stddecorator!(\r\n    utc { input: Numeric },\r\n    docs = {\r\n        description: \"Interprets an integer as a timestamp, and formats it in UTC standard\",\r\n        ext_description: \"This function will convert the input number to a UTC timestamp.\",\r\n        examples: \"\r\n            assert_eq(\r\n                123 @utc,\r\n                '1970-01-01T00:02:03Z'\r\n            )\r\n        \"\r\n    },\r\n    handler = (input) {\r\n        let input = input.as_a::\u003cI64\u003e()?;\r\n        let input = *input.arithmetic_op(I64::new(1000),\r\n            polyvalue::operations::ArithmeticOperation::Multiply,\r\n        )?.inner();\r\n\r\n        match chrono::DateTime::from_timestamp_millis(input) {\r\n            Some(datetime) =\u003e Ok(datetime.format(\"%Y-%m-%dT%H:%M:%SZ\").to_string()),\r\n            None =\u003e oops!(Range { input: input.to_string() }),\r\n        }\r\n    }\r\n);\r\n\r\ndefine_stddecorator!(\r\n    percent { input: Numeric },\r\n    docs = {\r\n        description: \"Interprets a number as a percentage\",\r\n        ext_description: \"This function will append a percentage sign to the input number times 100\",\r\n        examples: \"\r\n            assert_eq(\r\n                0.123 @percent,\r\n                '12.3%'\r\n            \r\n            )\r\n        \"\r\n    },\r\n    handler = (input) {\r\n        let input = input.as_a::\u003cf64\u003e()?;\r\n        Ok(format!(\"{}%\", input * 100.0))\r\n    }\r\n);\r\n","traces":[{"line":4,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":5,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":6,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":7,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":8,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":9,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":10,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":11,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":3},"fn_name":null}],"covered":88,"coverable":88},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","functions","stdlib","decorators_types.rs"],"content":"use crate::define_stddecorator;\r\nuse polyvalue::{\r\n    types::{Bool, Float, I64},\r\n    InnerValue, ValueTrait,\r\n};\r\n\r\ndefine_stddecorator!(\r\n    hex { input: Numeric },\r\n    docs = {\r\n        description: \"Base 16 number formatting, such as 0xFF\",\r\n        ext_description: \"Converts a number to a hexadecimal string. The output will be prefixed with '0x' with a length based on the input type.\",\r\n        examples: \"\r\n            assert_eq(\r\n                255 @hex,\r\n                '0xff'\r\n            )\r\n        \"\r\n    },\r\n    handler = (input) {\r\n        match input.inner() {\r\n            InnerValue::U8(v) =\u003e Ok(format!(\"{:#0x}\", v.inner())),\r\n            InnerValue::I8(v) =\u003e Ok(format!(\"{:#0x}\", v.inner())),\r\n            InnerValue::U16(v) =\u003e Ok(format!(\"{:#0x}\", v.inner())),\r\n            InnerValue::I16(v) =\u003e Ok(format!(\"{:#0x}\", v.inner())),\r\n            InnerValue::U32(v) =\u003e Ok(format!(\"{:#0x}\", v.inner())),\r\n            InnerValue::I32(v) =\u003e Ok(format!(\"{:#0x}\", v.inner())),\r\n            InnerValue::U64(v) =\u003e Ok(format!(\"{:#0x}\", v.inner())),\r\n            _ =\u003e {\r\n                let input = input.as_a::\u003ci64\u003e()?;\r\n                Ok(format!(\"{:#0x}\", input))\r\n            }\r\n        }\r\n    }\r\n);\r\n\r\ndefine_stddecorator!(\r\n    oct { input: Numeric },\r\n    docs = {\r\n        description: \"Base 8 number formatting, such as 0o77\",\r\n        ext_description: \"Converts a number to an octal string. The output will be prefixed with '0o' with a length based on the input type.\",\r\n        examples: \"\r\n            assert_eq(\r\n                255 @oct,\r\n                '0o377'\r\n            )\r\n        \"\r\n    },\r\n    handler = (input) {\r\n        match input.inner() {\r\n            InnerValue::U8(v) =\u003e Ok(format!(\"{:#0o}\", v.inner())),\r\n            InnerValue::I8(v) =\u003e Ok(format!(\"{:#0o}\", v.inner())),\r\n            InnerValue::U16(v) =\u003e Ok(format!(\"{:#0o}\", v.inner())),\r\n            InnerValue::I16(v) =\u003e Ok(format!(\"{:#0o}\", v.inner())),\r\n            InnerValue::U32(v) =\u003e Ok(format!(\"{:#0o}\", v.inner())),\r\n            InnerValue::I32(v) =\u003e Ok(format!(\"{:#0o}\", v.inner())),\r\n            InnerValue::U64(v) =\u003e Ok(format!(\"{:#0o}\", v.inner())),\r\n            _ =\u003e {\r\n                let input = input.as_a::\u003ci64\u003e()?;\r\n                Ok(format!(\"{:#0o}\", input))\r\n            }\r\n        }\r\n    }\r\n);\r\n\r\ndefine_stddecorator!(\r\n    bin { input: Numeric },\r\n    docs = {\r\n        description: \"Base 2 number formatting, such as 0b101\",\r\n        ext_description: \"Converts a number to a binary string. The output will be prefixed with '0b' with a length based on the input type.\",\r\n        examples: \"\r\n            assert_eq(\r\n                255 @bin,\r\n                '0b11111111'\r\n            )\r\n        \"\r\n    },\r\n    handler = (input) {\r\n        match input.inner() {\r\n            InnerValue::U8(v) =\u003e Ok(format!(\"{:#0b}\", v.inner())),\r\n            InnerValue::I8(v) =\u003e Ok(format!(\"{:#0b}\", v.inner())),\r\n            InnerValue::U16(v) =\u003e Ok(format!(\"{:#0b}\", v.inner())),\r\n            InnerValue::I16(v) =\u003e Ok(format!(\"{:#0b}\", v.inner())),\r\n            InnerValue::U32(v) =\u003e Ok(format!(\"{:#0b}\", v.inner())),\r\n            InnerValue::I32(v) =\u003e Ok(format!(\"{:#0b}\", v.inner())),\r\n            InnerValue::U64(v) =\u003e Ok(format!(\"{:#0b}\", v.inner())),\r\n            _ =\u003e {\r\n                let input = input.as_a::\u003ci64\u003e()?;\r\n                Ok(format!(\"{:#0b}\", input))\r\n            }\r\n        }\r\n    }\r\n);\r\n\r\ndefine_stddecorator!(\r\n    sci { input: Numeric },\r\n    docs = {\r\n        description: \"Scientific notation\",\r\n        ext_description: \"Converts a floating point number to sci notation.\",\r\n        examples: \"\r\n            assert_eq(\r\n                1000000.0 @sci,\r\n                '1e6'\r\n            )\r\n        \"\r\n    },\r\n    handler = (input) {\r\n        let input = input.as_a::\u003cf64\u003e()?;\r\n        Ok(format!(\"{:e}\", input))\r\n    }\r\n);\r\n\r\ndefine_stddecorator!(\r\n    float { input: Numeric },\r\n    docs = {\r\n        description: \"Floating point number formatting\",\r\n        ext_description: \"Converts a number to a floating point string.\",\r\n        examples: \"\r\n            assert_eq(\r\n                1.0 @float,\r\n                '1.0'\r\n            )\r\n        \"\r\n    },\r\n    handler = (input) {\r\n        let input = input.as_a::\u003cFloat\u003e()?;\r\n        Ok(input.to_string())\r\n    }\r\n);\r\n\r\ndefine_stddecorator!(\r\n    int { input: Numeric },\r\n    docs = {\r\n        description: \"Integer number formatting\",\r\n        ext_description: \"Converts a number to an integer string.\",\r\n        examples: \"\r\n            assert_eq(\r\n                1000000 @int,\r\n                '1000000'\r\n            )\r\n        \"\r\n    },\r\n    handler = (input) {\r\n        let input = input.as_a::\u003cI64\u003e()?;\r\n        Ok(input.to_string())\r\n    }\r\n);\r\n\r\ndefine_stddecorator!(\r\n    bool { input: Any },\r\n    docs = {\r\n        description: \"Boolean formatting\",\r\n        ext_description: \"Converts a number to a boolean string.\",\r\n        examples: \"\r\n            assert_eq(\r\n                1 @bool,\r\n                'true'\r\n            \r\n            )\r\n        \"\r\n    },\r\n    handler = (input) {\r\n        let input = Bool::from(input.is_truthy());\r\n        Ok(input.to_string())\r\n    }\r\n);\r\n","traces":[{"line":7,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":8,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":9,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":10,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":11,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":3},"fn_name":null}],"covered":118,"coverable":118},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","functions","stdlib","dev.rs"],"content":"use crate::{define_stdfunction, Error};\r\nuse polyvalue::Value;\r\nuse std::io::BufRead;\r\n\r\ndefine_stdfunction!(\r\n    time { },\r\n    returns = Float,\r\n    docs = {\r\n        category: \"Development\",\r\n        description: \"Returns a unix timestamp for the current system time\",\r\n        ext_description: \"\r\n            Returns a unix timestamp for the current system time.\r\n            The timestamp is a floating point number representing the number of seconds since the Unix epoch.\",\r\n        examples: \"\r\n            assert(\r\n                time() \u003e 0\r\n            )\r\n        \"\r\n    },\r\n    handler = (_state, _reference) {\r\n        Ok(Value::from(\r\n            std::time::SystemTime::now()\r\n                .duration_since(std::time::UNIX_EPOCH)\r\n                .unwrap_or_else(|_| std::time::Duration::ZERO)\r\n                .as_secs_f64(),\r\n        ))\r\n    }\r\n);\r\n\r\ndefine_stdfunction!(\r\n    tail {\r\n        file: Standard::String,\r\n        lines: Optional::Int\r\n    },\r\n    returns = Array,\r\n    docs = {\r\n        category: \"Development\",\r\n        description: \"Returns the last \u003clines\u003e lines from a given file\",\r\n        ext_description: \"\r\n            If \u003clines\u003e is not specified, the function will return the last line of the file.\",\r\n        examples: \"\r\n            lines = tail('.gitignore')\r\n            assert_eq(\r\n                lines,\r\n                ['/Cargo.lock']\r\n            )\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let n = optional_arg!(state::lines).unwrap_or(1.into()).as_a::\u003ci64\u003e()?;\r\n        let file = required_arg!(state::file).to_string();\r\n\r\n        let file = std::fs::File::open(file)?;\r\n        let lines = std::io::BufReader::new(file)\r\n            .lines()\r\n            .map(|f| Ok::\u003cValue, Error\u003e(Value::from(f?)))\r\n            .collect::\u003cResult\u003cVec\u003c_\u003e, _\u003e\u003e()?;\r\n\r\n        // return last n\r\n        Ok(Value::from(lines.iter().rev().take(n as usize).rev().cloned().collect::\u003cVec\u003c_\u003e\u003e()))\r\n    }\r\n);\r\n","traces":[{"line":5,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":6,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":7,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":8,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":9,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":10,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":11,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":6},"fn_name":null}],"covered":31,"coverable":44},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","functions","stdlib","math.rs"],"content":"use crate::{\r\n    define_stdfunction,\r\n    error::{ErrorDetails, WrapOption},\r\n};\r\nuse polyvalue::{fpdec::Round, types::CurrencyInner, InnerValue, Value, ValueTrait};\r\n\r\ndefine_stdfunction!(\r\n    min {\r\n        options: Standard::Array\r\n    },\r\n    returns = Numeric,\r\n    docs = {\r\n        category: \"Math\",\r\n        description: \"Returns the smallest value in the given array\",\r\n        ext_description: \"\r\n            The array can contain any number of elements, and they can be of any type.\r\n            Since all values in lavendeux are comparable, the function will work with any type of array.\r\n        \",\r\n        examples: \"\r\n            assert_eq(\r\n                min([1, 2, 3, 4, 5]),\r\n                1\r\n            )\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let options = required_arg!(state::options).as_a::\u003cVec\u003cValue\u003e\u003e()?;\r\n        let min = options.iter().min().or_error(ErrorDetails::ArrayEmpty)?;\r\n        Ok(min.clone())\r\n    }\r\n);\r\n\r\ndefine_stdfunction!(\r\n    max {\r\n        options: Standard::Array\r\n    },\r\n    returns = Numeric,\r\n    docs = {\r\n        category: \"Math\",\r\n        description: \"Returns the largest value in the given array\",\r\n        ext_description: \"\r\n            The array can contain any number of elements, and they can be of any type.\r\n            Since all values in lavendeux are comparable, the function will work with any type of array.\r\n        \",\r\n        examples: \"\r\n            assert_eq(\r\n                max([1, 2, 3, 4, 5]),\r\n                5\r\n            )\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let options = required_arg!(state::options).as_a::\u003cVec\u003cValue\u003e\u003e()?;\r\n        if options.is_empty() {\r\n            return oops!(ArrayEmpty)\r\n        }\r\n        let max = options.iter().max().or_error(ErrorDetails::ArrayEmpty)?;\r\n        Ok(max.clone())\r\n    }\r\n);\r\n\r\ndefine_stdfunction!(\r\n    ceil {\r\n        value: Standard::Numeric\r\n    },\r\n    returns = Numeric,\r\n    docs = {\r\n        category: \"Math\",\r\n        description: \"Rounds a number up to the nearest whole number\",\r\n        ext_description: \"\r\n            The function will round the input number up to the nearest whole number.\r\n            If the input number is already a whole number, the function will return the input number.\r\n        \",\r\n        examples: \"\r\n            assert_eq(\r\n                ceil(1.5),\r\n                2.0\r\n            )\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let value = required_arg!(state::value).as_a::\u003cf64\u003e()?;\r\n        Ok(value.ceil().into())\r\n    }\r\n);\r\n\r\ndefine_stdfunction!(\r\n    floor {\r\n        value: Standard::Numeric\r\n    },\r\n    returns = Numeric,\r\n    docs = {\r\n        category: \"Math\",\r\n        description: \"Rounds a number down to the nearest whole number\",\r\n        ext_description: \"\r\n            The function will round the input number down to the nearest whole number.\r\n            If the input number is already a whole number, the function will return the input number.\r\n        \",\r\n        examples: \"\r\n            assert_eq(\r\n                floor(1.5),\r\n                1.0\r\n            )\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let value = required_arg!(state::value).as_a::\u003cf64\u003e()?;\r\n        Ok(value.floor().into())\r\n    }\r\n);\r\n\r\ndefine_stdfunction!(\r\n    abs {\r\n        value: Standard::Numeric\r\n    },\r\n    returns = Numeric,\r\n    docs = {\r\n        category: \"Math\",\r\n        description: \"Returns the absolute value of a number\",\r\n        ext_description: \"\r\n            The function will return the absolute value of the input number.\r\n        \",\r\n        examples: \"\r\n            assert_eq(\r\n                abs(-5),\r\n                5\r\n            )\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let value = required_arg!(state::value);\r\n        match value.inner() {\r\n            InnerValue::Fixed(n) =\u003e Ok(Value::fixed(n.inner().abs())),\r\n            InnerValue::Currency(n) =\u003e {\r\n                let symbol = n.symbol().clone();\r\n                let precision = n.precision();\r\n                let value = n.inner().value().inner().abs();\r\n                Ok(CurrencyInner::new(symbol, precision, value.into()).into())\r\n            },\r\n\r\n            InnerValue::Float(n) =\u003e Ok(Value::from(n.inner().abs())),\r\n\r\n            InnerValue::U8(n) =\u003e Ok(Value::from(n.clone())),\r\n            InnerValue::U16(n) =\u003e Ok(Value::from(n.clone())),\r\n            InnerValue::U32(n) =\u003e Ok(Value::from(n.clone())),\r\n            InnerValue::U64(n) =\u003e Ok(Value::from(n.clone())),\r\n\r\n            InnerValue::I8(n) =\u003e Ok(Value::from(n.abs())),\r\n            InnerValue::I16(n) =\u003e Ok(Value::from(n.abs())),\r\n            InnerValue::I32(n) =\u003e Ok(Value::from(n.abs())),\r\n            InnerValue::I64(n) =\u003e Ok(Value::from(n.abs())),\r\n\r\n            _ =\u003e oops!(\r\n                Internal {\r\n                    msg: \"Invalid argument type\".to_string()\r\n                }\r\n            ),\r\n\r\n        }\r\n    }\r\n);\r\n\r\ndefine_stdfunction!(\r\n    round {\r\n        value: Standard::Numeric,\r\n        precision: Optional::Int\r\n    },\r\n    returns = Numeric,\r\n    docs = {\r\n        category: \"Math\",\r\n        description: \"Rounds a number to the nearest whole number\",\r\n        ext_description: \"\r\n            The function will round the input number to the nearest whole number.\r\n            If the input number is already a whole number, the function will return the input number.\r\n        \",\r\n        examples: \"\r\n            assert_eq(\r\n                round(1.5),\r\n                2.0\r\n            )\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let value = required_arg!(state::value);\r\n        let precision = optional_arg!(state::precision).unwrap_or(0.into()).as_a::\u003ci64\u003e()?;\r\n\r\n        match value.inner() {\r\n            InnerValue::Fixed(n) =\u003e Ok(Value::from(n.inner().clone().round(precision as i8))),\r\n            InnerValue::Currency(n) =\u003e {\r\n                let symbol = n.symbol().clone();\r\n                let precision = n.precision();\r\n                let value = n.inner().value().inner().clone().round(precision);\r\n                Ok(CurrencyInner::new(symbol, precision, value.into()).into())\r\n            },\r\n\r\n            InnerValue::Float(n) =\u003e {\r\n                let n = n.inner();\r\n                let n = n * 10.0_f64.powi(precision as i32);\r\n                let n = n.round();\r\n                let n = n / 10.0_f64.powi(precision as i32);\r\n                Ok(Value::from(n))\r\n            }\r\n            _ =\u003e oops!(\r\n                Internal {\r\n                    msg: \"Invalid argument type\".to_string()\r\n                }\r\n            ),\r\n        }\r\n    }\r\n);\r\n\r\ndefine_stdfunction!(\r\n    log2 {\r\n        value: Standard::Numeric\r\n    },\r\n    returns = Numeric,\r\n    docs = {\r\n        category: \"Math\",\r\n        description: \"Returns the base-2 logarithm of a number\",\r\n        ext_description: \"\",\r\n        examples: \"\r\n            assert_eq(\r\n                log2(8),\r\n                3\r\n            )\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let value = required_arg!(state::value);\r\n        let type_name = value.own_type();\r\n        let value = value.as_a::\u003cf64\u003e()?;\r\n        Ok(Value::from(value.log2()).as_type(type_name)?)\r\n    }\r\n);\r\n\r\ndefine_stdfunction!(\r\n    ilog2 {\r\n        value: Standard::Int\r\n    },\r\n    returns = Numeric,\r\n    docs = {\r\n        category: \"Math\",\r\n        description: \"Returns the base-2 logarithm of a number, rounded down to the nearest whole number\",\r\n        ext_description: \"\",\r\n        examples: \"\r\n            assert_eq(\r\n                ilog2(8),\r\n                3\r\n            )\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let value = required_arg!(state::value);\r\n        let type_name = value.own_type();\r\n        let value = value.as_a::\u003ci64\u003e()?;\r\n        Ok(Value::from(value.ilog2()).as_type(type_name)?)\r\n    }\r\n);\r\n\r\ndefine_stdfunction!(\r\n    log10 {\r\n        value: Standard::Numeric\r\n    },\r\n    returns = Numeric,\r\n    docs = {\r\n        category: \"Math\",\r\n        description: \"Returns the base-10 logarithm of a number\",\r\n        ext_description: \"\",\r\n        examples: \"\r\n            assert_eq(\r\n                log10(100),\r\n                2\r\n            )\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let value = required_arg!(state::value);\r\n        let type_name = value.own_type();\r\n        let value = value.as_a::\u003cf64\u003e()?;\r\n        Ok(Value::from(value.log10()).as_type(type_name)?)\r\n    }\r\n);\r\n\r\ndefine_stdfunction!(\r\n    ln {\r\n        value: Standard::Numeric\r\n    },\r\n    returns = Numeric,\r\n    docs = {\r\n        category: \"Math\",\r\n        description: \"Returns the natural logarithm of a number\",\r\n        ext_description: \"\",\r\n        examples: \"\r\n            assert_eq(\r\n                ln(2.718281828459045),\r\n                1.0\r\n            )\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let value = required_arg!(state::value);\r\n        let type_name = value.own_type();\r\n        let value = value.as_a::\u003cf64\u003e()?;\r\n        Ok(Value::from(value.ln()).as_type(type_name)?)\r\n    }\r\n);\r\n\r\ndefine_stdfunction!(\r\n    log {\r\n        value: Standard::Numeric,\r\n        base: Optional::Numeric\r\n    },\r\n    returns = Numeric,\r\n    docs = {\r\n        category: \"Math\",\r\n        description: \"Returns the logarithm of a number to a given base\",\r\n        ext_description: \"\",\r\n        examples: \"\r\n            assert_eq(\r\n                log(8, 2),\r\n                3.0\r\n            )\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let value = required_arg!(state::value).as_a::\u003cf64\u003e()?;\r\n        let base = optional_arg!(state::base).unwrap_or(10.into()).as_a::\u003cf64\u003e()?;\r\n        Ok(value.log(base).into())\r\n    }\r\n);\r\n\r\ndefine_stdfunction!(\r\n    sqrt {\r\n        value: Standard::Numeric\r\n    },\r\n    returns = Numeric,\r\n    docs = {\r\n        category: \"Math\",\r\n        description: \"Returns the square root of a number\",\r\n        ext_description: \"\",\r\n        examples: \"\r\n            assert_eq(\r\n                sqrt(9),\r\n                3.0\r\n            )\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let value = required_arg!(state::value).as_a::\u003cf64\u003e()?;\r\n        Ok(value.sqrt().into())\r\n    }\r\n);\r\n\r\ndefine_stdfunction!(\r\n    root {\r\n        value: Standard::Numeric,\r\n        root: Standard::Numeric\r\n    },\r\n    returns = Numeric,\r\n    docs = {\r\n        category: \"Math\",\r\n        description: \"Returns the nth root of a number\",\r\n        ext_description: \"\",\r\n        examples: \"\r\n            assert_eq(\r\n                root(8, 3),\r\n                2.0\r\n            )\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let value = required_arg!(state::value).as_a::\u003cf64\u003e()?;\r\n        let root = required_arg!(state::root).as_a::\u003cf64\u003e()?;\r\n        Ok(value.powf(1.0 / root).into())\r\n    }\r\n);\r\n","traces":[{"line":7,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":8,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":9,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":11,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":288,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":290,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":298,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":303,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":310,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":313,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":316,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":318,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":321,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":323,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":326,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":328,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":333,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":334,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":336,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":337,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":338,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":339,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":340,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":341,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":342,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":344,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":346,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":348,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":354,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":356,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":357,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":359,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":360,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":361,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":362,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":363,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":364,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":365,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":366,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":367,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":369,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":371,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":372,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":373,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":374,"address":[],"length":0,"stats":{"Line":6},"fn_name":null}],"covered":276,"coverable":276},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","functions","stdlib","network.rs"],"content":"use crate::{\r\n    define_stdfunction,\r\n    error::{ErrorDetails, WrapExternalError, WrapOption},\r\n    network::{request, resolve, ApiDefinition, ApiRegistry},\r\n};\r\nuse polyvalue::{types::Object, Value};\r\nuse serde_json::json;\r\nuse std::collections::HashMap;\r\n\r\n/**********************************************\r\n *\r\n * Network IO\r\n *\r\n *********************************************/\r\n\r\ndefine_stdfunction!(\r\n    resolve {\r\n        hostname: Standard::String\r\n    },\r\n    returns = String,\r\n    docs = {\r\n        category: \"Network\",\r\n        description: \"Resolves a hostname to an IP address\",\r\n        ext_description: \"\r\n            This function uses the system's DNS resolver to resolve a hostname to an IP address.\r\n            If the hostname cannot be resolved, this function will return an error, or time out\r\n        \",\r\n        examples: \"#skip\r\n            resolve('example.com')\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let hostname = required_arg!(state::hostname).to_string();\r\n        Ok(resolve(\u0026hostname).unwrap())\r\n    }\r\n);\r\n\r\ndefine_stdfunction!(\r\n    get {\r\n        url: Standard::String,\r\n        headers: Optional::Object\r\n    },\r\n    returns = String,\r\n    docs = {\r\n        category: \"Network\",\r\n        description: \"Performs an HTTP GET request\",\r\n        ext_description: \"\r\n            This function performs an HTTP GET request to the specified URL.\r\n            If the request fails, this function will return an error or time out\r\n        \",\r\n        examples: \"#skip\r\n            str_out = get('https://jsonplaceholder.typicode.com/users')\r\n            obj_out = get('https://jsonplaceholder.typicode.com/users', {\r\n                'Content-Type': 'application/json'\r\n            })\r\n            assert(str_out is string)\r\n            assert(obj_out is array)\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let url = required_arg!(state::url).to_string();\r\n        let headers = optional_arg!(state::headers).unwrap_or(Value::from(Object::default())).as_a::\u003cObject\u003e()?;\r\n        let headers = headers.iter().map(|(k, v)| (k.to_string(), v.to_string())).collect::\u003cHashMap\u003c_, _\u003e\u003e();\r\n        request(\u0026url, None, headers).without_context()\r\n    }\r\n);\r\n\r\ndefine_stdfunction!(\r\n    post {\r\n        url: Standard::String,\r\n        body: Standard::String,\r\n        headers: Optional::Object\r\n    },\r\n    returns = String,\r\n    docs = {\r\n        category: \"Network\",\r\n        description: \"Performs an HTTP POST request\",\r\n        ext_description: \"\r\n            This function performs an HTTP POST request to the specified URL.\r\n            If the request fails, this function will return an error or time out\r\n        \",\r\n        examples: \"#skip\r\n            obj_out = post(\r\n                'https://jsonplaceholder.typicode.com/users', \r\n                '{\\\"name\\\": \\\"John Doe\\\"}',\r\n                {'Content-Type': 'application/json'}\r\n            )\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let url = required_arg!(state::url).to_string();\r\n        let body = required_arg!(state::body).to_string();\r\n        let headers = optional_arg!(state::headers).unwrap_or(Value::from(Object::default())).as_a::\u003cObject\u003e()?;\r\n        let headers = headers.iter().map(|(k, v)| (k.to_string(), v.to_string())).collect::\u003cHashMap\u003c_, _\u003e\u003e();\r\n        request(\u0026url, Some(body), headers).without_context()\r\n    }\r\n);\r\n\r\n/**********************************************\r\n *\r\n * API Registry\r\n *\r\n *********************************************/\r\n\r\ndefine_stdfunction!(\r\n    api_add {\r\n        name: Standard::String,\r\n        endpoint: Standard::Any\r\n    },\r\n    returns = String,\r\n    docs = {\r\n        category: \"API\",\r\n        description: \"Registers an API\",\r\n        ext_description: \"\r\n            This function registers an API with the system. The API can then be used to make requests to the specified endpoint.\r\n            The endpoint can be a string, or an object with the properties [ base_url, headers, description, examples, auth_key]\r\n            Use the 'api_get' and 'api_post' functions to make requests to the registered API\r\n        \",\r\n        examples: \"\r\n            api_add('ipify', 'https://api.ipify.org')\r\n            assert( api_list() contains 'ipify' )\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let name = required_arg!(state::name).to_string();\r\n        let endpoint = required_arg!(state::endpoint);\r\n\r\n        let api = ApiDefinition::try_from(endpoint.clone())?;\r\n\r\n        ApiRegistry::new(state).add(state, \u0026name, api);\r\n        Ok(Value::from(name))\r\n    }\r\n);\r\n\r\ndefine_stdfunction!(\r\n    api_rem {name: Standard::String},\r\n    returns = String,\r\n    docs = {\r\n        category: \"API\",\r\n        description: \"Unregisters an API\",\r\n        ext_description: \"\r\n            This function unregisters an API with the system, and returns its name\r\n            The API can no longer be used to make requests\r\n        \",\r\n        examples: \"\r\n            api_rem('ipify')\r\n            assert( !(api_list() contains 'ipify') )\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let name = required_arg!(state::name).to_string();\r\n        ApiRegistry::new(state).remove(state, \u0026name);\r\n        Ok(Value::from(name))\r\n    }\r\n);\r\n\r\ndefine_stdfunction!(\r\n    api_all {},\r\n    returns = Object,\r\n    docs = {\r\n        category: \"API\",\r\n        description: \"Details all registered APIs\",\r\n        ext_description: \"\r\n            This function returns an object containing the names and endpoints of all registered APIs\r\n        \",\r\n        examples: \"\r\n            api_all()['chatgpt']['base_url']\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        Ok(ApiRegistry::raw(state))\r\n    }\r\n);\r\n\r\ndefine_stdfunction!(\r\n    api_list {},\r\n    returns = Object,\r\n    docs = {\r\n        category: \"API\",\r\n        description: \"Lists all registered APIs\",\r\n        ext_description: \"\r\n            This function returns an array containing the names of all registered APIs\r\n        \",\r\n        examples: \"\r\n            assert( api_list() contains 'chatgpt' )\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        Ok(ApiRegistry::new(state).all().keys().cloned().map(Value::from).collect::\u003cVec\u003c_\u003e\u003e().into())\r\n    }\r\n);\r\n\r\ndefine_stdfunction!(\r\n    api_get {\r\n        name: Standard::String,\r\n        path: Optional::String\r\n    },\r\n    returns = String,\r\n    docs = {\r\n        category: \"API\",\r\n        description: \"Performs a GET request to a registered API\",\r\n        ext_description: \"\r\n            This function performs a GET request to the specified path of a registered API.\r\n            The path is appended to the base URL of the API.\r\n        \",\r\n        examples: \"#skip\r\n            api_get('ipify')\r\n            api_get('ipify', '/?format=json')\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let name = required_arg!(state::name).to_string();\r\n        let path = optional_arg!(state::path).map(|v| v.to_string());\r\n\r\n        let registry = ApiRegistry::new(state);\r\n        let api = registry.get(\u0026name).or_error(ErrorDetails::Custom {\r\n            msg: format!(\"API '{}' not found\", name),\r\n        })?;\r\n\r\n        api.call(path.as_deref(), None, Default::default())\r\n    }\r\n);\r\n\r\ndefine_stdfunction!(\r\n    api_post {\r\n        name: Standard::String,\r\n        body: Standard::String,\r\n        path: Optional::String\r\n    },\r\n    returns = String,\r\n    docs = {\r\n        category: \"API\",\r\n        description: \"Performs a POST request to a registered API\",\r\n        ext_description: \"\r\n            This function performs a POST request to the specified path of a registered API.\r\n            The path is appended to the base URL of the API.\r\n        \",\r\n        examples: \"#skip\r\n            api_post('ipify', '{\\\"name\\\"=\\\"john\\\"}', 'format=json')\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let name = required_arg!(state::name).to_string();\r\n        let path = optional_arg!(state::path).map(|v| v.to_string());\r\n        let body = required_arg!(state::body).to_string();\r\n\r\n        let registry = ApiRegistry::new(state);\r\n        let api = registry.get(\u0026name).or_error(ErrorDetails::Custom {\r\n            msg: format!(\"API '{}' not found\", name),\r\n        })?;\r\n\r\n        api.call(path.as_deref(), Some(body), Default::default())\r\n    }\r\n);\r\n\r\ndefine_stdfunction!(\r\n    api_key {\r\n        name: Standard::String,\r\n        auth_key: Standard::String\r\n    },\r\n    returns = String,\r\n    docs = {\r\n        category: \"API\",\r\n        description: \"Sets an authentication key for a registered API\",\r\n        ext_description: \"\r\n            This function sets an authentication key for a registered API.\r\n            The key will be used in the 'Authorization' header of requests to the API.\r\n        \",\r\n        examples: \"\r\n            api_key('chatgpt', 'my_super_secret_api_key')\r\n            assert_eq( api_all()['chatgpt']['auth_key'], 'my_super_secret_api_key' )\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let name = required_arg!(state::name).to_string();\r\n        let auth_key = required_arg!(state::auth_key).to_string();\r\n\r\n        let mut registry = ApiRegistry::new(state);\r\n        let mut api = registry.get(\u0026name).or_error(ErrorDetails::Custom {\r\n            msg: format!(\"API '{}' not found\", name),\r\n        })?.clone();\r\n\r\n        api.auth_key = Some(auth_key);\r\n        registry.add(state, \u0026name, api);\r\n        Ok(Value::from(name))\r\n    }\r\n);\r\n\r\ndefine_stdfunction!(\r\n    chatgpt {\r\n        prompt: Standard::String\r\n    },\r\n    returns = String,\r\n    docs = {\r\n        category: \"API\",\r\n        description: \"Performs a request to the ChatGPT API\",\r\n        ext_description: \"\r\n            This function performs a request to the ChatGPT 3.5 API, using the specified prompt.\r\n        \",\r\n        examples: \"#skip\r\n            api_key('chatgpt', 'my_super_secret_api_key')\r\n            chatgpt('What is the meaning of life?')\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let prompt = required_arg!(state::prompt).to_string();\r\n        let registry = ApiRegistry::new(state);\r\n        let api = registry.get(\"chatgpt\").or_error(ErrorDetails::Custom {\r\n            msg: \"API 'chatgpt' not found\".to_string(),\r\n        })?;\r\n\r\n        if api.auth_key.is_none() {\r\n            return oops!(ValueFormat {\r\n                expected_format: \"API key for chatgpt is not set. You can set one with api_key('chatgpt', '\u003ckey\u003e')\".to_string()\r\n            });\r\n        }\r\n\r\n        use serde::{Deserialize, Serialize};\r\n        #[derive(Serialize, Deserialize)]\r\n        struct GPTMsg {\r\n            role: String,\r\n            content: String,\r\n        }\r\n        #[derive(Serialize, Deserialize)]\r\n        struct GPTQuery {\r\n            model: String,\r\n            messages: Vec\u003cGPTMsg\u003e,\r\n        }\r\n\r\n        let query = GPTQuery {\r\n            model: \"gpt-3.5-turbo\".to_string(),\r\n            messages: vec![\r\n                GPTMsg {\r\n                    role: \"system\".to_string(),\r\n                    content:\r\n                        \"You are a chatbot that must respond in concise, single-line messages.\"\r\n                            .to_string(),\r\n                },\r\n                GPTMsg {\r\n                    role: \"user\".to_string(),\r\n                    content: prompt,\r\n                },\r\n            ],\r\n        };\r\n        let query = serde_json::to_string(\u0026query)?;\r\n\r\n        let result = api\r\n            .call(Some(\u0026query), None, Default::default())?.to_string();\r\n\r\n        let json = json!(result);\r\n        let result = json[\"choices\"][0][\"message\"][\"content\"].clone();\r\n\r\n        Ok(Value::from(result.to_string()))\r\n    }\r\n);\r\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":281,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":290,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":298,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":303,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":306,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":307,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":313,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":318,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":321,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":322,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":326,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":330,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":331,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":333,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":334,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":335,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":336,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":337,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":339,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":340,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":341,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":345,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":347,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":348,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":351,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":232,"coverable":256},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","functions","stdlib","random.rs"],"content":"use crate::define_stdfunction;\r\nuse polyvalue::{types::Range, Value, ValueTrait};\r\n\r\ndefine_stdfunction!(\r\n    sha256 {\r\n        input: Standard::String\r\n    },\r\n    returns = String,\r\n    docs = {\r\n        category: \"Cryptographic\",\r\n        description: \"Returns the sha256 hash of a given string\",\r\n        ext_description: \"Will return an unsalted sha256 hash of the input string.\",\r\n        examples: \"\r\n            assert_eq(\r\n                sha256('hello'),\r\n                '2CF24DBA5FB0A30E26E83B2AC5B9E29E1B161E5C1FA7425E73043362938B9824'\r\n            )\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let input = required_arg!(state::input).to_string();\r\n\r\n        use sha2::{Digest, Sha256};\r\n        let mut hasher = Sha256::new();\r\n        hasher.update(input);\r\n\r\n        let s = format!(\"{:X}\", hasher.finalize());\r\n        Ok(Value::from(s))\r\n    }\r\n);\r\n\r\ndefine_stdfunction!(\r\n    sha512 {\r\n        input: Standard::String\r\n    },\r\n    returns = String,\r\n    docs = {\r\n        category: \"Cryptographic\",\r\n        description: \"Returns the sha512 hash of a given string\",\r\n        ext_description: \"Will return an unsalted sha512 hash of the input string.\",\r\n        examples: \"\r\n            assert_eq(\r\n                sha512('hello'),\r\n                '9B71D224BD62F3785D96D46AD3EA3D73319BFBC2890CAADAE2DFF72519673CA72323C3D99BA5C11D7C7ACC6E14B8C5DA0C4663475C2E5C3ADEF46F73BCDEC043'\r\n            )\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let input = required_arg!(state::input).to_string();\r\n\r\n        use sha2::{Digest, Sha512};\r\n        let mut hasher = Sha512::new();\r\n        hasher.update(input);\r\n\r\n        let s = format!(\"{:X}\", hasher.finalize());\r\n        Ok(Value::from(s))\r\n    }\r\n);\r\n\r\ndefine_stdfunction!(\r\n    md5 {\r\n        input: Standard::String\r\n    },\r\n    returns = String,\r\n    docs = {\r\n        category: \"Cryptographic\",\r\n        description: \"Returns the md5 hash of a given string\",\r\n        ext_description: \"Will return an unsalted md5 hash of the input string.\",\r\n        examples: \"\r\n            assert_eq(\r\n                md5('hello'),\r\n                '5D41402ABC4B2A76B9719D911017C592'\r\n            )\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let input = required_arg!(state::input).to_string();\r\n\r\n        use md5::{Digest, Md5};\r\n        let mut hasher = Md5::new();\r\n        hasher.update(input);\r\n\r\n        let s = format!(\"{:X}\", hasher.finalize());\r\n        Ok(Value::from(s))\r\n    }\r\n);\r\n\r\ndefine_stdfunction!(\r\n    choose {\r\n        options: Standard::Array\r\n    },\r\n    returns = String,\r\n    docs = {\r\n        category: \"Random\",\r\n        description: \"Returns a random element from a given array\",\r\n        ext_description: \"Uses a uniform distribution to select a random element from the input array.\",\r\n        examples: \"\r\n            s = ['a', 'b', 'c']\r\n            assert(\r\n                s contains choose(s)\r\n            )\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let options = required_arg!(state::options).as_a::\u003cVec\u003cValue\u003e\u003e()?;\r\n        if options.is_empty() {\r\n            return oops!(ArrayEmpty);\r\n        }\r\n\r\n        use rand::seq::SliceRandom;\r\n        let mut rng = rand::thread_rng();\r\n        Ok(options.choose(\u0026mut rng).unwrap().to_string().into())\r\n    }\r\n);\r\n\r\ndefine_stdfunction!(\r\n    rand {\r\n        range: Optional::Range\r\n    },\r\n    returns = Numeric,\r\n    docs = {\r\n        category: \"Random\",\r\n        description: \"Returns a random number within a given range, or between 0 and 1 if no range is specified.\",\r\n        ext_description: \"\r\n            If no range is specified, the function will return a random number between 0 and 1.\r\n            If a range is specified, the function will return a random number within that range.\r\n        \",\r\n        examples: \"\r\n            r = rand(0..10)\r\n            assert(\r\n                r \u003e= 0 \u0026\u0026 r \u003c= 10\r\n            )\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        use rand::Rng;\r\n\r\n        if let Some(range) = optional_arg!(state::range) {\r\n            let range = range.as_a::\u003cRange\u003e()?.inner().clone();\r\n            Ok(rand::thread_rng().gen_range(range).into())\r\n        } else {\r\n            Ok(rand::random::\u003cf64\u003e().into())\r\n        }\r\n    }\r\n);\r\n","traces":[{"line":4,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":5,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":6,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":8,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":9,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":10,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":11,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":4},"fn_name":null}],"covered":102,"coverable":102},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","functions","stdlib","string.rs"],"content":"use crate::define_stdfunction;\r\nuse polyvalue::{Value, ValueType};\r\n\r\n/**********************************************\r\n *\r\n * Character functions\r\n *\r\n *********************************************/\r\n\r\ndefine_stdfunction!(\r\n    ord { c: Standard::String },\r\n    returns = I64,\r\n    docs = {\r\n        category: \"String\",\r\n        description: \"Returns the Unicode code point of the character at the specified index.\",\r\n        ext_description: \"\r\n            Will always return a 32bit value, regardless of the width of the character.\r\n            This is the complement of chr(); Output from one is valid input for the other.\r\n        \",\r\n        examples: \"\r\n            assert_eq(97u32, ord('a'))\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let input = required_arg!(state::c).to_string();\r\n        if input.len() != 1 {\r\n            return oops!(Custom {\r\n                msg: \"ord() expected a single character\".to_string()\r\n            });\r\n        }\r\n        let c = input.chars().next().unwrap();\r\n        Ok(Value::from(c as u32))\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    chr { i: Standard::I64 },\r\n    returns = String,\r\n    docs = {\r\n        category: \"String\",\r\n        description: \"Returns a string containing the character represented by the Unicode code point.\",\r\n        ext_description: \"\r\n            This is the complement of ord(); Output from one is valid input for the other.\r\n        \",\r\n        examples: \"\r\n            assert_eq('a', chr(97))\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let input = required_arg!(state::i).as_a::\u003cu32\u003e()?;\r\n        match std::char::from_u32(input) {\r\n            Some(c) =\u003e Ok(Value::from(c.to_string())),\r\n            None =\u003e oops!(Custom {\r\n                msg: \"chr() expected a valid Unicode code point\".to_string()\r\n            }),\r\n        }\r\n    },\r\n);\r\n\r\n/**********************************************\r\n *\r\n * String Manipulation\r\n *********************************************/\r\n\r\ndefine_stdfunction!(\r\n    uppercase { s: Standard::String },\r\n    returns = String,\r\n    docs = {\r\n        category: \"String\",\r\n        description: \"Converts a string to uppercase.\",\r\n        ext_description: \"This function is locale-insensitive and will handle all Unicode characters.\",\r\n        examples: \"\r\n            assert_eq('HELLO', uppercase('hello'))\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let input = required_arg!(state::s).to_string();\r\n        Ok(Value::from(input.to_uppercase().to_string()))\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    lowercase { s: Standard::String },\r\n    returns = String,\r\n    docs = {\r\n        category: \"String\",\r\n        description: \"Converts a string to lowercase.\",\r\n        ext_description: \"This function is locale-insensitive and will handle all Unicode characters.\",\r\n        examples: \"\r\n            assert_eq('hello', lowercase('HELLO'))\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let input = required_arg!(state::s).to_string();\r\n        Ok(Value::from(input.to_lowercase().to_string()))\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    trim { s: Standard::String },\r\n    returns = String,\r\n    docs = {\r\n        category: \"String\",\r\n        description: \"Removes leading and trailing whitespace from a string.\",\r\n        ext_description: \"This function is locale-insensitive and will handle all Unicode characters.\",\r\n        examples: \"\r\n            assert_eq('hello', trim('  hello  '))\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let input = required_arg!(state::s).to_string();\r\n        Ok(Value::from(input.trim().to_string()))\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    trim_start { s: Standard::String },\r\n    returns = String,\r\n    docs = {\r\n        category: \"String\",\r\n        description: \"Removes leading whitespace from a string.\",\r\n        ext_description: \"This function is locale-insensitive and will handle all Unicode characters.\",\r\n        examples: \"\r\n            assert_eq('hello  ', trim_start('  hello  '))\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let input = required_arg!(state::s).to_string();\r\n        Ok(Value::from(input.trim_start().to_string()))\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    trim_end { s: Standard::String },\r\n    returns = String,\r\n    docs = {\r\n        category: \"String\",\r\n        description: \"Removes trailing whitespace from a string.\",\r\n        ext_description: \"This function is locale-insensitive and will handle all Unicode characters.\",\r\n        examples: \"\r\n            assert_eq('  hello', trim_end('  hello  '))\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let input = required_arg!(state::s).to_string();\r\n        Ok(Value::from(input.trim_end().to_string()))\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    replace {\r\n        s: Standard::String,\r\n        from: Standard::String,\r\n        to: Standard::String\r\n    },\r\n    returns = String,\r\n    docs = {\r\n        category: \"String\",\r\n        description: \"Replaces all occurrences of a substring within a string with another string.\",\r\n        ext_description: \"This function is locale-insensitive and will handle all Unicode characters.\",\r\n        examples: \"\r\n            assert_eq('hello world', replace('hello there', 'there', 'world'))\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let input = required_arg!(state::s).to_string();\r\n        let from = required_arg!(state::from).to_string();\r\n        let to = required_arg!(state::to).to_string();\r\n        Ok(Value::from(input.replace(\u0026from, \u0026to)))\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    repeat {\r\n        s: Standard::String,\r\n        n: Standard::I64\r\n    },\r\n    returns = String,\r\n    docs = {\r\n        category: \"String\",\r\n        description: \"Repeats a string a specified number of times.\",\r\n        ext_description: \"This function is locale-insensitive and will handle all Unicode characters.\",\r\n        examples: \"\r\n            assert_eq('hellohellohello', repeat('hello', 3))\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let input = required_arg!(state::s).to_string();\r\n        let n = required_arg!(state::n).as_a::\u003ci32\u003e()?;\r\n        Ok(Value::from(input.repeat(n as usize)))\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    chars {\r\n        s: Standard::String\r\n    },\r\n    returns = Array,\r\n    docs = {\r\n        category: \"String\",\r\n        description: \"Splits a string into its individual characters.\",\r\n        ext_description: \"This function will handle all Unicode characters.\",\r\n        examples: \"\r\n            assert_eq(['h', 'e', 'l', 'l', 'o'], chars('hello'))\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let input = required_arg!(state::s).to_string();\r\n        let chars: Vec\u003cValue\u003e = input.chars().map(|c| c.to_string().into()).collect();\r\n        Ok(Value::from(chars))\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    escape {\r\n        s: Standard::String\r\n    },\r\n    returns = String,\r\n    docs = {\r\n        category: \"String\",\r\n        description: \"Escapes special characters in a string.\",\r\n        ext_description: \"This function will handle all Unicode characters.\",\r\n        examples: \"\r\n            assert_eq('hello\\\\\\\\nworld', escape('hello\\nworld'))\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let input = required_arg!(state::s).to_string();\r\n        let mut output = String::new();\r\n        for c in input.chars() {\r\n            match c {\r\n                '\\n' =\u003e output.push_str(\"\\\\n\"),\r\n                '\\r' =\u003e output.push_str(\"\\\\r\"),\r\n                '\\t' =\u003e output.push_str(\"\\\\t\"),\r\n                '\\\\' =\u003e output.push_str(\"\\\\\\\\\"),\r\n                '\"' =\u003e output.push_str(\"\\\\\\\"\"),\r\n                _ =\u003e output.push(c),\r\n            }\r\n        }\r\n        Ok(Value::from(output))\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    pad_right {\r\n        s: Standard::String,\r\n        length: Standard::I64,\r\n        pad: Optional::String\r\n    },\r\n    returns = String,\r\n    docs = {\r\n        category: \"String\",\r\n        description: \"Pads a string to a specified length with a specified character.\",\r\n        ext_description: \"This function will handle all Unicode characters.\",\r\n        examples: \"\r\n            assert_eq('hello!!!!!!', pad_right('hello', 11, '!'))\r\n            assert_eq('hello      ', pad_right('hello', 11))\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let input = required_arg!(state::s).to_string();\r\n        let length = required_arg!(state::length).as_a::\u003ci64\u003e()?;\r\n        let pad = optional_arg!(state::pad).unwrap_or(Value::string(\" \")).to_string().chars().next().unwrap_or(' ').to_string();\r\n\r\n        let padding: i64 = length - input.len() as i64;\r\n        if padding \u003c= 0 {\r\n            Ok(Value::from(input))\r\n        } else {\r\n            let pad = pad.repeat(padding as usize);\r\n            Ok((input + \u0026pad).into())\r\n        }\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    pad_left {\r\n        s: Standard::String,\r\n        length: Standard::I64,\r\n        pad: Optional::String\r\n    },\r\n    returns = String,\r\n    docs = {\r\n        category: \"String\",\r\n        description: \"Pads a string to a specified length with a specified character.\",\r\n        ext_description: \"This function will handle all Unicode characters.\",\r\n        examples: \"\r\n            assert_eq('!!!!!!hello', pad_left('hello', 11, '!'))\r\n            assert_eq('      hello', pad_left('hello', 11))\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let input = required_arg!(state::s).to_string();\r\n        let length = required_arg!(state::length).as_a::\u003ci64\u003e()?;\r\n        let pad = optional_arg!(state::pad).unwrap_or(Value::string(\" \")).to_string().chars().next().unwrap_or(' ').to_string();\r\n\r\n        let padding: i64 = length - input.len() as i64;\r\n        if padding \u003c= 0 {\r\n            Ok(Value::from(input))\r\n        } else {\r\n            let pad = pad.repeat(padding as usize);\r\n            Ok((pad + \u0026input).into())\r\n        }\r\n    },\r\n);\r\n\r\n/**********************************************\r\n *\r\n * String Formatting\r\n *\r\n *********************************************/\r\n\r\ndefine_stdfunction!(\r\n    format {\r\n        s: Standard::String,\r\n        args: Standard::Array\r\n    },\r\n    returns = String,\r\n    docs = {\r\n        category: \"String\",\r\n        description: \"Formats a string using positional arguments.\",\r\n        ext_description: \"The 2nd argument is an array of values to be consumed in order\",\r\n        examples: \"\r\n            assert_eq('hello world', format('hello {}', ['world']))\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let input = required_arg!(state::s).to_string();\r\n        let args = required_arg!(state::args).as_a::\u003cVec\u003cValue\u003e\u003e()?;\r\n        let args: Vec\u003cString\u003e = args\r\n            .iter()\r\n            .map(|v| v.to_string())\r\n            .collect();\r\n\r\n        let mut result = input;\r\n        for arg in args {\r\n            let arg = arg.clone().to_string();\r\n            // Replace first instance of {} with arg\r\n            result = result.replacen(\"{}\", \u0026arg, 1);\r\n        }\r\n\r\n        Ok(result.into())\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    prettyjson { s: Standard::Object },\r\n    returns = String,\r\n    docs = {\r\n        category: \"String\",\r\n        description: \"Formats a JSON string for human readability.\",\r\n        ext_description: \"This function will handle all Unicode characters.\",\r\n        examples: \"\r\n            assert_eq(\r\n                '{\\n  \\\"hello\\\": \\\"world\\\"\\n}',\r\n                prettyjson({\\\"hello\\\": \\\"world\\\"})\r\n            )\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let input = required_arg!(state::s).as_type(ValueType::Object)?.to_json_string();\r\n        let input = serde_json::from_str::\u003cserde_json::Value\u003e(\u0026input)?;\r\n        Ok(Value::from(serde_json::to_string_pretty(\u0026input)?))\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    join {\r\n        parts: Standard::Array,\r\n        joiner: Optional::String\r\n    },\r\n    returns = String,\r\n    docs = {\r\n        category: \"String\",\r\n        description: \"Concatenates an array of values into a single string.\",\r\n        ext_description: \"\r\n            Converts all its arguments to strings and then concatenates them.\r\n            If a joiner is provided, it will be used to separate the parts.\r\n        \",\r\n        examples: \"\r\n            assert_eq('hello world', join(['hello', ' ', 'world']))\r\n            assert_eq('hello world', ['hello', 'world'].join(' '))\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let joiner = optional_arg!(state::joiner).unwrap_or(Value::string(\"\")).to_string();\r\n        let parts = required_arg!(state::parts).as_a::\u003cVec\u003cValue\u003e\u003e()?;\r\n        let parts: Vec\u003cString\u003e = parts\r\n            .iter()\r\n            .map(|v| v.to_string())\r\n            .collect();\r\n        Ok(Value::from(parts.join(\u0026joiner)))\r\n    },\r\n);\r\n\r\n/**********************************************\r\n *\r\n * String Encoding\r\n * urlencode, urldecode, atob, btoa\r\n *********************************************/\r\n\r\n#[cfg(feature = \"encoding-functions\")]\r\ndefine_stdfunction!(\r\n    url_encode { s: Standard::String },\r\n    returns = String,\r\n    docs = {\r\n        category: \"String\",\r\n        description: \"Encodes a string as a URL-safe string.\",\r\n        ext_description: \"This function will handle all Unicode characters.\",\r\n        examples: \"\r\n            assert_eq('hello%20world', url_encode('hello world'))\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let input = required_arg!(state::s).to_string();\r\n        Ok(Value::from(urlencoding::encode(\u0026input).into_owned()))\r\n    },\r\n);\r\n\r\n#[cfg(feature = \"encoding-functions\")]\r\ndefine_stdfunction!(\r\n    url_decode { s: Standard::String },\r\n    returns = String,\r\n    docs = {\r\n        category: \"String\",\r\n        description: \"Decodes a URL-safe string into a normal string.\",\r\n        ext_description: \"This function will handle all Unicode characters.\",\r\n        examples: \"\r\n            assert_eq('hello world', url_decode('hello%20world'))\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let input = required_arg!(state::s).to_string();\r\n        Ok(Value::from(urlencoding::decode(\u0026input)?.into_owned()))\r\n    },\r\n);\r\n\r\n#[cfg(feature = \"encoding-functions\")]\r\ndefine_stdfunction!(\r\n    base64_encode { s: Standard::String },\r\n    returns = String,\r\n    docs = {\r\n        category: \"String\",\r\n        description: \"Encodes a string into base64\",\r\n        ext_description: \"This function will handle all Unicode characters.\",\r\n        examples: \"\r\n            assert_eq('aGVsbG8gd29ybGQ=', base64_encode('hello world'))\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let input = required_arg!(state::s).to_string();\r\n\r\n        use base64::{engine::general_purpose, Engine as _};\r\n        let mut buf = String::new();\r\n        general_purpose::STANDARD.encode_string(\u0026input, \u0026mut buf);\r\n        Ok(Value::from(buf))\r\n    },\r\n);\r\n\r\n#[cfg(feature = \"encoding-functions\")]\r\ndefine_stdfunction!(\r\n    base64_decode { s: Standard::String },\r\n    returns = String,\r\n    docs = {\r\n        category: \"String\",\r\n        description: \"Decodes a base64 string into a string.\",\r\n        ext_description: \"This function will handle all Unicode characters.\",\r\n        examples: \"\r\n            assert_eq('hello world', base64_decode('aGVsbG8gd29ybGQ='))\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let input = required_arg!(state::s).to_string();\r\n\r\n        use base64::{engine::general_purpose, Engine as _};\r\n        if let Ok(bytes) = general_purpose::STANDARD.decode(input) {\r\n            if let Ok(s) = std::str::from_utf8(\u0026bytes) {\r\n                return Ok(Value::from(s));\r\n            }\r\n        }\r\n\r\n        oops!(\r\n            ValueFormat {\r\n                expected_format: \"base64\".to_string()\r\n            }\r\n        )\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    from_json {\r\n        s: Standard::String\r\n    },\r\n    returns = Any,\r\n    docs = {\r\n        category: \"String\",\r\n        description: \"Parses a JSON string into a value.\",\r\n        ext_description: \"This function will handle all Unicode characters.\",\r\n        examples: \"\r\n            assert_eq({\\\"hello\\\": \\\"world\\\"}, from_json('{\\\"hello\\\": \\\"world\\\"}'))\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let input = required_arg!(state::s).to_string();\r\n        let input = serde_json::from_str::\u003cserde_json::Value\u003e(\u0026input)?;\r\n        Ok(Value::try_from(input)?)\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    to_json {\r\n        v: Standard::Any\r\n    },\r\n    returns = String,\r\n    docs = {\r\n        category: \"String\",\r\n        description: \"Converts a value into a JSON string.\",\r\n        ext_description: \"\r\n            Objects will be encoded as (key, value) pairs, due to differences between JSON and lavendeux.\r\n        \",\r\n        examples: \"\r\n            assert_eq('{\\\"hello\\\":\\\"world\\\"}', to_json({'hello': 'world'}))\r\n        \"\r\n    },\r\n    handler = (state, _reference) {\r\n        let input = required_arg!(state::v).to_json_string();\r\n        Ok(Value::from(input))\r\n    },\r\n);\r\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":11,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":281,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":282,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":288,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":298,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":313,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":318,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":321,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":322,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":323,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":326,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":328,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":329,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":330,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":331,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":334,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":335,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":336,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":338,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":341,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":345,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":346,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":347,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":348,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":351,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":352,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":354,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":357,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":359,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":360,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":361,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":362,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":366,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":367,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":368,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":369,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":371,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":372,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":373,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":374,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":375,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":376,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":377,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":379,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":380,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":381,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":382,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":384,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":385,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":386,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":387,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":388,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":389,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":390,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":391,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":402,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":403,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":404,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":405,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":406,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":407,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":408,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":409,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":410,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":411,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":413,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":414,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":415,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":420,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":421,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":422,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":423,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":424,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":425,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":426,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":427,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":428,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":429,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":431,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":432,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":433,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":438,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":439,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":440,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":441,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":442,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":443,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":444,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":445,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":446,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":447,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":449,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":450,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":452,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":453,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":454,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":455,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":460,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":461,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":462,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":463,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":464,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":465,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":466,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":467,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":468,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":469,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":471,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":472,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":474,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":475,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":476,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":477,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":481,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":482,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":483,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":489,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":490,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":491,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":493,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":494,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":495,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":496,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":497,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":498,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":499,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":500,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":502,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":503,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":504,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":505,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":509,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":510,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":511,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":513,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":514,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":515,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":516,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":517,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":518,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":519,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":520,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":521,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":522,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":524,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":525,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":526,"address":[],"length":0,"stats":{"Line":4},"fn_name":null}],"covered":377,"coverable":377},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","functions","stdlib","system.rs"],"content":"use crate::{\r\n    define_stdfunction,\r\n    documentation::{DocumentationTemplate, MarkdownFormatter},\r\n    error::{ErrorDetails, WrapOption},\r\n    syntax_tree::traits::NodeExt,\r\n    Lavendeux,\r\n};\r\nuse polyvalue::{types::Object, Value};\r\n\r\n/**********************************************\r\n *\r\n * Code and Evaluation\r\n *\r\n *********************************************/\r\n\r\ndefine_stdfunction!(\r\n   call_function {\r\n       name: Standard::String,\r\n       args: Standard::Array\r\n   },\r\n   returns = Any,\r\n\r\n   docs = {\r\n       category: \"System\",\r\n       description: \"Calls a function or @decorator by name with the given arguments\",\r\n       ext_description: \"\r\n            If the name begins with '@', it will be treated as a decorator.\r\n            Maps the given object to the function's arguments and calls the function.\r\n            Important note: Functions that take in a _reference, such as pop/push etc, will act by-value and not modify the original object.\r\n        \",\r\n       examples: \"\r\n            @test(x) = x\r\n            assert_eq('5', call_function('@test', {'x': 5}))\r\n        \",\r\n   },\r\n\r\n    handler = (state, _reference) {\r\n         let name = required_arg!(state::name).to_string();\r\n         let args = required_arg!(state::args).as_a::\u003cVec\u003cValue\u003e\u003e()?;\r\n\r\n         state.call_function(\u0026name, args, None)\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    eval {\r\n        expression: Standard::String\r\n    },\r\n    returns = Any,\r\n\r\n    docs = {\r\n        category: \"System\",\r\n        description: \"Evaluates a string as a Lavendeux expression and returns the result\",\r\n        ext_description: \"\r\n            The string will be interpreted as a script and evaluated in it's own scope.\r\n            If there are multiple lines, an array of values will be returned.\r\n        \",\r\n        examples: \"\r\n            assert_eq(5, eval('2 + 3'))\r\n            assert_eq([6, 6], eval('x = 6; x'))\r\n            assert_eq([1, 2, 3], eval('1\\\\n2\\\\n3'))\r\n        \",\r\n    },\r\n    handler = (state, _reference) {\r\n        let expression = required_arg!(state::expression).to_string();\r\n\r\n        state.scope_into()?;\r\n        state.lock_scope();\r\n        let res = Lavendeux::eval(\u0026expression, state).map(|n| n.evaluate(state));\r\n\r\n        let mut values = match res {\r\n            Ok(r) =\u003e {\r\n                match r {\r\n                    Ok(v) =\u003e v,\r\n                    Err(e) =\u003e {\r\n                        state.scope_out();\r\n                        return Err(e);\r\n                    }\r\n                }\r\n            },\r\n            Err(e) =\u003e {\r\n                state.scope_out();\r\n                return Err(e);\r\n            }\r\n        };\r\n\r\n        state.scope_out();\r\n        if values.len() == 1 {\r\n            values = values.as_a::\u003cVec\u003cValue\u003e\u003e()?.into_iter().next().unwrap();\r\n        }\r\n        Ok(values)\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    include {\r\n        filename: Standard::String\r\n    },\r\n    returns = Any,\r\n\r\n    docs = {\r\n        category: \"System\",\r\n        description: \"Evaluates a file as a Lavendeux expression and returns the result\",\r\n        ext_description: \"\r\n            The file will be interpreted as a script and evaluated in it's own scope.\r\n            Returns an empty string in all cases.\r\n        \",\r\n        examples: \"\r\n            include('example_scripts/stdlib.lav')\r\n        \",\r\n    },\r\n    handler = (state, _reference) {\r\n        let script = required_arg!(state::filename).to_string();\r\n        let script = std::fs::read_to_string(script)?;\r\n\r\n        state.scope_into()?;\r\n        state.lock_scope();\r\n        let res = Lavendeux::eval(\u0026script, state).map(|n| n.evaluate(state));\r\n        match res {\r\n            Ok(r) =\u003e {\r\n                match r {\r\n                    Ok(v) =\u003e v,\r\n                    Err(e) =\u003e {\r\n                        state.scope_out();\r\n                        return Err(e);\r\n                    }\r\n                }\r\n            },\r\n            Err(e) =\u003e {\r\n                state.scope_out();\r\n                return Err(e);\r\n            }\r\n        };\r\n\r\n        state.scope_out();\r\n        Ok(Value::from(\"\"))\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    __exec_tests {\r\n    },\r\n    returns = Any,\r\n\r\n    docs = {\r\n        category: \"System\",\r\n        description: \"Evaluates all functions beginning with __test_, and reports a list of failed tests\",\r\n        ext_description: \"\r\n            Designed to be used mostly for internal testing, could be useful to testing scripts.\r\n            Throws an error if a test fails, otherwise returns a string with the number of tests run and the number of tests failed.\r\n        \",\r\n        examples: \"#skip\r\n            __test_will_fail() = assert_eq(1, 2)\r\n            __test_will_pass() = assert_eq(1, 1)\r\n            __exec_tests()\r\n            /* Output:\r\n            Errors:\r\n\r\n            In __test_will_fail: \r\n            Line 1: assert_eq (1, 2)\r\n                Assertion failed: 1 != 2\r\n                \r\n            2 tests run, 1 failed\r\n             */\r\n        \",\r\n    },\r\n    handler = (state, _reference) {\r\n        let matching_functions = state\r\n            .all_functions()\r\n            .iter()\r\n            .filter(|(name, _)| name.starts_with(\"__test_\"))\r\n            .map(|(name, _)| name.clone())\r\n            .collect::\u003cVec\u003c_\u003e\u003e();\r\n\r\n        let mut errors = vec![];\r\n        for test_case in matching_functions.iter() {\r\n            state.scope_into()?;\r\n            state.lock_scope();\r\n            let res = state.call_function(test_case, vec![], None);\r\n            state.scope_out();\r\n\r\n            if let Err(e) = res {\r\n                errors.push((test_case, e));\r\n            }\r\n        }\r\n\r\n        let mut output = String::new();\r\n        if !errors.is_empty() {\r\n            output.push_str(\"Errors:\\n\\n\");\r\n            for (name, e) in errors.iter() {\r\n                output.push_str(\u0026format!(\"In {}:\\n{}\\n\\n\", name, e));\r\n            }\r\n        }\r\n\r\n        output.push_str(\u0026format!(\r\n            \"{} tests run, {} failed\",\r\n            matching_functions.len(),\r\n            errors.len()\r\n        ));\r\n\r\n        if errors.is_empty() {\r\n            Ok(Value::from(format!(\"{} tests run, all passed\", matching_functions.len())))\r\n        } else {\r\n            oops!(Custom { msg: output })\r\n        }\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    generate_documentation {},\r\n    returns = String,\r\n    docs = {\r\n        category: \"System\",\r\n        description: \"Generates documentation for all standard library functions\",\r\n        ext_description: \"\r\n            Returns a markdown-formatted string containing documentation for all standard library functions.\r\n        \",\r\n        examples: \"\r\n            generate_documentation()\r\n        \",\r\n    },\r\n    handler = (state, _reference) {\r\n        Ok(DocumentationTemplate::new(MarkdownFormatter).render(state).into())\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    document_function {\r\n        name: Standard::String,\r\n        docs: Standard::Object\r\n    },\r\n    returns = String,\r\n    docs = {\r\n        category: \"System\",\r\n        description: \"Adds documentation to a user-defined function\",\r\n        ext_description: \"\r\n            Adds documentation to a function, which will be displayed help()\r\n            The documentation object should contain the keys 'category', 'description', 'ext_description', and 'examples'.\r\n        \",\r\n        examples: \"\r\n            a() = 5\r\n            document_function('a', {\r\n                'category': 'System',\r\n                'description': 'Adds documentation to a function',\r\n                'ext_description': 'Adds documentation to a function, which will be displayed in the documentation.',\r\n                'examples': 'document_function(\\\"document_function\\\", {\\\"category\\\": \\\"System\\\", \\\"description\\\": \\\"Adds documentation to a function\\\", \\\"ext_description\\\": \\\"Adds documentation to a function, which will be displayed in the documentation.\\\"})'\r\n            })\r\n        \",\r\n    },\r\n    handler = (state, _reference) {\r\n        let name = required_arg!(state::name).to_string();\r\n        let docs = required_arg!(state::docs).as_a::\u003cObject\u003e()?;\r\n\r\n        let function = state.get_function_mut(\u0026name).or_error(ErrorDetails::FunctionName { name: name.clone() })?;\r\n        if function.is_readonly() {\r\n            return oops!(Custom {\r\n                msg: \"Cannot modify a readonly function\".to_string()\r\n            })\r\n        }\r\n\r\n        if let Some(category) = docs.get(\u0026\"category\".into()) {\r\n            function.documentation_mut().set_category(\u0026category.to_string());\r\n        }\r\n\r\n        let ext_desc: Option\u003cString\u003e = docs.get(\u0026\"description\".into()).map(|v| v.to_string());\r\n        function.documentation_mut().set_description(ext_desc.as_deref());\r\n\r\n        let ext_desc: Option\u003cString\u003e = docs.get(\u0026\"ext_description\".into()).map(|v| v.to_string());\r\n        function.documentation_mut().set_ext_description(ext_desc.as_deref());\r\n\r\n        let ext_desc: Option\u003cString\u003e = docs.get(\u0026\"examples\".into()).map(|v| v.to_string());\r\n        function.documentation_mut().set_examples(ext_desc.as_deref());\r\n\r\n        Ok(state.help(Some(name)).into())\r\n    },\r\n);\r\n\r\n/**********************************************\r\n *\r\n * Assertions and Errors\r\n *\r\n *********************************************/\r\n\r\ndefine_stdfunction!(\r\n    assert {\r\n        condition: Standard::Any\r\n    },\r\n    returns = Any,\r\n\r\n    docs = {\r\n        category: \"System\",\r\n        description: \"Throws an error if the condition is false\",\r\n        ext_description: \"\r\n            Does a weak-comparison to boolean, so 0, '', [], etc. are all considered false.\r\n            Returns the value otherwise\r\n        \",\r\n        examples: \"\r\n            assert(true)\r\n            assert( would_err('assert(false)') )\r\n        \",\r\n    },\r\n    handler = (state, _reference) {\r\n        let cond = required_arg!(state::condition);\r\n        if cond.is_truthy() {\r\n            Ok(cond.clone())\r\n        } else {\r\n            oops!(Custom {\r\n                msg: \"Assertion failed\".to_string()\r\n            })\r\n        }\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    assert_eq {\r\n        condition: Standard::Any,\r\n        expected: Standard::Any\r\n    },\r\n    returns = Any,\r\n\r\n    docs = {\r\n        category: \"System\",\r\n        description: \"Asserts that 2 values are equal\",\r\n        ext_description: \"\r\n            Raises an error if the condition is not equal to the expected value.\r\n            Also verifies type, as opposed to the `==` operator, which uses weak typing.\r\n            use assert(a == b) if you want to compare values without checking their types.\r\n        \",\r\n        examples: \"\r\n            assert_eq(true, true)\r\n            assert_eq( true, would_err('assert_eq(1, true)') )\r\n        \",\r\n    },\r\n    handler = (state, _reference) {\r\n        let cond = required_arg!(state::condition);\r\n        let expected = required_arg!(state::expected);\r\n\r\n        if cond == expected {\r\n            Ok(cond.clone())\r\n        } else {\r\n            let message = format!(\"Assertion failed: {:?} != {:?}\", cond, expected);\r\n            oops!(Custom { msg: message })\r\n        }\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    would_err {\r\n        expression: Standard::String\r\n    },\r\n    returns = Bool,\r\n\r\n    docs = {\r\n        category: \"System\",\r\n        description: \"Returns true if the given expression would raise an error\",\r\n        ext_description: \"\r\n            Returns true if expression given by the string would raise an error, false otherwise.\r\n            This is useful for testing error messages.\r\n        \",\r\n        examples: \"\r\n            assert_eq( false, would_err('1 + 1') )\r\n            assert_eq( true, would_err('1 + asparagus') )\r\n        \",\r\n    },\r\n    handler = (state, _reference) {\r\n        let expression = required_arg!(state::expression).to_string();\r\n        let res = crate::Lavendeux::eval(\u0026expression, state).map(|n| n.evaluate(state));\r\n        match res {\r\n            Ok(r) if r.is_ok() =\u003e Ok(Value::from(false)),\r\n            _ =\u003e Ok(Value::from(true))\r\n        }\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    error {\r\n        msg: Standard::String\r\n    },\r\n    returns = Any,\r\n\r\n    docs = {\r\n        category: \"System\",\r\n        description: \"Throws an error with the given message\",\r\n        ext_description: \"\r\n            Throws an exception with a custom message. The error's source will be the line where the error was thrown.\r\n        \",\r\n        examples: \"\r\n            would_err('error(\\\"This is an error\\\")')\r\n        \",\r\n    },\r\n    handler = (state, _reference) {\r\n        let message = required_arg!(state::msg).to_string();\r\n        oops!(Custom { msg: message })\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    debug {\r\n        msg: Standard::String\r\n    },\r\n    returns = Any,\r\n\r\n    docs = {\r\n        category: \"System\",\r\n        description: \"Prints a debug message to the console\",\r\n        ext_description: \"\r\n            The message will be both written to stdout, and returned as a string.\r\n            If the parser is not attached to a console, it will not be visible.\r\n        \",\r\n        examples: \"\r\n            debug(\\\"This is a debug message\\\")\r\n        \",\r\n    },\r\n    handler = (state, _reference) {\r\n        let message = required_arg!(state::msg).to_string();\r\n        println!(\"{message}\");\r\n        Ok(Value::string(message))\r\n    },\r\n);\r\n\r\n/**********************************************\r\n *\r\n * Assignments and Variables\r\n *\r\n *********************************************/\r\n\r\ndefine_stdfunction!(\r\n    assign {\r\n        name: Standard::String,\r\n        value: Standard::Any\r\n    },\r\n    returns = Any,\r\n\r\n    docs = {\r\n        category: \"System\",\r\n        description: \"Assigns a variable in the current scope\",\r\n        ext_description: \"\r\n            Writes a value to the current scope, leaving other scopes unchanged.\r\n        \",\r\n        examples: \"\r\n            x = 5\r\n            if true then {\r\n                assign('x', 6)\r\n                assert_eq(6, x)\r\n            } else nil\r\n            assert_eq(5, x)\r\n        \",\r\n    },\r\n    handler = (state, _reference) {\r\n        let name = required_arg!(state::name).to_string();\r\n        let value = required_arg!(state::value);\r\n        state.set_variable_in_offset(1, \u0026name, value.clone());\r\n        Ok(value)\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    assign_global {\r\n        name: Standard::String,\r\n        value: Standard::Any\r\n    },\r\n    returns = Any,\r\n\r\n    docs = {\r\n        category: \"System\",\r\n        description: \"Assigns a variable in the top-level scope\",\r\n        ext_description: \"\r\n            Writes a value to the top-level scope, leaving other scopes unchanged.\r\n        \",\r\n        examples: \"\r\n            x = 5\r\n            if true then {\r\n                assign_global('x', 6)\r\n                assert_eq(6, x)\r\n            } else { 0 }\r\n            assert_eq(6, x)\r\n        \",\r\n    },\r\n    handler = (state, _reference) {\r\n        let name = required_arg!(state::name).to_string();\r\n        let value = required_arg!(state::value);\r\n        state.global_assign_variable(\u0026name, value.clone());\r\n        Ok(value.clone())\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    global {\r\n        name: Standard::String\r\n    },\r\n    returns = Any,\r\n\r\n    docs = {\r\n        category: \"System\",\r\n        description: \"Returns a variable from the top-level scope\",\r\n        ext_description: \"\r\n            Searches for the variable in the top-level scope only\r\n        \",\r\n        examples: \"\r\n            assign_global('x', 6)\r\n            assert_eq(6, global('x'))\r\n        \",\r\n    },\r\n    handler = (state, _reference) {\r\n        let name = required_arg!(state::name).to_string();\r\n        let value = state.global_get_variable(\u0026name).or_error(ErrorDetails::VariableName {\r\n            name\r\n        })?;\r\n        Ok(value.clone())\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    variables { },\r\n    returns = Object,\r\n\r\n    docs = {\r\n        category: \"System\",\r\n        description: \"Returns the currently defined variables\",\r\n        ext_description: \"\r\n            Returns a map of all the variables currently defined in the current scope.\r\n        \",\r\n        examples: \"\r\n            x = 5; y = 6\r\n            state = variables()\r\n            assert_eq(5, state['x'])\r\n            assert_eq(6, state['y'])\r\n        \",\r\n    },\r\n    handler = (state, _reference) {\r\n        let obj = Object::try_from(\r\n            state.all_variables_unscoped()\r\n                .iter()\r\n                .map(|(k, v)| (Value::from(k.to_string()), (*v).clone()))\r\n                .collect::\u003cVec\u003c(Value, Value)\u003e\u003e(),\r\n        )?;\r\n\r\n        Ok(obj.into())\r\n    },\r\n);\r\n\r\ndefine_stdfunction!(\r\n    typeof {\r\n        value: Standard::Any\r\n    },\r\n    returns = String,\r\n\r\n    docs = {\r\n        category: \"System\",\r\n        description: \"Returns the type of its input\",\r\n        ext_description: \"\r\n            Returns the type of the given value as a string.\r\n        \",\r\n        examples: \"\r\n            assert_eq('string', typeof('hello'))\r\n            assert_eq('i64', typeof(5))\r\n            assert_eq('object', typeof({}))\r\n        \",\r\n    },\r\n    handler = (state, _reference) {\r\n        let value = required_arg!(state::value);\r\n        Ok(Value::string(value.own_type().to_string()))\r\n    },\r\n);\r\n\r\n#[cfg(test)]\r\nmod test {\r\n    use crate::lav;\r\n\r\n    lav!(test_exec_tests_bad(Error) r#\"\r\n        __test_will_fail() = assert_eq(1, 2)\r\n        __test_will_pass() = assert_eq(1, 1)\r\n        __exec_tests()\r\n    \"#);\r\n\r\n    lav!(test_exec_tests_good r#\"\r\n        __test_will_pass() = assert_eq(1, 1)\r\n        __exec_tests()\r\n    \"#);\r\n}\r\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":37},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":694},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":694},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":694},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":694},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":694},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":694},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":694},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":694},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":694},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":694},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":694},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":694},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":694},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":694},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":694},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":694},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":694},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":867},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":1040},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":1040},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":867},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":866},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":695},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":695},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":37},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":61},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":59},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":35},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":281,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":288,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":290,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":303,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":306,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":307,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":310,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":313,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":316,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":318,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":329,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":330,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":331,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":334,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":336,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":337,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":338,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":339,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":340,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":341,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":342,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":344,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":345,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":346,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":347,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":348,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":351,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":352,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":354,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":359,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":360,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":361,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":362,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":364,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":366,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":367,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":368,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":369,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":370,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":371,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":372,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":373,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":374,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":375,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":376,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":377,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":379,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":381,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":382,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":383,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":384,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":385,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":389,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":390,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":391,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":393,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":395,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":396,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":397,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":398,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":399,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":400,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":401,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":402,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":403,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":404,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":406,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":407,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":408,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":409,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":411,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":415,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":416,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":417,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":419,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":420,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":421,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":422,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":423,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":424,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":425,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":426,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":427,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":428,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":429,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":430,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":432,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":433,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":434,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":435,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":436,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":437,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":438,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":441,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":445,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":446,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":447,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":449,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":451,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":452,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":453,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":454,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":455,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":456,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":457,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":458,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":459,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":460,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":461,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":463,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":464,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":465,"address":[],"length":0,"stats":{"Line":10},"fn_name":null}],"covered":300,"coverable":328},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","functions","stdlib","trig.rs"],"content":"use crate::define_stdfunction;\r\nuse polyvalue::Value;\r\n\r\nmacro_rules! define_trigfunction {\r\n    ($name:ident, examples = $examples:literal) =\u003e {\r\n        define_stdfunction!(\r\n            $name {\r\n                n: Standard::Numeric\r\n            },\r\n            returns = Float,\r\n            docs = {\r\n                category: \"Trigonometry\",\r\n                description: concat!(\"Calculate the \", stringify!($name), \" of n\"),\r\n                ext_description: \"\r\n                    Returns a result for the angle n (in radians).\r\n                    You can use the `to_degrees` and `to_radians` functions to convert between degrees and radians.\r\n                \",\r\n                examples: $examples,\r\n            },\r\n            handler = (state, _reference) {\r\n                let n = required_arg!(state::n).as_a::\u003cf64\u003e()?;\r\n                Ok(Value::from(n.$name()))\r\n            }\r\n        );\r\n    };\r\n}\r\n\r\ndefine_trigfunction!(sin, examples = \"assert_eq( 0.0, sin(0) )\");\r\ndefine_trigfunction!(asin, examples = \"assert_eq( 0.0, asin(0) )\");\r\ndefine_trigfunction!(sinh, examples = \"assert_eq( 0.0, sinh(0) )\");\r\ndefine_trigfunction!(asinh, examples = \"assert_eq( 0.0, asinh(0) )\");\r\n\r\ndefine_trigfunction!(cos, examples = \"assert_eq( 1.0, cos(0) )\");\r\ndefine_trigfunction!(acos, examples = \"assert_eq( 0.0, acos(1) )\");\r\ndefine_trigfunction!(cosh, examples = \"assert_eq( 1.0, cosh(0) )\");\r\ndefine_trigfunction!(acosh, examples = \"assert_eq( 0.0, acosh(1) )\");\r\n\r\ndefine_trigfunction!(tan, examples = \"assert_eq( 0.0, tan(0) )\");\r\ndefine_trigfunction!(atan, examples = \"assert_eq( 0.0, atan(0) )\");\r\ndefine_trigfunction!(tanh, examples = \"assert_eq( 0.0, tanh(0) )\");\r\ndefine_trigfunction!(atanh, examples = \"assert_eq( 0.0, atanh(0) )\");\r\n","traces":[{"line":20,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":3},"fn_name":null}],"covered":14,"coverable":14},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","functions","stdlib.rs"],"content":"use super::std_function::ParserFunction;\r\nuse std::collections::HashMap;\r\n\r\nmod bitwise;\r\nmod collections;\r\nmod dev;\r\nmod math;\r\nmod string;\r\nmod system;\r\nmod trig;\r\n\r\n#[cfg(feature = \"crypto-functions\")]\r\nmod random;\r\n\r\nmod decorators_currency;\r\nmod decorators_numeric;\r\nmod decorators_types;\r\n\r\n#[cfg(feature = \"network-functions\")]\r\nmod network;\r\n\r\ninventory::collect!(\u0026'static dyn ParserFunction);\r\n/// Returns a map of all standard library functions\r\n/// Used by the state to load stdlib\r\npub fn all() -\u003e HashMap\u003cString, Box\u003cdyn ParserFunction\u003e\u003e {\r\n    inventory::iter::\u003c\u0026'static dyn ParserFunction\u003e\r\n        .into_iter()\r\n        .map(|f| (f.name().to_string(), f.clone_self()))\r\n        .collect()\r\n}\r\n\r\n#[cfg(test)]\r\nmod test {\r\n    use crate::{error::ErrorDetails, Error};\r\n\r\n    use super::*;\r\n\r\n    #[test]\r\n    fn test_stdlib_documentation() {\r\n        let mut parser = crate::Lavendeux::new(Default::default());\r\n        let stdlib = all();\r\n\r\n        let mut errors = vec![];\r\n\r\n        for (name, function) in stdlib {\r\n            let examples = function.documentation().examples().unwrap();\r\n            let skip_example = examples.starts_with(\"#skip\");\r\n            let examples = examples.trim_start_matches(\"#skip\").trim();\r\n            if examples.is_empty() {\r\n                errors.push(Error {\r\n                    details: ErrorDetails::Custom {\r\n                        msg: format!(\r\n                            \"No examples for function {}::{name}\",\r\n                            function.documentation().category()\r\n                        ),\r\n                    },\r\n                    source: None,\r\n                    context: None,\r\n                });\r\n                continue;\r\n            }\r\n\r\n            if skip_example {\r\n                continue;\r\n            }\r\n\r\n            match parser.parse(\u0026examples) {\r\n                Ok(_) =\u003e {}\r\n                Err(e) =\u003e {\r\n                    errors.push(Error {\r\n                        details: ErrorDetails::Custom {\r\n                            msg: format!(\r\n                                \"Failed to parse example for function {}::{name}\",\r\n                                function.documentation().category()\r\n                            ),\r\n                        },\r\n                        source: Some(Box::new(e)),\r\n                        context: None,\r\n                    });\r\n                }\r\n            }\r\n        }\r\n\r\n        for e in errors.iter() {\r\n            eprintln!(\"\\n{}\\n\", e);\r\n        }\r\n\r\n        assert!(\r\n            errors.is_empty(),\r\n            \"Some documentation tests failed. See output for details.\"\r\n        );\r\n    }\r\n}\r\n","traces":[{"line":25,"address":[],"length":0,"stats":{"Line":57},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":57},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":7467},"fn_name":null}],"covered":3,"coverable":3},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","functions","user_function.rs"],"content":"use std::borrow::Cow;\r\n\r\nuse crate::{\r\n    error::ErrorDetails,\r\n    syntax_tree::{\r\n        traits::{IntoOwned, NodeExt},\r\n        AssignmentTarget, Node,\r\n    },\r\n    Error, Lavendeux, Rule, State,\r\n};\r\nuse polyvalue::{Value, ValueType};\r\n\r\nuse super::{\r\n    documentation::UserFunctionDocumentation,\r\n    std_function::{FunctionArgument, FunctionArgumentType, ParserFunction},\r\n    FunctionDocumentation,\r\n};\r\n\r\n/// A user-defined function\r\n/// This is a function defined in lavendish, and is not a part of the standard library\r\n#[derive(Debug, Clone)]\r\npub struct UserDefinedFunction\u003c'i\u003e {\r\n    name: String,\r\n    args: Vec\u003c(String, ValueType)\u003e,\r\n    returns: ValueType,\r\n    src: String,\r\n    body: Node\u003c'i\u003e,\r\n\r\n    src_line_offset: usize,\r\n\r\n    own_docs: UserFunctionDocumentation,\r\n}\r\nimpl ParserFunction for UserDefinedFunction\u003c'_\u003e {\r\n    fn name(\u0026self) -\u003e \u0026str {\r\n        \u0026self.name\r\n    }\r\n\r\n    fn documentation(\u0026self) -\u003e \u0026dyn FunctionDocumentation {\r\n        \u0026self.own_docs\r\n    }\r\n\r\n    fn documentation_mut(\u0026mut self) -\u003e \u0026mut dyn FunctionDocumentation {\r\n        \u0026mut self.own_docs\r\n    }\r\n\r\n    fn return_type(\u0026self) -\u003e ValueType {\r\n        self.returns\r\n    }\r\n\r\n    fn expected_arguments(\u0026self) -\u003e Vec\u003c(Cow\u003c'static, str\u003e, FunctionArgument)\u003e {\r\n        // map self.args to FunctionArgument Standard/All\r\n        self.args\r\n            .iter()\r\n            .map(|(name, expects)| {\r\n                (\r\n                    Cow::Owned(name.clone()),\r\n                    FunctionArgument {\r\n                        expected_type: *expects,\r\n                        meta: FunctionArgumentType::Standard,\r\n                    },\r\n                )\r\n            })\r\n            .collect()\r\n    }\r\n\r\n    fn clone_self(\u0026self) -\u003e Box\u003cdyn ParserFunction\u003e {\r\n        Box::new(UserDefinedFunction {\r\n            name: self.name.clone(),\r\n            args: self.args.clone(),\r\n            returns: self.returns,\r\n            src: self.src.clone(),\r\n            body: UserDefinedFunction::compile(\u0026self.src, \u0026mut Default::default()).unwrap(), // This is safe because the function is already checked\r\n\r\n            src_line_offset: self.src_line_offset,\r\n\r\n            own_docs: self.own_docs.clone(),\r\n        })\r\n    }\r\n\r\n    fn call(\r\n        \u0026self,\r\n        state: \u0026mut State,\r\n        _reference: Option\u003c\u0026AssignmentTarget\u003e,\r\n    ) -\u003e Result\u003cValue, Error\u003e {\r\n        // Execute the body - this is checked in the constructor\r\n        // so we can unwrap here\r\n        match self.body.evaluate(state) {\r\n            Ok(v) =\u003e Ok(v.as_type(self.returns)?),\r\n            Err(e) =\u003e {\r\n                if let ErrorDetails::Return { value } = e.details {\r\n                    return Ok(value.as_type(self.returns)?);\r\n                } else {\r\n                    let e = e.offset_linecount(self.src_line_offset);\r\n                    return Err(e);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nimpl UserDefinedFunction\u003c'_\u003e {\r\n    /// Create a new user-defined function\r\n    pub fn new(name: \u0026str, src: String, state: \u0026mut State) -\u003e Result\u003cSelf, Error\u003e {\r\n        let body = Self::compile(\u0026src, state)?;\r\n        Ok(UserDefinedFunction {\r\n            name: name.to_string(),\r\n            args: vec![],\r\n            returns: ValueType::Any,\r\n            body,\r\n            src,\r\n            src_line_offset: 0,\r\n            own_docs: UserFunctionDocumentation {\r\n                category: \"User-Defined Functions\".to_string(),\r\n                description: None,\r\n                ext_description: None,\r\n                examples: None,\r\n            },\r\n        })\r\n    }\r\n\r\n    fn compile(src: \u0026str, state: \u0026mut State) -\u003e Result\u003cNode\u003c'static\u003e, Error\u003e {\r\n        Lavendeux::eval_rule(src, state, Rule::BLOCK).map(|n| n.into_owned())\r\n    }\r\n\r\n    /// Add a required argument to the function\r\n    pub fn add_arg(\u0026mut self, name: \u0026str, t: ValueType) {\r\n        self.args.push((name.to_string(), t));\r\n    }\r\n\r\n    /// Set the return type of the function\r\n    pub fn set_returns(\u0026mut self, t: ValueType) {\r\n        self.returns = t;\r\n    }\r\n\r\n    /// Offset the location in source-code for errors\r\n    pub fn set_src_line_offset(\u0026mut self, offset: usize) {\r\n        self.src_line_offset = offset;\r\n    }\r\n\r\n    /// Get the source code of the function\r\n    pub fn src(\u0026self) -\u003e \u0026str {\r\n        \u0026self.src\r\n    }\r\n\r\n    /// Remove the lifetime from the function\r\n    pub fn into_owned(self) -\u003e UserDefinedFunction\u003c'static\u003e {\r\n        UserDefinedFunction {\r\n            name: self.name,\r\n            args: self.args,\r\n            returns: self.returns,\r\n            body: self.body.into_owned(),\r\n            src: self.src,\r\n            src_line_offset: self.src_line_offset,\r\n            own_docs: self.own_docs,\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":35,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":113},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":58,"coverable":77},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","language_docs.rs"],"content":"#![allow(rustdoc::invalid_html_tags)]\r\n#![allow(rustdoc::broken_intra_doc_links)]\r\n#![doc = include_str!(\"../documentation.md\")]\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","lavendeux.rs"],"content":"use crate::documentation::{DocumentationTemplate, MarkdownFormatter};\r\nuse crate::functions::ParserFunction;\r\nuse crate::pest::LavendeuxParser;\r\nuse crate::syntax_tree::traits::NodeExt;\r\nuse crate::syntax_tree::Node;\r\nuse crate::{Error, Rule, State, Value};\r\nuse std::num::NonZeroUsize;\r\nuse std::time::Duration;\r\n\r\n/// Available options for the parser\r\n/// timeout - The timeout for the parser\r\n/// stack_size - The stack size in bytes for the parsing thread\r\n#[derive(Debug, Clone)]\r\npub struct ParserOptions {\r\n    /// Timeout value to use when building the [State]\r\n    pub timeout: Duration,\r\n\r\n    /// The maximum number of calls to the pest parser\r\n    /// This is used to prevent stack overflows\r\n    pub pest_call_limit: usize,\r\n}\r\nimpl Default for ParserOptions {\r\n    fn default() -\u003e Self {\r\n        Self {\r\n            timeout: Duration::from_secs(0),\r\n            pest_call_limit: 0,\r\n        }\r\n    }\r\n}\r\n\r\n/// The main parser, and the entrypoint for the library\r\n#[derive(Debug)]\r\npub struct Lavendeux {\r\n    state: State,\r\n    options: ParserOptions,\r\n}\r\nimpl Lavendeux {\r\n    /// Create a new Lavendeux instance\r\n    /// The instance will have a new state\r\n    pub fn new(options: ParserOptions) -\u003e Self {\r\n        Self::with_state(options.clone(), State::with_timeout(options.timeout))\r\n    }\r\n\r\n    /// Create a new Lavendeux instance with a given state\r\n    pub fn with_state(options: ParserOptions, state: State) -\u003e Self {\r\n        Self { state, options }\r\n    }\r\n\r\n    /// Register a function with the parser\r\n    pub fn register_function(\u0026mut self, function: impl ParserFunction) -\u003e Result\u003c(), Error\u003e {\r\n        self.state.register_function(function)\r\n    }\r\n\r\n    /// Get a reference to the state\r\n    pub fn state(\u0026self) -\u003e \u0026State {\r\n        \u0026self.state\r\n    }\r\n\r\n    /// Get a mutable reference to the state\r\n    pub fn state_mut(\u0026mut self) -\u003e \u0026mut State {\r\n        \u0026mut self.state\r\n    }\r\n\r\n    /// Evaluate input against a given state, bypassing the normal checks for\r\n    /// threading, timeout, and without sanitizing scope depth\r\n    pub(crate) fn eval\u003c'i\u003e(input: \u0026'i str, state: \u0026mut State) -\u003e Result\u003cNode\u003c'i\u003e, Error\u003e {\r\n        Self::eval_rule(input, state, Rule::SCRIPT)\r\n    }\r\n\r\n    /// Evaluate input against a given state, bypassing the normal checks for\r\n    /// threading, timeout, and without sanitizing scope depth\r\n    pub(crate) fn eval_rule\u003c'i\u003e(\r\n        input: \u0026'i str,\r\n        state: \u0026mut State,\r\n        rule: Rule,\r\n    ) -\u003e Result\u003cNode\u003c'i\u003e, Error\u003e {\r\n        let root = LavendeuxParser::parse2(input, rule)?;\r\n        LavendeuxParser::compile_ast(root, state)\r\n    }\r\n\r\n    /// Parses the given input\r\n    /// Returns an array of values, one for each line in the input\r\n    pub fn parse(\u0026mut self, input: \u0026str) -\u003e Result\u003cVec\u003cValue\u003e, Error\u003e {\r\n        self.state.sanitize_scopes();\r\n        pest::set_call_limit(NonZeroUsize::new(self.options.pest_call_limit));\r\n        self.state.start_timer();\r\n\r\n        let value = Self::eval(input, \u0026mut self.state)?.evaluate(\u0026mut self.state)?;\r\n        let lines = value.as_a::\u003cVec\u003cValue\u003e\u003e()?;\r\n        Ok(lines)\r\n    }\r\n\r\n    /// Run the parser on the given file\r\n    /// Returns an array of values, one for each line in the input\r\n    pub fn run(\u0026mut self, filename: \u0026str) -\u003e Result\u003cVec\u003cValue\u003e, Error\u003e {\r\n        let input = std::fs::read_to_string(filename)?;\r\n        self.parse(\u0026input)\r\n    }\r\n\r\n    /// Generates markdown formatted documentation for the parser\r\n    /// Returns it as a string\r\n    pub fn generate_documentation(\u0026self) -\u003e String {\r\n        DocumentationTemplate::new(MarkdownFormatter).render(\u0026self.state)\r\n    }\r\n}\r\n\r\n// Tests mostly related to the fuzzer\r\n#[cfg(test)]\r\nmod test {\r\n    use super::*;\r\n\r\n    #[test]\r\n    fn test_slow_brackets() {\r\n        let mut parser = Lavendeux::new(ParserOptions {\r\n            timeout: Duration::from_millis(500),\r\n            pest_call_limit: 25000000,\r\n            ..Default::default()\r\n        });\r\n        parser\r\n            .parse(\"X[[[]3[4[bri[z[eeg(e4?estarts_witheHoAs(tX[[[]3[4[bri[z[eee(e4?estarts_\u003ca\")\r\n            .unwrap_err();\r\n        parser\r\n            .parse(\"X[[[]3[4[bri[z[eee(e4?estarts_witheHAso(tX[[[]3[4[bri[z[eee(e4?estarts_\u003ca\")\r\n            .unwrap_err();\r\n        parser\r\n            .parse(\"eeeeeeeA(e5[[4^A(e5[[4^A^eA(e5[[4^A(e5[[4^A^A^\")\r\n            .unwrap_err();\r\n        parser\r\n            .parse(\"eeeeeeA(peeeeeA(eeeeA(peeeeeA(eeA(pA(peeA(pA(pi^A\")\r\n            .unwrap_err();\r\n        parser\r\n                  .parse(\"forirPP[forPorP[f\u0026r[forPorP[ffororPP[forororPP[forPorP[f\u0026r[forPorP[ffororPP[forororPP[forPorP[f\u0026r[forPorP[f\u0026\u0004Br[PP]/b@\u0010]][f\u0026r[P;;P]]]^d]f\u0006\u0026[]P[f\u0026r[forPorP[f\u0026r[PP]-b@]]]^d]PP]][PorP[f\u0026\u0004Br[PP]/b@\u0010]][f\u0026r[P;;P]]]^d]f\u0006\u0026[]P[f\u0026r[forPorP[f\u0026r[PP]-b@]]]^d]PP]][f\u0026r[P;;P]]]^d]f\u0006\u0026[]\")\r\n                 .unwrap_err();\r\n    }\r\n\r\n    #[test]\r\n    fn test_large_fixed_convert() {\r\n        let mut parser = Lavendeux::new(Default::default());\r\n        parser.parse(\r\n            \"1$1666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666662.11\",\r\n        ).unwrap_err();\r\n        parser.parse(\"e8**82asin\").unwrap_err();\r\n        parser.parse(\"e85**88d**e8**8\").unwrap_err();\r\n    }\r\n}\r\n","traces":[{"line":28,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":185},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":185},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":169},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":169},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":169},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":495},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":338},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":169},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":169},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":338},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":169},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":338},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":169},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":169},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":169},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":314},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":157},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":25,"coverable":37},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","lib.rs"],"content":"//!\n#![warn(missing_docs)]\n\n// Language documentation\n// Regenerate this using:\n// `cargo run --bin generate_docs`\npub mod language_docs;\n\n// Utitlity functions for the network related functions in stdlib\n#[cfg(feature = \"network-functions\")]\nmod network;\n\n// Docgen utilities\n#[macro_use]\nmod documentation;\n\n// Errors and error-adjacent gubbins\n#[macro_use]\npub mod error;\npub use error::Error;\n\n// The core parser. Builds the AST and evaluates it.\npub mod pest;\npub use pest::Rule; // exported for Token\nmod syntax_tree;\npub use syntax_tree::AssignmentTarget;\n\n/// Function related definitions\n/// Home of the stdlib, user-functions, and function docs\npub mod functions;\n\n// The main parser state\nmod state;\npub use state::State;\n\n// A token parsed from the input\n// Comes up in error handling\nmod token;\npub use token::Token;\n\n// Main entrypoint for the parser\nmod lavendeux;\npub use lavendeux::{Lavendeux, ParserOptions};\n\n// Experimental memory manager\n//mod memory_manager;\n\n// Public re-export of the polyvalue crate\npub use polyvalue;\npub use polyvalue::Value;\n\n/// A few critical tests for common grammar issues post-update\n#[cfg(test)]\nmod test {\n    use crate::Lavendeux;\n\n    #[test]\n    fn test_empty_input() {\n        let mut lav = Lavendeux::new(Default::default());\n        lav.parse(\"\").expect(\"Failed to parse empty input\");\n    }\n\n    #[test]\n    fn test_stackoverflow() {\n        let mut lav = Lavendeux::new(Default::default());\n        let input = \"[[[[[[[[[[99-7[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[99-7[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[99-7[[[[[[[[[[W[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[9[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[99-7[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[99-7[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[K[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[99-7[[[[[[[[[[[[[[[[[[[[[[[[[9-7[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[99-7[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[K[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[99-7[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[z-0\u0026z\u0026oo]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]\";\n        lav.parse(\u0026input).expect_err(\"this should fail\");\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","network","api.rs"],"content":"use super::request;\r\nuse crate::{error::ErrorDetails, Error};\r\nuse polyvalue::{types::Object, Value, ValueTrait, ValueType};\r\nuse std::collections::HashMap;\r\n\r\n#[derive(Debug, Clone, Default)]\r\npub struct ApiDefinition {\r\n    pub base_url: String,\r\n    pub additional_headers: HashMap\u003cString, String\u003e,\r\n    pub description: String,\r\n    pub examples: String,\r\n    pub auth_key: Option\u003cString\u003e,\r\n}\r\n\r\nimpl ApiDefinition {\r\n    pub fn call(\r\n        \u0026self,\r\n        endpoint: Option\u003c\u0026str\u003e,\r\n        body: Option\u003cString\u003e,\r\n        mut headers: HashMap\u003cString, String\u003e,\r\n    ) -\u003e Result\u003cValue, Error\u003e {\r\n        let endpoint = endpoint.unwrap_or_default().trim_start_matches('/');\r\n        let target = format!(\"{}/{}\", \u0026self.base_url, endpoint);\r\n        if let Some(auth_key) = \u0026self.auth_key {\r\n            headers.insert(\"Authorization\".to_string(), format!(\"Bearer {}\", auth_key));\r\n        }\r\n\r\n        request(\u0026target, body, headers)\r\n    }\r\n}\r\n\r\nimpl TryFrom\u003cValue\u003e for ApiDefinition {\r\n    type Error = ErrorDetails;\r\n    fn try_from(value: Value) -\u003e Result\u003cSelf, Self::Error\u003e {\r\n        let value = if value.is_a(ValueType::String) {\r\n            Object::try_from(vec![(\r\n                Value::from(\"base_url\"),\r\n                Value::from(value.to_string()),\r\n            )])?\r\n        } else {\r\n            value.as_a::\u003cObject\u003e()?\r\n        };\r\n\r\n        let mut base_url =\r\n        value\r\n            .get(\u0026Value::from(\"base_url\"))\r\n            .ok_or(ErrorDetails::ValueFormat {\r\n                expected_format: \"\u003cbase_url: string\u003e | {\u003cbase_url: string\u003e, \u003cdescription: string\u003e, \u003cexamples: string\u003e, \u003cauth_key: string\u003e, \u003cheaders: object\u003e}\".to_string(),\r\n            })?.to_string();\r\n\r\n        base_url = base_url.trim_end_matches('/').to_string();\r\n\r\n        Ok(Self {\r\n            base_url,\r\n\r\n            description: value\r\n                .get(\u0026(\"description\".into()))\r\n                .unwrap_or(\u0026Value::from(\"\"))\r\n                .to_string(),\r\n            examples: value\r\n                .get(\u0026(\"examples\".into()))\r\n                .unwrap_or(\u0026Value::from(\"\"))\r\n                .to_string(),\r\n\r\n            auth_key: value\n                .get(\u0026(\"auth_key\".into())).map(|v| v.to_string()),\r\n\r\n            additional_headers: value\r\n                .get(\u0026(\"additional_headers\".into()))\r\n                .unwrap_or(\u0026Value::from(Object::new(Default::default())))\r\n                .clone()\r\n                .as_a::\u003cObject\u003e()?\r\n                .iter()\r\n                .map(|(k, v)| (k.to_string(), v.to_string()))\r\n                .collect(),\r\n        })\r\n    }\r\n}\r\n\r\nimpl From\u003cApiDefinition\u003e for Value {\r\n    fn from(val: ApiDefinition) -\u003e Self {\r\n        let mut obj = Object::new(Default::default());\r\n        obj.insert(\"base_url\".into(), Value::from(val.base_url))\r\n            .ok();\r\n        obj.insert(\"description\".into(), Value::from(val.description))\r\n            .ok();\r\n        obj.insert(\"examples\".into(), Value::from(val.examples))\r\n            .ok();\r\n\r\n        if let Some(auth_key) = val.auth_key {\r\n            obj.insert(\"auth_key\".into(), Value::from(auth_key)).ok();\r\n        }\r\n\r\n        obj.insert(\r\n            \"additional_headers\".into(),\r\n            Value::try_from(\r\n                val.additional_headers\r\n                    .iter()\r\n                    .map(|(k, v)| (Value::from(k.as_str()), Value::from(v.as_str())))\r\n                    .collect::\u003cVec\u003c(_, _)\u003e\u003e(),\r\n            )\r\n            .unwrap(),\r\n        )\r\n        .ok();\r\n        Value::from(obj)\r\n    }\r\n}\r\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":58},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":64},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":294},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":294},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":294},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":294},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":294},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":297},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":294},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":294},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":294},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":294},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":294},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":353},"fn_name":null}],"covered":23,"coverable":30},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","network","defaults.rs"],"content":"use super::ApiDefinition;\r\nuse std::collections::HashMap;\r\n\r\npub fn default_apis() -\u003e HashMap\u003cString, ApiDefinition\u003e {\r\n    let mut apis = HashMap::new();\r\n\r\n    apis.insert(\r\n        \"httpbin\".to_string(),\r\n        ApiDefinition {\r\n            base_url: \"https://httpbin.org\".to_string(),\r\n            description: \"A simple HTTP Request \u0026 Response Service.\".to_string(),\r\n            examples: \"https://httpbin.org\".to_string(),\r\n            ..Default::default()\r\n        },\r\n    );\r\n\r\n    apis.insert(\r\n        \"ipify\".to_string(),\r\n        ApiDefinition {\r\n            base_url: \"https://api.ipify.org\".to_string(),\r\n            description: \"A simple public IP address API.\".to_string(),\r\n            examples: \"https://api.ipify.org\".to_string(),\r\n            ..Default::default()\r\n        },\r\n    );\r\n\r\n    apis.insert(\r\n        \"ipinfo\".to_string(),\r\n        ApiDefinition {\r\n            base_url: \"https://ipinfo.io\".to_string(),\r\n            description: \"Find out your public and private IP addresses.\".to_string(),\r\n            examples: \"https://ipinfo.io\".to_string(),\r\n            ..Default::default()\r\n        },\r\n    );\r\n\r\n    apis.insert(\r\n        \"ipapi\".to_string(),\r\n        ApiDefinition {\r\n            base_url: \"https://ipapi.co\".to_string(),\r\n            description: \"IP address location API and geolocation service.\".to_string(),\r\n            examples: \"https://ipapi.co\".to_string(),\r\n            ..Default::default()\r\n        },\r\n    );\r\n\r\n    apis.insert(\r\n        \"chatgpt\".to_string(),\r\n        ApiDefinition {\r\n            base_url: \"https://api.openai.com/v1/chat/completions\".to_string(),\r\n            description: \"Chat with GPT-3.5\".to_string(),\r\n            examples: \"chatgpt('hello world')\".to_string(),\r\n            additional_headers: vec![(\"Content-Type\".to_string(), \"application/json\".to_string())]\r\n                .into_iter()\r\n                .collect(),\r\n            ..Default::default()\r\n        },\r\n    );\r\n\r\n    apis\r\n}\r\n","traces":[{"line":4,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":5,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":7,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":8,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":9,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":10,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":11,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":56},"fn_name":null}],"covered":41,"coverable":41},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","network","mod.rs"],"content":"mod api;\r\npub use api::ApiDefinition;\r\n\r\nmod util;\r\npub use util::*;\r\n\r\nmod registry;\r\npub use registry::ApiRegistry;\r\n\r\nmod defaults;\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","network","registry.rs"],"content":"use super::{defaults::default_apis, ApiDefinition};\r\nuse crate::State;\r\nuse polyvalue::{types::Object, Value};\r\nuse std::collections::HashMap;\r\n\r\npub struct ApiRegistry(HashMap\u003cString, ApiDefinition\u003e);\r\nimpl ApiRegistry {\r\n    const STORE_NAME: \u0026'static str = \"__api_definitions\";\r\n\r\n    /// Create a new instance of the registry, loading the APIs\r\n    /// from the state object\r\n    pub fn new(state: \u0026State) -\u003e Self {\r\n        let mut inst = Self(HashMap::new());\r\n        inst.load(state);\r\n        inst\r\n    }\r\n\r\n    /// Populate the state with the default APIs\r\n    pub fn populate_defaults(state: \u0026mut State) {\r\n        Self(default_apis()).save(state);\r\n    }\r\n\r\n    /// Get the raw value of the registry from the state object\r\n    pub fn raw(state: \u0026State) -\u003e Value {\r\n        state\r\n            .global_get_variable(Self::STORE_NAME)\r\n            .cloned()\r\n            .unwrap_or(Object::default().into())\r\n    }\r\n\r\n    /// Load the APIs from the state object\r\n    fn load(\u0026mut self, state: \u0026State) {\r\n        self.0.clear();\r\n        let state = Self::raw(state).as_a::\u003cObject\u003e().unwrap_or_default();\r\n        for (k, v) in state.iter() {\r\n            if let Ok(api) = ApiDefinition::try_from(v.clone()) {\r\n                self.0.insert(k.to_string(), api);\r\n            }\r\n        }\r\n    }\r\n\r\n    /// Save the APIs to the state object\r\n    fn save(\u0026self, state: \u0026mut State) {\r\n        let obj = self\r\n            .0\r\n            .iter()\r\n            .map(|(k, v)| (k.to_string(), v.clone()))\r\n            .collect::\u003cVec\u003c(_, _)\u003e\u003e();\r\n        state.global_assign_variable(Self::STORE_NAME, Value::try_from(obj).unwrap());\r\n    }\r\n\r\n    /// Add a new API to the registry\r\n    pub fn add(\u0026mut self, state: \u0026mut State, name: \u0026str, api: ApiDefinition) {\r\n        self.0.insert(name.to_string(), api);\r\n        self.save(state);\r\n    }\r\n\r\n    /// Remove an API from the registry\r\n    pub fn remove(\u0026mut self, state: \u0026mut State, name: \u0026str) {\r\n        self.0.remove(name);\r\n        self.save(state);\r\n    }\r\n\r\n    /// Get an API from the registry\r\n    pub fn get(\u0026self, name: \u0026str) -\u003e Option\u003c\u0026ApiDefinition\u003e {\r\n        self.0.get(name)\r\n    }\r\n\r\n    /// Get all APIs from the registry\r\n    pub fn all(\u0026self) -\u003e \u0026HashMap\u003cString, ApiDefinition\u003e {\r\n        \u0026self.0\r\n    }\r\n}\r\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":34},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":59},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":59},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":59},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":412},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":59},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":3},"fn_name":null}],"covered":30,"coverable":30},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","network","util.rs"],"content":"use polyvalue::Value;\r\nuse std::collections::HashMap;\r\nuse std::net::ToSocketAddrs;\r\nuse std::str::FromStr;\r\nuse std::time::Duration;\r\n\r\nuse crate::{oops, Error};\r\n\r\npub fn resolve(hostname: \u0026str) -\u003e Result\u003cValue, Error\u003e {\r\n    match (hostname, 0).to_socket_addrs() {\r\n        Ok(mut addresses) =\u003e {\r\n            if let Some(addr) = addresses.next() {\r\n                return Ok(Value::from(addr.ip().to_string()));\r\n            } else {\r\n                return oops!(Custom {\r\n                    msg: format!(\"No addresses found for `{hostname}`\")\r\n                });\r\n            }\r\n        }\r\n        Err(e) =\u003e Err(e.into()),\r\n    }\r\n}\r\n\r\nfn decode_response(response: \u0026str, headers: \u0026HashMap\u003cString, String\u003e) -\u003e Value {\r\n    let json_decode = headers.get(\"Content-Type\").cloned().unwrap_or_default()\r\n        == \"application/json\"\r\n        || headers.get(\"content-type\").cloned().unwrap_or_default() == \"application/json\";\r\n    if json_decode {\r\n        if let Ok(v) = serde_json::Value::from_str(response) {\r\n            if let Ok(v) = Value::try_from(v) {\r\n                return v;\r\n            }\r\n        }\r\n    }\r\n\r\n    Value::from(response)\r\n}\r\n\r\n/// Fetch from a given URL\r\n///\r\n/// # Arguments\r\n/// * `url` - Target URL\r\n/// * `body` - Body if POST\r\n/// * `headers` - Array of header=value strings\r\npub fn request(\r\n    url: \u0026str,\r\n    body: Option\u003cString\u003e,\r\n    headers: HashMap\u003cString, String\u003e,\r\n) -\u003e Result\u003cValue, Error\u003e {\r\n    match reqwest::blocking::Client::builder()\r\n        .timeout(Duration::from_millis(1500))\r\n        .build()\r\n    {\r\n        Ok(client) =\u003e {\r\n            let mut request = match body {\r\n                None =\u003e client.get(url),\r\n                Some(s) =\u003e client.post(url).body(s),\r\n            };\r\n\r\n            for (header, value) in headers.iter() {\r\n                request = request.header(header, value);\r\n            }\r\n\r\n            match request.send() {\r\n                Ok(res) =\u003e match res.text() {\r\n                    Ok(s) =\u003e {\r\n                        let value = decode_response(\u0026s, \u0026headers);\r\n                        Ok(value)\r\n                    }\r\n                    Err(e) =\u003e Err(e.into()),\r\n                },\r\n                Err(e) =\u003e Err(e.into()),\r\n            }\r\n        }\r\n        Err(e) =\u003e Err(e.into()),\r\n    }\r\n}\r\n","traces":[{"line":9,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":10,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":11,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":34},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","pest.rs"],"content":"//! This module contains the underlying PEST parser for Lavendeux\r\n//! It is not intended to be used directly, but instead is used to parse the input into a syntax tree\r\n//! Use [Lavendeux] to parse input instead\r\n#![allow(missing_docs)]\r\nuse crate::{error::WrapSyntaxError, Error, State};\r\nuse pest::Parser;\r\nuse pest_derive::Parser;\r\n\r\n/// Re-export for use with the internal Lavendeux::eval compiler function\r\npub use crate::syntax_tree::Node;\r\n\r\n/// Re-export for use with the internal Lavendeux::eval compiler function\r\npub use crate::syntax_tree::traits::NodeExt;\r\n\r\n/// Lavendeux's parser\r\n/// We will not directly expose this to the user, but instead use it to\r\n/// parse the input into a syntax tree\r\n#[derive(Parser)]\r\n#[grammar = \"grammar.pest\"]\r\npub struct LavendeuxParser;\r\nimpl LavendeuxParser {\r\n    pub fn compile_ast\u003c'i\u003e(\r\n        root_pair: pest::iterators::Pair\u003c'i, Rule\u003e,\r\n        state: \u0026mut State,\r\n    ) -\u003e Result\u003cNode\u003c'i\u003e, Error\u003e {\r\n        Node::from_pair(root_pair, state)\r\n    }\r\n\r\n    pub fn parse2\u003c'i\u003e(\r\n        input: \u0026'i str,\r\n        rule: Rule,\r\n    ) -\u003e Result\u003cpest::iterators::Pair\u003c'i, Rule\u003e, Error\u003e {\r\n        let pairs = stacker::maybe_grow(Node::STACK_EXP * 10, Node::STACK_EXP * 10, || {\r\n            Self::parse(rule, input).wrap_syntax_error(input)\r\n        })?;\r\n        if let Some(pair) = pairs.flatten().next() {\r\n            Ok(pair)\r\n        } else {\r\n            oops!(Internal {\r\n                msg: format!(\"No instance of rule {:?} found in input\", rule)\r\n            })\r\n        }\r\n    }\r\n}\r\n\r\n/// Runs a single expression through the parser and tests the last value\r\n/// This is a convenience function for testing\r\n/// # Example\r\n/// ```rust\r\n/// use lavendeux_parser::assert_expr;\r\n/// assert_expr!(\"1 + 1\", 2i64);\r\n/// ```\r\n#[cfg(test)]\r\n#[macro_export]\r\nmacro_rules! assert_expr {\r\n    ($e:literal, $v:expr) =\u003e {\r\n        assert_eq!(\r\n            $crate::Lavendeux::new(Default::default())\r\n                .parse($e)\r\n                .expect(\u0026format!(\"Error parsing `{}`\", $e))\r\n                .into_iter()\r\n                .last()\r\n                .expect(\"No values returned from expression\"),\r\n            $crate::Value::from($v),\r\n        )\r\n    };\r\n}\r\n\r\n/// Runs a single expression through the parser and matches the result\r\n/// This is a convenience function for testing\r\n/// # Example\r\n/// ```rust\r\n/// use lavendeux_parser::match_expr;\r\n/// match_expr!(\"foo + bar\", Err(_));\r\n/// ```\r\n#[cfg(test)]\r\n#[macro_export]\r\nmacro_rules! match_expr {\r\n    ($e:literal, $v:pat) =\u003e {\r\n        matches!(\r\n            $crate::Lavendeux::new(Default::default())\r\n                .parse($e)\r\n            $v\r\n        )\r\n    };\r\n}\r\n\r\n/// Runs a single expression through the parser and matches on the details of the error\r\n/// This is a convenience function for testing\r\n/// # Example\r\n/// ```rust\r\n/// use lavendeux_parser::match_expr_err;\r\n/// match_expr!(\"foo + bar\", VariableName {..});\r\n/// ```\r\n#[cfg(test)]\r\n#[macro_export]\r\nmacro_rules! match_expr_err {\r\n    ($e:literal, $v:pat) =\u003e {\r\n        matches!(\r\n            $crate::Lavendeux::new(Default::default())\r\n                .parse($e)\r\n                .expect_err(\u0026format!(\"Expected an error from `{}`\", $e))\r\n                .details,\r\n            $v\r\n        )\r\n    };\r\n}\r\n\r\n/// Generates a test case sent to the parser\r\n/// # Example\r\n///  ```rust\r\n/// use lavendeux_parser::lav;\r\n/// use lavendeux_parser::{error::ErrorDetails, Error};\r\n///\r\n/// lav!(test_isok r#\"\r\n/// 1 + 1\r\n/// \"#);\r\n///\r\n/// lav!(test_isvar(a = 1, b = 2) r#\"\r\n/// a=1, b=2\r\n/// \"#);\r\n///\r\n/// lav!(test_iserr(Error) r#\"\r\n/// asparagus\r\n/// \"#);\r\n///\r\n/// lav!(test_whaterr(Error = |e: \u0026Error| matches!(e.details, ErrorDetails::VariableName {..})) r#\"\r\n/// asparagus\r\n/// \"#);\r\n/// ```\r\n#[cfg(test)]\r\n#[macro_export]\r\nmacro_rules! lav {\r\n    ($test_name:ident $body:literal) =\u003e {\r\n        #[test]\r\n        fn $test_name() {\r\n            $crate::Lavendeux::new(Default::default()).parse($body).expect(\"Error parsing expression\");\r\n        }\r\n    };\r\n    ($test_name:ident(Error) $body:literal) =\u003e {\r\n        #[test]\r\n        fn $test_name() {\r\n            $crate::Lavendeux::new(Default::default()).parse($body).expect_err(\"Expected expression to fail\");\r\n        }\r\n    };\r\n\r\n    ($test_name:ident(Error = $pattern:expr) $body:literal) =\u003e {\r\n        #[test]\r\n        fn $test_name() {\r\n            let mut lav = $crate::Lavendeux::new(Default::default());\r\n            let e = lav.parse($body).expect_err(\"Expected expression to fail\");\r\n            if !( $pattern(\u0026e) ) {\r\n                panic!(\"Error did not match pattern: {:#?}\", e)\r\n            }\r\n        }\r\n    };\r\n\r\n    ($test_name:ident($($n:ident = $v:expr),+$(,)?) $body:literal) =\u003e {\r\n        #[test]\r\n        fn $test_name() {\r\n            let mut lav = $crate::Lavendeux::new(Default::default());\r\n            lav.parse($body).expect(\"Error parsing expression\");\r\n            $( assert_eq!(lav.state().get_variable(stringify!($n)).expect(\u0026format!(\"`{}` was not set\", stringify!($n))), \u0026$crate::Value::from($v)); )+\r\n        }\r\n    };\r\n}\r\n\r\n#[cfg(test)]\r\nmod test {\r\n    use crate::{error::ErrorDetails, Error};\r\n\r\n    lav!(test_isok r#\"\r\n        1 + 1\r\n    \"#);\r\n\r\n    lav!(test_isvar(a = 1i64, b = 2i64) r#\"\r\n        a=1; b=2\r\n    \"#);\r\n\r\n    lav!(test_iserr(Error) r#\"\r\n        asparagus\r\n    \"#);\r\n\r\n    lav!(test_whaterr(Error = |e: \u0026Error| matches!(e.details, ErrorDetails::VariableName {..})) r#\"\r\n        asparagus\r\n    \"#);\r\n}\r\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":210},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":420},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":201},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":201},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":3},"fn_name":null}],"covered":16,"coverable":19},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","state.rs"],"content":"use crate::{\r\n    documentation::{DocumentationFormatter, PlaintextFormatter},\r\n    error::ErrorDetails,\r\n    functions::{stdlib, ParserFunction},\r\n    network::ApiRegistry,\r\n    syntax_tree::AssignmentTarget,\r\n    Error, Value,\r\n};\r\nuse std::{\r\n    collections::HashMap,\r\n    time::{Duration, Instant},\r\n};\r\n\r\n/// The main parser state\r\n/// Stores variables, scoping data, functions, and metadata about the current parse\r\n#[derive(Debug)]\r\npub struct State {\r\n    /// Current depth of the parser\r\n    /// This is used to prevent infinite recursion\r\n    /// while parsing user_functions\r\n    depth: usize,\r\n    locked: Vec\u003cusize\u003e,\r\n\r\n    /// The time that the current parse started\r\n    /// This is used to prevent infinite loops\r\n    /// and implement a timeout\r\n    parse_starttime: Instant,\r\n    timeout: Duration,\r\n\r\n    /// Registered variables\r\n    /// Used as a stack for scoping\r\n    variables: Vec\u003cHashMap\u003cString, Value\u003e\u003e,\r\n\r\n    /// Registered functions\r\n    functions: HashMap\u003cString, Box\u003cdyn ParserFunction\u003e\u003e,\r\n}\r\n\r\nimpl Default for State {\r\n    fn default() -\u003e Self {\r\n        let stdlib_fns = stdlib::all();\r\n        let mut instance = Self {\r\n            depth: 0,\r\n            locked: Vec::new(),\r\n            parse_starttime: std::time::Instant::now(),\r\n            timeout: Duration::from_secs(0),\r\n            variables: vec![HashMap::new()],\r\n\r\n            functions: stdlib_fns,\r\n        };\r\n\r\n        ApiRegistry::populate_defaults(\u0026mut instance);\r\n\r\n        instance\r\n    }\r\n}\r\n\r\nimpl State {\r\n    const MAX_DEPTH: usize = 15000;\r\n\r\n    /// Creates a new parser state\r\n    pub fn new() -\u003e Self {\r\n        Self::default()\r\n    }\r\n\r\n    /**\r\n     *\r\n     * Timeout handling functions\r\n     *\r\n     */\r\n\r\n    /// Creates a new parser state with a timeout\r\n    /// Parsing will fail with `ErrorDetails::Timeout` if the timeout is exceeded\r\n    /// The timer does not begin until `start_timer` is called\r\n    /// And is checked with `check_timer` (which is called internally by the parser)\r\n    pub fn with_timeout(timeout: Duration) -\u003e Self {\r\n        Self {\r\n            timeout,\r\n            ..Self::default()\r\n        }\r\n    }\r\n\r\n    /// Sets the timeout of the parser\r\n    /// Used on parse start\r\n    pub fn start_timer(\u0026mut self) {\r\n        self.parse_starttime = Instant::now();\r\n    }\r\n\r\n    /// Checks the timeout of the parser\r\n    pub fn check_timer(\u0026self) -\u003e Result\u003c(), Error\u003e {\r\n        if !self.timeout.is_zero() \u0026\u0026 self.parse_starttime.elapsed() \u003e self.timeout {\r\n            Err(ErrorDetails::Timeout.into())\r\n        } else {\r\n            Ok(())\r\n        }\r\n    }\r\n\r\n    /**\r\n     *\r\n     * Scope handling functions\r\n     *\r\n     */\r\n\r\n    /// Returns the current depth of the parser\r\n    pub fn current_depth(\u0026self) -\u003e usize {\r\n        self.depth\r\n    }\r\n\r\n    /// Sets the depth to 0, and destroys all scopes but the root scope\r\n    pub fn sanitize_scopes(\u0026mut self) {\r\n        self.depth = 0;\r\n        self.locked = Vec::new();\r\n        self.variables.truncate(1);\r\n    }\r\n\r\n    /// Creates a new scope from this state\r\n    /// A limit is placed on the depth of scopes that can be created\r\n    /// This is to prevent infinite recursion\r\n    pub fn scope_into(\u0026mut self) -\u003e Result\u003c(), Error\u003e {\r\n        // If stacker reports \u003c 1MB of stack remaining, then we need to stop\r\n        if self.depth \u003e= Self::MAX_DEPTH\r\n            || stacker::remaining_stack() \u003c Some(crate::pest::Node::MIN_STACK)\r\n        {\r\n            return Err(ErrorDetails::StackOverflow.into());\r\n        }\r\n\r\n        self.depth += 1;\r\n        self.variables.push(HashMap::new());\r\n\r\n        Ok(())\r\n    }\r\n\r\n    /// Locks the current scope, preventing access to variables in higher scopes\r\n    pub fn lock_scope(\u0026mut self) {\r\n        self.locked.push(self.depth);\r\n    }\r\n\r\n    /// Unlocks the current scope, granting access to variables in higher scopes\r\n    pub fn unlock_scope(\u0026mut self) {\r\n        self.locked.pop();\r\n    }\r\n\r\n    /// Returns the last valid scope\r\n    fn last_valid_scope(\u0026self) -\u003e usize {\r\n        if let Some(lock) = self.locked.last() {\r\n            *lock\r\n        } else {\r\n            0\r\n        }\r\n    }\r\n\r\n    /// Returns the last valid scope for the parent caller\r\n    fn last_valid_parent_scope(\u0026self) -\u003e usize {\r\n        if let Some(lock) = self.locked.iter().rev().nth(1) {\r\n            *lock\r\n        } else {\r\n            0\r\n        }\r\n    }\r\n\r\n    /// Removes the current scope from this state\r\n    pub fn scope_out(\u0026mut self) {\r\n        if self.depth == 0 {\r\n            return;\r\n        }\r\n        self.depth -= 1;\r\n        self.variables.pop();\r\n\r\n        if self.depth \u003c self.last_valid_scope() {\r\n            self.unlock_scope();\r\n        }\r\n    }\r\n\r\n    fn get_valid_scopes(\u0026self) -\u003e impl Iterator\u003cItem = \u0026HashMap\u003cString, polyvalue::Value\u003e\u003e {\r\n        self.variables\r\n            .iter()\r\n            .rev()\r\n            .take(self.depth - self.last_valid_scope() + 1)\r\n    }\r\n\r\n    fn get_valid_scopes_mut(\r\n        \u0026mut self,\r\n    ) -\u003e impl Iterator\u003cItem = \u0026mut HashMap\u003cString, polyvalue::Value\u003e\u003e {\r\n        let lock = self.last_valid_scope();\r\n        self.variables.iter_mut().rev().take(self.depth - lock + 1)\r\n    }\r\n\r\n    fn get_valid_parent_scopes(\u0026self) -\u003e impl Iterator\u003cItem = \u0026HashMap\u003cString, polyvalue::Value\u003e\u003e {\r\n        self.variables\r\n            .iter()\r\n            .rev()\r\n            .skip(1)\r\n            .take(self.depth - self.last_valid_parent_scope())\r\n    }\r\n\r\n    fn get_valid_parent_scopes_mut(\r\n        \u0026mut self,\r\n    ) -\u003e impl Iterator\u003cItem = \u0026mut HashMap\u003cString, polyvalue::Value\u003e\u003e {\r\n        let lock = self.last_valid_parent_scope();\r\n        self.variables\r\n            .iter_mut()\r\n            .rev()\r\n            .skip(1)\r\n            .take(self.depth - lock)\r\n    }\r\n\r\n    /**\r\n     *\r\n     * Variable handling functions\r\n     *\r\n     */\r\n\r\n    /// Assigns a variable in the state, in the root scope\r\n    pub fn global_assign_variable(\u0026mut self, name: \u0026str, value: Value) {\r\n        self.variables[0].insert(name.to_string(), value);\r\n    }\r\n\r\n    /// Gets a variable from the root scope\r\n    pub fn global_get_variable(\u0026self, name: \u0026str) -\u003e Option\u003c\u0026Value\u003e {\r\n        self.variables[0].get(name)\r\n    }\r\n\r\n    /// Sets a variable in the a scope offset levels from the current scope\r\n    /// If that scope does not exist, the variable is not set\r\n    pub fn set_variable_in_offset(\u0026mut self, offset: usize, name: \u0026str, value: Value) {\r\n        if let Some(scope) = self.variables.iter_mut().rev().nth(offset) {\r\n            scope.insert(name.to_string(), value);\r\n        }\r\n    }\r\n\r\n    /// Sets a variable as if it were in the parent scope\r\n    /// Bypasses the scope lock\r\n    pub fn set_variable_as_parent(\u0026mut self, name: \u0026str, value: Value) {\r\n        let mut scopes = self.get_valid_scopes_mut();\r\n        scopes.next();\r\n        for scope in scopes {\r\n            if scope.contains_key(name) {\r\n                scope.insert(name.to_string(), value);\r\n                return;\r\n            }\r\n        }\r\n\r\n        // If the variable is not found, assign it in the current scope\r\n        self.set_variable_in_offset(1, name, value)\r\n    }\r\n\r\n    /// Sets a variable in the state\r\n    pub fn set_variable(\u0026mut self, name: \u0026str, value: Value) {\r\n        for scope in self.get_valid_scopes_mut() {\r\n            if scope.contains_key(name) {\r\n                scope.insert(name.to_string(), value);\r\n                return;\r\n            }\r\n        }\r\n\r\n        // If the variable is not found, assign it in the root scope\r\n        self.set_variable_in_scope(name, value)\r\n    }\r\n\r\n    /// Sets a variable in the current scope\r\n    pub fn set_variable_in_scope(\u0026mut self, name: \u0026str, value: Value) {\r\n        if let Some(scope) = self.variables.last_mut() {\r\n            scope.insert(name.to_string(), value);\r\n        }\r\n    }\r\n\r\n    /// Returns the value of a variable\r\n    pub fn get_variable(\u0026self, name: \u0026str) -\u003e Option\u003c\u0026Value\u003e {\r\n        for scope in self.get_valid_scopes() {\r\n            if let Some(value) = scope.get(name) {\r\n                return Some(value);\r\n            }\r\n        }\r\n        None\r\n    }\r\n\r\n    /// Returns the value of a variable, mutably\r\n    pub fn get_variable_mut(\u0026mut self, name: \u0026str) -\u003e Option\u003c\u0026mut Value\u003e {\r\n        for scope in self.get_valid_scopes_mut() {\r\n            if let Some(value) = scope.get_mut(name) {\r\n                return Some(value);\r\n            }\r\n        }\r\n        None\r\n    }\r\n\r\n    /// Returns the value of a variable from the parent scope\r\n    pub fn get_variable_as_parent(\u0026self, name: \u0026str) -\u003e Option\u003c\u0026Value\u003e {\r\n        let scopes = self.get_valid_parent_scopes();\r\n        for scope in scopes {\r\n            if let Some(value) = scope.get(name) {\r\n                return Some(value);\r\n            }\r\n        }\r\n        None\r\n    }\r\n\r\n    /// Returns the value of a variable, mutably from the parent scope\r\n    pub fn get_variable_mut_as_parent(\u0026mut self, name: \u0026str) -\u003e Option\u003c\u0026mut Value\u003e {\r\n        let scopes = self.get_valid_parent_scopes_mut();\r\n        for scope in scopes {\r\n            if let Some(value) = scope.get_mut(name) {\r\n                return Some(value);\r\n            }\r\n        }\r\n        None\r\n    }\r\n\r\n    /// Deletes a variable from the state\r\n    pub fn delete_variable(\u0026mut self, name: \u0026str) -\u003e Option\u003cValue\u003e {\r\n        for scope in self.get_valid_scopes_mut() {\r\n            if let Some(value) = scope.remove(name) {\r\n                return Some(value);\r\n            }\r\n        }\r\n        None\r\n    }\r\n\r\n    /// Returns all variables in the state\r\n    pub fn all_variables(\u0026self) -\u003e HashMap\u003c\u0026str, \u0026Value\u003e {\r\n        let mut variables = HashMap::new();\r\n        for scope in self.get_valid_scopes() {\r\n            variables.extend(scope.iter().map(|(k, v)| (k.as_str(), v)));\r\n        }\r\n\r\n        variables\r\n    }\r\n\r\n    /// Returns all variables in the state\r\n    /// Ignores the scope lock\r\n    pub fn all_variables_unscoped(\u0026self) -\u003e HashMap\u003c\u0026str, \u0026Value\u003e {\r\n        let mut variables = HashMap::new();\r\n        for scope in self.variables.iter().rev() {\r\n            variables.extend(scope.iter().map(|(k, v)| (k.as_str(), v)));\r\n        }\r\n\r\n        variables\r\n    }\r\n\r\n    /**\r\n     *\r\n     * Function handling functions\r\n     *\r\n     */\r\n\r\n    /// Returns true if the given function is a read-only system function\r\n    pub fn is_system_function(\u0026self, name: \u0026str) -\u003e bool {\r\n        if let Some(function) = self.functions.get(name) {\r\n            function.is_readonly()\r\n        } else {\r\n            false\r\n        }\r\n    }\r\n\r\n    /// Registers a function in the state\r\n    /// See [crate::define_stdfunction] for an example of how to define a function\r\n    pub fn register_function(\u0026mut self, function: impl ParserFunction) -\u003e Result\u003c(), Error\u003e {\r\n        let name = function.name();\r\n        if self.is_system_function(name) {\r\n            oops!(ReadOnlyFunction {\r\n                name: name.to_string()\r\n            })\r\n        } else {\r\n            self.functions\r\n                .insert(name.to_string(), function.clone_self());\r\n            Ok(())\r\n        }\r\n    }\r\n\r\n    /// Unregisters a function from the state\r\n    pub fn unregister_function(\r\n        \u0026mut self,\r\n        name: \u0026str,\r\n    ) -\u003e Result\u003cOption\u003cBox\u003cdyn ParserFunction\u003e\u003e, Error\u003e {\r\n        if self.is_system_function(name) {\r\n            oops!(ReadOnlyFunction {\r\n                name: name.to_string()\r\n            })\r\n        } else {\r\n            Ok(self.functions.remove(name))\r\n        }\r\n    }\r\n\r\n    /// Returns a function from the state\r\n    pub fn get_function(\u0026self, name: \u0026str) -\u003e Option\u003c\u0026dyn ParserFunction\u003e {\r\n        self.functions.get(name).map(|f| f.as_ref())\r\n    }\r\n\r\n    /// Returns a function from the state\r\n    pub fn get_function_mut(\u0026mut self, name: \u0026str) -\u003e Option\u003c\u0026mut Box\u003cdyn ParserFunction\u003e\u003e {\r\n        self.functions.get_mut(name)\r\n    }\r\n\r\n    /// List all functions in the state\r\n    pub fn all_functions(\u0026self) -\u003e \u0026HashMap\u003cString, Box\u003cdyn ParserFunction\u003e\u003e {\r\n        \u0026self.functions\r\n    }\r\n\r\n    /// Calls a function in the state\r\n    /// arg1_references maps to the references field of the source [crate::Token]\r\n    pub fn call_function(\r\n        \u0026mut self,\r\n        name: \u0026str,\r\n        args: Vec\u003cValue\u003e,\r\n        reference: Option\u003c\u0026AssignmentTarget\u003e,\r\n    ) -\u003e Result\u003cValue, Error\u003e {\r\n        let function = self.get_function(name).ok_or(ErrorDetails::FunctionName {\r\n            name: name.to_string(),\r\n        })?;\r\n        let function = function.clone_self();\r\n        function.exec(\u0026args, self, reference)\r\n    }\r\n\r\n    /// Calls a decorator function\r\n    pub fn decorate(\u0026mut self, name: \u0026str, value: Value) -\u003e Result\u003cString, Error\u003e {\r\n        let name = format!(\"@{name}\");\r\n        match self.call_function(\u0026name, vec![value], None) {\r\n            Ok(value) =\u003e Ok(value.to_string()),\r\n            Err(e) if matches!(e.details, ErrorDetails::FunctionName { .. }) =\u003e {\r\n                oops!(DecoratorName {\r\n                    name: name.to_string()\r\n                })\r\n            }\r\n            Err(e) =\u003e Err(e),\r\n        }\r\n    }\r\n\r\n    /// Returns a string containing the help for all functions\r\n    pub fn help(\u0026self, filter: Option\u003cString\u003e) -\u003e String {\r\n        PlaintextFormatter.format_functions(self, filter.as_deref())\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod test {\r\n    use super::*;\r\n    #[test]\r\n    fn test_scope() {\r\n        let mut state = State::new();\r\n        state.set_variable(\"a\", Value::from(2.0));\r\n        state.scope_into().ok();\r\n        assert_eq!(state.delete_variable(\"a\"), Some(Value::from(2.0)));\r\n        assert_eq!(state.delete_variable(\"a\"), None);\r\n\r\n        state.global_assign_variable(\"b\", Value::from(2.0));\r\n\r\n        assert_eq!(state.current_depth(), 1);\r\n        state.scope_out();\r\n        assert_eq!(state.current_depth(), 0);\r\n\r\n        state.scope_out();\r\n        assert_eq!(state.current_depth(), 0);\r\n\r\n        assert_eq!(state.get_variable(\"a\"), None);\r\n        assert_eq!(state.get_variable(\"b\"), Some(\u0026Value::from(2.0)));\r\n\r\n        state.depth = State::MAX_DEPTH;\r\n        assert!(matches!(\r\n            state.scope_into().unwrap_err().details,\r\n            ErrorDetails::StackOverflow { .. }\r\n        ));\r\n    }\r\n\r\n    #[test]\r\n    fn test_timer() {\r\n        let mut state = State::with_timeout(Duration::from_millis(100));\r\n        state.start_timer();\r\n        std::thread::sleep(std::time::Duration::from_millis(250));\r\n        assert!(matches!(\r\n            state.check_timer().unwrap_err().details,\r\n            ErrorDetails::Timeout\r\n        ));\r\n    }\r\n\r\n    #[test]\r\n    fn test_all_variables() {\r\n        let mut state = State::new();\r\n        state.set_variable(\"a\", Value::from(2.0));\r\n        state.scope_into().ok();\r\n        state.set_variable(\"b\", Value::from(3.0));\r\n\r\n        let variables = state.all_variables();\r\n        assert!(variables.contains_key(\"a\"));\r\n        assert!(variables.contains_key(\"b\"));\r\n    }\r\n}\r\n","traces":[{"line":39,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":170},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":170},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":111},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":112},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":110},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":169},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":169},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":169},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":169},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":470},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":470},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":469},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":469},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":469},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":387},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":387},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":387},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":387},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":1921},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":3550},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":292},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":469},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":469},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":468},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":468},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":855},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":387},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":736},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":736},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":736},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":717},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":717},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":717},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":62},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":62},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":699},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":1443},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":744},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":686},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":686},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":1372},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":735},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":1488},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":1476},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":723},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":306,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":307,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":310,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":321,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":330,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":331,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":333,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":334,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":337,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":338,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":339,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":344,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":348,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":358,"address":[],"length":0,"stats":{"Line":515},"fn_name":null},{"line":359,"address":[],"length":0,"stats":{"Line":1544},"fn_name":null},{"line":363,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":364,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":368,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":369,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":374,"address":[],"length":0,"stats":{"Line":383},"fn_name":null},{"line":380,"address":[],"length":0,"stats":{"Line":766},"fn_name":null},{"line":381,"address":[],"length":0,"stats":{"Line":383},"fn_name":null},{"line":388,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":389,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":390,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":391,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":392,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":393,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":394,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":397,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":402,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":403,"address":[],"length":0,"stats":{"Line":3},"fn_name":null}],"covered":119,"coverable":144},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","syntax_tree","assignment_target.rs"],"content":"use crate::{\r\n    error::{ErrorDetails, WrapOption},\r\n    Error, State,\r\n};\r\n\r\nuse super::{\r\n    traits::{IntoOwned, NodeExt},\r\n    Node,\r\n};\r\nuse polyvalue::{\r\n    operations::{IndexingMutationExt, IndexingOperationExt},\r\n    Value, ValueType,\r\n};\r\n\r\n/// The target for a RW operation on a value\r\n#[derive(Debug, Clone)]\r\npub enum AssignmentTarget\u003c'i\u003e {\r\n    /// Directly assign to a variable ( a )\r\n    Identifier(String),\r\n\r\n    /// Assign to an index of a value ( a[0] )\r\n    Index(String, Vec\u003cOption\u003cNode\u003c'i\u003e\u003e\u003e), // None = last-entry index\r\n\r\n    /// Destructure a value into multiple targets ( [a, b, c] )\r\n    Destructure(Vec\u003cAssignmentTarget\u003c'i\u003e\u003e),\r\n}\r\n\r\nimpl std::fmt::Display for AssignmentTarget\u003c'_\u003e {\r\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\r\n        match self {\r\n            Self::Identifier(id) =\u003e write!(f, \"{}\", id),\r\n            Self::Index(base, indices) =\u003e {\r\n                write!(f, \"{}\", base)?;\r\n                for index in indices {\r\n                    write!(\r\n                        f,\r\n                        \"[{}]\",\r\n                        if let Some(i) = index {\r\n                            \u0026i.token().input\r\n                        } else {\r\n                            \"\"\r\n                        }\r\n                    )?;\r\n                }\r\n                Ok(())\r\n            }\r\n            Self::Destructure(targets) =\u003e {\r\n                write!(\r\n                    f,\r\n                    \"[{}]\",\r\n                    targets\r\n                        .iter()\r\n                        .map(|t| t.to_string())\r\n                        .collect::\u003cVec\u003c_\u003e\u003e()\r\n                        .join(\",\")\r\n                )\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nimpl IntoOwned for AssignmentTarget\u003c'_\u003e {\r\n    type Owned = AssignmentTarget\u003c'static\u003e;\r\n    fn into_owned(self) -\u003e Self::Owned {\r\n        match self {\r\n            Self::Identifier(id) =\u003e Self::Owned::Identifier(id),\r\n            Self::Index(base, indices) =\u003e Self::Owned::Index(\r\n                base,\r\n                indices\r\n                    .into_iter()\r\n                    .map(|i| i.map(|i| i.into_owned()))\r\n                    .collect(),\r\n            ),\r\n            Self::Destructure(targets) =\u003e {\r\n                Self::Owned::Destructure(targets.into_iter().map(|t| t.into_owned()).collect())\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003c'i\u003e AssignmentTarget\u003c'i\u003e {\r\n    pub(crate) fn get_index_handle(base: Value, indices: \u0026[Option\u003cValue\u003e]) -\u003e Result\u003cValue, Error\u003e {\r\n        let mut base = base;\r\n        for index in indices {\r\n            let default_idx = Value::from(if base.len() == 0 { 0 } else { base.len() - 1 });\r\n            let index = index.as_ref().unwrap_or(\u0026default_idx);\r\n\r\n            if index.is_a(ValueType::Collection) \u0026\u0026 !index.is_a(ValueType::String) {\r\n                base = base.get_indices(index)?;\r\n            } else {\r\n                base = base.get_index(index)?;\r\n            }\r\n        }\r\n        Ok(base)\r\n    }\r\n\r\n    pub(crate) fn get_mut_index_handle\u003c'v\u003e(\r\n        base: \u0026'v mut Value,\r\n        indices: \u0026[Option\u003cValue\u003e],\r\n    ) -\u003e Result\u003c\u0026'v mut Value, Error\u003e {\r\n        let mut base = base;\r\n        for index in indices {\r\n            let default_idx = Value::from(if base.len() == 0 { 0 } else { base.len() - 1 });\r\n            let index = index.as_ref().unwrap_or(\u0026default_idx);\r\n            base = base.get_index_mut(index)?;\r\n        }\r\n        Ok(base)\r\n    }\r\n\r\n    /// Evaluate the target to get the value it points to\r\n    pub fn get_value(\u0026self, state: \u0026mut State) -\u003e Result\u003cValue, Error\u003e {\r\n        match self {\r\n            Self::Identifier(id) =\u003e state\r\n                .get_variable(id)\r\n                .cloned()\r\n                .or_error(ErrorDetails::VariableName { name: id.clone() }),\r\n            Self::Index(base, indices) =\u003e {\r\n                let mut idx = vec![];\r\n                for index in indices {\r\n                    idx.push(index.as_ref().map(|i| i.evaluate(state)).transpose()?);\r\n                }\r\n\r\n                let base = state\r\n                    .get_variable(base)\r\n                    .cloned()\r\n                    .or_error(ErrorDetails::VariableName { name: base.clone() })?;\r\n                Self::get_index_handle(base, \u0026idx)\r\n            }\r\n            Self::Destructure(targets) =\u003e targets\r\n                .iter()\r\n                .map(|t| t.get_value(state))\r\n                .collect::\u003cResult\u003cVec\u003c_\u003e, _\u003e\u003e()\r\n                .map(Value::from),\r\n        }\r\n    }\r\n\r\n    /// Evaluate the target to get the value it points to\r\n    /// This version of the function will look for the variable in the parent scope\r\n    pub fn get_value_in_parent(\u0026self, state: \u0026mut State) -\u003e Result\u003cValue, Error\u003e {\r\n        match self {\r\n            Self::Identifier(id) =\u003e state\r\n                .get_variable_as_parent(id)\r\n                .cloned()\r\n                .or_error(ErrorDetails::VariableName { name: id.clone() }),\r\n            Self::Index(base, indices) =\u003e {\r\n                let mut idx = vec![];\r\n                for index in indices {\r\n                    idx.push(index.as_ref().map(|i| i.evaluate(state)).transpose()?);\r\n                }\r\n\r\n                let base = state\r\n                    .get_variable_as_parent(base)\r\n                    .cloned()\r\n                    .or_error(ErrorDetails::VariableName { name: base.clone() })?;\r\n                Self::get_index_handle(base, \u0026idx)\r\n            }\r\n            Self::Destructure(targets) =\u003e targets\r\n                .iter()\r\n                .map(|t| t.get_value_in_parent(state))\r\n                .collect::\u003cResult\u003cVec\u003c_\u003e, _\u003e\u003e()\r\n                .map(Value::from),\r\n        }\r\n    }\r\n\r\n    /// Update the value the target points to\r\n    pub fn update_value(\u0026self, state: \u0026mut State, value: Value) -\u003e Result\u003c(), Error\u003e {\r\n        match self {\r\n            Self::Identifier(id) =\u003e {\r\n                state.set_variable(id, value);\r\n                Ok(())\r\n            }\r\n            Self::Index(base, indices) =\u003e {\r\n                let mut idx = vec![];\r\n                for index in indices {\r\n                    idx.push(index.as_ref().map(|i| i.evaluate(state)).transpose()?);\r\n                }\r\n\r\n                let mut base = state\r\n                    .get_variable_mut(base)\r\n                    .or_error(ErrorDetails::VariableName { name: base.clone() })?;\r\n\r\n                if idx.is_empty() {\r\n                    *base = value;\r\n                    return Ok(());\r\n                }\r\n\r\n                let target_idx = idx.pop().unwrap();\r\n                base = Self::get_mut_index_handle(base, \u0026idx)?;\r\n\r\n                let target_idx = target_idx.unwrap_or(base.len().into());\r\n\r\n                base.set_index(\u0026target_idx, value)?;\r\n                Ok(())\r\n            }\r\n            Self::Destructure(targets) =\u003e {\r\n                if targets.len() != value.len() {\r\n                    oops!(DestructuringAssignment {\r\n                        expected_length: targets.len(),\r\n                        actual_length: value.len()\r\n                    })\r\n                } else {\r\n                    let values = value.as_a::\u003cVec\u003cValue\u003e\u003e()?;\r\n                    for (target, value) in targets.iter().zip(values.into_iter()) {\r\n                        target.update_value(state, value)?;\r\n                    }\r\n                    Ok(())\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /// Get a handle to the target value, if it exists.\r\n    /// This function will look for the variable in the parent scope\r\n    pub fn get_target_mut_in_parent\u003c's\u003e(\r\n        \u0026self,\r\n        state: \u0026's mut State,\r\n    ) -\u003e Result\u003cOption\u003c\u0026's mut Value\u003e, Error\u003e {\r\n        match self {\r\n            Self::Identifier(id) =\u003e Some(\r\n                state\r\n                    .get_variable_mut_as_parent(id)\r\n                    .or_error(ErrorDetails::VariableName { name: id.clone() }),\r\n            )\r\n            .transpose(),\r\n            Self::Index(base, indices) =\u003e {\r\n                let mut idx = vec![];\r\n                for index in indices {\r\n                    idx.push(index.as_ref().map(|i| i.evaluate(state)).transpose()?);\r\n                }\r\n\r\n                let base = state\r\n                    .get_variable_mut_as_parent(base)\r\n                    .or_error(ErrorDetails::VariableName { name: base.clone() })?;\r\n                Some(Self::get_mut_index_handle(base, \u0026idx)).transpose()\r\n            }\r\n            Self::Destructure(_) =\u003e Ok(None),\r\n        }\r\n    }\r\n\r\n    /// Update the value the target points to\r\n    /// This version of the function will look for the variable in the parent scope\r\n    pub fn update_value_in_parent(\u0026self, state: \u0026mut State, value: Value) -\u003e Result\u003c(), Error\u003e {\r\n        match self {\r\n            Self::Identifier(id) =\u003e {\r\n                state.set_variable_as_parent(id, value);\r\n                Ok(())\r\n            }\r\n            Self::Index(base, indices) =\u003e {\r\n                let mut idx = vec![];\r\n                for index in indices {\r\n                    idx.push(index.as_ref().map(|i| i.evaluate(state)).transpose()?);\r\n                }\r\n\r\n                let mut base = state\r\n                    .get_variable_mut_as_parent(base)\r\n                    .or_error(ErrorDetails::VariableName { name: base.clone() })?;\r\n                base = Self::get_mut_index_handle(base, \u0026idx)?;\r\n\r\n                if idx.is_empty() {\r\n                    *base = value;\r\n                    return Ok(());\r\n                }\r\n\r\n                let target_idx = idx.pop().unwrap();\r\n                base = Self::get_mut_index_handle(base, \u0026idx)?;\r\n\r\n                let target_idx = target_idx.unwrap_or(base.len().into());\r\n                base.set_index(\u0026target_idx, value)?;\r\n                Ok(())\r\n            }\r\n            Self::Destructure(targets) =\u003e {\r\n                if targets.len() != value.len() {\r\n                    oops!(DestructuringAssignment {\r\n                        expected_length: targets.len(),\r\n                        actual_length: value.len()\r\n                    })\r\n                } else {\r\n                    let values = value.as_a::\u003cVec\u003cValue\u003e\u003e()?;\r\n                    for (target, value) in targets.iter().zip(values.into_iter()) {\r\n                        target.update_value_in_parent(state, value)?;\r\n                    }\r\n                    Ok(())\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /// Delete the value the target points to\r\n    pub fn delete(\u0026self, state: \u0026mut State) -\u003e Result\u003cValue, Error\u003e {\r\n        match self {\r\n            Self::Identifier(id) =\u003e {\r\n                if let Some(value) = state.delete_variable(id) {\r\n                    Ok(value)\r\n                } else if let Some(function) = state.unregister_function(id)? {\r\n                    Ok(function.signature().into())\r\n                } else {\r\n                    oops!(VariableName { name: id.clone() })\r\n                }\r\n            }\r\n\r\n            AssignmentTarget::Index(base, indices) =\u003e {\r\n                let mut idx = vec![];\r\n                for index in indices {\r\n                    idx.push(index.as_ref().map(|i| i.evaluate(state)).transpose()?);\r\n                }\r\n\r\n                if indices.is_empty() {\r\n                    return oops!(ArrayEmpty);\r\n                }\r\n\r\n                let mut base = state\r\n                    .get_variable_mut(base)\r\n                    .or_error(ErrorDetails::VariableName { name: base.clone() })?;\r\n                let target_idx = idx.pop().unwrap();\r\n                base = Self::get_mut_index_handle(base, \u0026idx)?;\r\n\r\n                let target_idx = target_idx.unwrap_or((base.len() - 1).into());\r\n\r\n                Ok(base.delete_index(\u0026target_idx)?)\r\n            }\r\n\r\n            AssignmentTarget::Destructure(ids) =\u003e {\r\n                let results = ids\r\n                    .iter()\r\n                    .map(|id| id.delete(state))\r\n                    .collect::\u003cResult\u003cVec\u003c_\u003e, _\u003e\u003e()?;\r\n                Ok(Value::from(results))\r\n            }\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":23,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":115},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":115},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":110},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":110},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":110},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":43},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":43},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":40},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":40},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":40},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":290,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":307,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":77,"coverable":176},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","syntax_tree","macros.rs"],"content":"macro_rules! define_astnode {\r\n    (\r\n        outer = $oname:ident,\r\n        $name:ident $({$($param:ident : $param_t:ty),*})?,\r\n        build = ($pairsvar:ident, $btokvar:ident, $bstatevar:ident) $build_hnd:block,\r\n        eval  = ($selfvar:ident, $estatevar:ident) $eval_hnd:block,\r\n        owned = ($oselfvar:ident) $owned_hnd:block\r\n        $(\r\n                ,docs  = {\r\n                name: $docs_name:literal,\r\n                symbols = [$($docs_symbols:literal),*],\r\n                description: $docs_desc:literal,\r\n                examples: $docs_examples:literal,\r\n            }\r\n        )?\r\n    ) =\u003e {\r\n        $(\r\n            document_operator! {\r\n                name = $docs_name,\r\n                rules = [],\r\n                symbols = [$($docs_symbols),*],\r\n                description = $docs_desc,\r\n                examples = $docs_examples,\r\n            }\r\n        )?\r\n\r\n        #[allow(missing_docs)]\r\n        #[derive(Debug, Clone)]\r\n        pub struct $name\u003c'i\u003e {\r\n            $($(pub $param: $param_t,)*)?\r\n            token: crate::Token\u003c'i\u003e,\r\n        }\r\n        impl crate::syntax_tree::traits::IntoOwned for $name\u003c'_\u003e {\r\n            type Owned = $name\u003c'static\u003e;\r\n            fn into_owned(self) -\u003e Self::Owned {\r\n                let $oselfvar = self;\r\n                $owned_hnd\r\n            }\r\n        }\r\n        impl\u003c'i\u003e crate::syntax_tree::traits::NodeExt\u003c'i\u003e for $name\u003c'i\u003e {\r\n            fn evaluate(\u0026self, $estatevar: \u0026mut crate::State) -\u003e Result\u003ccrate::Value, crate::Error\u003e {\r\n                let $selfvar = self;\r\n                $eval_hnd\r\n            }\r\n\r\n            fn token(\u0026self) -\u003e \u0026crate::Token\u003c'i\u003e {\r\n                \u0026self.token\r\n            }\r\n        }\r\n        #[allow(unused_mut)]\r\n        impl\u003c'i\u003e crate::syntax_tree::traits::SyntaxNodeBuilderExt\u003c'i\u003e for $name\u003c'i\u003e {\r\n            fn build(mut $pairsvar: crate::syntax_tree::pair::InnerPestIterator\u003c'i\u003e, $btokvar: crate::Token\u003c'i\u003e, $bstatevar: \u0026mut crate::State) -\u003e Result\u003ccrate::syntax_tree::Node\u003c'i\u003e, crate::Error\u003e\r\n            $build_hnd\r\n        }\r\n        /// Simplify conversion from node to AST node\r\n        impl\u003c'i\u003e From\u003c$name\u003c'i\u003e\u003e for crate::syntax_tree::Node\u003c'i\u003e {\r\n            fn from(node: $name\u003c'i\u003e) -\u003e Self {\r\n                Self::$oname(Box::new($oname::$name(node)))\r\n            }\r\n        }\r\n    };\r\n}\r\n\r\nmacro_rules! define_ast {\r\n    (\r\n        $name:ident {\r\n            $($iname:ident $(($($param:ident : $param_t:ty),*))? {\r\n                build = ($pairsvar:ident, $btokvar:ident, $bstatevar:ident) $build_hnd:block,\r\n                eval  = ($selfvar:ident, $estatevar:ident) $eval_hnd:block,\r\n                owned = ($oselfvar:ident) $owned_hnd:block\r\n                $(\r\n                        ,docs  = {\r\n                        name: $docs_name:literal,\r\n                        symbols = [$($docs_symbols:literal),*],\r\n                        description: $docs_desc:literal,\r\n                        examples: $docs_examples:literal,\r\n                    }\r\n                )?\r\n            }),+\r\n        }\r\n    ) =\u003e {\r\n        #[enum_dispatch::enum_dispatch]\r\n        #[derive(Debug, Clone)]\r\n        pub enum $name\u003c'i\u003e {\r\n            $( $iname($iname\u003c'i\u003e), )+\r\n        }\r\n        impl crate::syntax_tree::traits::IntoOwned for $name\u003c'_\u003e {\r\n            type Owned = $name\u003c'static\u003e;\r\n            fn into_owned(self) -\u003e Self::Owned {\r\n                match self {\r\n                    $(\r\n                        $name::$iname(node) =\u003e $name::$iname(node.into_owned()),\r\n                    )+\r\n                }\r\n            }\r\n        }\r\n        impl\u003c'i\u003e crate::syntax_tree::traits::NodeExt\u003c'i\u003e for $name\u003c'i\u003e {\r\n            fn evaluate(\u0026self, state: \u0026mut crate::State) -\u003e Result\u003cpolyvalue::Value, crate::Error\u003e {\r\n                match self {\r\n                    $(\r\n                        $name::$iname(node) =\u003e node.evaluate(state),\r\n                    )+\r\n                }\r\n            }\r\n            fn token(\u0026self) -\u003e \u0026crate::Token\u003c'i\u003e {\r\n                match self {\r\n                    $(\r\n                        $name::$iname(node) =\u003e node.token(),\r\n                    )+\r\n                }\r\n            }\r\n        }\r\n\r\n        $(\r\n            define_astnode! {\r\n                outer = $name,\r\n                $iname $({$($param: $param_t),*})?,\r\n                build = ($pairsvar, $btokvar, $bstatevar) $build_hnd,\r\n                eval  = ($selfvar, $estatevar) $eval_hnd,\r\n                owned = ($oselfvar) $owned_hnd\r\n                $(,docs  = {\r\n                    name: $docs_name,\r\n                    symbols = [$($docs_symbols),*],\r\n                    description: $docs_desc,\r\n                    examples: $docs_examples,\r\n                })?\r\n            }\r\n        )+\r\n    };\r\n}\r\n\r\nmacro_rules! define_handler {\r\n    ($name:ident ($pairsvar:ident, $btokvar:ident, $bstatevar:ident) $build_hnd:block) =\u003e {\r\n        pub struct $name;\r\n        #[allow(unused_mut)]\r\n        impl\u003c'i\u003e crate::syntax_tree::traits::SyntaxNodeBuilderExt\u003c'i\u003e for $name {\r\n            fn build(mut $pairsvar: crate::syntax_tree::pair::InnerPestIterator\u003c'i\u003e, $btokvar: crate::Token\u003c'i\u003e, $bstatevar: \u0026mut crate::State) -\u003e Result\u003ccrate::syntax_tree::Node\u003c'i\u003e, crate::Error\u003e\r\n            $build_hnd\r\n        }\r\n    };\r\n}\r\n\r\nmacro_rules! as_assignment_target {\r\n    ($value:expr) =\u003e {\r\n        match $value {\r\n            $crate::syntax_tree::Node::Values(node) =\u003e {\r\n                if let $crate::syntax_tree::nodes::Values::Reference(node) = *node {\r\n                    Some(node.target)\r\n                } else {\r\n                    None\r\n                }\r\n            }\r\n            $crate::syntax_tree::Node::Collections(node) =\u003e {\r\n                if let $crate::syntax_tree::nodes::Collections::Array(array) = *node {\r\n                    match array\r\n                        .elements\r\n                        .into_iter()\r\n                        .map(|e| match e {\r\n                            $crate::syntax_tree::Node::Values(node) =\u003e {\r\n                                if let $crate::syntax_tree::nodes::Values::Reference(node) = *node {\r\n                                    Some(node.target)\r\n                                } else {\r\n                                    None\r\n                                }\r\n                            }\r\n                            _ =\u003e None,\r\n                        })\r\n                        .collect::\u003cOption\u003cVec\u003c_\u003e\u003e\u003e()\r\n                    {\r\n                        Some(t) =\u003e Some(AssignmentTarget::Destructure(t)),\r\n                        None =\u003e None,\r\n                    }\r\n                } else {\r\n                    None\r\n                }\r\n            }\r\n            _ =\u003e None,\r\n        }\r\n    };\r\n}\r\n\r\nmacro_rules! as_reference {\r\n    ($value:expr) =\u003e {\r\n        match $value {\r\n            $crate::syntax_tree::Node::Values(node) =\u003e {\r\n                if let $crate::syntax_tree::nodes::Values::Reference(node) = *node {\r\n                    Some(node.target)\r\n                } else {\r\n                    None\r\n                }\r\n            }\r\n            _ =\u003e None,\r\n        }\r\n    };\r\n}\r\n\r\nmacro_rules! unwrap_next {\r\n    ($pairs:expr, $context:expr) =\u003e {\r\n        $pairs.next().unwrap_or_else(|| {\r\n            panic!(\r\n                \"Rule {:?} expected a token; Grammar bug - please report this.\",\r\n                $context.rule,\r\n            )\r\n        })\r\n    };\r\n}\r\n\r\nmacro_rules! unwrap_last {\r\n    ($pairs:expr, $context:expr) =\u003e {\r\n        $pairs.last_child().unwrap_or_else(|| {\r\n            panic!(\r\n                \"Rule {:?} expected a token; Grammar bug - please report this.\",\r\n                $context.rule,\r\n            )\r\n        })\r\n    };\r\n}\r\n\r\nmacro_rules! unwrap_node {\r\n    ($pairs:expr, $state:expr, $context:expr) =\u003e {\r\n        unwrap_next!($pairs, $context)\r\n            .into_node($state)\r\n            .with_context(\u0026$context)\r\n    };\r\n}\r\n","traces":[{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":1823},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":1823},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":2369},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":2369},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":1759},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":1759},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":1823},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":1823},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":589},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":18,"coverable":21},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","syntax_tree","mod.rs"],"content":"#[macro_use]\r\nmod macros;\r\n\r\nmod assignment_target;\r\npub mod nodes;\r\nmod pair;\r\nmod pratt;\r\npub mod traits;\r\n\r\npub use assignment_target::AssignmentTarget;\r\npub use nodes::Node;\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","syntax_tree","nodes","arithmetic.rs"],"content":"use super::Node;\r\nuse crate::{\r\n    error::{ErrorDetails, WrapExternalError, WrapOption},\r\n    syntax_tree::{assignment_target::AssignmentTarget, traits::IntoNode},\r\n    Rule,\r\n};\r\nuse polyvalue::{\r\n    operations::{ArithmeticOperation, ArithmeticOperationExt},\r\n    Value,\r\n};\r\n\r\n#[derive(Clone, Debug)]\r\npub enum IncDecType {\r\n    PreI,\r\n    PreD,\r\n    PostI,\r\n    PostD,\r\n}\r\nimpl IncDecType {\r\n    fn is_pre(\u0026self) -\u003e bool {\r\n        matches!(self, Self::PreI | Self::PreD)\r\n    }\r\n    fn operation(\u0026self) -\u003e ArithmeticOperation {\r\n        if matches!(self, Self::PreI | Self::PostI) {\r\n            ArithmeticOperation::Add\r\n        } else {\r\n            ArithmeticOperation::Subtract\r\n        }\r\n    }\r\n}\r\n\r\ndefine_ast!(\r\n    Arithmetic {\r\n        IncDec(target: AssignmentTarget\u003c'i\u003e, variant: IncDecType) {\r\n            build = (pairs, token, state) {\r\n                let (op, value) = if matches!(token.rule, Rule::PREFIX_INC | Rule::PREFIX_DEC) {\r\n                    (unwrap_next!(pairs, token).as_rule(), unwrap_node!(pairs, state, token)?)\r\n                } else {\r\n                    (token.rule, unwrap_node!(pairs, state, token)?)\r\n                };\r\n\r\n                let target = as_reference!(value).or_error(ErrorDetails::ConstantValue).with_context(\u0026token)?;\r\n                let variant = match op {\r\n                    Rule::PREFIX_INC =\u003e IncDecType::PreI,\r\n                    Rule::PREFIX_DEC =\u003e IncDecType::PreD,\r\n                    Rule::POSTFIX_INC =\u003e IncDecType::PostI,\r\n                    _ =\u003e IncDecType::PostD,\r\n                };\r\n\r\n                Ok(Self {\r\n                    target,\r\n                    variant,\r\n                    token,\r\n                }.into())\r\n            },\r\n            eval = (this, state) {\r\n                let value = this.target.get_value(state).with_context(this.token())?;\r\n                let increment = Value::from(1).as_type(value.own_type()).with_context(this.token())?;\r\n                let operation = this.variant.operation();\r\n\r\n                let new_value = value.clone().arithmetic_op(increment, operation)?;\r\n                this.target.update_value(state, new_value.clone()).with_context(this.token())?;\r\n\r\n                if this.variant.is_pre() {\r\n                    Ok(new_value)\r\n                } else {\r\n                    Ok(value)\r\n                }\r\n            },\r\n            owned = (this) {\r\n                Self::Owned {\r\n                    target: this.target.into_owned(),\r\n                    variant: this.variant,\r\n                    token: this.token.into_owned(),\r\n                }\r\n            },\r\n\r\n            docs = {\r\n                name: \"Increment/Decrement\",\r\n                symbols = [\"++\", \"--\"],\r\n                description: \"\r\n                    Increments or decrements a value.\r\n                    If used as a prefix, the value is updated before the expression is evaluated.\r\n                    If used as a postfix, the value is updated after the expression is evaluated.\r\n                \",\r\n                examples: \"\r\n                    a = 1; assert_eq(a++, 1);\r\n                    a = 1; assert_eq(--a, 0);\r\n                \",\r\n            }\r\n        },\r\n\r\n        ArithmeticNeg(value: Node\u003c'i\u003e) {\r\n            build = (pairs, token, state) {\r\n                pairs.next(); // Skip the operator\r\n                let value = unwrap_node!(pairs, state, token)?;\r\n                Ok(Self {\r\n                    value: value,\r\n                    token,\r\n                }\r\n                .into())\r\n            },\r\n            eval = (this, state) {\r\n                let value = this.value.evaluate(state).with_context(this.token())?;\r\n                value.arithmetic_neg().with_context(this.token())\r\n            },\r\n            owned = (this) {\r\n                Self::Owned {\r\n                    value: this.value.into_owned(),\r\n                    token: this.token.into_owned(),\r\n                }\r\n            },\r\n\r\n            docs = {\r\n                name: \"Unary Negation\",\r\n                symbols = [\"-\"],\r\n                description: \"Negates a value.\",\r\n                examples: \"-1\",\r\n            }\r\n        },\r\n\r\n        ArithmeticExpr(lhs: Node\u003c'i\u003e, op: ArithmeticOperation, rhs: Node\u003c'i\u003e) {\r\n            build = (pairs, token, state) {\r\n                let lhs = unwrap_node!(pairs, state, token)?;\r\n\r\n                let op = unwrap_next!(pairs, token);\r\n                let op = match op.as_rule() {\r\n                    Rule::OP_ADD =\u003e ArithmeticOperation::Add,\r\n                    Rule::OP_SUB =\u003e ArithmeticOperation::Subtract,\r\n                    Rule::OP_POW =\u003e ArithmeticOperation::Exponentiate,\r\n                    Rule::OP_DIV =\u003e ArithmeticOperation::Divide,\r\n                    Rule::OP_MOD =\u003e ArithmeticOperation::Modulo,\r\n                    Rule::OP_MUL =\u003e ArithmeticOperation::Multiply,\r\n                    _ =\u003e {\r\n                        return oops!(\r\n                            Internal {\r\n                                msg: format!(\"Unrecognize arithmetic operator {}\", op.as_str())\r\n                            },\r\n                            token\r\n                        )\r\n                    }\r\n                };\r\n\r\n                let rhs = unwrap_node!(pairs, state, token)?;\r\n\r\n                Ok(Self {\r\n                    lhs: lhs,\r\n                    op,\r\n                    rhs: rhs,\r\n                    token,\r\n                }\r\n                .into())\r\n            },\r\n            eval = (this, state) {\r\n                let lhs = this.lhs.evaluate(state).with_context(this.token())?;\r\n                let rhs = this.rhs.evaluate(state).with_context(this.token())?;\r\n                lhs.arithmetic_op(rhs, this.op).with_context(this.token())\r\n            },\r\n            owned = (this) {\r\n                Self::Owned {\r\n                    lhs: this.lhs.into_owned(),\r\n                    op: this.op,\r\n                    rhs: this.rhs.into_owned(),\r\n                    token: this.token.into_owned(),\r\n                }\r\n            },\r\n\r\n            docs = {\r\n                name: \"Arithmetic Expression\",\r\n                symbols = [\"+\", \"-\", \"*\", \"/\", \"%\", \"**\"],\r\n                description: \"\r\n                    Performs arithmetic operations on two values.\r\n                    All but exponentiation are left-associative.\r\n                \",\r\n                examples: \"\r\n                    1 + 2 / 3\r\n                    2 ** 3\r\n                \",\r\n            }\r\n        }\r\n    }\r\n);\r\n\r\n#[cfg(test)]\r\nmod test {\r\n    use crate::lav;\r\n\r\n    lav!(test_negation(a = -1i64, b = 1i64) r#\"\r\n        a = -1;\r\n        b = -a\r\n    \"#);\r\n\r\n    lav!(test_expr(a = 8i64, b = 0i64, c = 8i64) r#\"\r\n        a = 2 + 3 * 2;\r\n        b = 2 - 4 / 2;\r\n        c = 2 ** 3;\r\n    \"#);\r\n}\r\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":33},"fn_name":null}],"covered":13,"coverable":18},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","syntax_tree","nodes","assignment.rs"],"content":"use super::Node;\r\nuse crate::{\r\n    error::{ErrorDetails, WrapExternalError, WrapOption},\r\n    syntax_tree::{\r\n        assignment_target::AssignmentTarget,\r\n        traits::{IntoNode, NodeExt, SyntaxNodeBuilderExt},\r\n    },\r\n    Error, Rule, State,\r\n};\r\nuse polyvalue::{\r\n    operations::{\r\n        ArithmeticOperation, ArithmeticOperationExt, BitwiseOperation, BitwiseOperationExt,\r\n        BooleanOperation, BooleanOperationExt,\r\n    },\r\n    Value,\r\n};\r\n\r\n#[derive(Debug, Clone, Copy)]\r\n#[rustfmt::skip]\r\npub enum AssignmentOperation {\r\n    Add, Sub, Mul, Div, Mod, Pow,\r\n    BitAnd, BitOr, BitXor, BitSl, BitSr,\r\n    And, Or, None\r\n}\r\nimpl AssignmentOperation {\r\n    pub fn is_none(\u0026self) -\u003e bool {\r\n        matches!(self, Self::None)\r\n    }\r\n\r\n    pub fn is_some(\u0026self) -\u003e bool {\r\n        !self.is_none()\r\n    }\r\n\r\n    pub fn apply_to(\r\n        \u0026self,\r\n        state: \u0026mut State,\r\n        target: \u0026AssignmentTarget,\r\n        rhs: Value,\r\n    ) -\u003e Result\u003cValue, Error\u003e {\r\n        let value = if self.is_none() {\r\n            rhs\r\n        } else {\r\n            let lhs = target.get_value(state)?.clone();\r\n            let rhs = rhs.as_type(lhs.own_type())?;\r\n\r\n            match self {\r\n                Self::Add =\u003e lhs.arithmetic_op(rhs, ArithmeticOperation::Add)?,\r\n                Self::Sub =\u003e lhs.arithmetic_op(rhs, ArithmeticOperation::Subtract)?,\r\n                Self::Mul =\u003e lhs.arithmetic_op(rhs, ArithmeticOperation::Multiply)?,\r\n                Self::Div =\u003e lhs.arithmetic_op(rhs, ArithmeticOperation::Divide)?,\r\n                Self::Mod =\u003e lhs.arithmetic_op(rhs, ArithmeticOperation::Modulo)?,\r\n                Self::Pow =\u003e lhs.arithmetic_op(rhs, ArithmeticOperation::Exponentiate)?,\r\n\r\n                Self::BitAnd =\u003e lhs.bitwise_op(rhs, BitwiseOperation::And)?,\r\n                Self::BitOr =\u003e lhs.bitwise_op(rhs, BitwiseOperation::Or)?,\r\n                Self::BitXor =\u003e lhs.bitwise_op(rhs, BitwiseOperation::Xor)?,\r\n                Self::BitSl =\u003e lhs.bitwise_op(rhs, BitwiseOperation::LeftShift)?,\r\n                Self::BitSr =\u003e lhs.bitwise_op(rhs, BitwiseOperation::RightShift)?,\r\n\r\n                Self::And =\u003e lhs.boolean_op(rhs, BooleanOperation::And)?,\r\n                Self::Or =\u003e lhs.boolean_op(rhs, BooleanOperation::Or)?,\r\n\r\n                Self::None =\u003e rhs,\r\n            }\r\n        };\r\n\r\n        target.update_value(state, value.clone())?;\r\n        Ok(value)\r\n    }\r\n\r\n    pub fn apply(\r\n        \u0026self,\r\n        state: \u0026mut State,\r\n        target: \u0026AssignmentTarget,\r\n        rhs: Value,\r\n    ) -\u003e Result\u003cValue, Error\u003e {\r\n        match \u0026target {\r\n            // Assign a single value to multiple targets\r\n            AssignmentTarget::Destructure(targets) if rhs.len() == 1 =\u003e {\r\n                for target in targets {\r\n                    self.apply_to(state, target, rhs.clone())?;\r\n                }\r\n                target.get_value(state)\r\n            }\r\n\r\n            // Assign multiple values to multiple targets\r\n            AssignmentTarget::Destructure(targets) if rhs.len() == targets.len() =\u003e {\r\n                let rhs = rhs.as_a::\u003cVec\u003cValue\u003e\u003e()?;\r\n                for (target, value) in targets.into_iter().zip(rhs) {\r\n                    self.apply_to(state, target, value)?;\r\n                }\r\n                target.get_value(state)\r\n            }\r\n\r\n            // Target count mismatch\r\n            AssignmentTarget::Destructure(targets) =\u003e oops!(DestructuringAssignment {\r\n                expected_length: targets.len(),\r\n                actual_length: rhs.len()\r\n            }),\r\n\r\n            // Assign a single value to a single target\r\n            _ =\u003e self.apply_to(state, \u0026target, rhs),\r\n        }\r\n    }\r\n}\r\nimpl From\u003cRule\u003e for AssignmentOperation {\r\n    fn from(value: Rule) -\u003e Self {\r\n        match value {\r\n            Rule::OP_ASSIGN_ADD =\u003e Self::Add,\r\n            Rule::OP_ASSIGN_SUB =\u003e Self::Sub,\r\n            Rule::OP_ASSIGN_POW =\u003e Self::Pow,\r\n            Rule::OP_ASSIGN_MUL =\u003e Self::Mul,\r\n            Rule::OP_ASSIGN_DIV =\u003e Self::Div,\r\n            Rule::OP_ASSIGN_MOD =\u003e Self::Mod,\r\n            Rule::OP_BASSIGN_AND =\u003e Self::And,\r\n            Rule::OP_BASSIGN_OR =\u003e Self::Or,\r\n            Rule::OP_ASSIGN_AND =\u003e Self::BitAnd,\r\n            Rule::OP_ASSIGN_XOR =\u003e Self::BitXor,\r\n            Rule::OP_ASSIGN_OR =\u003e Self::BitOr,\r\n            Rule::OP_ASSIGN_SL =\u003e Self::BitSl,\r\n            Rule::OP_ASSIGN_SR =\u003e Self::BitSr,\r\n            _ =\u003e Self::None,\r\n        }\r\n    }\r\n}\r\n\r\ndefine_ast!(\r\n    Assignment {\r\n        DeleteExpression(target: AssignmentTarget\u003c'i\u003e) {\r\n            build = (pairs, token, state) {\r\n                let op = unwrap_next!(pairs, token);\r\n                let is_decorator = op.as_str().ends_with('@');\r\n                let target = unwrap_next!(pairs, token);\r\n\r\n                let target = target.into_node(state).with_context(\u0026token)?;\r\n                let mut target = as_assignment_target!(target).or_error(ErrorDetails::ConstantValue).with_context(\u0026token)?;\r\n\r\n                match target {\r\n                    AssignmentTarget::Identifier(ref mut id) =\u003e {\r\n                        if is_decorator {\r\n                            *id = format!(\"@{id}\");\r\n                        }\r\n                    }\r\n                    _ if is_decorator =\u003e {\r\n                        return oops!(\r\n                            DecoratorName {\r\n                                name: target.to_string()\r\n                            },\r\n                            token\r\n                        );\r\n                    }\r\n                    _ =\u003e {}\r\n                }\r\n\r\n                Ok(Self { target, token }.into())\r\n            },\r\n            eval = (this, state) {\r\n                this.target.delete(state).with_context(this.token())\r\n            },\r\n            owned = (this) {\r\n                Self::Owned {\r\n                    target: this.target.into_owned(),\r\n                    token: this.token.into_owned()\r\n                }\r\n            },\r\n            docs = {\r\n                name: \"Deletion Keyword\",\r\n                symbols = [\"del\", \"delete\", \"unset\"],\r\n                description: \"\r\n                    Deletes a value, function, @decorator, or index\r\n                    Will return the value deleted (or the function signature if a function was deleted)\r\n                    Index can be blank to delete the last value in an array, or negative to count from the end\r\n                    Indices can also be a collection to delete multiple values at once\r\n                \",\r\n                examples: \"\r\n                    a = 2; del a        // Deletes the variable a\r\n                    a = [1]; del a[]    // Deletes the last value in the array\r\n\r\n                    // Deletes the key 'test' from an object\r\n                    a = {'test': 1}\r\n                    del a['test']   \r\n\r\n                    a=1;b=2; del [a,b] // Deletes both a and b\r\n        \r\n                    @dec(x) = 2\r\n                    del @dec    // Deletes the decorator\r\n                \",\r\n            }\r\n        },\r\n\r\n        AssignmentExpression(target: AssignmentTarget\u003c'i\u003e, op: AssignmentOperation, rhs: Node\u003c'i\u003e) {\r\n            build = (pairs, token, state) {\r\n\r\n                let lhs = unwrap_next!(pairs, token);\r\n                let lhs = lhs.into_node(state).with_context(\u0026token)?;\r\n                let op = AssignmentOperation::from(unwrap_next!(pairs, token).as_rule());\r\n                let rhs = unwrap_node!(pairs, state, token)?;\r\n\r\n                let target = as_assignment_target!(lhs).or_error(ErrorDetails::ConstantValue).with_context(\u0026token)?;\r\n                Ok(Self { target, op, rhs, token }.into())\r\n            },\r\n            eval = (this, state) {\r\n                let rhs = this.rhs.evaluate(state).with_context(this.token())?;\r\n                this.op.apply(state, \u0026this.target, rhs).with_context(this.token())\r\n            },\r\n            owned = (this) {\r\n                Self::Owned {\r\n                    target: this.target.into_owned(),\r\n                    op: this.op,\r\n                    rhs: this.rhs.into_owned(),\r\n                    token: this.token.into_owned(),\r\n                }\r\n            },\r\n            docs = {\r\n                name: \"Assignment Operator\",\r\n                symbols = [\"=\", \"+=\", \"-=\", \"*=\", \"/=\", \"%=\", \"**=\", \"\u0026=\", \"|=\", \"^=\", \"\u003c\u003c=\", \"\u003e\u003e=\"],\r\n                description: \"\r\n                    Assigns a value to a variable, index, or destructuring assignment\r\n                    Target is either a literal with optional indices, or a destructuring assignment\r\n                    If an index is empty, a new value will be appended to the array\r\n                    If the target is a destructuring assignment, the value must be a collection of the same length\r\n                    If the operator is present, the value will be transformed before assignment\r\n\r\n                    Operators:\r\n                    - Arithmetic: `+=, -=, *=, /=, %=, **=`\r\n                    - Bitwise: `\u0026=, |=, ^=, \u003c\u003c=, \u003e\u003e=`\r\n                    - Boolean: `\u0026\u0026=, ||=`\r\n\r\n                    Note: Operators are not supported for destructuring assignments\r\n                \",\r\n                examples: \"\r\n                    [a, b] = [1, 2]     // Destructuring assignment\r\n                    a = 1; a += 1       // Arithmetic assignment\r\n                    a = [1]; a[] = 2    // Array index assignment (appends to array)\r\n                \",\r\n            }\r\n        }\r\n    }\r\n);\r\n\r\n#[cfg(test)]\r\nmod test {\r\n    use crate::lav;\r\n\r\n    lav!(test_del_ident r#\"\r\n        a=1; del a\r\n    \"#);\r\n\r\n    lav!(test_del_const(Error) r#\"\r\n        del 1\r\n    \"#);\r\n\r\n    lav!(test_del_const_arr(Error) r#\"\r\n        a=1; del [a,1]\r\n    \"#);\r\n\r\n    lav!(test_del_const_idx(Error) r#\"\r\n        a=1; del a[1]\r\n    \"#);\r\n\r\n    lav!(test_assign_ops r#\"\r\n        a=1; a+=1; assert_eq(a, 2)\r\n        b=1; b-=1; assert_eq(b, 0)\r\n        c=1; c*=2; assert_eq(c, 2)\r\n        d=4; d/=2; assert_eq(d, 2)\r\n        ee=4; ee%=2; assert_eq(ee, 0)\r\n        f=2; f**=3; assert_eq(f, 8)\r\n        g=2; g\u0026=3; assert_eq(g, 2)\r\n        h=2; h|=3; assert_eq(h, 3)\r\n        i=2; i^=3; assert_eq(i, 1)\r\n        j=2; j\u003c\u003c=3; assert_eq(j, 16)\r\n        k=2; k\u003e\u003e=3; assert_eq(k, 0)\r\n        l=true ; l\u0026\u0026=false; assert_eq(l, false)\r\n        m=true ; m||=false; assert_eq(m, true)\r\n    \"#);\r\n\r\n    lav!(test_assign_destructure r#\"\r\n        [a, b] = [1, [1,2]]\r\n        assert_eq(a, 1)\r\n        assert_eq(b, [1,2])\r\n\r\n        a = 1; b = 2;\r\n        [a, b] = [1, 1]\r\n        assert_eq(a, 1)\r\n        assert_eq(b, 1)\r\n        \r\n        [a, b] = 1\r\n        assert_eq(a, 1)\r\n        assert_eq(b, 1)\r\n    \"#);\r\n\r\n    lav!(test_assign_destructure_error(Error) r#\"\r\n        [a, b] = [1, 2, 3]\r\n    \"#);\r\n\r\n    lav!(test_buggy_push r#\"\r\n        save = {'choices':[]}; choice = 5\r\n        save['choices'].push(choice)\r\n        assert_eq(save['choices'], [5])\r\n    \"#);\r\n\r\n    lav!(test_assign_idx r#\"\r\n        a = [1, 2, 3]\r\n        a[0] = 2\r\n        assert_eq(a, [2, 2, 3])\r\n\r\n        assert_eq(a[], 3)\r\n        assert_eq(a[-1], 3)\r\n\r\n        a[] = [[[3]]]\r\n        assert_eq(a[][][0][], 3)\r\n    \"#);\r\n\r\n    lav!(test_assign_idx_error(Error) r#\"\r\n        a = [1, 2, 3]\r\n        a[4] = 2\r\n    \"#);\r\n\r\n    lav!(test_assign_idx_error2(Error) r#\"\r\n        a = [1, 2, 3]\r\n        a[0][1] = [1, 2]\r\n    \"#);\r\n}\r\n","traces":[{"line":28,"address":[],"length":0,"stats":{"Line":38},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":39},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":38},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":76},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":37},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":38},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":38},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":38},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":37},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":38},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":38},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":76},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":38},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":42,"coverable":79},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","syntax_tree","nodes","bitwise.rs"],"content":"use super::Node;\r\nuse crate::{error::WrapExternalError, syntax_tree::traits::IntoNode, Rule};\r\nuse polyvalue::operations::{BitwiseOperation, BitwiseOperationExt};\r\n\r\ndefine_ast!(Bitwise {\r\n    BitwiseNot(value: Node\u003c'i\u003e) {\r\n        build = (pairs, token, state) {\r\n            pairs.next(); // Skip the operator\r\n            let value = unwrap_node!(pairs, state, token)?;\r\n            Ok(Self {\r\n                value: value,\r\n                token,\r\n            }\r\n            .into())\r\n        },\r\n        eval = (this, state) {\r\n            let value = this.value.evaluate(state).with_context(this.token())?;\r\n            value.bitwise_not().with_context(this.token())\r\n        },\r\n        owned = (this) {\r\n            Self::Owned {\r\n                value: this.value.into_owned(),\r\n                token: this.token.into_owned(),\r\n            }\r\n        },\r\n\r\n        docs = {\r\n            name: \"Unary Bitwise Not\",\r\n            symbols = [\"~\"],\r\n            description: \"\r\n                A prefix operator that performs bitwise NOT on a value.\r\n                The value is first converted to an integer.\r\n                A larger set of bitwise operations are available in the 'bitwise' category of the standard library.\r\n            \",\r\n            examples: \"~5\",\r\n        }\r\n    },\r\n\r\n    BitwiseExpr(lhs: Node\u003c'i\u003e, op: BitwiseOperation, rhs: Node\u003c'i\u003e) {\r\n        build = (pairs, token, state) {\r\n            let lhs = unwrap_node!(pairs, state, token)?;\r\n\r\n            let op = unwrap_next!(pairs, token);\r\n            let op = match op.as_rule() {\r\n                Rule::OP_BIT_OR =\u003e BitwiseOperation::Or,\r\n                Rule::OP_BIT_XOR =\u003e BitwiseOperation::Xor,\r\n                Rule::OP_BIT_AND =\u003e BitwiseOperation::And,\r\n                Rule::OP_BIT_SL =\u003e BitwiseOperation::LeftShift,\r\n                Rule::OP_BIT_SR =\u003e BitwiseOperation::RightShift,\r\n                _ =\u003e {\r\n                    return oops!(\r\n                        Internal {\r\n                            msg: format!(\"Unrecognize bitwise operator {}\", op.as_str())\r\n                        },\r\n                        token\r\n                    )\r\n                }\r\n            };\r\n\r\n            let rhs = unwrap_node!(pairs, state, token)?;\r\n\r\n            Ok(Self {lhs, op, rhs, token}.into())\r\n        },\r\n        eval = (this, state) {\r\n            let lhs = this.lhs.evaluate(state).with_context(this.token())?;\r\n            let rhs = this.rhs.evaluate(state).with_context(this.token())?;\r\n            lhs.bitwise_op(rhs, this.op).with_context(this.token())\r\n        },\r\n        owned = (this) {\r\n            Self::Owned {\r\n                lhs: this.lhs.into_owned(),\r\n                op: this.op,\r\n                rhs: this.rhs.into_owned(),\r\n                token: this.token.into_owned(),\r\n            }\r\n        },\r\n\r\n        docs = {\r\n            name: \"Bitwise\",\r\n            symbols = [\"|\", \"^\", \"\u0026\", \"\u003c\u003c\", \"\u003e\u003e\"],\r\n            description: \"\r\n                A left-associative infix operator that performs bitwise operations on two values.\r\n                Values are first converted to integers.\r\n                Shifts are arithmetic for signed integers and logical for unsigned integers.\r\n                A larger set of bitwise operations are available in the 'bitwise' category of the standard library.\r\n            \",\r\n            examples: \"\r\n                5 | 3 \u0026 3\r\n                5 ^ 3\r\n                5 \u003c\u003c 3 \u003e\u003e 3\r\n            \",\r\n        }\r\n    }\r\n});\r\n","traces":[{"line":7,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":8,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":9,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":7},"fn_name":null}],"covered":12,"coverable":17},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","syntax_tree","nodes","boolean.rs"],"content":"use super::Node;\r\nuse crate::{error::WrapExternalError, syntax_tree::traits::IntoNode, Rule};\r\nuse polyvalue::operations::{BooleanOperation, BooleanOperationExt};\r\n\r\ndefine_ast!(Boolean {\r\n    BooleanNot(value: Node\u003c'i\u003e) {\r\n        build = (pairs, token, state) {\r\n            pairs.next(); // Skip the operator\r\n            let value = unwrap_node!(pairs, state, token)?;\r\n            Ok(Self {\r\n                value,\r\n                token,\r\n            }\r\n            .into())\r\n        },\r\n        eval = (this, state) {\r\n            let value = this.value.evaluate(state).with_context(this.token())?;\r\n            value.boolean_not().with_context(this.token())\r\n        },\r\n        owned = (this) {\r\n            Self::Owned {\r\n                value: this.value.into_owned(),\r\n                token: this.token.into_owned(),\r\n            }\r\n        },\r\n\r\n        docs = {\r\n            name: \"Unary Boolean Not\",\r\n            symbols = [\"not\"],\r\n            description: \"\r\n                Negates a boolean value.\r\n                If the value is not a boolean, it is cooerced to boolean first.\r\n            \",\r\n            examples: \"\r\n                !true == false\r\n                !'test' == false\r\n                !0 == true\r\n            \",\r\n        }\r\n    },\r\n\r\n    BooleanExpr(lhs: Node\u003c'i\u003e, op: BooleanOperation, rhs: Node\u003c'i\u003e) {\r\n        build = (pairs, token, state) {\r\n            let lhs = unwrap_node!(pairs, state, token)?;\r\n\r\n            let op = unwrap_next!(pairs, token);\r\n            let op = match op.as_rule() {\r\n                Rule::OP_BOOL_OR =\u003e BooleanOperation::Or,\r\n                Rule::OP_BOOL_AND =\u003e BooleanOperation::And,\r\n                Rule::OP_BOOL_EQ =\u003e BooleanOperation::EQ,\r\n                Rule::OP_BOOL_NE =\u003e BooleanOperation::NEQ,\r\n                Rule::OP_BOOL_LE =\u003e BooleanOperation::LTE,\r\n                Rule::OP_BOOL_GE =\u003e BooleanOperation::GTE,\r\n                Rule::OP_BOOL_LT =\u003e BooleanOperation::LT,\r\n                Rule::OP_BOOL_GT =\u003e BooleanOperation::GT,\r\n                _ =\u003e {\r\n                    return oops!(\r\n                        Internal {\r\n                            msg: format!(\"Unrecognize boolean operator {}\", op.as_str())\r\n                        },\r\n                        token\r\n                    )\r\n                }\r\n            };\r\n\r\n            let rhs = unwrap_node!(pairs, state, token)?;\r\n\r\n            Ok(Self { lhs, op, rhs, token }.into())\r\n        },\r\n        eval = (this, state) {\r\n            let lhs = this.lhs.evaluate(state).with_context(this.token())?;\r\n\r\n            // Short-circuiting\r\n            if this.op == BooleanOperation::Or \u0026\u0026 lhs.is_truthy() {\r\n                return Ok(true.into())\r\n            } else if this.op == BooleanOperation::And \u0026\u0026 !lhs.is_truthy() {\r\n                return Ok(false.into())\r\n            }\r\n\r\n            let rhs = this.rhs.evaluate(state).with_context(this.token())?;\r\n            lhs.boolean_op(rhs, this.op).with_context(this.token())\r\n        },\r\n        owned = (this) {\r\n            Self::Owned {\r\n                lhs: this.lhs.into_owned(),\r\n                op: this.op,\r\n                rhs: this.rhs.into_owned(),\r\n                token: this.token.into_owned(),\r\n            }\r\n        },\r\n\r\n        docs = {\r\n            name: \"Boolean\",\r\n            symbols = [\"or\", \"and\", \"==\", \"!=\", \"\u003c=\", \"\u003e=\", \"\u003c\", \"\u003e\"],\r\n            description: \"\r\n                Performs an infix boolean comparison between two values.\r\n                Comparisons are weak, meaning that the types of the values are not checked.\r\n                Result are always a boolean value.\r\n                And and Or are short-circuiting.\r\n                All are left-associative.\r\n            \",\r\n            examples: \"\r\n                true || false\r\n                1 \u003c 2\r\n            \",\r\n        }\r\n    }\r\n});\r\n","traces":[{"line":7,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":8,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":9,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":15},"fn_name":null}],"covered":14,"coverable":20},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","syntax_tree","nodes","collections.rs"],"content":"use super::{values::Reference, Node};\r\nuse crate::{\r\n    error::{ErrorDetails, WrapExternalError, WrapOption},\r\n    syntax_tree::{assignment_target::AssignmentTarget, traits::IntoNode},\r\n    Error, Rule,\r\n};\r\nuse polyvalue::{Value, ValueType};\r\n\r\ndefine_ast!(\r\n    Collections {\r\n        Array(elements: Vec\u003cNode\u003c'i\u003e\u003e) {\r\n            build = (pairs, token, state) {\r\n                pairs.next(); // Skip the bracket\r\n                let elements = pairs\r\n                    .map(|pair| pair.into_node(state))\r\n                    .collect::\u003cResult\u003cVec\u003c_\u003e, _\u003e\u003e().with_context(\u0026token)?;\r\n                Ok(Self { elements, token }.into())\r\n            },\r\n            eval = (this, state) {\r\n                let elements = this\r\n                    .elements\r\n                    .iter()\r\n                    .map(|element| element.evaluate(state))\r\n                    .collect::\u003cResult\u003cVec\u003c_\u003e, _\u003e\u003e().with_context(this.token())?;\r\n                Ok(Value::array(elements))\r\n            },\r\n            owned = (this) {\r\n                Self::Owned {\r\n                    elements: this.elements.into_iter().map(|e| e.into_owned()).collect(),\r\n                    token: this.token.into_owned(),\r\n                }\r\n            },\r\n\r\n            docs = {\r\n                name: \"Array Literals\",\r\n                symbols = [\"[ a, b, ... ]\"],\r\n                description: \"\r\n                    A collection of values.\r\n                    Arrays can contain any type of value, including other arrays.\r\n                    Arrays are 0-indexed, meaning the first element is at index 0.\r\n                    The indexing operator (a[b]) can be used to access elements of an array.\r\n                \",\r\n                examples: \"\r\n                    [1, 2, 3, 4, 5]\r\n                    [\\\"Hello\\\", \\\"World\\\"]\r\n                    [1, [2, 3], 4]\r\n                \",\r\n            }\r\n        },\r\n\r\n        Object(entries: Vec\u003c(Node\u003c'i\u003e, Node\u003c'i\u003e)\u003e) {\r\n            build = (pairs, token, state) {\r\n                let mut entries: Vec\u003c(_, _)\u003e = Vec::new();\r\n                while let Some(key) = pairs.next() {\r\n                    let key = key.into_node(state).with_context(\u0026token)?;\r\n                    let value = unwrap_node!(pairs, state, token)?;\r\n                    entries.push((key, value));\r\n                }\r\n\r\n                Ok(Self { entries, token }.into())\r\n            },\r\n            eval = (this, state) {\r\n                let values = this.entries.iter()\r\n                    .map(|(key, value)| Ok::\u003c(_, _), Error\u003e((key.evaluate(state).with_context(this.token())?, value.evaluate(state).with_context(this.token())?)))\r\n                    .collect::\u003cResult\u003cVec\u003c(_, _)\u003e, _\u003e\u003e().with_context(this.token())?;\r\n                Value::try_from(values).with_context(this.token())\r\n            },\r\n            owned = (this) {\r\n                Self::Owned {\r\n                    entries: this.entries.into_iter().map(|(k, v)| (k.into_owned(), v.into_owned())).collect(),\r\n                    token: this.token.into_owned(),\r\n                }\r\n            },\r\n\r\n            docs = {\r\n                name: \"Object Literals\",\r\n                symbols = [\"{ key: value, ... }\"],\r\n                description: \"\r\n                    A collection of key-value pairs.\r\n                    Values can contain any type, including other objects.\r\n                    Keys can be any non-collection type\r\n                    The indexing operator (a[b]) can be used to access elements of an object.\r\n                \",\r\n                examples: \"\r\n                    { \\\"name\\\": \\\"John\\\", \\\"age\\\": 25 }\r\n                    { \\\"name\\\": \\\"John\\\", \\\"address\\\": { \\\"city\\\": \\\"New York\\\", \\\"state\\\": \\\"NY\\\" } }\r\n                \",\r\n            }\r\n        },\r\n\r\n        Range(\r\n            start: Node\u003c'i\u003e,\r\n            end: Node\u003c'i\u003e\r\n        ) {\r\n            build = (pairs, token, state) {\r\n                let start = unwrap_node!(pairs, state, token)?;\r\n                pairs.next(); // Skip the '..'\r\n                let end = unwrap_node!(pairs, state, token)?;\r\n                Ok(Self { start, end, token }.into())\r\n            },\r\n\r\n            eval = (this, state) {\r\n                let start = this.start.evaluate(state).with_context(this.token())?;\r\n                let end = this.end.evaluate(state).with_context(this.token())?;\r\n\r\n                let (start, end) = start.resolve(end).with_context(this.token())?;\r\n                match start.own_type() {\r\n                    ValueType::String =\u003e {\r\n                        let start = start.as_a::\u003cString\u003e()?;\r\n                        let end = end.as_a::\u003cString\u003e()?;\r\n                        if start.len() != 1 || end.len() != 1 {\r\n                            return oops!(\r\n                                InvalidRange {\r\n                                    start: start.to_string(),\r\n                                    end: end.to_string()\r\n                                },\r\n                                this.token.clone()\r\n                            );\r\n                        }\r\n\r\n                        let start = start.chars().next().unwrap();\r\n                        let end = end.chars().next().unwrap();\r\n\r\n                        if start \u003e end {\r\n                            return oops!(\r\n                                RangeStartGT {\r\n                                    start: start.to_string(),\r\n                                    end: end.to_string()\r\n                                },\r\n                                this.token.clone()\r\n                            );\r\n                        }\r\n\r\n                        // as array spanning the range inclusively\r\n                        let array = (start..=end)\r\n                            .map(|i| Value::from(i.to_string()))\r\n                            .collect::\u003cVec\u003c_\u003e\u003e();\r\n                        Ok(Value::from(array))\r\n                    }\r\n\r\n                    _ if start.is_a(ValueType::Int) =\u003e {\r\n                        let start = start.as_a::\u003ci64\u003e()?;\r\n                        let end = end.as_a::\u003ci64\u003e()?;\r\n\r\n                        if start \u003e end {\r\n                            return oops!(\r\n                                RangeStartGT {\r\n                                    start: start.to_string(),\r\n                                    end: end.to_string()\r\n                                },\r\n                                this.token.clone()\r\n                            );\r\n                        }\r\n\r\n                        Ok(Value::range(start..=end))\r\n                    }\r\n\r\n                    _ =\u003e {\r\n                        oops!(RangeTypeMismatch, this.token.clone())\r\n                    }\r\n                }\r\n            },\r\n\r\n            owned = (this) {\r\n                Self::Owned {\r\n                    start: this.start.into_owned(),\r\n                    end: this.end.into_owned(),\r\n                    token: this.token.into_owned(),\r\n                }\r\n            },\r\n\r\n            docs = {\r\n                name: \"Range Literals\",\r\n                symbols = [\"first..last\"],\r\n                description: \"\r\n                    A range of values.\r\n                    Ranges can be used to create arrays of numbers or characters.\r\n                    Ranges are inclusive, meaning the start and end values are included in the array.\r\n                    Start and end values must be of the same type, and start must be \u003c= end.\r\n                    Character ranges are inclusive and can only be used with single-character strings.\r\n                \",\r\n                examples: \"\r\n                    1..5\r\n                    'a'..'z'\r\n                \",\r\n            }\r\n        },\r\n\r\n        IndexingExpression(base: Node\u003c'i\u003e, indices: Vec\u003cOption\u003cNode\u003c'i\u003e\u003e\u003e) {\r\n            build = (pairs, token, state) {\r\n                let base = unwrap_node!(pairs, state, token)?;\r\n                let indices = unwrap_next!(pairs, token);\r\n                let indices = indices\r\n                    .map(|pair| {\r\n                    if pair.as_rule() == Rule::POSTFIX_EMPTYINDEX {\r\n                        Ok::\u003c_, Error\u003e(None)\r\n                    } else {\r\n                        Ok(Some(pair.into_node(state).with_context(\u0026token)?))\r\n                    }\r\n                })\r\n                .collect::\u003cResult\u003cVec\u003c_\u003e, _\u003e\u003e().with_context(\u0026token)?;\r\n\r\n                let is_reference = match base {\r\n                    Node::Values(ref node) =\u003e match \u0026**node {\r\n                        super::Values::Reference(_) =\u003e true,\r\n                        _ =\u003e false,\r\n\r\n                    },\r\n                    _ =\u003e false,\r\n                };\r\n\r\n                if is_reference {\r\n                    let target = as_reference!(base).or_error(ErrorDetails::ConstantValue).with_context(\u0026token)?;\r\n                    Ok(Reference::new(AssignmentTarget::Index(target.to_string(), indices), token).into())\r\n                } else {\r\n                    Ok(Self { base, indices, token }.into())\r\n                }\r\n            },\r\n\r\n            eval = (this, state) {\r\n                let base = this.base.evaluate(state).with_context(this.token())?;\r\n                let indices = this\r\n                    .indices\r\n                    .iter()\r\n                    .map(|index| {\r\n                        if let Some(index) = index {\r\n                            Ok::\u003c_, Error\u003e(Some(index.evaluate(state).with_context(this.token())?))\r\n                        } else {\r\n                            Ok(None)\r\n                        }\r\n                    })\r\n                    .collect::\u003cResult\u003cVec\u003c_\u003e, _\u003e\u003e().with_context(this.token())?;\r\n                let value = AssignmentTarget::get_index_handle(base, \u0026indices).with_context(this.token())?;\r\n                Ok(value.clone())\r\n            },\r\n\r\n            owned = (this) {\r\n                Self::Owned {\r\n                    base: this.base.into_owned(),\r\n                    indices: this.indices.into_iter().map(|i| i.map(|i| i.into_owned())).collect(),\r\n                    token: this.token.into_owned(),\r\n                }\r\n            },\r\n\r\n            docs = {\r\n                name: \"Indexing\",\r\n                symbols = [\"a[b]\", \"a[]\"],\r\n                description: \"\r\n                    Accessing elements of a collection.\r\n                    The indexing operator can be used to access elements of a collection or string.\r\n                    If the index is a collection, it is used to access multiple elements.\r\n                    If the index is a string, it is used to access a character.\r\n                    If the index is blank, it is used to access the last element of the collection.\r\n                    Negative indices can be used to access elements from the end of the collection.\r\n                \",\r\n                examples: \"\r\n                    [1, 2, 3][0]\r\n                    [1, 2, 3][0..1]\r\n                    { \\\"name\\\": \\\"John\\\", \\\"age\\\": 25 }[\\\"name\\\"]\r\n                \",\r\n            }\r\n        }\r\n    }\r\n);\r\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":852},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":852},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":1704},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":2767},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":852},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":1056},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":87},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":34},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":31,"coverable":37},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","syntax_tree","nodes","conditionals.rs"],"content":"use super::Node;\r\nuse crate::{\r\n    error::{ErrorDetails, WrapExternalError},\r\n    functions::{ParserFunction, UserDefinedFunction},\r\n    syntax_tree::traits::{IntoNode, IntoOwned},\r\n    Error, Rule, Token,\r\n};\r\nuse polyvalue::{\r\n    types::{Object, Range},\r\n    Value, ValueTrait, ValueType,\r\n};\r\n\r\ndefine_ast!(\r\n    Conditionals {\r\n        IfExpression(\r\n            condition: Node\u003c'i\u003e,\r\n            then_branch: Node\u003c'i\u003e,\r\n            else_branch: Node\u003c'i\u003e\r\n        ) {\r\n            build = (pairs, token, state) {\r\n                if pairs.len() % 2 == 0 {\r\n                    // We parse as a set of (if, then) pairs ending with an else\r\n                    // if the number of children is even, we have no else\r\n                    return oops!(NoElseBlock, token.clone());\r\n                }\r\n\r\n                // We will begin at the end, the final right-side expression\r\n                // Then we will work backwards, grabbing pairs of expressions\r\n                // And turning them into ternary expressions with the previous\r\n                // iteration as the false side until we run out of children\r\n                let mut else_branch = unwrap_last!(pairs, token).into_node(state).with_context(\u0026token)?;\r\n                while pairs.peek().is_some() {\r\n                    let then_branch = unwrap_last!(pairs, token).into_node(state).with_context(\u0026token)?;\r\n                    let condition = unwrap_last!(pairs, token).into_node(state).with_context(\u0026token)?;\r\n\r\n                    else_branch = Self {\r\n                        condition,\r\n                        then_branch,\r\n                        else_branch,\r\n                        token: token.clone(),\r\n                    }.into();\r\n                }\r\n\r\n                Ok(else_branch)\r\n            },\r\n            eval = (this, state) {\r\n                let condition = this.condition.evaluate(state).with_context(this.token())?;\r\n                state.scope_into().with_context(this.token())?;\r\n                let result = if condition.is_truthy() {\r\n                    this.then_branch.evaluate(state)\r\n                } else {\r\n                    this.else_branch.evaluate(state)\r\n                };\r\n\r\n                state.scope_out();\r\n                result\r\n            },\r\n            owned = (this) {\r\n                Self::Owned {\r\n                    condition: this.condition.into_owned(),\r\n                    then_branch: this.then_branch.into_owned(),\r\n                    else_branch: this.else_branch.into_owned(),\r\n                    token: this.token.into_owned(),\r\n                }\r\n            },\r\n\r\n            docs = {\r\n                name: \"If\",\r\n                symbols = [\"if \u003ccondition\u003e then \u003cblock\u003e else \u003cblock\u003e\", \"if \u003ccondition\u003e {block} else {block}\"],\r\n                description: \"\r\n                    A conditional expression that evaluates a condition and then one of two branches.\r\n                    body can be either a block or a single expression. The last expression is returned from a block.\r\n                    Since all expressions in lavendeux return a value, the if expression will return the value of the branch that is executed.\r\n                    As such, all if expressions must have both a then and an else branch.\r\n                    If a condition doesn't need to return a value (side-effect `if`s for example), use `nil`\r\n                \",\r\n                examples: \"\r\n                    a = 6\r\n                    if a \u003e 5 { a } else { 5 }\r\n                    if a == 4 {\r\n                        a\r\n                    } else if a == 5 {\r\n                        5\r\n                    } else nil\r\n                \",\r\n            }\r\n        },\r\n\r\n        SwitchExpression(\r\n            match_on: Node\u003c'i\u003e,\r\n            cases: Vec\u003cSwitchCase\u003c'i\u003e\u003e\r\n        ) {\r\n            build = (pairs, token, state) {\r\n                let match_on = unwrap_node!(pairs, state, token)?;\r\n                let mut cases = vec![];\r\n\r\n                while let Some(case) = pairs.next()  {\r\n                    let body = unwrap_node!(pairs, state, token)?;\r\n\r\n                    if case.as_str() == \"_\" {\r\n                        cases.push(SwitchCase::Default(body));\r\n                        if pairs.next().is_some() {\r\n                            return oops!(UnreachableSwitchCase, token);\r\n                        }\r\n\r\n                        break;\r\n                    } else {\r\n                        cases.push(SwitchCase::Case(case.into_node(state).with_context(\u0026token)?, body));\r\n                    }\r\n                }\r\n\r\n                Ok(Self {\r\n                    match_on,\r\n                    cases,\r\n                    token,\r\n                }.into())\r\n            },\r\n            eval = (this, state) {\r\n                let match_on = this.match_on.evaluate(state).with_context(this.token())?;\r\n\r\n                for case in \u0026this.cases {\r\n                    match case {\r\n                        SwitchCase::Default(body) =\u003e {\r\n                            state.scope_into().with_context(this.token())?;\r\n                            let result = body.evaluate(state);\r\n\r\n                            state.scope_out();\r\n                            return result;\r\n                        },\r\n\r\n                        SwitchCase::Case(value, body) =\u003e {\r\n                            let value = value.evaluate(state).with_context(this.token())?;\r\n\r\n                            if value.own_type() != match_on.own_type() {\r\n                                return oops!(SwitchCaseTypeMismatch {\r\n                                    case: value,\r\n                                    expected_type: match_on.own_type()\r\n                                }, this.token.clone());\r\n                            }\r\n\r\n                            if value == match_on {\r\n                                state.scope_into().with_context(this.token())?;\r\n                                let result = body.evaluate(state);\r\n\r\n                                state.scope_out();\r\n                                return result;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                oops!(NonExhaustiveSwitch, this.token.clone())\r\n            },\r\n            owned = (this) {\r\n                Self::Owned {\r\n                    match_on: this.match_on.into_owned(),\r\n                    cases: this.cases.into_iter().map(|c| c.into_owned()).collect(),\r\n                    token: this.token.into_owned(),\r\n                }\r\n            },\r\n            docs = {\r\n                name: \"match\",\r\n                symbols = [\"match \u003cvalue\u003e { \u003ccondition\u003e =\u003e \u003cblock\u003e, _ =\u003e \u003cblock\u003e }\"],\r\n                description: \"\r\n                    A conditional expression that evaluates a value and then one of several cases.\r\n                    match blocks must be exhaustive, and therefore must end in a default case\r\n                \",\r\n                examples: \"\r\n                    a = 6\r\n                    match a {\r\n                        5 =\u003e { 'five' },\r\n                        6 =\u003e { 'six' },\r\n                        _ =\u003e { 'other' }\r\n                    }\r\n                \",\r\n            }\r\n        }\r\n    }\r\n);\r\n\r\n#[derive(Debug, Clone)]\r\npub enum SwitchCase\u003c'i\u003e {\r\n    Default(Node\u003c'i\u003e),\r\n    Case(Node\u003c'i\u003e, Node\u003c'i\u003e),\r\n}\r\nimpl IntoOwned for SwitchCase\u003c'_\u003e {\r\n    type Owned = SwitchCase\u003c'static\u003e;\r\n    fn into_owned(self) -\u003e Self::Owned {\r\n        match self {\r\n            Self::Default(node) =\u003e Self::Owned::Default(node.into_owned()),\r\n            Self::Case(condition, body) =\u003e {\r\n                Self::Owned::Case(condition.into_owned(), body.into_owned())\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ndefine_handler!(\r\n    TernaryExpression(pairs, token, state) {\r\n        let condition = unwrap_node!(pairs, state, token)?;\r\n\r\n        let mut then_pair = unwrap_next!(pairs, token);\r\n        let then_branch = unwrap_node!(then_pair, state, token)?;\r\n        let else_branch = unwrap_node!(pairs, state, token)?;\r\n\r\n        Ok(IfExpression {\r\n            condition: condition,\r\n            then_branch: then_branch,\r\n            else_branch: else_branch,\r\n            token,\r\n        }.into())\r\n    }\r\n);\r\ndocument_operator!(\r\n    name = \"Ternary\",\r\n    rules = [],\r\n    symbols = [\"condition ? then : else\"],\r\n    description = \"\r\n        A right-associative ternary operator.\r\n        The condition is evaluated first, then either the then or else branch is evaluated.\r\n    \",\r\n    examples = \"true ? 1 : 2\",\r\n);\r\n","traces":[{"line":20,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":30,"coverable":39},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","syntax_tree","nodes","core.rs"],"content":"use crate::{\r\n    error::WrapExternalError,\r\n    syntax_tree::{pratt, traits::IntoNode},\r\n    Token,\r\n};\r\n\r\nuse super::Node;\r\nuse polyvalue::Value;\r\n\r\ndefine_ast!(\r\n    Core {\r\n        Script(statements: Vec\u003cNode\u003c'i\u003e\u003e) {\r\n            build = (pairs, token, state) {\r\n                let statements = pairs\r\n                    .map(|pair| pair.into_node(state))\r\n                    .collect::\u003cResult\u003cVec\u003c_\u003e, _\u003e\u003e()?;\r\n                let node = Self { statements, token };\r\n                Ok(node.into())\r\n            },\r\n            eval = (this, state) {\r\n                Ok(\r\n                    Value::array(\r\n                        this.statements\r\n                            .iter()\r\n                            .map(|s| s.evaluate(state))\r\n                            .collect::\u003cResult\u003cVec\u003c_\u003e, _\u003e\u003e()?\r\n                    )\r\n                )\r\n            },\r\n            owned = (this) {\r\n                Self::Owned {\r\n                    statements: this.statements\r\n                        .into_iter()\r\n                        .map(|s| s.into_owned())\r\n                        .collect(),\r\n                    token: this.token.into_owned(),\r\n                }\r\n            },\r\n            docs = {\r\n                name: \"Script\",\r\n                symbols = [\"\u003cstatement\u003e [ ; | \\\\n ] \u003cstatement\u003e\"],\r\n                description: \"\r\n                    A series of expressions or function definitions that are executed in order, and are separated by semicolons or linebreaks.\r\n                \",\r\n                examples: \"\r\n                    1 + 2 ; 3 @hex\r\n                    min([1, 2, 3])\r\n                \",\r\n            }\r\n        },\r\n\r\n        Block(statements: Vec\u003cNode\u003c'i\u003e\u003e) {\r\n            build = (pairs, token, state) {\r\n                let statements = pairs\r\n                    .map(|pair| pair.into_node(state))\r\n                    .collect::\u003cResult\u003cVec\u003c_\u003e, _\u003e\u003e()?;\r\n\r\n                if statements.is_empty() {\r\n                    return oops!(EmptyBlock, token);\r\n                }\r\n\r\n                let node = Self { statements, token };\r\n                Ok(node.into())\r\n            },\r\n            eval = (this, state) {\r\n                let mut value = None;\r\n                for statement in \u0026this.statements {\r\n                    value = Some(statement.evaluate(state)?);\r\n                }\r\n                Ok(value.unwrap_or_else(|| Value::from(false)))\r\n            },\r\n            owned = (this) {\r\n                Self::Owned {\r\n                    statements: this.statements\r\n                        .into_iter()\r\n                        .map(|s| s.into_owned())\r\n                        .collect(),\r\n                    token: this.token.into_owned(),\r\n                }\r\n            },\r\n            docs = {\r\n                name: \"Block\",\r\n                symbols = [\"{ \u003cstatements\u003e }\"],\r\n                description: \"\r\n                    A series of expressions that are executed in order, and are separated by semicolons or linebreaks.\r\n                    The last statement's value is returned.\r\n                    A block must return a value, and thus cannot be empty.\r\n                    If a block doesn't need to return a value (side-effect `if`s for example), use `nil`\r\n                \",\r\n                examples: \"\r\n                    if true {\r\n                        1; 2\r\n                    } else nil\r\n                \",\r\n            }\r\n        }\r\n    }\r\n);\r\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":176},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":351},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":685},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":177},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":327},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":87},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":3},"fn_name":null}],"covered":12,"coverable":15},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","syntax_tree","nodes","functions.rs"],"content":"use super::Node;\r\nuse crate::{\r\n    error::{ErrorDetails, WrapExternalError},\r\n    functions::{ParserFunction, UserDefinedFunction},\r\n    syntax_tree::traits::IntoNode,\r\n    Error, Rule, Token,\r\n};\r\nuse polyvalue::{Value, ValueType};\r\n\r\ndefine_ast!(\r\n    Functions {\r\n        KeywordReturn(value: Node\u003c'i\u003e) {\r\n            build = (pairs, token, state) {\r\n                let value = unwrap_node!(pairs, state, token)?;\r\n                Ok(Self { value, token }.into())\r\n            },\r\n            eval = (this, state) {\r\n                let value = this.value.evaluate(state).with_context(this.token())?;\r\n                oops!(Return { value }, this.token().clone())\r\n            },\r\n            owned = (this) {\r\n                Self::Owned {\r\n                    value: this.value.into_owned(),\r\n                    token: this.token.into_owned(),\r\n                }\r\n            },\r\n            docs = {\r\n                name: \"Return\",\r\n                symbols = [\"return \u003cvalue\u003e\"],\r\n                description: \"\r\n                    Returns a value from a function.\r\n                    By default, the last expression is returned, unless a return statement is used.\r\n                \",\r\n                examples: \"\r\n                    a() = { return 5 ; 2 }\r\n                    b() = { 5 ; 2 }\r\n                    \r\n                    assert_eq( a(), 5 )\r\n                    assert_eq( b(), 2 )\r\n                \",\r\n            }\r\n        },\r\n\r\n        FunctionCall(name: String, arguments: Vec\u003cNode\u003c'i\u003e\u003e) {\r\n            build = (pairs, token, state) {\r\n                let lhs = unwrap_next!(pairs, token); // Function name, or the first argument of an object mode call\r\n                let mut rhs = unwrap_next!(\r\n                    unwrap_next!(pairs, token),\r\n                    token\r\n                ); // Arguments, or function name and arguments in object mode\r\n\r\n                let mut node = match rhs.as_rule() {\r\n                    Rule::POSTFIX_NORMALMODE =\u003e {\r\n                        let name = lhs.as_str().to_string();\r\n                        let arguments = if \u0026name == \"help\" {\r\n                            match rhs.next() {\r\n                                Some(arg) =\u003e vec![Node::Literal(Value::from(arg.as_str().to_string()), token.clone())],\r\n                                None =\u003e Vec::new(),\r\n                            }\r\n                        } else {\r\n                            rhs.map(|p| p.into_node(state)).collect::\u003cResult\u003cVec\u003c_\u003e, _\u003e\u003e().with_context(\u0026token)?\r\n                        };\r\n\r\n                        Self { name, arguments, token }\r\n                    }\r\n\r\n                    // Rule::POSTFIX_OBJECTMODE\r\n                    _ =\u003e {\r\n                        let mut rhs = rhs;\r\n                        let name = unwrap_next!(rhs, token).as_str().to_string();\r\n\r\n                        let rhs = unwrap_next!(rhs, token);\r\n                        let arguments = vec![lhs.into_node(state)] // First argument\r\n                            .into_iter()\r\n                            .chain(rhs.map(|p| p.into_node(state)))\r\n                            .collect::\u003cResult\u003cVec\u003c_\u003e, _\u003e\u003e().with_context(\u0026token)?;\r\n\r\n                        Self { name, arguments, token }\r\n                    }\r\n                };\r\n\r\n                Ok(node.into())\r\n            },\r\n            eval = (this, state) {\r\n                if \u0026this.name == \"help\" {\r\n                    let filter = match this.arguments.first() {\r\n                        Some(n) =\u003e Some(n.evaluate(state).with_context(this.token())?.to_string()),\r\n                        None =\u003e None\r\n                    };\r\n\r\n                    let help_text = state.help(filter);\r\n                    return Ok(Value::from(help_text));\r\n                }\r\n\r\n                // Collect arguments\r\n                let mut arguments = Vec::new();\r\n                for argument in this.arguments.iter() {\r\n                    arguments.push(argument.evaluate(state).with_context(this.token())?);\r\n                }\r\n\r\n                // Update reference argument\r\n                let reference = this.arguments.first().and_then(|arg1| {\r\n                    as_reference!(arg1.clone())\r\n                });\r\n\r\n                let value = match state.call_function(\u0026this.name, arguments, reference.as_ref()) {\r\n                    Ok(value) =\u003e value,\r\n                    Err(e) =\u003e {\r\n                        if let ErrorDetails::Return { value, .. } = e.details {\r\n                            value\r\n                        } else {\r\n                            return Err(ErrorDetails::FunctionCall { name: this.name.clone() })\r\n                            .with_context(this.token())\r\n                            .with_source(e)\r\n                        }\r\n                    },\r\n                };\r\n\r\n                Ok(value)\r\n            },\r\n            owned = (this) {\r\n                Self::Owned {\r\n                    name: this.name,\r\n                    arguments: this.arguments\r\n                        .into_iter()\r\n                        .map(|s| s.into_owned())\r\n                        .collect(),\r\n                    token: this.token.into_owned(),\r\n                }\r\n            },\r\n\r\n            docs = {\r\n                name: \"Function Call\",\r\n                symbols = [\"name(arg1, arg2, ...)\", \"arg1.func(arg2, arg3, ...)\"],\r\n                description: \"\r\n                    Calls a function with the given arguments.\r\n                    The help() will list all available functions, and can filter by category or function name.\r\n\r\n                    Functions can be called as `name(arg1, arg2, ...)` or `arg1.func(arg2, arg3, ...)`.\r\n                    Some stdlib functions such as `push`, `pop`, etc take the 1st argument as a reference.\r\n                    In every other case, all arguments are passed by value.\r\n                \",\r\n                examples: \"\r\n                    arr = []\r\n                    push(arr, 3)\r\n                    arr.push(3)\r\n                    help(push)\r\n                    help(collections)\r\n                \",\r\n            }\r\n        }\r\n    }\r\n);\r\n\r\ndefine_handler!(\r\n    FunctionDefinition(pairs, token, state) {\r\n        let name = unwrap_next!(pairs, token).as_str().to_string();\r\n        let src = pairs.last_child().unwrap().as_str().to_string();\r\n\r\n        let mut returns = match pairs.peek_last() {\r\n            Some(p) if p.as_rule() == Rule::function_typespec =\u003e {\r\n                let t = pairs.last_child().unwrap().last_child().unwrap();\r\n                let t = t.as_str();\r\n                ValueType::try_from(t).with_context(\u0026token)?\r\n            },\r\n            _ =\u003e ValueType::Any\r\n        };\r\n\r\n        let arguments = pairs.map(|arg| {\r\n            let mut arg = arg;\r\n            let name = unwrap_next!(arg, token).as_str().to_string();\r\n            let t = match arg.next() {\r\n                Some(t) =\u003e {\r\n                    let t = t.as_str();\r\n                    ValueType::try_from(t).with_context(\u0026token)?\r\n                }\r\n                None =\u003e ValueType::Any\r\n            };\r\n            Ok((name, t))\r\n        }).collect::\u003cResult\u003cVec\u003c_\u003e, Error\u003e\u003e().with_context(\u0026token)?;\r\n\r\n        // Make sure decorators follow the `@name(in): string` signature\r\n        if name.starts_with('@') {\r\n            if arguments.len() != 1 {\r\n                return Err(ErrorDetails::DecoratorSignatureArgs { name: name.clone() })\r\n                .with_context(\u0026token);\r\n            } else if returns != ValueType::Any {\r\n                return Err(ErrorDetails::DecoratorSignatureReturn { name: name.clone() })\r\n                .with_context(\u0026token);\r\n            }\r\n\r\n            returns = ValueType::String;\r\n        }\r\n\r\n        let mut function = UserDefinedFunction::new(\u0026name, src.clone(), state).with_context(\u0026token)?;\r\n        function.set_returns(returns);\r\n      //  function.set_src_line_offset(token.line);\r\n\r\n        for (name, t) in arguments.iter() {\r\n            function.add_arg(name, *t);\r\n        }\r\n\r\n        let sig = function.signature();\r\n        state.register_function(function).with_context(\u0026token)?;\r\n        Ok(Node::Literal(Value::from(sig), token))\r\n    }\r\n);\r\ndocument_operator!(\r\n    name = \"Function Assignment\",\r\n    rules = [],\r\n    symbols = [\"name([arg1:type, arg2, ...]) = { ... }\"],\r\n    description = \"\r\n        Assigns a block of code to a function name.\r\n        The function can be called later in the code.\r\n        If the function name begins with `@`, it is a decorator and must take in one argument and return a string\r\n\r\n        Function body can be a block of code or a single expression. The last expression is returned, unless a return statement is used.\r\n        Return type or argued types can be specified with `: type`, but are optional.\r\n\r\n        Arguments will be cooerced to the specified type if provided, as will the return value.\r\n        Valid type names are: `u[8-64]`, `i[8-64]`, `float`, `int`, `numeric`, `string`, `array`, `object`, `bool`, `any`.\r\n    \",\r\n    examples = \"\r\n        // Decorator taking in a number and returning a string\r\n        @double(x:numeric) = 2*x\r\n        5 @double\r\n\r\n        // Takes in any 2 numeric values, and returns an integer (i64 by default)\r\n        add(a:numeric, b:numeric): int = {\r\n            a + b\r\n        }\r\n        add(3, 4.5)\r\n    \",\r\n);\r\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":366},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":366},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":366},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":732},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":362},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":362},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":948},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":349},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":349},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":331},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":7},"fn_name":null}],"covered":46,"coverable":56},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","syntax_tree","nodes","iterators.rs"],"content":"use super::Node;\r\nuse crate::{\r\n    error::{ErrorDetails, WrapExternalError},\r\n    functions::{ParserFunction, UserDefinedFunction},\r\n    pest::NodeExt,\r\n    syntax_tree::traits::IntoNode,\r\n    Error, Rule, Token,\r\n};\r\nuse polyvalue::{\r\n    types::{Object, Range},\r\n    Value, ValueTrait, ValueType,\r\n};\r\n\r\ndefine_ast!(\r\n    Iterators {\r\n        KeywordContinue() {\r\n            build = (_pairs, token, _state) {\r\n                Ok(Self { token }.into())\r\n            },\r\n            eval = (this, _state) {\r\n                oops!(Skip, this.token.clone())\r\n            },\r\n            owned = (this) {\r\n                Self::Owned { token: this.token.into_owned() }\r\n            },\r\n            docs = {\r\n                name: \"Continue\",\r\n                symbols = [\"continue\"],\r\n                description: \"Skips the current iteration of a loop\",\r\n                examples: \"\r\n                    for i in 0..10 { if i == 5 { continue } else {i} } \r\n                \",\r\n            }\r\n        },\r\n\r\n        KeywordBreak() {\r\n            build = (_pairs, token, _state) {\r\n                Ok(Self { token }.into())\r\n            },\r\n            eval = (this, _state) {\r\n                oops!(Break, this.token.clone())\r\n            },\r\n            owned = (this) {\r\n                Self::Owned { token: this.token.into_owned() }\r\n            },\r\n            docs = {\r\n                name: \"Break\",\r\n                symbols = [\"break\"],\r\n                description: \"Breaks out of a loop\",\r\n                examples: \"\r\n                    for i in 0..10 { if i == 5 { break } else {i} }\r\n                \",\r\n            }\r\n        },\r\n\r\n        ForLoopExpression(\r\n            variable: Option\u003cString\u003e,\r\n            iterable: Node\u003c'i\u003e,\r\n            body: Node\u003c'i\u003e,\r\n            condition: Option\u003cNode\u003c'i\u003e\u003e\r\n        ) {\r\n            build = (pairs, token, state) {\r\n                let condition = match pairs.peek_last() {\r\n                    Some(p) if p.as_rule() == Rule::for_conditional =\u003e {\r\n                        Some(\r\n                            unwrap_node!(\r\n                                unwrap_last!(pairs, token),\r\n                                state,\r\n                                token\r\n                            )?\r\n                        )\r\n                    },\r\n                    _ =\u003e None,\r\n                };\r\n\r\n                let body = pairs.last_child().unwrap().into_node(state).with_context(\u0026token)?;\r\n                let iterable = pairs.last_child().unwrap().into_node(state).with_context(\u0026token)?;\r\n                let variable = pairs.last_child().map(|p| p.as_str().to_string());\r\n\r\n                Ok(Self { variable, iterable, body, condition, token }.into())\r\n            },\r\n\r\n            eval = (this, state) {\r\n                let iterable = this.iterable.evaluate(state).with_context(this.token())?;\r\n                match iterable.own_type() {\r\n                    ValueType::Range =\u003e {\r\n                        let iterable = iterable.as_a::\u003cRange\u003e().with_context(this.token())?.into_inner();\r\n                        let values = iterable.into_iter().map(|i| {\r\n                            state.check_timer()?;\r\n                            Ok::\u003c_, Error\u003e(Value::from(i))\r\n                        }).collect::\u003cResult\u003cVec\u003c_\u003e, _\u003e\u003e().with_context(this.token())?;\r\n                        iterate_over(values.into_iter(), state, this)\r\n                    },\r\n\r\n                    ValueType::Object =\u003e {\r\n                        let iterable = iterable.as_a::\u003cObject\u003e().with_context(this.token())?;\r\n                        let iterable = iterable.keys().into_iter().cloned();\r\n                        iterate_over(iterable, state, this)\r\n                    },\r\n\r\n                    _ =\u003e {\r\n                        let iterable = iterable.as_a::\u003cVec\u003cValue\u003e\u003e().with_context(this.token())?;\r\n                        iterate_over(iterable.into_iter(), state, this)\r\n                    }\r\n                }\r\n            },\r\n\r\n            owned = (this) {\r\n                Self::Owned {\r\n                    variable: this.variable,\r\n                    iterable: this.iterable.into_owned(),\r\n                    body: this.body.into_owned(),\r\n                    condition: this.condition.map(|c| c.into_owned()),\r\n                    token: this.token.into_owned(),\r\n                }\r\n            },\r\n\r\n            docs = {\r\n                name: \"For\",\r\n                symbols = [\"for \u003cvariable\u003e in \u003citerable\u003e { \u003cblock\u003e }\", \"for [\u003cvariable\u003e in] \u003citerable\u003e do \u003cblock\u003e [if \u003ccondition\u003e]\"],\r\n                description: \"\r\n                    For loops are finite value iterators. This means they map over a range, array, or object, \r\n                    and return a new array of values.\r\n                    The variable is optional, and if not provided, the loop will not bind a variable.\r\n                    The expression will return an array of the results of the block.\r\n                    Break and skip/continue can be used to exit the loop or skip the current iteration.\r\n                    A condition can be provided to filter the loop.\r\n                \",\r\n                examples: \"\r\n                    for i in 0..10 { i }\r\n                    for i in [1, 2, 3] { i }\r\n                    for i in {'a': 1, 'b': 2} { i }\r\n        \r\n                    for a in 0..10 do a if a % 2 == 0\r\n        \r\n                    for 0..10 do '!'\r\n                \",\r\n            }\r\n        }\r\n    }\r\n);\r\n\r\nfn iterate_over(\r\n    iterable: impl Iterator\u003cItem = Value\u003e,\r\n    state: \u0026mut crate::State,\r\n    this: \u0026ForLoopExpression,\r\n) -\u003e Result\u003cValue, Error\u003e {\r\n    let mut result = vec![];\r\n    for v in iterable {\r\n        state.check_timer().with_context(this.token())?; // Potentially long-running operation\r\n\r\n        state.scope_into().with_context(this.token())?;\r\n        if let Some(variable) = \u0026this.variable {\r\n            state.set_variable(variable, v);\r\n        }\r\n        if let Some(condition) = \u0026this.condition {\r\n            let condition = condition.evaluate(state).with_context(this.token());\r\n            match condition {\r\n                Ok(condition) if !condition.is_truthy() =\u003e {\r\n                    state.scope_out();\r\n                    continue;\r\n                }\r\n                Err(e) =\u003e {\r\n                    state.scope_out();\r\n                    return Err(e);\r\n                }\r\n                _ =\u003e {}\r\n            }\r\n        }\r\n\r\n        let value = this.body.evaluate(state);\r\n        state.scope_out();\r\n        match value {\r\n            Ok(value) =\u003e result.push(value),\r\n            Err(e) if error_matches!(e, Skip) =\u003e {}\r\n            Err(e) if error_matches!(e, Break) =\u003e {\r\n                break;\r\n            }\r\n\r\n            Err(e) =\u003e {\r\n                return Err(e);\r\n            }\r\n        }\r\n    }\r\n\r\n    Ok(Value::array(result))\r\n}\r\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":12,"coverable":16},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","syntax_tree","nodes","literals.rs"],"content":"use super::{Node, Token};\r\nuse crate::{error::WrapExternalError, Rule};\r\nuse polyvalue::{types::*, Value};\r\nuse std::str::FromStr;\r\n\r\ndefine_handler!(\r\n    IntLiteral(pairs, token, _state) {\r\n        let literal = unwrap_next!(pairs, token);\r\n        let str = literal.as_str();\r\n        let size = pairs\r\n            .next()\r\n            .map(|v| v.as_rule());\r\n\r\n        let value = match size {\r\n            Some(Rule::intsize_i32) =\u003e I32::from_str(str).with_context(\u0026token)?.into(),\r\n            Some(Rule::intsize_i16) =\u003e I16::from_str(str).with_context(\u0026token)?.into(),\r\n            Some(Rule::intsize_i8) =\u003e I8::from_str(str).with_context(\u0026token)?.into(),\r\n            Some(Rule::intsize_u64) =\u003e U64::from_str(str).with_context(\u0026token)?.into(),\r\n            Some(Rule::intsize_u32) =\u003e U32::from_str(str).with_context(\u0026token)?.into(),\r\n            Some(Rule::intsize_u16) =\u003e U16::from_str(str).with_context(\u0026token)?.into(),\r\n            Some(Rule::intsize_u8) =\u003e U8::from_str(str).with_context(\u0026token)?.into(),\r\n            _ =\u003e I64::from_str(str).with_context(\u0026token)?.into()\r\n        };\r\n\r\n        Ok(Node::Literal(value, token))\r\n    }\r\n);\r\n\r\ndefine_handler!(\r\n    FloatLiteral(_pairs, token, _state) {\r\n        let value: Value = Float::from_str(\u0026token.input).with_context(\u0026token)?.into();\r\n        Ok(Node::Literal(value, token))\r\n    }\r\n);\r\n\r\ndefine_handler!(\r\n    StringLiteral(_pairs, token, _state) {\r\n        // Remove the first and last characters - the quotes around our string\r\n        // This would not work great with graphemes like , but we know that it's\r\n        // either ' or \" so this should be safe\r\n        let mut c = token.input.chars();\r\n        c.next();\r\n        c.next_back();\r\n\r\n        // Now we split along our \\\\ backslash escapes, and rejoin after\r\n        // to prevent going over them twice. This method isn't super\r\n        // neat, there's likely a better way\r\n        let mut out = String::new();\r\n        let mut await_escape = false;\r\n        for char in c {\r\n            match char {\r\n                '\\\\' =\u003e {\r\n                    if await_escape {\r\n                        out.push('\\\\');\r\n                        await_escape = false;\r\n                    } else {\r\n                        await_escape = true;\r\n                    }\r\n                }\r\n                _ =\u003e {\r\n                    if await_escape {\r\n                        out.push(match char {\r\n                            '\\'' =\u003e '\\'',\r\n                            '\"' =\u003e '\"',\r\n                            'n' =\u003e '\\n',\r\n                            'r' =\u003e '\\r',\r\n                            't' =\u003e '\\t',\r\n                            _ =\u003e char,\r\n                        });\r\n                        await_escape = false;\r\n                    } else {\r\n                        out.push(char);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        Ok(Node::Literal(Value::string(out), token))\r\n    }\r\n);\r\n\r\ndefine_handler!(\r\n    BoolLiteral(_pairs, token, _state) {\r\n        let value = Bool::from_str(\u0026token.input).with_context(\u0026token)?;\r\n        Ok(Node::Literal(Value::bool(value), token))\r\n    }\r\n);\r\n\r\ndefine_handler!(\r\n    RegexLiteral(_pairs, token, _state) {\r\n        Ok(Node::Literal(Value::string(token.input.as_ref()), token))\r\n    }\r\n);\r\n\r\ndefine_handler!(\r\n    FixedLiteral(_pairs, token, _state) {\r\n        // remove the D suffix first\r\n        let input = \u0026token.input[..token.input.len() - 1];\r\n\r\n        let value = Fixed::from_str(input).with_context(\u0026token)?;\r\n        Ok(Node::Literal(Value::fixed(value), token))\r\n    }\r\n);\r\n\r\ndefine_handler!(\r\n    CurrencyLiteral(_pairs, token, _state) {\r\n        let value = Currency::from_str(\u0026token.input).with_context(\u0026token)?;\r\n        Ok(Node::Literal(Value::currency(value), token))\r\n    }\r\n);\r\n\r\ndefine_handler!(\r\n    ConstLiteral(_pairs, token, _state) {\r\n        let value = match token.input.as_ref() {\r\n            \"pi\" =\u003e Value::from(std::f64::consts::PI),\r\n            \"e\" =\u003e Value::from(std::f64::consts::E),\r\n            \"tau\" =\u003e Value::from(std::f64::consts::TAU),\r\n            \"nil\" =\u003e Value::from(false),\r\n\r\n            _ =\u003e {\r\n                return oops!(Internal {\r\n                    msg: format!(\"Unexpected const literal\")\r\n                }, token);\r\n            }\r\n        };\r\n        Ok(Node::Literal(value, token))\r\n    }\r\n);\r\ndocument_operator!(\r\n    name = \"Constants\",\r\n    rules = [],\r\n    symbols = [\"pi\", \"e\", \"tau\", \"nil\"],\r\n    description = \"\r\n        A constant value.\r\n        A predefined set of values that are always available.\r\n\r\n        - `pi` - The mathematical constant \r\n        - `e` - The mathematical constant e\r\n        - `tau` - The mathematical constant \r\n        - `nil` - The nil value - used to represent nothing or an empty value, especially in the context of a side-effect conditional\r\n    \",\r\n    examples = \"\r\n        pi; e; tau; nil\r\n    \",\r\n);\r\n","traces":[{"line":7,"address":[],"length":0,"stats":{"Line":589},"fn_name":null},{"line":8,"address":[],"length":0,"stats":{"Line":589},"fn_name":null},{"line":9,"address":[],"length":0,"stats":{"Line":589},"fn_name":null},{"line":10,"address":[],"length":0,"stats":{"Line":589},"fn_name":null},{"line":11,"address":[],"length":0,"stats":{"Line":589},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":1185},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":596},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":1164},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":54},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":218},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":218},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":218},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":218},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":218},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":218},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":4178},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":1976},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":1974},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":218},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":34},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":68},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":41,"coverable":57},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","syntax_tree","nodes","values.rs"],"content":"use super::Node;\r\nuse crate::{\r\n    error::WrapExternalError,\r\n    syntax_tree::{assignment_target::AssignmentTarget, traits::IntoNode},\r\n    Error, Rule, State, Token,\r\n};\r\nuse polyvalue::{\r\n    operations::{MatchingOperation, MatchingOperationExt},\r\n    Value, ValueType,\r\n};\r\n\r\ndefine_handler!(\r\n    Identifier(_pairs, token, _state) {\r\n        let name = token.input.to_string();\r\n        Ok(Reference::new(AssignmentTarget::Identifier(name), token).into())\r\n    }\r\n);\r\ndocument_operator!(\r\n    name = \"Identifier\",\r\n    rules = [],\r\n    symbols = [\"a\", \"b\", \"c\"],\r\n    description = \"\r\n        A variable name.\r\n        The value of the variable is looked up in the state.\r\n    \",\r\n    examples = \"\r\n        [a, b, c] = [1, 2, 3]\r\n        a; b; c\r\n    \",\r\n);\r\n\r\ndefine_ast!(\r\n    Values {\r\n        Reference(target: AssignmentTarget\u003c'i\u003e) {\r\n            build = (_pairs, token, _state) {\r\n                oops!(Internal {\r\n                    msg: \"Reference node should not be built directly\".to_string()\r\n                }, token)\r\n            },\r\n\r\n            eval = (this, state) {\r\n                Ok(this.target.get_value(state).with_context(this.token())?)\r\n            },\r\n\r\n            owned = (this) {\r\n                Self::Owned {\r\n                    target: this.target.into_owned(),\r\n                    token: this.token.into_owned(),\r\n                }\r\n            }\r\n        },\r\n\r\n        CastExpression(value: Node\u003c'i\u003e, target: Node\u003c'i\u003e) {\r\n            build = (pairs, token, state) {\r\n                let mut pairs = pairs;\r\n                let value = unwrap_node!(pairs, state, token)?;\r\n                pairs.next(); // skip the operator\r\n                let target = unwrap_node!(pairs, state, token)?;\r\n\r\n                Ok(Self {\r\n                    value: value,\r\n                    target: target,\r\n                    token,\r\n                }\r\n                .into())\r\n            },\r\n            eval = (this, state) {\r\n                let value = this.value.evaluate(state).with_context(this.token())?;\r\n                let target = if this.target.token().rule == Rule::identifier {\r\n                    this.target.token().input.to_string()\r\n                } else {\r\n                    this.target.evaluate(state).with_context(this.token())?.to_string()\r\n                };\r\n\r\n                let target = ValueType::try_from(target.as_str()).with_context(this.token())?;\r\n                value.as_type(target).with_context(this.token())\r\n            },\r\n            owned = (this) {\r\n                Self::Owned {\r\n                    value: this.value.into_owned(),\r\n                    target: this.target.into_owned(),\r\n                    token: this.token.into_owned(),\r\n                }\r\n            },\r\n\r\n            docs = {\r\n                name: \"Cast\",\r\n                symbols = [\"as\"],\r\n                description: \"\r\n                    Casts a value to a different type.\r\n                    The type can be a string or an identifier.\r\n                    The operator is right-associative\r\n                \",\r\n                examples: \"\r\n                    5 as float\r\n                    5 as 'float'\r\n                    5 as i8\r\n                \",\r\n            }\r\n        },\r\n\r\n        DecoratorExpression(expression: Node\u003c'i\u003e, decorator: String) {\r\n            build = (pairs, token, state) {\r\n                let mut pairs = pairs;\r\n                let expression = unwrap_node!(pairs, state, token)?;\r\n\r\n                let mut decorator_pair = unwrap_next!(pairs, token);\r\n                let decorator = unwrap_next!(decorator_pair, token).as_str().to_string();\r\n\r\n                Ok(Self {\r\n                    expression: expression,\r\n                    decorator,\r\n                    token,\r\n                }\r\n                .into())\r\n            },\r\n            eval = (this, state) {\r\n                let value = this.expression.evaluate(state).with_context(this.token())?;\r\n                let result = state.decorate(\u0026this.decorator, value).with_context(this.token())?;\r\n                Ok(Value::from(result))\r\n            },\r\n            owned = (this) {\r\n                Self::Owned {\r\n                    expression: this.expression.into_owned(),\r\n                    decorator: this.decorator,\r\n                    token: this.token.into_owned(),\r\n                }\r\n            },\r\n\r\n            docs = {\r\n                name: \"Decorator\",\r\n                symbols = [\"@name\"],\r\n                description: \"\r\n                    Converts a value to a formatted string.\r\n                    It calls a function named '@name' with the value as an argument.\r\n                \",\r\n                examples: \"\r\n                    assert_eq(\r\n                        5 @float,\r\n                        '5.0'\r\n                    )\r\n                \",\r\n            }\r\n        },\r\n\r\n        MatchingExpression(\r\n            left: Node\u003c'i\u003e,\r\n            right: Node\u003c'i\u003e,\r\n            operator: MatchingOperation\r\n        ) {\r\n            build = (pairs, token, state) {\r\n                let mut pairs = pairs;\r\n                let left = unwrap_node!(pairs, state, token)?;\r\n                let operator = unwrap_next!(pairs, token).as_rule();\r\n                let right = unwrap_node!(pairs, state, token)?;\r\n\r\n                let operator = match operator {\r\n                    Rule::OP_MATCH_CONTAINS =\u003e MatchingOperation::Contains,\r\n                    Rule::OP_MATCH_MATCHES =\u003e MatchingOperation::Matches,\r\n                    Rule::OP_MATCH_IS =\u003e MatchingOperation::Is,\r\n                    Rule::OP_MATCH_STARTSWITH =\u003e MatchingOperation::StartsWith,\r\n                    Rule::OP_MATCH_ENDSWITH =\u003e MatchingOperation::EndsWith,\r\n                    _ =\u003e {\r\n                        return oops!(\r\n                            Internal {\r\n                                msg: format!(\"Unrecognize matching operator {operator:?}\")\r\n                            },\r\n                            token\r\n                        )\r\n                    }\r\n                };\r\n\r\n                Ok(Self {\r\n                    left: left,\r\n                    right: right,\r\n                    operator,\r\n                    token,\r\n                }\r\n                .into())\r\n            },\r\n            eval = (this, state) {\r\n                let left = this.left.evaluate(state).with_context(this.token())?;\r\n                let right = if this.operator == MatchingOperation::Is\r\n                    \u0026\u0026 this.right.token().rule == Rule::identifier\r\n                {\r\n                    Value::from(\u0026*this.right.token().input)\r\n                } else {\r\n                    this.right.evaluate(state).with_context(this.token())?\r\n                };\r\n\r\n                Value::matching_op(\u0026left, \u0026right, this.operator).with_context(this.token())\r\n            },\r\n            owned = (this) {\r\n                Self::Owned {\r\n                    left: this.left.into_owned(),\r\n                    right: this.right.into_owned(),\r\n                    operator: this.operator,\r\n                    token: this.token.into_owned(),\r\n                }\r\n            },\r\n\r\n            docs = {\r\n                name: \"Matching\",\r\n                symbols = [\"contains\", \"matches\", \"is\", \"starts_with\", \"ends_with\"],\r\n                description: \"\r\n                    A set of left-associative boolean operators comparing a collection with a pattern\r\n                    'is' is a special case that compares type (`value is string` is equivalent `typeof(value) == 'string'`)\r\n                    starts/ends with are not applicable to objects, which are not ordered\r\n                \",\r\n                examples: \"\r\n                    {'name': 'test'} contains 'name'\r\n                    'hello' matches 'ell'\r\n                    'hello' is string\r\n                    'hello' starts_with 'hel'\r\n                    [1, 2] endswith 2\r\n                \",\r\n            }\r\n        }\r\n    }\r\n);\r\n\r\nimpl\u003c'i\u003e Reference\u003c'i\u003e {\r\n    pub(crate) fn new(target: AssignmentTarget\u003c'i\u003e, token: Token\u003c'i\u003e) -\u003e Reference\u003c'i\u003e {\r\n        Self { target, token }\r\n    }\r\n\r\n    /// Get the reference's value from the state\r\n    pub fn get_value(\u0026self, state: \u0026mut State) -\u003e Result\u003cValue, Error\u003e {\r\n        self.target.get_value(state)\r\n    }\r\n\r\n    /// Get the reference's value from the state\r\n    /// Uses the parent scope (if a function defines a value of the same name)\r\n    pub fn get_value_in_parent(\u0026self, state: \u0026mut State) -\u003e Result\u003cValue, Error\u003e {\r\n        self.target.get_value_in_parent(state)\r\n    }\r\n\r\n    /// Update the reference's value in the state\r\n    pub fn update_value(\u0026self, state: \u0026mut State, value: Value) -\u003e Result\u003c(), Error\u003e {\r\n        self.target.update_value(state, value)\r\n    }\r\n\r\n    /// Update the reference's value in the state\r\n    /// Uses the parent scope (if a function defines a value of the same name)\r\n    pub fn update_value_in_parent(\u0026self, state: \u0026mut State, value: Value) -\u003e Result\u003c(), Error\u003e {\r\n        self.target.update_value_in_parent(state, value)\r\n    }\r\n\r\n    /// Get the reference's value from the state as a mutable reference\r\n    pub fn get_target_mut_in_parent\u003c's\u003e(\r\n        \u0026self,\r\n        state: \u0026's mut State,\r\n    ) -\u003e Result\u003cOption\u003c\u0026's mut Value\u003e, Error\u003e {\r\n        self.target.get_target_mut_in_parent(state)\r\n    }\r\n}\r\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":121},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":121},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":121},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":131},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":38},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":38},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":9},"fn_name":null}],"covered":27,"coverable":40},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","syntax_tree","nodes.rs"],"content":"#![allow(unused_imports)]\r\nuse crate::{error::WrapExternalError, token, Error, Rule, State, Token};\r\nuse pest::iterators::Pair;\r\nuse polyvalue::Value;\r\n\r\nuse super::{\r\n    pair::PestIterator,\r\n    traits::{IntoOwned, NodeExt, SyntaxNodeBuilderExt},\r\n};\r\n\r\nmod assignment;\r\nuse assignment::Assignment;\r\n\r\nmod arithmetic;\r\nuse arithmetic::Arithmetic;\r\n\r\nmod bitwise;\r\nuse bitwise::Bitwise;\r\n\r\nmod boolean;\r\nuse boolean::Boolean;\r\n\r\nmod collections;\r\nuse collections::Collections;\r\n\r\nmod core;\r\nuse core::Core;\r\n\r\nmod functions;\r\nuse functions::Functions;\r\n\r\nmod iterators;\r\n\r\nmod conditionals;\r\nuse conditionals::Conditionals;\r\n\r\nmod values;\r\nuse values::Values;\r\n\r\nmod literals;\r\n\r\n/// Root type for AST nodes, split by class of node\r\n#[derive(Debug, Clone)]\r\npub enum Node\u003c'i\u003e {\r\n    /// Core syntax elements (script and block)\r\n    Core(Box\u003ccore::Core\u003c'i\u003e\u003e),\r\n\r\n    /// Variable storate (identifiers, assignment and deletion)\r\n    Assignment(Box\u003cassignment::Assignment\u003c'i\u003e\u003e),\r\n\r\n    /// Value manipulation (references, decorators, match, cast, etc.)\r\n    Values(Box\u003cvalues::Values\u003c'i\u003e\u003e),\r\n\r\n    /// Collections (arrays, objects, ranges, etc.)\r\n    Collections(Box\u003ccollections::Collections\u003c'i\u003e\u003e),\r\n\r\n    /// Conditional expressions (if, ternary, switch)\r\n    Conditionals(Box\u003cconditionals::Conditionals\u003c'i\u003e\u003e),\r\n\r\n    /// Iterators (for loops)\r\n    Iterators(Box\u003citerators::Iterators\u003c'i\u003e\u003e),\r\n\r\n    /// Function assignment and calling\r\n    Functions(Box\u003cfunctions::Functions\u003c'i\u003e\u003e),\r\n\r\n    /// Arithmetic expressions (add, sub, mul, div, etc.)\r\n    Arithmetic(Box\u003carithmetic::Arithmetic\u003c'i\u003e\u003e),\r\n\r\n    /// Bitwise expressions\r\n    Bitwise(Box\u003cbitwise::Bitwise\u003c'i\u003e\u003e),\r\n\r\n    /// Boolean expressions\r\n    Boolean(Box\u003cboolean::Boolean\u003c'i\u003e\u003e),\r\n\r\n    /// Literal constants\r\n    Literal(Value, Token\u003c'i\u003e),\r\n}\r\nimpl Node\u003c'_\u003e {\r\n    /// The minimum available stack size for the parser\r\n    /// We are guaranteed to have at least this much stack\r\n    pub const MIN_STACK: usize = 1024 * 1024;\r\n\r\n    /// The stack expansion size for the parser\r\n    /// This is the amount of stack to allocate when the parser runs out\r\n    pub const STACK_EXP: usize = 8 * 1024 * 1024;\r\n\r\n    /// This is where rules are matched to node-builder types\r\n    pub fn from_pair\u003c'i\u003e(pair: Pair\u003c'i, Rule\u003e, state: \u0026mut State) -\u003e Result\u003cNode\u003c'i\u003e, Error\u003e {\r\n        let pairs = PestIterator::from(pair);\r\n        Self::from_iterator(pairs, state)\r\n    }\r\n\r\n    pub(crate) fn from_iterator\u003c'i\u003e(\r\n        pairs: PestIterator\u003c'i\u003e,\r\n        state: \u0026mut State,\r\n    ) -\u003e Result\u003cNode\u003c'i\u003e, Error\u003e {\r\n        let (token, pairs) = pairs.decompose();\r\n\r\n        // println!(\"{:#?}\", pairs);\r\n\r\n        stacker::maybe_grow(Node::MIN_STACK, Node::STACK_EXP, || match token.rule {\r\n            //\r\n            // Core nodes\r\n            Rule::SCRIPT =\u003e core::Script::build(pairs, token, state),\r\n            Rule::BLOCK =\u003e core::Block::build(pairs, token, state),\r\n\r\n            //\r\n            // Value Literals\r\n            Rule::int_literal =\u003e literals::IntLiteral::build(pairs, token, state),\r\n            Rule::float_literal | Rule::sci_literal =\u003e {\r\n                literals::FloatLiteral::build(pairs, token, state)\r\n            }\r\n            Rule::string_literal =\u003e literals::StringLiteral::build(pairs, token, state),\r\n            Rule::bool_literal =\u003e literals::BoolLiteral::build(pairs, token, state),\r\n            Rule::regex_literal =\u003e literals::RegexLiteral::build(pairs, token, state),\r\n            Rule::fixed_literal =\u003e literals::FixedLiteral::build(pairs, token, state),\r\n            Rule::currency_literal =\u003e literals::CurrencyLiteral::build(pairs, token, state),\r\n            Rule::const_literal =\u003e literals::ConstLiteral::build(pairs, token, state),\r\n\r\n            //\r\n            // Value expressions\r\n            Rule::identifier =\u003e values::Identifier::build(pairs, token, state),\r\n            Rule::OP_CAST =\u003e values::CastExpression::build(pairs, token, state),\r\n            Rule::POSTFIX_DECORATE =\u003e values::DecoratorExpression::build(pairs, token, state),\r\n\r\n            //\r\n            // Matching expressions\r\n            Rule::OP_MATCH_CONTAINS\r\n            | Rule::OP_MATCH_MATCHES\r\n            | Rule::OP_MATCH_IS\r\n            | Rule::OP_MATCH_STARTSWITH\r\n            | Rule::OP_MATCH_ENDSWITH =\u003e values::MatchingExpression::build(pairs, token, state),\r\n\r\n            //\r\n            // Collection nodes\r\n            Rule::ARRAY_TERM =\u003e collections::Array::build(pairs, token, state),\r\n            Rule::OBJECT_TERM =\u003e collections::Object::build(pairs, token, state),\r\n            Rule::OP_RANGE =\u003e collections::Range::build(pairs, token, state),\r\n            Rule::POSTFIX_INDEX =\u003e collections::IndexingExpression::build(pairs, token, state),\r\n\r\n            //\r\n            // Iterator nodes\r\n            Rule::BREAK_KEYWORD =\u003e iterators::KeywordBreak::build(pairs, token, state),\r\n            Rule::SKIP_KEYWORD =\u003e iterators::KeywordContinue::build(pairs, token, state),\r\n            Rule::FOR_LOOP_EXPRESSION =\u003e iterators::ForLoopExpression::build(pairs, token, state),\r\n\r\n            //\r\n            // Conditional nodes\r\n            Rule::IF_EXPRESSION =\u003e conditionals::IfExpression::build(pairs, token, state),\r\n            Rule::OP_TERNARY =\u003e conditionals::TernaryExpression::build(pairs, token, state),\r\n            Rule::SWITCH_EXPRESSION =\u003e conditionals::SwitchExpression::build(pairs, token, state),\r\n\r\n            //\r\n            // Arithmetic\r\n            Rule::PREFIX_INC | Rule::PREFIX_DEC | Rule::POSTFIX_INC | Rule::POSTFIX_DEC =\u003e {\r\n                arithmetic::IncDec::build(pairs, token, state)\r\n            }\r\n            Rule::PREFIX_NEG =\u003e arithmetic::ArithmeticNeg::build(pairs, token, state),\r\n            Rule::OP_ADD\r\n            | Rule::OP_SUB\r\n            | Rule::OP_POW\r\n            | Rule::OP_DIV\r\n            | Rule::OP_MOD\r\n            | Rule::OP_MUL =\u003e arithmetic::ArithmeticExpr::build(pairs, token, state),\r\n\r\n            //\r\n            // Bitwise\r\n            Rule::PREFIX_BIT_NOT =\u003e bitwise::BitwiseNot::build(pairs, token, state),\r\n            Rule::OP_BIT_OR\r\n            | Rule::OP_BIT_XOR\r\n            | Rule::OP_BIT_AND\r\n            | Rule::OP_BIT_SL\r\n            | Rule::OP_BIT_SR =\u003e bitwise::BitwiseExpr::build(pairs, token, state),\r\n\r\n            //\r\n            // Boolean\r\n            Rule::PREFIX_BOOL_NOT =\u003e boolean::BooleanNot::build(pairs, token, state),\r\n            Rule::OP_BOOL_OR\r\n            | Rule::OP_BOOL_AND\r\n            | Rule::OP_BOOL_EQ\r\n            | Rule::OP_BOOL_NE\r\n            | Rule::OP_BOOL_LE\r\n            | Rule::OP_BOOL_GE\r\n            | Rule::OP_BOOL_LT\r\n            | Rule::OP_BOOL_GT =\u003e boolean::BooleanExpr::build(pairs, token, state),\r\n\r\n            //\r\n            // Functions\r\n            Rule::FUNCTION_ASSIGNMENT_STATEMENT =\u003e {\r\n                functions::FunctionDefinition::build(pairs, token, state)\r\n            }\r\n            Rule::POSTFIX_CALL =\u003e functions::FunctionCall::build(pairs, token, state),\r\n            Rule::RETURN_EXPRESSION =\u003e functions::KeywordReturn::build(pairs, token, state),\r\n\r\n            //\r\n            // Assignment\r\n            Rule::OP_ASSIGN_ADD\r\n            | Rule::OP_ASSIGN_SUB\r\n            | Rule::OP_ASSIGN_POW\r\n            | Rule::OP_ASSIGN_MUL\r\n            | Rule::OP_ASSIGN_DIV\r\n            | Rule::OP_ASSIGN_MOD\r\n            | Rule::OP_ASSIGN_AND\r\n            | Rule::OP_ASSIGN_XOR\r\n            | Rule::OP_ASSIGN_OR\r\n            | Rule::OP_ASSIGN_SL\r\n            | Rule::OP_ASSIGN_SR\r\n            | Rule::OP_BASSIGN_AND\r\n            | Rule::OP_BASSIGN_OR\r\n            | Rule::OP_ASSIGN =\u003e assignment::AssignmentExpression::build(pairs, token, state),\r\n            Rule::PREFIX_DEL =\u003e assignment::DeleteExpression::build(pairs, token, state),\r\n\r\n            //\r\n            // Errors\r\n            Rule::UNTERMINATED_BLOCK_COMMENT =\u003e oops!(UnterminatedComment),\r\n            Rule::UNTERMINATED_STRING_LITERAL =\u003e oops!(UnterminatedLiteral),\r\n            Rule::UNCLOSED_BRACKET =\u003e oops!(UnterminatedArray),\r\n            Rule::UNCLOSED_BRACE =\u003e oops!(UnterminatedObject),\r\n            Rule::UNCLOSED_PAREN =\u003e oops!(UnterminatedParen),\r\n            Rule::MISSING_LINEBREAK =\u003e oops!(UnterminatedLinebreak),\r\n\r\n            _ =\u003e panic!(\"No node builder for rule {:?}\", token.rule),\r\n        })\r\n    }\r\n}\r\nimpl IntoOwned for Node\u003c'_\u003e {\r\n    type Owned = Node\u003c'static\u003e;\r\n    fn into_owned(self) -\u003e Self::Owned {\r\n        match self {\r\n            Self::Core(node) =\u003e Self::Owned::Core(Box::new(node.into_owned())),\r\n            Self::Assignment(node) =\u003e Self::Owned::Assignment(Box::new(node.into_owned())),\r\n            Self::Collections(node) =\u003e Self::Owned::Collections(Box::new(node.into_owned())),\r\n            Self::Values(node) =\u003e Self::Owned::Values(Box::new(node.into_owned())),\r\n            Self::Arithmetic(node) =\u003e Self::Owned::Arithmetic(Box::new(node.into_owned())),\r\n            Self::Functions(node) =\u003e Self::Owned::Functions(Box::new(node.into_owned())),\r\n            Self::Iterators(node) =\u003e Self::Owned::Iterators(Box::new(node.into_owned())),\r\n            Self::Conditionals(node) =\u003e Self::Owned::Conditionals(Box::new(node.into_owned())),\r\n            Self::Bitwise(node) =\u003e Self::Owned::Bitwise(Box::new(node.into_owned())),\r\n            Self::Boolean(node) =\u003e Self::Owned::Boolean(Box::new(node.into_owned())),\r\n            Self::Literal(value, token) =\u003e Self::Owned::Literal(value.clone(), token.into_owned()),\r\n        }\r\n    }\r\n}\r\nimpl\u003c'i\u003e NodeExt\u003c'i\u003e for Node\u003c'i\u003e {\r\n    fn evaluate(\u0026self, state: \u0026mut State) -\u003e Result\u003cValue, Error\u003e {\r\n        stacker::maybe_grow(Node::MIN_STACK, Node::STACK_EXP, || match self {\r\n            Self::Core(node) =\u003e node.evaluate(state),\r\n            Self::Assignment(node) =\u003e node.evaluate(state),\r\n            Self::Collections(node) =\u003e node.evaluate(state),\r\n            Self::Values(node) =\u003e node.evaluate(state),\r\n            Self::Arithmetic(node) =\u003e node.evaluate(state),\r\n            Self::Functions(node) =\u003e node.evaluate(state),\r\n            Self::Iterators(node) =\u003e node.evaluate(state),\r\n            Self::Conditionals(node) =\u003e node.evaluate(state),\r\n            Self::Bitwise(node) =\u003e node.evaluate(state),\r\n            Self::Boolean(node) =\u003e node.evaluate(state),\r\n            Self::Literal(value, ..) =\u003e Ok(value.clone()),\r\n        })\r\n    }\r\n\r\n    fn token(\u0026self) -\u003e \u0026Token\u003c'i\u003e {\r\n        match self {\r\n            Self::Core(node) =\u003e node.token(),\r\n            Self::Assignment(node) =\u003e node.token(),\r\n            Self::Collections(node) =\u003e node.token(),\r\n            Self::Values(node) =\u003e node.token(),\r\n            Self::Arithmetic(node) =\u003e node.token(),\r\n            Self::Functions(node) =\u003e node.token(),\r\n            Self::Iterators(node) =\u003e node.token(),\r\n            Self::Conditionals(node) =\u003e node.token(),\r\n            Self::Bitwise(node) =\u003e node.token(),\r\n            Self::Boolean(node) =\u003e node.token(),\r\n            Self::Literal(.., token) =\u003e token,\r\n        }\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod test {\r\n    use crate::Lavendeux;\r\n\r\n    #[test]\r\n    fn run_lav_selftest() {\r\n        let mut lav = Lavendeux::new(Default::default());\r\n        lav.run(\"example_scripts/self_test.lav\")\r\n            .expect(\"Selftest failed\");\r\n    }\r\n}\r\n","traces":[{"line":61,"address":[],"length":0,"stats":{"Line":201},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":201},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":201},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":2643},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":2643},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":2643},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":176},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":589},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":218},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":34},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":121},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":852},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":366},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":38},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":43},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":43},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":2721},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":2721},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":248},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":44},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":893},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":149},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":362},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":44},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":898},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":63,"coverable":122},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","syntax_tree","pair.rs"],"content":"use crate::{Error, Rule, State, Token};\r\nuse pest::iterators::Pair;\r\nuse std::collections::VecDeque;\r\n\r\nuse super::{pratt, traits::IntoNode, Node};\r\n\r\n#[derive(Clone, Debug)]\r\npub struct PestIterator\u003c'i\u003e {\r\n    token: Token\u003c'i\u003e,\r\n    inner: InnerPestIterator\u003c'i\u003e,\r\n}\r\n\r\n#[allow(dead_code)]\r\nimpl\u003c'i\u003e PestIterator\u003c'i\u003e {\r\n    pub fn from_pair(pair: Pair\u003c'i, Rule\u003e) -\u003e Self {\r\n        match pair.as_rule() {\r\n            Rule::EXPR =\u003e {\r\n                let mut inner = pair.into_inner();\r\n                if inner.len() == 1 {\r\n                    Self::from_pair(inner.next().unwrap())\r\n                } else {\r\n                    pratt::Parser::parse(inner)\r\n                }\r\n            }\r\n            _ =\u003e {\r\n                let token = Token::from(\u0026pair);\r\n                Self {\r\n                    inner: InnerPestIterator::from_pair(pair),\r\n                    token,\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    pub fn from_infix(left: PestIterator\u003c'i\u003e, op: Pair\u003c'i, Rule\u003e, right: PestIterator\u003c'i\u003e) -\u003e Self {\r\n        let mut token = Token::from(\u0026op);\r\n        token.input = format!(\"{} {} {}\", left.as_str(), token.input, right.as_str()).into();\r\n        let inner = InnerPestIterator::from_vec(vec![left, Self::from_pair(op), right]);\r\n        Self { token, inner }\r\n    }\r\n\r\n    pub fn from_prefix(op: Pair\u003c'i, Rule\u003e, right: PestIterator\u003c'i\u003e) -\u003e Self {\r\n        let mut token = Token::from(\u0026op);\r\n        token.input = format!(\"{} {}\", token.input, right.as_str()).into();\r\n        let inner = InnerPestIterator::from_vec(vec![Self::from_pair(op), right]);\r\n        Self { token, inner }\r\n    }\r\n\r\n    pub fn from_postfix(left: PestIterator\u003c'i\u003e, op: Pair\u003c'i, Rule\u003e) -\u003e Self {\r\n        let mut token = Token::from(\u0026op);\r\n        token.input = format!(\"{} {}\", left.as_str(), token.input).into();\r\n        let inner = InnerPestIterator::from_vec(vec![left, Self::from_pair(op)]);\r\n        Self { token, inner }\r\n    }\r\n\r\n    pub fn token(\u0026self) -\u003e \u0026Token\u003c'i\u003e {\r\n        \u0026self.token\r\n    }\r\n\r\n    pub fn next_child(\u0026mut self) -\u003e Option\u003cSelf\u003e {\r\n        self.inner.next_child()\r\n    }\r\n\r\n    pub fn last_child(\u0026mut self) -\u003e Option\u003cSelf\u003e {\r\n        self.inner.last_child()\r\n    }\r\n\r\n    pub fn peek(\u0026self) -\u003e Option\u003c\u0026Self\u003e {\r\n        self.inner.peek()\r\n    }\r\n\r\n    pub fn peek_last(\u0026self) -\u003e Option\u003c\u0026Self\u003e {\r\n        self.inner.peek_last()\r\n    }\r\n\r\n    pub fn as_str(\u0026self) -\u003e \u0026str {\r\n        \u0026self.token.input\r\n    }\r\n\r\n    pub fn as_rule(\u0026self) -\u003e Rule {\r\n        self.token.rule\r\n    }\r\n\r\n    pub fn into_inner(self) -\u003e InnerPestIterator\u003c'i\u003e {\r\n        self.inner\r\n    }\r\n\r\n    pub fn into_token(self) -\u003e Token\u003c'i\u003e {\r\n        self.token\r\n    }\r\n\r\n    pub fn decompose(self) -\u003e (Token\u003c'i\u003e, InnerPestIterator\u003c'i\u003e) {\r\n        (self.token, self.inner)\r\n    }\r\n}\r\n\r\nimpl\u003c'i\u003e IntoNode\u003c'i\u003e for PestIterator\u003c'i\u003e {\r\n    fn into_node(self, state: \u0026mut State) -\u003e Result\u003cNode\u003c'i\u003e, Error\u003e {\r\n        Node::from_iterator(self, state)\r\n    }\r\n}\r\n\r\nimpl\u003c'i\u003e From\u003cPair\u003c'i, Rule\u003e\u003e for PestIterator\u003c'i\u003e {\r\n    fn from(p: Pair\u003c'i, Rule\u003e) -\u003e Self {\r\n        Self::from_pair(p)\r\n    }\r\n}\r\n\r\nimpl\u003c'i\u003e Iterator for PestIterator\u003c'i\u003e {\r\n    type Item = Self;\r\n\r\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\r\n        self.next_child()\r\n    }\r\n}\r\n\r\nimpl\u003c'i\u003e DoubleEndedIterator for PestIterator\u003c'i\u003e {\r\n    fn next_back(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\r\n        self.last_child()\r\n    }\r\n}\r\n\r\nimpl\u003c'i\u003e ExactSizeIterator for PestIterator\u003c'i\u003e {\r\n    fn len(\u0026self) -\u003e usize {\r\n        self.inner.len()\r\n    }\r\n}\r\n\r\n#[derive(Clone, Debug)]\r\npub struct InnerPestIterator\u003c'i\u003e(VecDeque\u003cPestIterator\u003c'i\u003e\u003e);\r\nimpl\u003c'i\u003e InnerPestIterator\u003c'i\u003e {\r\n    pub fn from_pair(pair: Pair\u003c'i, Rule\u003e) -\u003e Self {\r\n        let inner = pair\r\n            .into_inner()\r\n            .filter(|p| !Token::is_symbol(p.as_rule()))\r\n            .map(PestIterator::from)\r\n            .collect();\r\n        Self(inner)\r\n    }\r\n\r\n    pub fn from_vec(pairs: Vec\u003cPestIterator\u003c'i\u003e\u003e) -\u003e Self {\r\n        Self(pairs.into())\r\n    }\r\n\r\n    pub fn next_child(\u0026mut self) -\u003e Option\u003cPestIterator\u003c'i\u003e\u003e {\r\n        self.0.pop_front()\r\n    }\r\n\r\n    pub fn last_child(\u0026mut self) -\u003e Option\u003cPestIterator\u003c'i\u003e\u003e {\r\n        self.0.pop_back()\r\n    }\r\n\r\n    pub fn peek(\u0026self) -\u003e Option\u003c\u0026PestIterator\u003c'i\u003e\u003e {\r\n        self.0.front()\r\n    }\r\n\r\n    pub fn peek_last(\u0026self) -\u003e Option\u003c\u0026PestIterator\u003c'i\u003e\u003e {\r\n        self.0.back()\r\n    }\r\n}\r\n\r\nimpl\u003c'i\u003e Iterator for InnerPestIterator\u003c'i\u003e {\r\n    type Item = PestIterator\u003c'i\u003e;\r\n\r\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\r\n        self.next_child()\r\n    }\r\n}\r\n\r\nimpl\u003c'i\u003e DoubleEndedIterator for InnerPestIterator\u003c'i\u003e {\r\n    fn next_back(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\r\n        self.last_child()\r\n    }\r\n}\r\n\r\nimpl\u003c'i\u003e ExactSizeIterator for InnerPestIterator\u003c'i\u003e {\r\n    fn len(\u0026self) -\u003e usize {\r\n        self.0.len()\r\n    }\r\n}\r\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":7060},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":7060},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":2147},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":2147},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":1646},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":501},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":4913},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":4913},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":117},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":117},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":117},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":117},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":412},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":412},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":412},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":412},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":1429},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":1429},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":1683},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":1683},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":511},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":511},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":2643},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":2643},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":2442},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":2442},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":4869},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":4869},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":1429},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":1429},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":4913},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":4913},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":15397},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":4913},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":4913},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":545},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":545},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":7250},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":7250},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":54},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":54},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":5821},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":5821},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":7},"fn_name":null}],"covered":55,"coverable":73},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","syntax_tree","pratt.rs"],"content":"use crate::pest::Rule;\r\nuse pest::{\r\n    iterators::Pair,\r\n    pratt_parser::{Assoc, Op, PrattParser},\r\n};\r\n\r\nuse super::pair::PestIterator;\r\n\r\npub struct Parser;\r\nimpl Parser {\r\n    fn get_pratt_parser() -\u003e PrattParser\u003cRule\u003e {\r\n        let mut pratt = PrattParser::new();\r\n        for op_level in PRECEDENCE_MAP {\r\n            let mut r = op_level[0].to_pratt();\r\n            for op in *op_level {\r\n                r = r | op.to_pratt();\r\n            }\r\n            pratt = pratt.op(r);\r\n        }\r\n        pratt\r\n    }\r\n\r\n    pub fn parse\u003c'i, I\u003e(input: I) -\u003e PestIterator\u003c'i\u003e\r\n    where\r\n        I: Iterator\u003cItem = Pair\u003c'i, Rule\u003e\u003e + ExactSizeIterator,\r\n    {\r\n        let pratt = Self::get_pratt_parser();\r\n        let mut pratt = pratt\r\n            .map_primary(PestIterator::from)\r\n            .map_infix(PestIterator::from_infix)\r\n            .map_prefix(PestIterator::from_prefix)\r\n            .map_postfix(PestIterator::from_postfix);\r\n        pratt.parse(input)\r\n    }\r\n}\r\n\r\n#[derive(Clone, Debug)]\r\npub enum PrattOperatorType {\r\n    Prefix,\r\n    Infix,\r\n    Postfix,\r\n}\r\npub struct PrattOperator {\r\n    ty: PrattOperatorType,\r\n    rule: Rule,\r\n    asoc: Assoc,\r\n}\r\n\r\nimpl PrattOperator {\r\n    pub fn to_pratt(\u0026self) -\u003e Op\u003cRule\u003e {\r\n        match self.ty {\r\n            PrattOperatorType::Prefix =\u003e Op::prefix(self.rule),\r\n            PrattOperatorType::Infix =\u003e Op::infix(self.rule, self.asoc),\r\n            PrattOperatorType::Postfix =\u003e Op::postfix(self.rule),\r\n        }\r\n    }\r\n}\r\n\r\nmacro_rules! prefix {\r\n    ($rule:ident) =\u003e {\r\n        PrattOperator {\r\n            ty: PrattOperatorType::Prefix,\r\n            rule: Rule::$rule,\r\n            asoc: Assoc::Left,\r\n        }\r\n    };\r\n}\r\nmacro_rules! infix {\r\n    ($rule:ident, $asso:ident) =\u003e {\r\n        PrattOperator {\r\n            ty: PrattOperatorType::Infix,\r\n            rule: Rule::$rule,\r\n            asoc: Assoc::$asso,\r\n        }\r\n    };\r\n}\r\nmacro_rules! postfix {\r\n    ($rule:ident) =\u003e {\r\n        PrattOperator {\r\n            ty: PrattOperatorType::Postfix,\r\n            rule: Rule::$rule,\r\n            asoc: Assoc::Left,\r\n        }\r\n    };\r\n}\r\n\r\n/// The precedence map for the Pratt parser\r\n/// This is a list of lists of all EXPR operators, where each list is a level of precedence\r\n/// from lowest to highest precedence\r\npub const PRECEDENCE_MAP: \u0026[\u0026[PrattOperator]] = \u0026[\r\n    // Assignment\r\n    \u0026[\r\n        infix!(OP_ASSIGN_ADD, Right),\r\n        infix!(OP_ASSIGN_SUB, Right),\r\n        infix!(OP_ASSIGN_POW, Right),\r\n        infix!(OP_ASSIGN_MUL, Right),\r\n        infix!(OP_ASSIGN_DIV, Right),\r\n        infix!(OP_ASSIGN_MOD, Right),\r\n        infix!(OP_BASSIGN_AND, Right),\r\n        infix!(OP_BASSIGN_OR, Right),\r\n        infix!(OP_ASSIGN_OR, Right),\r\n        infix!(OP_ASSIGN_AND, Right),\r\n        infix!(OP_ASSIGN_XOR, Right),\r\n        infix!(OP_ASSIGN_SL, Right),\r\n        infix!(OP_ASSIGN_SR, Right),\r\n        infix!(OP_ASSIGN, Right),\r\n    ],\r\n    // Delete\r\n    \u0026[prefix!(PREFIX_DEL)],\r\n    // Range, Ternary\r\n    \u0026[infix!(OP_RANGE, Left)],\r\n    \u0026[infix!(OP_TERNARY, Right)],\r\n    // Decorator\r\n    \u0026[postfix!(POSTFIX_DECORATE)],\r\n    //\r\n    // Logical OR, Logical AND\r\n    \u0026[infix!(OP_BOOL_OR, Left)],\r\n    \u0026[infix!(OP_BOOL_AND, Left)],\r\n    //\r\n    // Pattern Matching\r\n    \u0026[\r\n        infix!(OP_MATCH_MATCHES, Left),\r\n        infix!(OP_MATCH_CONTAINS, Left),\r\n        infix!(OP_MATCH_IS, Left),\r\n        infix!(OP_MATCH_STARTSWITH, Left),\r\n        infix!(OP_MATCH_ENDSWITH, Left),\r\n    ],\r\n    //\r\n    // Bitwise OR, Bitwise XOR, Bitwise AND\r\n    \u0026[infix!(OP_BIT_OR, Left)],\r\n    \u0026[infix!(OP_BIT_XOR, Left)],\r\n    \u0026[infix!(OP_BIT_AND, Left)],\r\n    //\r\n    // == and !=, followed by \u003c, \u003c=, \u003e, \u003e=\r\n    \u0026[infix!(OP_BOOL_EQ, Left), infix!(OP_BOOL_NE, Left)],\r\n    \u0026[\r\n        infix!(OP_BOOL_LT, Left),\r\n        infix!(OP_BOOL_LE, Left),\r\n        infix!(OP_BOOL_GT, Left),\r\n        infix!(OP_BOOL_GE, Left),\r\n    ],\r\n    //\r\n    // \u003c\u003c and \u003e\u003e\r\n    \u0026[infix!(OP_BIT_SL, Left), infix!(OP_BIT_SR, Left)],\r\n    //\r\n    // Add and subtract, followed by multiply divide and mod, then pow\r\n    \u0026[infix!(OP_ADD, Left), infix!(OP_SUB, Left)],\r\n    \u0026[\r\n        infix!(OP_MUL, Left),\r\n        infix!(OP_DIV, Left),\r\n        infix!(OP_MOD, Left),\r\n    ],\r\n    \u0026[infix!(OP_POW, Right)],\r\n    //\r\n    // Cast, and prefix operators\r\n    \u0026[\r\n        infix!(OP_CAST, Right),\r\n        prefix!(PREFIX_NEG),\r\n        prefix!(PREFIX_INC),\r\n        prefix!(PREFIX_DEC),\r\n        prefix!(PREFIX_BOOL_NOT),\r\n        prefix!(PREFIX_BIT_NOT),\r\n    ],\r\n    //\r\n    // Postfix operators\r\n    \u0026[\r\n        postfix!(POSTFIX_INC),\r\n        postfix!(POSTFIX_DEC),\r\n        postfix!(POSTFIX_CALL),\r\n        postfix!(POSTFIX_INDEX),\r\n    ],\r\n];\r\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":501},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":501},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":19539},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":87675},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":26052},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":9519},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":501},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":501},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":501},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":501},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":501},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":501},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":501},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":501},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":501},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":35571},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":35571},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":3507},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":28557},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":3507},"fn_name":null}],"covered":20,"coverable":20},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","syntax_tree","traits.rs"],"content":"use crate::{Error, State, Token};\r\nuse enum_dispatch::enum_dispatch;\r\nuse polyvalue::Value;\r\n\r\nuse crate::Rule;\r\n\r\nuse super::{nodes::Node, pair::InnerPestIterator};\r\n\r\npub trait IntoOwned {\r\n    type Owned;\r\n    fn into_owned(self) -\u003e Self::Owned;\r\n}\r\n\r\n/// Internal trait for use with the compiler, and AST manipulation\r\n#[enum_dispatch(CoreSyntaxNode)]\r\npub trait NodeExt\u003c'i\u003e\r\nwhere\r\n    Self: IntoOwned,\r\n{\r\n    /// Evaluate this tree\r\n    fn evaluate(\u0026self, state: \u0026mut State) -\u003e Result\u003cValue, Error\u003e;\r\n\r\n    /// Get the token for this node\r\n    fn token(\u0026self) -\u003e \u0026Token\u003c'i\u003e;\r\n}\r\n\r\n/// Tree construction trait\r\npub trait SyntaxNodeBuilderExt\u003c'i\u003e {\r\n    fn build(\r\n        pairs: InnerPestIterator\u003c'i\u003e,\r\n        token: Token\u003c'i\u003e,\r\n        state: \u0026mut State,\r\n    ) -\u003e Result\u003cNode\u003c'i\u003e, Error\u003e;\r\n}\r\n\r\npub trait IntoNode\u003c'i\u003e {\r\n    fn into_node(self, state: \u0026mut State) -\u003e Result\u003cNode\u003c'i\u003e, Error\u003e;\r\n}\r\nimpl\u003c'i\u003e IntoNode\u003c'i\u003e for pest::iterators::Pair\u003c'i, Rule\u003e {\r\n    fn into_node(self, state: \u0026mut State) -\u003e Result\u003cNode\u003c'i\u003e, Error\u003e {\r\n        Node::from_pair(self, state)\r\n    }\r\n}\r\n","traces":[{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":2},{"path":["C:","\\","Users","rcarson1","Repositories","lavendeux_workspace","lavendeux_parser","src","token.rs"],"content":"use crate::Rule;\r\nuse pest::iterators::Pair;\r\nuse std::borrow::Cow;\r\n\r\n/// A struct representing a token in the syntax tree\r\n/// It stores metadata about the token, such as the rule it was parsed from,\r\n/// the input it was parsed from, and the references to variables it contains\r\n#[derive(Debug, Clone)]\r\npub struct Token\u003c'i\u003e {\r\n    /// Source-code line number\r\n    pub line: usize,\r\n\r\n    /// Grammar-rule that this token was parsed from\r\n    /// See [crate::Rule]\r\n    pub rule: Rule,\r\n\r\n    /// The input that this token was parsed from\r\n    pub input: Cow\u003c'i, str\u003e,\r\n}\r\n\r\nimpl Token\u003c'_\u003e {\r\n    /// Creates a new root token from the input\r\n    pub fn dummy() -\u003e Self {\r\n        Token {\r\n            line: 0,\r\n            rule: Rule::SCRIPT,\r\n            input: Cow::Borrowed(\"\"),\r\n        }\r\n    }\r\n\r\n    /// Check if this token is a symbol\r\n    pub fn is_symbol(rule: Rule) -\u003e bool {\r\n        matches!(\r\n            rule,\r\n            Rule::symbol_questionmark\r\n                | Rule::symbol_colon\r\n                | Rule::symbol_comma\r\n                | Rule::symbol_arrow\r\n                | Rule::symbol_at\r\n                | Rule::symbol_eq\r\n                | Rule::symbol_opencurly\r\n                | Rule::symbol_closecurly\r\n                | Rule::symbol_opensquare\r\n                | Rule::symbol_closesquare\r\n                | Rule::EOL\r\n        )\r\n    }\r\n\r\n    /// Remove lifetime restrictions from this token\r\n    pub fn into_owned(self) -\u003e Token\u003c'static\u003e {\r\n        Token {\r\n            line: self.line,\r\n            rule: self.rule,\r\n            input: Cow::Owned(self.input.into_owned()),\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003c'i\u003e From\u003c\u0026Pair\u003c'i, Rule\u003e\u003e for Token\u003c'i\u003e {\r\n    fn from(pair: \u0026Pair\u003c'i, Rule\u003e) -\u003e Token\u003c'i\u003e {\r\n        Token {\r\n            line: pair.line_col().0,\r\n            rule: pair.as_rule(),\r\n            input: Cow::Borrowed(pair.as_str().trim()),\r\n        }\r\n    }\r\n}\r\n\r\nimpl std::fmt::Display for Token\u003c'_\u003e {\r\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\r\n        let lines = self\r\n            .input\r\n            .lines()\r\n            .map(|l| format!(\"| {l}\"))\r\n            .collect::\u003cVec\u003c_\u003e\u003e();\r\n        if lines.len() == 1 {\r\n            write!(f, \"Line {}: {}\", self.line, self.input)\r\n        } else {\r\n            write!(f, \"Line {}: \\n{}\", self.line, lines.join(\"\\n\"))\r\n        }\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod test {\r\n    use super::*;\r\n    use crate::pest::LavendeuxParser;\r\n    use pest::Parser;\r\n\r\n    fn get_pair() -\u003e Pair\u003c'static, Rule\u003e {\r\n        let mut pairs = LavendeuxParser::parse(Rule::SCRIPT, \"1\").unwrap();\r\n        pairs.next().unwrap()\r\n    }\r\n\r\n    #[test]\r\n    fn test_token_from_pair() {\r\n        let token = Token::from(\u0026get_pair());\r\n        assert_eq!(token.line, 1);\r\n        assert_eq!(token.rule, Rule::SCRIPT);\r\n        assert_eq!(token.input, \"1\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_token_display() {\r\n        let token = Token {\r\n            line: 1,\r\n            rule: Rule::symbol_arrow,\r\n            input: Cow::Borrowed(\"-\u003e\"),\r\n        };\r\n        assert_eq!(format!(\"{}\", token), \"Line 1: -\u003e\");\r\n\r\n        let token = Token {\r\n            line: 1,\r\n            rule: Rule::symbol_arrow,\r\n            input: Cow::Borrowed(\"-\u003e\\n-\u003e\"),\r\n        };\r\n        assert_eq!(format!(\"{}\", token), \"Line 1: \\n| -\u003e\\n| -\u003e\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_token_into_owned() {\r\n        let token = Token {\r\n            line: 1,\r\n            rule: Rule::symbol_arrow,\r\n            input: Cow::Borrowed(\"-\u003e\"),\r\n        };\r\n        let token = token.into_owned();\r\n        assert_eq!(token.line, 1);\r\n        assert_eq!(token.rule, Rule::symbol_arrow);\r\n        assert_eq!(token.input, \"-\u003e\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_token_is_symbol() {\r\n        assert!(Token::is_symbol(Rule::symbol_arrow));\r\n        assert!(!Token::is_symbol(Rule::OP_ADD));\r\n    }\r\n\r\n    #[test]\r\n    fn test_token_dummy() {\r\n        let token = Token::dummy();\r\n        assert_eq!(token.line, 0);\r\n        assert_eq!(token.rule, Rule::SCRIPT);\r\n        assert_eq!(token.input, \"\");\r\n    }\r\n}\r\n","traces":[{"line":23,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":5573},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":4051},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":5573},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":805},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":805},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":805},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":805},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":5459},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":5459},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":5459},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":5459},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":20,"coverable":20}]};
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      }
    };
  });

  return [
    ...folders,
    ...files.filter(file => file.path.length === 1),
  ];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener("hashchange", () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.substr(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(({current}) => {
      return {current: [...current, file.path[0]]};
    }, () => this.updateHash());
  }

  back(file) {
    this.setState(({current}) => {
      return {current: current.slice(0, current.length - 1)};
    }, () => this.updateHash());
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e('div', {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e('table', {className: 'files-list'},
      e('thead', {className: 'files-list__head'},
        e('tr', null,
          e('th', null, "Path"),
          e('th', null, "Coverage")
        )
      ),
      e('tbody', {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile}))
      )
    )
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? file.covered / file.coverable * 100 : -1;
  const coverageDelta = file.prevRun &&
    (file.covered / file.coverable * 100 - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('tr', {
      className: 'files-list__file'
        + (coverage >= 0 && coverage < 50 ? ' files-list__file_low': '')
        + (coverage >= 50 && coverage < 80 ? ' files-list__file_medium': '')
        + (coverage >= 80 ? ' files-list__file_high': '')
        + (file.is_folder ? ' files-list__file_folder': ''),
      onClick: () => onClick(file),
    },
    e('td', null, e('a', null, pathToString(file.path))),
    e('td', null,
      file.covered + ' / ' + file.coverable +
      (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'},
    e(FileHeader, {file, onBack}),
    e(FileContent, {file})
  );
}

function FileHeader({file, onBack}) {
  const coverage = file.covered / file.coverable * 100;
  const coverageDelta = file.prevRun && (coverage - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('div', {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e('div', {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable +
      (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function FileContent({file}) {
  return e('pre', {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e('code', {
          className: 'code-line'
            + (covered ? ' code-line_covered' : '')
            + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        }, line);
    })
  );
}

(function(){
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData && previousData.files.forEach((file) => {
    const path = file.path.slice(commonPath.length).join('/');
    prevFilesMap.set(path, file);
  });

  const files = data.files.map((file) => {
    const path = file.path.slice(commonPath.length);
    const { covered = 0, coverable = 0 } = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: { covered, coverable },
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    }
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));
}());
</script>
</body>
</html>